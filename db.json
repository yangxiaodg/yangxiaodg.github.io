{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-matery/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/barrager.css","path":"css/barrager.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/bb.css","path":"css/bb.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/dark.css","path":"css/dark.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/gallery.css","path":"css/gallery.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/indexcover.css","path":"css/indexcover.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/matery.css","path":"css/matery.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/my.css","path":"css/my.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/post.css","path":"css/post.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/css/reward.css","path":"css/reward.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/crypto-js.js","path":"js/crypto-js.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/gallery-encrypt.js","path":"js/gallery-encrypt.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/jquery.barrager.js","path":"js/jquery.barrager.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/matery.js","path":"js/matery.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/comment_bg.png","path":"medias/comment_bg.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","path":"medias/cover.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/icp.png","path":"medias/icp.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","path":"medias/logo.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/Meting.min.js","path":"libs/aplayer/Meting.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-refresh.min.js","path":"libs/background/ribbon-refresh.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/fancybox/jquery.fancybox.css","path":"libs/fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/fancybox/fancybox.js","path":"libs/fancybox/fancybox.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/instantpage/instantpage.js","path":"libs/instantpage/instantpage.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery-3.6.0.min.js","path":"libs/jquery/jquery-3.6.0.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/justifiedGallery/justifiedGallery.min.css","path":"libs/justifiedGallery/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/justifiedGallery/justifiedGallery.min.js","path":"libs/justifiedGallery/justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/mermaid/mermaid.js","path":"libs/mermaid/mermaid.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/mermaid/mermaid.min.css","path":"libs/mermaid/mermaid.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/mermaid/mermaid.min.js","path":"libs/mermaid/mermaid.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/minivaline/MiniValine.js","path":"libs/minivaline/MiniValine.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/TencentCaptcha.js","path":"libs/others/TencentCaptcha.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/sakura-half.js","path":"libs/others/sakura-half.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/sakura-reduce.js","path":"libs/others/sakura-reduce.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/sakura-small.js","path":"libs/others/sakura-small.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/sakura.js","path":"libs/others/sakura.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/snow.js","path":"libs/others/snow.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/others/star.js","path":"libs/others/star.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/prism/prism.min.css","path":"libs/prism/prism.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/prism/prism.min.js","path":"libs/prism/prism.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/twikoo/twikoo.all.min.js","path":"libs/twikoo/twikoo.all.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/twikoo/twikoo.all.min.js.LICENSE.txt","path":"libs/twikoo/twikoo.all.min.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/typed/typed.js","path":"libs/typed/typed.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/waline/Waline.min.js","path":"libs/waline/Waline.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/barrager/0.png","path":"medias/barrager/0.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/barrager/1.png","path":"medias/barrager/1.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/barrager/2.png","path":"medias/barrager/2.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/barrager/close.png","path":"medias/barrager/close.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/images/01.jpg","path":"medias/images/01.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/images/02.jpg","path":"medias/images/02.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/images/03.jpg","path":"medias/images/03.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/all.min.css","path":"libs/awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/all.css","path":"libs/awesome/css/all.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.ttf","path":"libs/awesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff2","path":"libs/awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.ttf","path":"libs/awesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff2","path":"libs/awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.ttf","path":"libs/awesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff2","path":"libs/awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-v4compatibility.ttf","path":"libs/awesome/webfonts/fa-v4compatibility.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-v4compatibility.woff2","path":"libs/awesome/webfonts/fa-v4compatibility.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/404/index.md","hash":"f3af07fa14a0a9a4119ad2ab7637ecf23568f47a","modified":1665137999412},{"_id":"source/_data/friends.json","hash":"64317415d9a3c31c69e7efaff17ba8775268355f","modified":1665137999412},{"_id":"source/_posts/基于Xcode11创建自定义UIWindow.md","hash":"28c1f5b6f285e595b6512916b053532b488f7e53","modified":1667187365485},{"_id":"source/_posts/记录学习设计模式-01-简单工厂和工厂方法.md","hash":"cc1805a028a3084a1e86557ba398f0df7f2aef02","modified":1667187365485},{"_id":"source/categories/index.md","hash":"57974cb8107db54818077da09cd4851bfdac9716","modified":1665137999417},{"_id":"source/contact/index.md","hash":"543e39afa39588a1c4cec1a9060dcf19fb8f2c2d","modified":1665137999417},{"_id":"source/friends/index.md","hash":"6e1710744cd6ee34cd876af8b9a51b32e8677df8","modified":1665137999418},{"_id":"source/about/index.md","hash":"27716ad12695774908760b4b4efa667654c1f754","modified":1665137999417},{"_id":"source/tags/index.md","hash":"5ad11165bda96d8d1bbc3641c7cf4402894f8fa0","modified":1665137999418},{"_id":"source/_posts/基于Xcode11创建自定义UIWindow/16277872853169.png","hash":"9d4bf9cf8097ba301e9c7e60ef5a382e5ff68b35","modified":1665137999416},{"_id":"source/_posts/基于Xcode11创建自定义UIWindow/16277873129770.png","hash":"e9f5c3d9a0c3043678d798111c954c1f42836662","modified":1665137999417},{"_id":"themes/hexo-theme-matery/.gitignore","hash":"727607929a51db7ea10968f547c26041eee9cfff","modified":1665140264654},{"_id":"themes/hexo-theme-matery/CHANGELOG.md","hash":"084ec8b110a20170d08a0aa5fd8accf601051835","modified":1665140264654},{"_id":"themes/hexo-theme-matery/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1665140264655},{"_id":"themes/hexo-theme-matery/README.md","hash":"d64f79581eaf7b2ce8205209de8b01311db41832","modified":1665140264655},{"_id":"themes/hexo-theme-matery/README_CN.md","hash":"45d95b12690fdf4aabe5c471ef9f84109bdaf7bd","modified":1665140264655},{"_id":"themes/hexo-theme-matery/_config.yml","hash":"c9b40e10dced3a714f76286912cbee3013088b35","modified":1667788876373},{"_id":"themes/hexo-theme-matery/languages/jp.yml","hash":"a811cec0b6d91f405e8c7386a57039cd8c3448bb","modified":1665140264656},{"_id":"themes/hexo-theme-matery/languages/default.yml","hash":"2ed57824573d7bed71e56023ed92500734a8886d","modified":1665140264656},{"_id":"themes/hexo-theme-matery/languages/zh-CN.yml","hash":"a2695fdb7579a77daec7773a9bb8e71b9edbf16b","modified":1665140264656},{"_id":"themes/hexo-theme-matery/languages/zh-HK.yml","hash":"51c06005927e8bde5b3e23353d2bf2c32ed855f3","modified":1665140264656},{"_id":"themes/hexo-theme-matery/layout/404.ejs","hash":"36f8d3e530e8144bf80d0772284edd9b0da362fe","modified":1665140264656},{"_id":"themes/hexo-theme-matery/layout/about.ejs","hash":"99a74316aed478efb0db823c4460ee2e660f101c","modified":1665140264667},{"_id":"themes/hexo-theme-matery/layout/archive.ejs","hash":"cdac701de8370f9f3794a0eed4165983993a1ca7","modified":1665140264667},{"_id":"themes/hexo-theme-matery/layout/bb.ejs","hash":"21959d702f17a3d98b716daf44c8b5eecd59c7c5","modified":1665140264668},{"_id":"themes/hexo-theme-matery/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1665140264668},{"_id":"themes/hexo-theme-matery/layout/category.ejs","hash":"00019bca11fb46477f22017cb1f5ad8444da0580","modified":1665140264669},{"_id":"themes/hexo-theme-matery/layout/contact.ejs","hash":"71ef2540fa586cd0c3b1f216f59fa9ec85fc6a38","modified":1665140264669},{"_id":"themes/hexo-theme-matery/layout/friends.ejs","hash":"534511d9f38f281b531e24c19d9c1526cc7e5e27","modified":1665140264670},{"_id":"themes/hexo-theme-matery/layout/galleries.ejs","hash":"85b8b9e583ffa7a4ee6d0c2be4779cb2f7d91777","modified":1665140264671},{"_id":"themes/hexo-theme-matery/layout/gallery.ejs","hash":"fcc7364b03329148ba4920cddb0d34d5b7410788","modified":1665140264671},{"_id":"themes/hexo-theme-matery/layout/index.ejs","hash":"1656c2db90e24a360282d15c71144b4f14edb43d","modified":1665140264672},{"_id":"themes/hexo-theme-matery/layout/layout.ejs","hash":"f5d76dea8673199693fb0c4e0955853112538a04","modified":1665140264672},{"_id":"themes/hexo-theme-matery/layout/movies.ejs","hash":"abce85ffdd99e787e3652fbd466447e032b626bd","modified":1665140264673},{"_id":"themes/hexo-theme-matery/layout/musics.ejs","hash":"9ac6053e09ed2c8a844d7e93c3fdce4ded95248a","modified":1665140264673},{"_id":"themes/hexo-theme-matery/layout/post.ejs","hash":"3d4f40121dbb75bcb71837c35ec5ee17cdffae31","modified":1665140264673},{"_id":"themes/hexo-theme-matery/layout/tag.ejs","hash":"85a4b05bd8a6ad0f17ff2e97dae56949b379c204","modified":1665140264674},{"_id":"themes/hexo-theme-matery/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1665140264674},{"_id":"themes/hexo-theme-matery/source/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1665140264686},{"_id":"themes/hexo-theme-matery/layout/_partial/back-top.ejs","hash":"47ee36a042bb6d52bbe1d0f329637e8ffcf1d0aa","modified":1665140264656},{"_id":"themes/hexo-theme-matery/layout/_partial/background.ejs","hash":"12350c0d366141b5c27792bb414d4adc303b0a9f","modified":1665140264656},{"_id":"themes/hexo-theme-matery/layout/_partial/baidu-analytics.ejs","hash":"3bbcdb474ca1dcad514bdc4b7763e17c55df04fd","modified":1665140264656},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover-content.ejs","hash":"4765267aafe2871a2fdaeccd1598890219bd7d71","modified":1665140264657},{"_id":"themes/hexo-theme-matery/layout/_partial/baidu-push.ejs","hash":"2cebcc5ea3614d7f76ec36670e68050cbe611202","modified":1665140264657},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1665140264657},{"_id":"themes/hexo-theme-matery/layout/_partial/bg-video.ejs","hash":"963422029eb5158eb5f5bc97ce19b66e5399db97","modified":1665140264657},{"_id":"themes/hexo-theme-matery/layout/_partial/changyan.ejs","hash":"cd919d31564e118c2ee8d5cbfb7d51ee6da15d82","modified":1665140264657},{"_id":"themes/hexo-theme-matery/layout/_partial/codeblock.ejs","hash":"086a06863a0f88888707409936aa06a09ff50e3a","modified":1665140264657},{"_id":"themes/hexo-theme-matery/layout/_partial/cover-style.ejs","hash":"4288b9d91b2d71404e7a509a81a5d7f7a4b8b5e8","modified":1665140264657},{"_id":"themes/hexo-theme-matery/layout/_partial/disqus.ejs","hash":"b2dc2c8b5ed56815e55cc2ea54a6dc4eeba2375d","modified":1665140264657},{"_id":"themes/hexo-theme-matery/layout/_partial/gitalk.ejs","hash":"2aa8fbb04b046fa7679092a48372d7e036835dff","modified":1665140264658},{"_id":"themes/hexo-theme-matery/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1665140264658},{"_id":"themes/hexo-theme-matery/layout/_partial/footer.ejs","hash":"7c87e0eb2cf662c2a9b9b0e1e5d228b0fac2622e","modified":1665140264658},{"_id":"themes/hexo-theme-matery/layout/_partial/gitment.ejs","hash":"90f6218512ef2eab63ada7ad2fc766ae635a2297","modified":1665140264658},{"_id":"themes/hexo-theme-matery/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1665140264658},{"_id":"themes/hexo-theme-matery/layout/_partial/head.ejs","hash":"f5c00f21af281a09dc7de89e82a3b442903451a7","modified":1665140264658},{"_id":"themes/hexo-theme-matery/layout/_partial/header.ejs","hash":"59e38c70f3d8e7165e686e5e84a627835f4321b0","modified":1665140264659},{"_id":"themes/hexo-theme-matery/layout/_partial/index-cover.ejs","hash":"e8b44268b59add61af44b7338527523d10d9d742","modified":1665140264659},{"_id":"themes/hexo-theme-matery/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1665140264659},{"_id":"themes/hexo-theme-matery/layout/_partial/main-style.ejs","hash":"8819b334509682355a5e53fa0f307f90166d175c","modified":1665140264659},{"_id":"themes/hexo-theme-matery/layout/_partial/mobile-nav.ejs","hash":"52de0cf3ce13a3477b0a1659d2b8aa41db1f622d","modified":1665140264659},{"_id":"themes/hexo-theme-matery/layout/_partial/navigation.ejs","hash":"0953217f4e19a51dfc5a0ffc7d066406df18060b","modified":1665140264659},{"_id":"themes/hexo-theme-matery/layout/_partial/paging.ejs","hash":"e2df12cf92a82b1a7a7add2eac1db1d954bc5511","modified":1665140264660},{"_id":"themes/hexo-theme-matery/layout/_partial/post-cover.ejs","hash":"d1c873c5de54498c722e155aadb8c0ec39485dfa","modified":1665140264660},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail-toc.ejs","hash":"70fccaea75ce48364222c4e5de0496e556b01cb1","modified":1665140264660},{"_id":"themes/hexo-theme-matery/layout/_partial/post-detail.ejs","hash":"6261f8191c3c1159f63ec7f9293bb93f7d2a3dbb","modified":1665140264660},{"_id":"themes/hexo-theme-matery/layout/_partial/post-statis.ejs","hash":"04889f9031743c6b081d02fa4027b0dbfcc45ecf","modified":1665140264661},{"_id":"themes/hexo-theme-matery/layout/_partial/post-style.ejs","hash":"243c3ba783553f25955d524fd47a5bb59a5e732b","modified":1665140264661},{"_id":"themes/hexo-theme-matery/layout/_partial/prev-next.ejs","hash":"c76b78782ea82340104fccc089417572e0adece4","modified":1665140264661},{"_id":"themes/hexo-theme-matery/layout/_partial/reprint-statement.ejs","hash":"0ce3f9361f558b99cc2f059c5e50b0e2a152ae38","modified":1665140264661},{"_id":"themes/hexo-theme-matery/layout/_partial/reward-style.ejs","hash":"8256ed940c0185ccf01890d59fb4262f196e2323","modified":1665140264662},{"_id":"themes/hexo-theme-matery/layout/_partial/reward.ejs","hash":"236668e72b01db91f5bf29eec4c79e34e2746d98","modified":1665140264662},{"_id":"themes/hexo-theme-matery/layout/_partial/search.ejs","hash":"150529c9fb9aa8ddb42ec3e02645d301faa2503b","modified":1665140264662},{"_id":"themes/hexo-theme-matery/layout/_partial/share.ejs","hash":"c941730a2471d6aab367cbb6e09ed08b56c83143","modified":1665140264662},{"_id":"themes/hexo-theme-matery/layout/_partial/social-link.ejs","hash":"6f871bd3a70f720e4e451f1f4f625cbc6d8994a4","modified":1665140264662},{"_id":"themes/hexo-theme-matery/layout/_partial/twikoo.ejs","hash":"f9cb8c82b9d2a7cdb644e10718f1cdeb9400414c","modified":1665140264663},{"_id":"themes/hexo-theme-matery/layout/_partial/valine.ejs","hash":"2ac48566bb806336f1e5bc5c66fc816a580d63c3","modified":1665140264663},{"_id":"themes/hexo-theme-matery/layout/_partial/waline.ejs","hash":"2658cb73ef984a30b248351d7858ee15596a6e7a","modified":1665140264663},{"_id":"themes/hexo-theme-matery/layout/_widget/artitalk.ejs","hash":"b14e486f12b9ac42a273b80e4d785fcb94cf04b2","modified":1665140264664},{"_id":"themes/hexo-theme-matery/layout/_widget/category-cloud.ejs","hash":"1b3df1009234c0112424b497b18b4ad8240b3bc7","modified":1665140264664},{"_id":"themes/hexo-theme-matery/layout/_widget/category-radar.ejs","hash":"1d8747fda89a0b2ca3c7008867cbfeecad0578a6","modified":1665140264664},{"_id":"themes/hexo-theme-matery/layout/_widget/day-night.ejs","hash":"ff21dd5e49e1fc9a9ab8c7d164fd4b32a8265ea2","modified":1665140264664},{"_id":"themes/hexo-theme-matery/layout/_widget/dream.ejs","hash":"9a472ad5591100cdb65d0df9d01034163bd6dd9d","modified":1665140264664},{"_id":"themes/hexo-theme-matery/layout/_widget/music.ejs","hash":"bb25a6fa51eb5ebfba687b2cbadff6c7a4b4bfef","modified":1665140264665},{"_id":"themes/hexo-theme-matery/layout/_widget/musics.ejs","hash":"bfebdf0731fee0cd4fd51efa0da1d0184565ae25","modified":1665140264665},{"_id":"themes/hexo-theme-matery/layout/_widget/my-gallery.ejs","hash":"65a2d2f9722f84c7fd98f6bdf79087a14848ebd8","modified":1665140264665},{"_id":"themes/hexo-theme-matery/layout/_widget/my-projects.ejs","hash":"ef60b64021fa349b0048425d858dfcf6c906fede","modified":1665140264665},{"_id":"themes/hexo-theme-matery/layout/_widget/my-skills.ejs","hash":"89a0092df72d23093128f2fbbdc8ca7f83ebcfd9","modified":1665140264665},{"_id":"themes/hexo-theme-matery/layout/_widget/post-calendar.ejs","hash":"48821e644bc73553d7c5c56d2e8ee111a70cd776","modified":1665140264665},{"_id":"themes/hexo-theme-matery/layout/_widget/post-charts.ejs","hash":"ab5f986f428215941aeaa0c88aefd440c47d3bcf","modified":1665140264666},{"_id":"themes/hexo-theme-matery/layout/_widget/recommend.ejs","hash":"8551137e94ca4e2e3b8b63d5626255884cb60cb5","modified":1665140264666},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-cloud.ejs","hash":"fc42b72cddc231f7485cdc1fd6852b66be6add26","modified":1665140264666},{"_id":"themes/hexo-theme-matery/layout/_widget/tag-wordcloud.ejs","hash":"487aacb2454d6bf0d21cdb07ddd1fd5ddbca9038","modified":1665140264666},{"_id":"themes/hexo-theme-matery/layout/_widget/video.ejs","hash":"5e5ec78f8ab229d54786ef2e0ea2864af2dc459f","modified":1665140264667},{"_id":"themes/hexo-theme-matery/scripts/tags/button.js","hash":"ab02fb2da648f4f7afa0c2381aaca334bdeb54e6","modified":1665140264675},{"_id":"themes/hexo-theme-matery/scripts/tags/index.js","hash":"223a31ea3aa4a689d45a033c7d680cb4fff8d8af","modified":1665140264675},{"_id":"themes/hexo-theme-matery/scripts/tags/note.js","hash":"84b0122b92342834540f69b19600cb54c50ab69e","modified":1665140264675},{"_id":"themes/hexo-theme-matery/source/css/barrager.css","hash":"862879d9313ed8d4c721fa32ef8f94ac2f0a28ae","modified":1665140264676},{"_id":"themes/hexo-theme-matery/source/css/bb.css","hash":"aa15633888c7cf9baea8bb48d796c68b57cf14bf","modified":1665140264677},{"_id":"themes/hexo-theme-matery/source/css/dark.css","hash":"0dcd292d10f27f11c18d1a1a461b7e0cfe6c55cf","modified":1665140264677},{"_id":"themes/hexo-theme-matery/source/css/gallery.css","hash":"015097ca1271dd44e6d663332587dbe58ae2ade8","modified":1665140264677},{"_id":"themes/hexo-theme-matery/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1665140264678},{"_id":"themes/hexo-theme-matery/source/css/indexcover.css","hash":"e4a478c91cd6750a9f18b65b914ff0b316fb08b3","modified":1665140264678},{"_id":"themes/hexo-theme-matery/source/css/matery.css","hash":"413ad9731332810823b57dd0f4c0284e3af2af63","modified":1665140264679},{"_id":"themes/hexo-theme-matery/source/css/my-gitalk.css","hash":"af18dd29e58642c18bab9b89541767b494c468dd","modified":1665140264679},{"_id":"themes/hexo-theme-matery/source/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1665140264680},{"_id":"themes/hexo-theme-matery/source/css/post.css","hash":"1ebbf9ddee7db4b3039d8d4e25f2605072ab6e24","modified":1665140264680},{"_id":"themes/hexo-theme-matery/source/css/reward.css","hash":"56f8d21c3bb1dc57c762a63d13b08161d8260738","modified":1665140264681},{"_id":"themes/hexo-theme-matery/source/js/gallery-encrypt.js","hash":"f611a391d62da17b71f75577a72ad246ef6c5a71","modified":1665140264688},{"_id":"themes/hexo-theme-matery/source/js/jquery.barrager.js","hash":"19c8b2498ca1083e537f7f443172970912107f83","modified":1665140264689},{"_id":"themes/hexo-theme-matery/source/js/matery.js","hash":"aa957ea8cf6787f0ed6095fedc6cb9d7d1bf3522","modified":1665140264691},{"_id":"themes/hexo-theme-matery/source/js/search.js","hash":"5caa2d6e3d34c334ac68dfaafc81a583d6123382","modified":1665140264693},{"_id":"themes/hexo-theme-matery/source/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1665140264807},{"_id":"themes/hexo-theme-matery/source/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1665140264817},{"_id":"themes/hexo-theme-matery/source/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1665140264838},{"_id":"themes/hexo-theme-matery/source/medias/logo.png","hash":"d9095f5ea8719374d9d1ff020279426f5b2a1396","modified":1665140264846},{"_id":"themes/hexo-theme-matery/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1665140264698},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1665140264698},{"_id":"themes/hexo-theme-matery/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1665140264698},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1665140264699},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1665140264705},{"_id":"themes/hexo-theme-matery/source/libs/aplayer/Meting.min.js","hash":"f2b3d20b8bd64ccd031c64628f2b1323078ae324","modified":1665140264706},{"_id":"themes/hexo-theme-matery/source/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1665140264720},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1665140264721},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1665140264721},{"_id":"themes/hexo-theme-matery/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1665140264721},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1665140264722},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1665140264722},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1665140264722},{"_id":"themes/hexo-theme-matery/source/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1665140264723},{"_id":"themes/hexo-theme-matery/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1665140264723},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1665140264724},{"_id":"themes/hexo-theme-matery/source/libs/fancybox/jquery.fancybox.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1665140264732},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.css","hash":"61d71cb30f5f34cbb1f2b5bc469784d6cb908c22","modified":1665140264732},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1665140264739},{"_id":"themes/hexo-theme-matery/source/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1665140264740},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1665140264740},{"_id":"themes/hexo-theme-matery/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1665140264741},{"_id":"themes/hexo-theme-matery/source/libs/justifiedGallery/justifiedGallery.min.css","hash":"b9323091d50785ad6c617d7cae76a41a89eb44b3","modified":1665140264743},{"_id":"themes/hexo-theme-matery/source/libs/justifiedGallery/justifiedGallery.min.js","hash":"6f5433cc9f19ce2403e903e5d01a4c7b38f0969b","modified":1665140264743},{"_id":"themes/hexo-theme-matery/source/libs/masonry/masonry.pkgd.min.js","hash":"d20252cf76c3be8af37a8415d13ad368c762b4d8","modified":1665140264751},{"_id":"themes/hexo-theme-matery/source/libs/mermaid/mermaid.min.css","hash":"1dbcd9312e57f2a0b569451d0028d88316614481","modified":1665140264774},{"_id":"themes/hexo-theme-matery/source/libs/minivaline/MiniValine.js","hash":"f7f6cdc1b22297e02334e304444e9a8351acb455","modified":1665140264783},{"_id":"themes/hexo-theme-matery/source/libs/others/TencentCaptcha.js","hash":"fb4d34c48567b7b992aac1c75f0d24c3eb2cc3fa","modified":1665140264783},{"_id":"themes/hexo-theme-matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1665140264784},{"_id":"themes/hexo-theme-matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1665140264784},{"_id":"themes/hexo-theme-matery/source/libs/others/sakura-half.js","hash":"a41b64af88fdd0e2d3502752d059661c1bc743dc","modified":1665140264785},{"_id":"themes/hexo-theme-matery/source/libs/others/sakura-reduce.js","hash":"f7527e9fb4e6fe2cc7c8880692d77bcda95900c7","modified":1665140264785},{"_id":"themes/hexo-theme-matery/source/libs/others/sakura-small.js","hash":"3284a9ab71454e574d80663f3a05735cd12a6a05","modified":1665140264785},{"_id":"themes/hexo-theme-matery/source/libs/others/snow.js","hash":"02b1eeaca737c47be637b304feb3d36d792ee0c4","modified":1665140264786},{"_id":"themes/hexo-theme-matery/source/libs/others/sakura.js","hash":"b6ebe8f040c84f067300996a5f377846f01605fa","modified":1665140264786},{"_id":"themes/hexo-theme-matery/source/libs/others/star.js","hash":"cf32f8ce2a1a51ba65d3b6063fe2ee1482550190","modified":1665140264786},{"_id":"themes/hexo-theme-matery/source/libs/prism/prism.min.css","hash":"ed3896649670cf142e514685da2b060cca5fd43a","modified":1665140264787},{"_id":"themes/hexo-theme-matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1665140264791},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1665140264796},{"_id":"themes/hexo-theme-matery/source/libs/tocbot/tocbot.min.js","hash":"39055053a477e7d54b46cfb46591f84cc3818eeb","modified":1665140264796},{"_id":"themes/hexo-theme-matery/source/libs/twikoo/twikoo.all.min.js.LICENSE.txt","hash":"1e286a31ef472fb864fe2b9502e87df9242df56b","modified":1665140264800},{"_id":"themes/hexo-theme-matery/source/libs/typed/typed.js","hash":"eaf2798298790ec3fad17f6c68b5d3b02dfd069c","modified":1665140264802},{"_id":"themes/hexo-theme-matery/source/medias/barrager/0.png","hash":"b30416fd3b3aec5af3fa90823a7e2e9c0af4cda8","modified":1665140264816},{"_id":"themes/hexo-theme-matery/source/medias/barrager/1.png","hash":"b8c211690dba3addedfe7b928e3936cd487df0d6","modified":1665140264816},{"_id":"themes/hexo-theme-matery/source/medias/barrager/2.png","hash":"52b2b13373fe611ad2327b9b40426d6dc05b69cd","modified":1665140264816},{"_id":"themes/hexo-theme-matery/source/medias/barrager/close.png","hash":"045346df61ee01abe5018c5d9ba805d2831ce7b1","modified":1665140264817},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1665140264822},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1665140264824},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1665140264825},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1665140264826},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1665140264829},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1665140264831},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1665140264831},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1665140264832},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1665140264833},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1665140264834},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1665140264835},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1665140264836},{"_id":"themes/hexo-theme-matery/source/medias/reward/alipay.jpg","hash":"1abc719b95d1b26f1f898e6b0a9b7609146e332f","modified":1665140264847},{"_id":"themes/hexo-theme-matery/source/medias/reward/wechat.png","hash":"fe93385aa92fe328e01c8221a80b039be9e4e140","modified":1665140264847},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"9b26d745a1e69b23d71b7ea36d5de1209c997901","modified":1665140264713},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f7a09bcbd996fd634045d4e79b6504c945730686","modified":1665140264713},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-v4compatibility.ttf","hash":"3fc15c8154f8bd2d7bd1dfe55ae5ab1c33e5e40f","modified":1665140264720},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-v4compatibility.woff2","hash":"37ab2a6a0810d5a6c10a355fe1d7af0042bd6a2a","modified":1665140264720},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"7873d80020ae04955bb57521bd249a6974d1180f","modified":1665140264745},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.svg","hash":"509c56c80732a1cd80df8f2b4b0ac1128c31999f","modified":1665140264745},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.ttf","hash":"49693fa946534a56d7e5d4274e1ce55b05d782c3","modified":1665140264746},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/fonts/lg.woff","hash":"04f09ad797ced119d6608909d06e500f16a03bbb","modified":1665140264746},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1665140264747},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1665140264747},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1665140264748},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1665140264748},{"_id":"themes/hexo-theme-matery/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1665140264792},{"_id":"themes/hexo-theme-matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"aab2633f69581c2e26e22a23712f1501d7fcec18","modified":1665140264749},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1665140264793},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1665140264793},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1665140264793},{"_id":"themes/hexo-theme-matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1665140264794},{"_id":"themes/hexo-theme-matery/source/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1665140264795},{"_id":"themes/hexo-theme-matery/source/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1665140264795},{"_id":"themes/hexo-theme-matery/source/libs/fancybox/fancybox.js","hash":"eef46b6fb2e460838cd7328a6e13ecda0cb1e194","modified":1665140264731},{"_id":"themes/hexo-theme-matery/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1665140264739},{"_id":"themes/hexo-theme-matery/source/libs/jquery/jquery-3.6.0.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1665140264742},{"_id":"themes/hexo-theme-matery/source/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1665140264809},{"_id":"themes/hexo-theme-matery/source/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1665140264811},{"_id":"themes/hexo-theme-matery/source/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1665140264812},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1665140264820},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1665140264821},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1665140264823},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1665140264823},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1665140264824},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1665140264827},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1665140264827},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1665140264828},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1665140264830},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1665140264833},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1665140264835},{"_id":"themes/hexo-theme-matery/source/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1665140264837},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/all.min.css","hash":"0ae47fa834fb55de7b50c79021aeabecfae50c9c","modified":1665140264708},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"e219af1e3bbc2219359d3d0916e263b279c4abfd","modified":1665140264711},{"_id":"themes/hexo-theme-matery/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1665140264817},{"_id":"themes/hexo-theme-matery/source/libs/dplayer/DPlayer.min.js","hash":"490148a22ab2b03a880495cc733ecd1840c02ed6","modified":1665140264725},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1665140264752},{"_id":"themes/hexo-theme-matery/source/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1665140264754},{"_id":"themes/hexo-theme-matery/source/libs/valine/Valine.min.js","hash":"d081a412c63411a75a3a880ddece65335d1c3ee8","modified":1665140264803},{"_id":"themes/hexo-theme-matery/source/libs/waline/Waline.min.js","hash":"94f70e622e2a1ab05adb205033a9ddf371c61534","modified":1665140264807},{"_id":"themes/hexo-theme-matery/source/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1665140264809},{"_id":"themes/hexo-theme-matery/source/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1665140264814},{"_id":"themes/hexo-theme-matery/source/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1665140264815},{"_id":"themes/hexo-theme-matery/source/medias/images/02.jpg","hash":"a5b656606811f4d7e10307f48c0e3c373e0b886d","modified":1665140264841},{"_id":"themes/hexo-theme-matery/source/libs/awesome/css/all.css","hash":"8d63fa8b0f60a50b07ac0f7e751f6f5e02ecdc44","modified":1665140264707},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"fa5745d421c0fc90928626be98e9f8cf7580b327","modified":1665140264710},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"1979128e8ba1517d85f5e4ee505abf486c51557c","modified":1665140264719},{"_id":"themes/hexo-theme-matery/source/js/crypto-js.js","hash":"ddacd177f23f65ff97b93b0417048f51928ee17e","modified":1665140264688},{"_id":"themes/hexo-theme-matery/source/libs/valine/av-min.js","hash":"db56ef6acb789da00d39bd6b97c1b09c2d429195","modified":1665140264805},{"_id":"source/_posts/基于Xcode11创建自定义UIWindow/16277872068447.png","hash":"4dd634e01851446ff1adc6424b39ba5233ac0064","modified":1665137999416},{"_id":"themes/hexo-theme-matery/source/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1665140264813},{"_id":"themes/hexo-theme-matery/source/medias/images/03.jpg","hash":"2bd3815508a9f5b0ae79aa780bc02ac80b2a354e","modified":1665140264845},{"_id":"themes/hexo-theme-matery/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"e3339400ef6214cfa077d003daed2bfa659e2956","modified":1665140264717},{"_id":"themes/hexo-theme-matery/source/libs/twikoo/twikoo.all.min.js","hash":"c3f5f0a69b7864e7ef5bbf99fc774bec37947d7c","modified":1665140264799},{"_id":"themes/hexo-theme-matery/source/libs/prism/prism.min.js","hash":"6fc9b7be93e51b4017a61483c13187af0149f194","modified":1665140264791},{"_id":"themes/hexo-theme-matery/source/medias/images/01.jpg","hash":"6a81f437fb876666bafaa98b2a09bd8bd7f21832","modified":1665140264840},{"_id":"themes/hexo-theme-matery/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1665140264730},{"_id":"themes/hexo-theme-matery/source/libs/gitalk/gitalk.min.js","hash":"564fc7c731d05fa70d71ef853a2c8cc7725739e2","modified":1665140264736},{"_id":"themes/hexo-theme-matery/source/libs/mermaid/mermaid.min.js","hash":"6bee48c26c32b90f50519f125890fcbb04779da6","modified":1665140264782},{"_id":"themes/hexo-theme-matery/source/libs/mermaid/mermaid.js","hash":"a7933bef8aba190825ba7716497209187ac1de5d","modified":1665140264773},{"_id":"public/search.xml","hash":"03e70bb781a04d9b54acc7facfe02267340ff277","modified":1668850951662},{"_id":"public/404/index.html","hash":"1a71b682d19b8056596d7445b8d9a632a1acf5de","modified":1668415301182},{"_id":"public/categories/index.html","hash":"d8ab8bc13b88bdad5d86952c2996edb2b788ec62","modified":1668850951662},{"_id":"public/contact/index.html","hash":"0500f11ee17ab5c64a396f491b730a041a176074","modified":1668415301182},{"_id":"public/friends/index.html","hash":"cdd984cb48546f4e7b48bd4cbd1d59f0344ca30b","modified":1668415301182},{"_id":"public/about/index.html","hash":"5665f0e063f0c7497f296b34512e50ee06594032","modified":1668850951662},{"_id":"public/tags/index.html","hash":"5feed218b46836e2ec2289b012e817bb23c2e5b7","modified":1668850951662},{"_id":"public/2022/10/07/ji-lu-xue-xi-she-ji-mo-shi-01-jian-dan-gong-han-he-gong-han-fang-fa/index.html","hash":"4d65deb94778e66be671f9fe397e64433795af87","modified":1667187398166},{"_id":"public/2021/10/21/ji-yu-xcode11-chuang-jian-zi-ding-yi-uiwindow/index.html","hash":"b939887be60ebe5e2575572075c2cbc16037a4c3","modified":1667187398166},{"_id":"public/archives/index.html","hash":"18fd4208313472eccf58fb4769f3a7725c529baf","modified":1668850951662},{"_id":"public/archives/2021/index.html","hash":"2e21b8fd3dc1f71a955ae49d763fa1c1c697ebd4","modified":1667187398166},{"_id":"public/archives/2021/10/index.html","hash":"e3389336d2363e92b2e05cd192dcfbe823ae71fa","modified":1667187398166},{"_id":"public/archives/2022/index.html","hash":"28167722802f7ffbbe8ac1c1616b3d4073c5c3e5","modified":1668850951662},{"_id":"public/archives/2022/10/index.html","hash":"c98465f93b4fd06d944131bd88b40fac8e5a6d4d","modified":1667187398166},{"_id":"public/categories/ios/index.html","hash":"6bf28906216c75119453aa6d37ae6d16c95a4c78","modified":1667187398166},{"_id":"public/categories/java/index.html","hash":"ad59de6619a2eb1450d4822610deb0d0272d53bd","modified":1668850951662},{"_id":"public/index.html","hash":"4cdc4167131788108f6a0d3658882961482bf6f0","modified":1668850951662},{"_id":"public/tags/ios/index.html","hash":"2ef3a671eaa481614ae4a477c1a6b3c6f169e492","modified":1667187398166},{"_id":"public/tags/objective-c/index.html","hash":"2e71731feaaf65ef656177dcaaeee03b2feceff5","modified":1667187398166},{"_id":"public/tags/设计模式/index.html","hash":"0cfbcc11c45177213f9a83e79dd06fbe99559bce","modified":1668850951662},{"_id":"public/tags/思考方式/index.html","hash":"11c9f5528fdbdfd70469200c54344b4b2c44d111","modified":1667187398166},{"_id":"public/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1667187398166},{"_id":"public/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1667187398166},{"_id":"public/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1667187398166},{"_id":"public/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1667187398166},{"_id":"public/medias/logo.png","hash":"d9095f5ea8719374d9d1ff020279426f5b2a1396","modified":1667187398166},{"_id":"public/libs/twikoo/twikoo.all.min.js.LICENSE.txt","hash":"1e286a31ef472fb864fe2b9502e87df9242df56b","modified":1667187398166},{"_id":"public/medias/barrager/0.png","hash":"b30416fd3b3aec5af3fa90823a7e2e9c0af4cda8","modified":1667187398166},{"_id":"public/medias/barrager/1.png","hash":"b8c211690dba3addedfe7b928e3936cd487df0d6","modified":1667187398166},{"_id":"public/medias/barrager/2.png","hash":"52b2b13373fe611ad2327b9b40426d6dc05b69cd","modified":1667187398166},{"_id":"public/medias/barrager/close.png","hash":"045346df61ee01abe5018c5d9ba805d2831ce7b1","modified":1667187398166},{"_id":"public/medias/featureimages/10.jpg","hash":"98e7f6fd9c97d4de9044b6871ca08ebf14db11b9","modified":1667187398166},{"_id":"public/medias/featureimages/13.jpg","hash":"35a320174f8e316e3eadaec658024276b651c6e9","modified":1667187398166},{"_id":"public/medias/featureimages/16.jpg","hash":"97a829c4bc94f9d2929b20a1a9b798c57b9f7205","modified":1667187398166},{"_id":"public/medias/featureimages/15.jpg","hash":"da0fbee3b7bde1607eace377ddf834c0be99edfe","modified":1667187398166},{"_id":"public/medias/featureimages/2.jpg","hash":"4bba691cf71a517ecaeaf42afd3e8f8b31e346c1","modified":1667187398166},{"_id":"public/medias/featureimages/21.jpg","hash":"b26edb128bb0bf58b23fd2f014e9555e89a2ca3b","modified":1667187398166},{"_id":"public/medias/featureimages/22.jpg","hash":"754579747a3e99747d890fca3162f370b96a7941","modified":1667187398166},{"_id":"public/medias/featureimages/23.jpg","hash":"7d7f37da3fa7128343adac23866449eb2c6a549a","modified":1667187398166},{"_id":"public/medias/featureimages/3.jpg","hash":"6ec646c2a70f5f11edacf225c1477f2200a37a96","modified":1667187398166},{"_id":"public/medias/featureimages/5.jpg","hash":"41ca20129a37fedc573eec28dd7d7b9e5b09228a","modified":1667187398166},{"_id":"public/medias/featureimages/8.jpg","hash":"8e4b7186352085483ca1174c7c0800114c48df8b","modified":1667187398166},{"_id":"public/medias/featureimages/7.jpg","hash":"7975141cd64e875122c0ea33daaca1a06bf00b8e","modified":1667187398166},{"_id":"public/medias/reward/alipay.jpg","hash":"1abc719b95d1b26f1f898e6b0a9b7609146e332f","modified":1667187398166},{"_id":"public/medias/reward/wechat.png","hash":"fe93385aa92fe328e01c8221a80b039be9e4e140","modified":1667187398166},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f7a09bcbd996fd634045d4e79b6504c945730686","modified":1667187398166},{"_id":"public/libs/awesome/webfonts/fa-regular-400.ttf","hash":"9b26d745a1e69b23d71b7ea36d5de1209c997901","modified":1667187398166},{"_id":"public/libs/awesome/webfonts/fa-v4compatibility.ttf","hash":"3fc15c8154f8bd2d7bd1dfe55ae5ab1c33e5e40f","modified":1667187398166},{"_id":"public/libs/awesome/webfonts/fa-v4compatibility.woff2","hash":"37ab2a6a0810d5a6c10a355fe1d7af0042bd6a2a","modified":1667187398166},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"509c56c80732a1cd80df8f2b4b0ac1128c31999f","modified":1667187398166},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"49693fa946534a56d7e5d4274e1ce55b05d782c3","modified":1667187398166},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"04f09ad797ced119d6608909d06e500f16a03bbb","modified":1667187398166},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1667187398166},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1667187398166},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1667187398166},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1667187398166},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1667187398166},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1667187398166},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1667187398166},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1667187398166},{"_id":"public/medias/banner/0.jpg","hash":"69ec96cd9b4bc3aa631adc9da61353f50c39f031","modified":1667187398166},{"_id":"public/medias/banner/2.jpg","hash":"39fb2535460ce66cc0b34e07ffb9411db1405f09","modified":1667187398166},{"_id":"public/medias/banner/3.jpg","hash":"4ac047e92d0363b1a61ab756aca6dac13fb77494","modified":1667187398166},{"_id":"public/medias/featureimages/0.jpg","hash":"1c3300f029fc85d6dda6fa4f1d699551034cdaf7","modified":1667187398166},{"_id":"public/medias/featureimages/1.jpg","hash":"684ae89de8cb7acefae19f5aee6c612037c46393","modified":1667187398166},{"_id":"public/medias/featureimages/11.jpg","hash":"f55972ce7175684f2b11c3c9fc2b5b14bccbfae8","modified":1667187398166},{"_id":"public/medias/featureimages/12.jpg","hash":"8a4b2e7d92ae95c3b0c921db23c35aa9a41a7d58","modified":1667187398166},{"_id":"public/medias/featureimages/14.jpg","hash":"38e11221406785bcd93aa9cd23e568e164630ef1","modified":1667187398166},{"_id":"public/medias/featureimages/17.jpg","hash":"42d47903551ee81885c1386022982cae165841c5","modified":1667187398166},{"_id":"public/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1667187398166},{"_id":"public/medias/featureimages/19.jpg","hash":"eb250906fdbc0c408f42ae9933725bc1a05d79fb","modified":1667187398166},{"_id":"public/medias/featureimages/20.jpg","hash":"3b11f9b461168d907073f793190865fe621a8573","modified":1667187398166},{"_id":"public/medias/featureimages/4.jpg","hash":"e06c47de27619984be9d5d02947f8370a432dfea","modified":1667187398166},{"_id":"public/medias/featureimages/6.jpg","hash":"c8f2aa4bbb041158b4e73733a341e6a77c8583f7","modified":1667187398166},{"_id":"public/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1667187398166},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff2","hash":"e219af1e3bbc2219359d3d0916e263b279c4abfd","modified":1667187398166},{"_id":"public/2021/10/21/ji-yu-xcode11-chuang-jian-zi-ding-yi-uiwindow/16277872853169.png","hash":"9d4bf9cf8097ba301e9c7e60ef5a382e5ff68b35","modified":1667187398166},{"_id":"public/2021/10/21/ji-yu-xcode11-chuang-jian-zi-ding-yi-uiwindow/16277873129770.png","hash":"e9f5c3d9a0c3043678d798111c954c1f42836662","modified":1667187398166},{"_id":"public/css/barrager.css","hash":"862879d9313ed8d4c721fa32ef8f94ac2f0a28ae","modified":1667187398166},{"_id":"public/css/bb.css","hash":"aa15633888c7cf9baea8bb48d796c68b57cf14bf","modified":1667187398166},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1667187398166},{"_id":"public/css/gallery.css","hash":"79dfdf68d675c17782271647283c568d086e4b98","modified":1667187398166},{"_id":"public/css/indexcover.css","hash":"4dea2c489452c3efe70fa91a6a7678da64d895da","modified":1667187398166},{"_id":"public/css/my-gitalk.css","hash":"af18dd29e58642c18bab9b89541767b494c468dd","modified":1667187398166},{"_id":"public/css/post.css","hash":"d38c71eddb8af1752c48eb48595fbaf89450ff40","modified":1667187398166},{"_id":"public/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1667187398166},{"_id":"public/css/reward.css","hash":"98b32aabeb908727844af04c31f08da6cab08335","modified":1667187398166},{"_id":"public/js/gallery-encrypt.js","hash":"18dcfa4a8da8847b64be75f287f45c0e830bbcab","modified":1667187398166},{"_id":"public/js/jquery.barrager.js","hash":"19c8b2498ca1083e537f7f443172970912107f83","modified":1667187398166},{"_id":"public/js/matery.js","hash":"aa957ea8cf6787f0ed6095fedc6cb9d7d1bf3522","modified":1667187398166},{"_id":"public/js/search.js","hash":"5caa2d6e3d34c334ac68dfaafc81a583d6123382","modified":1667187398166},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1667187398166},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1667187398166},{"_id":"public/libs/aplayer/Meting.min.js","hash":"f2b3d20b8bd64ccd031c64628f2b1323078ae324","modified":1667187398166},{"_id":"public/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1667187398166},{"_id":"public/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1667187398166},{"_id":"public/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1667187398166},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1667187398166},{"_id":"public/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1667187398166},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1667187398166},{"_id":"public/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1667187398166},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1667187398166},{"_id":"public/libs/fancybox/jquery.fancybox.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1667187398166},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1667187398166},{"_id":"public/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1667187398166},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1667187398166},{"_id":"public/libs/justifiedGallery/justifiedGallery.min.css","hash":"89fb099880771c23dce3005a87db36053c8c491c","modified":1667187398166},{"_id":"public/libs/mermaid/mermaid.min.css","hash":"1dbcd9312e57f2a0b569451d0028d88316614481","modified":1667187398166},{"_id":"public/libs/minivaline/MiniValine.js","hash":"f7f6cdc1b22297e02334e304444e9a8351acb455","modified":1667187398166},{"_id":"public/libs/others/TencentCaptcha.js","hash":"10a034ac0b4ebe97ec5916b092b36fa2d6e9edd0","modified":1667187398166},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1667187398166},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1667187398166},{"_id":"public/libs/others/snow.js","hash":"02b1eeaca737c47be637b304feb3d36d792ee0c4","modified":1667187398166},{"_id":"public/libs/others/star.js","hash":"cf32f8ce2a1a51ba65d3b6063fe2ee1482550190","modified":1667187398166},{"_id":"public/libs/prism/prism.min.css","hash":"ed3896649670cf142e514685da2b060cca5fd43a","modified":1667187398166},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1667187398166},{"_id":"public/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1667187398166},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"39055053a477e7d54b46cfb46591f84cc3818eeb","modified":1667187398166},{"_id":"public/libs/typed/typed.js","hash":"eaf2798298790ec3fad17f6c68b5d3b02dfd069c","modified":1667187398166},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1667187398166},{"_id":"public/css/dark.css","hash":"0dcd292d10f27f11c18d1a1a461b7e0cfe6c55cf","modified":1667187398166},{"_id":"public/css/matery.css","hash":"413ad9731332810823b57dd0f4c0284e3af2af63","modified":1667187398166},{"_id":"public/js/crypto-js.js","hash":"3dd73b6f13dc818a3a9c5c7424c1c4a9649b00a2","modified":1667187398166},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1667187398166},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1667187398166},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1667187398166},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1667187398166},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1667187398166},{"_id":"public/libs/gitalk/gitalk.css","hash":"61d71cb30f5f34cbb1f2b5bc469784d6cb908c22","modified":1667187398166},{"_id":"public/libs/fancybox/fancybox.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1667187398166},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1667187398166},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"490148a22ab2b03a880495cc733ecd1840c02ed6","modified":1667187398166},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1667187398166},{"_id":"public/libs/jquery/jquery-3.6.0.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1667187398166},{"_id":"public/libs/justifiedGallery/justifiedGallery.min.js","hash":"82ab395176c927ffbb2f7c95132ee0a06cd5d64a","modified":1667187398166},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"d20252cf76c3be8af37a8415d13ad368c762b4d8","modified":1667187398166},{"_id":"public/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1667187398166},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1667187398166},{"_id":"public/libs/others/sakura-reduce.js","hash":"f7527e9fb4e6fe2cc7c8880692d77bcda95900c7","modified":1667187398166},{"_id":"public/libs/others/sakura-half.js","hash":"a41b64af88fdd0e2d3502752d059661c1bc743dc","modified":1667187398166},{"_id":"public/libs/others/sakura-small.js","hash":"3284a9ab71454e574d80663f3a05735cd12a6a05","modified":1667187398166},{"_id":"public/libs/others/sakura.js","hash":"9e196ab241799126e6a2dd23ee1708b1505ccbf0","modified":1667187398166},{"_id":"public/libs/valine/Valine.min.js","hash":"d081a412c63411a75a3a880ddece65335d1c3ee8","modified":1667187398166},{"_id":"public/libs/valine/av-min.js","hash":"db56ef6acb789da00d39bd6b97c1b09c2d429195","modified":1667187398166},{"_id":"public/libs/twikoo/twikoo.all.min.js","hash":"c3f5f0a69b7864e7ef5bbf99fc774bec37947d7c","modified":1667187398166},{"_id":"public/libs/waline/Waline.min.js","hash":"94f70e622e2a1ab05adb205033a9ddf371c61534","modified":1667187398166},{"_id":"public/libs/awesome/css/all.min.css","hash":"0ae47fa834fb55de7b50c79021aeabecfae50c9c","modified":1667187398166},{"_id":"public/libs/awesome/css/all.css","hash":"8d63fa8b0f60a50b07ac0f7e751f6f5e02ecdc44","modified":1667187398166},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"7873d80020ae04955bb57521bd249a6974d1180f","modified":1667187398166},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"aab2633f69581c2e26e22a23712f1501d7fcec18","modified":1667187398166},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1667187398166},{"_id":"public/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1667187398166},{"_id":"public/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1667187398166},{"_id":"public/medias/banner/1.jpg","hash":"ab122a36998a4f62a61e61a4fc5e00248113413b","modified":1667187398166},{"_id":"public/medias/banner/5.jpg","hash":"852418f4f09e796e12bc3bab7a1488d3f37d6486","modified":1667187398166},{"_id":"public/medias/banner/6.jpg","hash":"ed7282cc129c4ff9f322d2f2897fb4aac5c48589","modified":1667187398166},{"_id":"public/medias/images/02.jpg","hash":"a5b656606811f4d7e10307f48c0e3c373e0b886d","modified":1667187398166},{"_id":"public/libs/awesome/webfonts/fa-brands-400.ttf","hash":"fa5745d421c0fc90928626be98e9f8cf7580b327","modified":1667187398166},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff2","hash":"1979128e8ba1517d85f5e4ee505abf486c51557c","modified":1667187398166},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1667187398166},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"564fc7c731d05fa70d71ef853a2c8cc7725739e2","modified":1667187398166},{"_id":"public/libs/prism/prism.min.js","hash":"6fc9b7be93e51b4017a61483c13187af0149f194","modified":1667187398166},{"_id":"public/libs/mermaid/mermaid.min.js","hash":"6bee48c26c32b90f50519f125890fcbb04779da6","modified":1667187398166},{"_id":"public/medias/banner/4.jpg","hash":"e5ac5033678afa9d69edffe9a61004f836cb5734","modified":1667187398166},{"_id":"public/medias/images/03.jpg","hash":"2bd3815508a9f5b0ae79aa780bc02ac80b2a354e","modified":1667187398166},{"_id":"public/libs/awesome/webfonts/fa-solid-900.ttf","hash":"e3339400ef6214cfa077d003daed2bfa659e2956","modified":1667187398166},{"_id":"public/medias/images/01.jpg","hash":"6a81f437fb876666bafaa98b2a09bd8bd7f21832","modified":1667187398166},{"_id":"public/libs/mermaid/mermaid.js","hash":"a7933bef8aba190825ba7716497209187ac1de5d","modified":1667187398166},{"_id":"public/2021/10/21/ji-yu-xcode11-chuang-jian-zi-ding-yi-uiwindow/16277872068447.png","hash":"4dd634e01851446ff1adc6424b39ba5233ac0064","modified":1667187398166},{"_id":"source/_posts/java8的stream.md","hash":"5a88fd152272fa08cbdfc9bd5f9d062622ea0396","modified":1667181688846},{"_id":"public/2022/10/26/java8-de-stream/index.html","hash":"5d3338acd953139f8f8ca805ecf8adec3145af01","modified":1667186055924},{"_id":"public/tags/java8/index.html","hash":"b343f89fad75afb9249c48a00a58d7aa44abf662","modified":1667186055924},{"_id":"source/_posts/什么是Web3-0.md","hash":"eed388594ef5c3adb30a3cbe1499915405150d42","modified":1667187222977},{"_id":"public/2022/10/31/shi-me-shi-web3-0/index.html","hash":"1d1ddc4a1588ce1d50e95141953674bb41df8336","modified":1667187176192},{"_id":"public/categories/web3-0/index.html","hash":"53710af2539210a89afff121ba663a3f40e0de3c","modified":1667186055924},{"_id":"public/tags/web/index.html","hash":"1c76ea4f1b5fca17bc231f94c8a021b95de7df3c","modified":1667186055924},{"_id":"source/_posts/什么是Web3-0/1667183789631-dd785c26-0224-4212-a3dc-782fe61d5dc4.jpeg","hash":"e191a24c878f23e2f6b2a7bc33120da6657df144","modified":1667184345575},{"_id":"source/_posts/什么是Web3-0/1667183789718-964dbbfc-1786-4678-867d-e69cea9981f9.jpeg","hash":"602d0af08bc8b8b553ee7f5c06359a8a3af7f00d","modified":1667184345560},{"_id":"source/_posts/什么是Web3-0/1667183789660-e1d372b9-3971-4cce-b0dc-e3ef6133e671.jpeg","hash":"48a54f3a13605f38b14967276f3021106bf012ff","modified":1667184345540},{"_id":"source/_posts/什么是Web3-0/1667183790172-0d0d9de2-891b-4864-b5c4-834c6d950816.jpeg","hash":"2c4504360a5052f9d64f302c36611e34db45d30b","modified":1667184345505},{"_id":"source/_posts/什么是Web3-0/1667183789652-9cba8aef-9ee1-4d8e-a6b4-d421eb87e6f5.jpeg","hash":"1a04b7ea9493f07b4c58ad91642405476c29e2af","modified":1667184345591},{"_id":"source/_posts/什么是Web3-0/1667183790180-a72ab9b6-e223-4aa3-a0dd-475a8c603072.jpeg","hash":"5de623c89da98b6710338c0f26d5ea59b9843d8b","modified":1667184345526},{"_id":"source/_posts/什么是Web3-0/1667183790202-825900a2-6d75-4a59-9d3a-35e031294881.jpeg","hash":"3babacb9ee90f26bb2e7424becbe76a1539d73a8","modified":1667184345512},{"_id":"public/2022/10/31/shi-me-shi-web3-0/1667183789631-dd785c26-0224-4212-a3dc-782fe61d5dc4.jpeg","hash":"e191a24c878f23e2f6b2a7bc33120da6657df144","modified":1667184444213},{"_id":"public/2022/10/31/shi-me-shi-web3-0/1667183789660-e1d372b9-3971-4cce-b0dc-e3ef6133e671.jpeg","hash":"48a54f3a13605f38b14967276f3021106bf012ff","modified":1667184444213},{"_id":"public/2022/10/31/shi-me-shi-web3-0/1667183789718-964dbbfc-1786-4678-867d-e69cea9981f9.jpeg","hash":"602d0af08bc8b8b553ee7f5c06359a8a3af7f00d","modified":1667184444213},{"_id":"public/2022/10/31/shi-me-shi-web3-0/1667183790172-0d0d9de2-891b-4864-b5c4-834c6d950816.jpeg","hash":"2c4504360a5052f9d64f302c36611e34db45d30b","modified":1667184444213},{"_id":"public/2022/10/31/shi-me-shi-web3-0/1667183789652-9cba8aef-9ee1-4d8e-a6b4-d421eb87e6f5.jpeg","hash":"1a04b7ea9493f07b4c58ad91642405476c29e2af","modified":1667184444213},{"_id":"public/2022/10/31/shi-me-shi-web3-0/1667183790202-825900a2-6d75-4a59-9d3a-35e031294881.jpeg","hash":"3babacb9ee90f26bb2e7424becbe76a1539d73a8","modified":1667184444213},{"_id":"public/2022/10/31/shi-me-shi-web3-0/1667183790180-a72ab9b6-e223-4aa3-a0dd-475a8c603072.jpeg","hash":"5de623c89da98b6710338c0f26d5ea59b9843d8b","modified":1667184444213},{"_id":"source/_posts/什么是Web3-0/1667183789631.jpeg","hash":"e191a24c878f23e2f6b2a7bc33120da6657df144","modified":1667184345575},{"_id":"source/_posts/什么是Web3-0/1667183789660.jpeg","hash":"48a54f3a13605f38b14967276f3021106bf012ff","modified":1667184345540},{"_id":"source/_posts/什么是Web3-0/1667183790172.jpeg","hash":"2c4504360a5052f9d64f302c36611e34db45d30b","modified":1667184345505},{"_id":"source/_posts/什么是Web3-0/1667183789718.jpeg","hash":"602d0af08bc8b8b553ee7f5c06359a8a3af7f00d","modified":1667184345560},{"_id":"source/_posts/什么是Web3-0/1667183789652.jpeg","hash":"1a04b7ea9493f07b4c58ad91642405476c29e2af","modified":1667184345591},{"_id":"source/_posts/什么是Web3-0/1667183790180.jpeg","hash":"5de623c89da98b6710338c0f26d5ea59b9843d8b","modified":1667184345526},{"_id":"source/_posts/什么是Web3-0/1667183790202.jpeg","hash":"3babacb9ee90f26bb2e7424becbe76a1539d73a8","modified":1667184345512},{"_id":"public/2022/10/31/shi-me-shi-web3-0/1667183789631.jpeg","hash":"e191a24c878f23e2f6b2a7bc33120da6657df144","modified":1667185710859},{"_id":"public/2022/10/31/shi-me-shi-web3-0/1667183789718.jpeg","hash":"602d0af08bc8b8b553ee7f5c06359a8a3af7f00d","modified":1667185710859},{"_id":"public/2022/10/31/shi-me-shi-web3-0/1667183789660.jpeg","hash":"48a54f3a13605f38b14967276f3021106bf012ff","modified":1667185710859},{"_id":"public/2022/10/31/shi-me-shi-web3-0/1667183790172.jpeg","hash":"2c4504360a5052f9d64f302c36611e34db45d30b","modified":1667185710859},{"_id":"public/2022/10/31/shi-me-shi-web3-0/1667183789652.jpeg","hash":"1a04b7ea9493f07b4c58ad91642405476c29e2af","modified":1667185710859},{"_id":"public/2022/10/31/shi-me-shi-web3-0/1667183790180.jpeg","hash":"5de623c89da98b6710338c0f26d5ea59b9843d8b","modified":1667185710859},{"_id":"public/2022/10/31/shi-me-shi-web3-0/1667183790202.jpeg","hash":"3babacb9ee90f26bb2e7424becbe76a1539d73a8","modified":1667185710859},{"_id":"source/_posts/hellow.md","hash":"e24788d8adee0257ff1b70bb5e08cd035386306c","modified":1667187509683},{"_id":"source/_posts/感受java8后lambda之美.md","hash":"4725cbabc450f2bcffe6f1b081de0e8894e44bb6","modified":1667540868306},{"_id":"source/_posts/感受java8后lambda之美/image_16155432.png","hash":"82bfdd63567076352313b10286ddcbc46588f6ee","modified":1667526120451},{"_id":"source/_posts/感受java8后lambda之美/image_23fab375.png","hash":"f40bb976e9bfbbdb7b31232c8f5f1a125a4c5d59","modified":1667526120451},{"_id":"source/_posts/感受java8后lambda之美/image_7771b4fe.png","hash":"a0b4ed5df52f34ac41e7e901bbd93d4b45961c75","modified":1667526120452},{"_id":"source/_posts/感受java8后lambda之美/image_79d304da.png","hash":"ab609b189e3da922b22c0a94146eadfc7ec2373d","modified":1667526120453},{"_id":"source/_posts/感受java8后lambda之美/image_9186bf98.png","hash":"7e7c755f3d086836057e551e4b809186a6a85176","modified":1667526120453},{"_id":"source/_posts/感受java8后lambda之美/image_c1ac2536.png","hash":"8721847009c10220ecec669342f626568e3fe497","modified":1667526120454},{"_id":"source/_posts/感受java8后lambda之美/image_eba0197b.png","hash":"126816f760c9a3abae668504b06b2fcdfd3c6d40","modified":1667526120454},{"_id":"source/_posts/感受java8后lambda之美/image_ec9c4260.png","hash":"a12867ca34f35c0cc2208210e8931c8a9ba7d35c","modified":1667526120455},{"_id":"public/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/index.html","hash":"15f6df8df53ba30cc117584dd2890add931b952a","modified":1668415301182},{"_id":"public/archives/2022/11/index.html","hash":"c2021e926243362a2a7f6d0cfb99a69c1713110d","modified":1668850951662},{"_id":"public/categories/jdk1-8/index.html","hash":"150c18ca5100067a70348ba99f98cb40726d6d6f","modified":1667526452507},{"_id":"public/categories/jdk1-8/lambda/index.html","hash":"cf47cb314f8c1480d8eb71cda4f55a63a6de660b","modified":1667526452507},{"_id":"public/categories/jdk1-8/lambda/函数式编程/index.html","hash":"a17b5b6862096f2879a8d4dfeb9b985534817d42","modified":1667526452507},{"_id":"public/tags/java/index.html","hash":"04de3c7b2a1ba1dac61db24b0acacbaf9fd38e24","modified":1668850951662},{"_id":"public/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_16155432.png","hash":"82bfdd63567076352313b10286ddcbc46588f6ee","modified":1667526452507},{"_id":"public/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_23fab375.png","hash":"f40bb976e9bfbbdb7b31232c8f5f1a125a4c5d59","modified":1667526452507},{"_id":"public/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_7771b4fe.png","hash":"a0b4ed5df52f34ac41e7e901bbd93d4b45961c75","modified":1667526452507},{"_id":"public/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_79d304da.png","hash":"ab609b189e3da922b22c0a94146eadfc7ec2373d","modified":1667526452507},{"_id":"public/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_9186bf98.png","hash":"7e7c755f3d086836057e551e4b809186a6a85176","modified":1667526452507},{"_id":"public/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_c1ac2536.png","hash":"8721847009c10220ecec669342f626568e3fe497","modified":1667526452507},{"_id":"public/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_eba0197b.png","hash":"126816f760c9a3abae668504b06b2fcdfd3c6d40","modified":1667526452507},{"_id":"public/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_ec9c4260.png","hash":"a12867ca34f35c0cc2208210e8931c8a9ba7d35c","modified":1667526452507},{"_id":"source/_posts/在hexo中无痛使用本地图片.md","hash":"3dabe309a0b059262fbc70eac7401048aea4fe82","modified":1667554149359},{"_id":"public/2022/11/04/zai-hexo-zhong-wu-tong-shi-yong-ben-di-tu-pian/index.html","hash":"fc21b36dcb5d2b3d218294a0c0cdd61703c3d8f6","modified":1668415301182},{"_id":"public/tags/hexo/index.html","hash":"596c6ad66af0660cdb0659bb9a11c0a85a844cf6","modified":1668850951662},{"_id":"public/categories/hexo/index.html","hash":"f52700c9ca7c8ed488b887ba24be72c7bdcf5e7a","modified":1668850951662},{"_id":"public/tags/jdk1-8/index.html","hash":"7b55de9e34a7454e7089f23dbe4554d182465a6a","modified":1668850951662},{"_id":"public/tags/lambda/index.html","hash":"ae569c90c2371b0d9e0089ca86af1512b655bf39","modified":1668850951662},{"_id":"public/tags/函数式编程/index.html","hash":"e161d4f6b014b385ca5051ccc9919f1c0e7240cf","modified":1668850951662},{"_id":"source/_posts/Java8Stream实战系列.md","hash":"8a814a02ae37c825f2ac53a32281aecce7189ba1","modified":1667538837194},{"_id":"public/2022/11/04/java8stream-shi-zhan-xi-lie/index.html","hash":"e2955d5b7c1e05a0305e7f800b778821095492a0","modified":1668415301182},{"_id":"public/tags/stream/index.html","hash":"57feb3cf032f39d56a5812f4efa41ac683b993be","modified":1668850951662},{"_id":"public/tags/lambda操作/index.html","hash":"328b31a9d5fe43a1aa2b695a236f6cfe5fbca504","modified":1668850951662},{"_id":"source/_posts/45个日常用git合代码的经典操作场景.md","hash":"6655229e72a8bb708c97a7ad8eb3be7206dd5dad","modified":1667553579054},{"_id":"public/2022/11/04/45-ge-ri-chang-yong-git-he-dai-ma-de-jing-dian-cao-zuo-chang-jing/index.html","hash":"d60077f66f9ee60f5e1ab12a986e56f99d788bef","modified":1668415301182},{"_id":"public/categories/git/index.html","hash":"256659bcfca1bf888d33ec9a49e54101393576ee","modified":1668850951662},{"_id":"public/tags/git/index.html","hash":"bce7f412464dd210b12672e152186b5be8354a2b","modified":1668850951662},{"_id":"public/tags/代码合并/index.html","hash":"b7f0562486c12d0a6c97362a12d554d69966fd04","modified":1668850951662},{"_id":"source/_posts/Java基础篇的八股文.md","hash":"3fd4adc0d6b0e99b7fc6cb07feefbca340f52b2d","modified":1667540828896},{"_id":"source/_posts/Java并发编程八股文.md","hash":"a3a472e76f5d65a7ae6e7b7dc430e83626c78ac1","modified":1667540805544},{"_id":"source/_posts/Java虚拟机八股文.md","hash":"0e06bba5c9ab95b109d52f023fa4a1383c3a1cac","modified":1667539374139},{"_id":"public/2022/11/04/java-bing-fa-bian-cheng-ba-gu-wen/index.html","hash":"a477a5e42a96b2c9987cb8e64262f5c141b00cea","modified":1668415301182},{"_id":"public/2022/11/04/java-ji-chu-pian-de-ba-gu-wen/index.html","hash":"31fc19031a5f8380ab3effc760b8029649d856b6","modified":1668415301182},{"_id":"public/2022/11/04/java-xu-ni-ji-ba-gu-wen/index.html","hash":"2ff4b83e577b33bb3387b0af395d07b0c034e1fa","modified":1668415301182},{"_id":"public/tags/并发编程/index.html","hash":"f1ec72a26edc26fbe25798f1c3dcbd0e240931e9","modified":1668850951662},{"_id":"public/tags/java基础/index.html","hash":"702b15aa141d24ff88ab6725018f6e718302f306","modified":1668850951662},{"_id":"public/tags/虚拟机/index.html","hash":"80cb5be3460fb6e5cea4937d05080484c62156f4","modified":1667539119757},{"_id":"public/tags/八股文/index.html","hash":"ab6634bf07af41698d3563ff5a37c965f4d453cd","modified":1668850951662},{"_id":"public/tags/java虚拟机/index.html","hash":"9db3b28e6f09f185c1604b9354a1e414b2415b2c","modified":1668850951662},{"_id":"source/_posts/SQL语句性能优化策略.md","hash":"7dfa0284a72b49634100d837ecba380c0e23ad88","modified":1667553600274},{"_id":"public/2022/11/04/sql-yu-ju-xing-neng-you-hua-ce-lue/index.html","hash":"f504786d28f610f77b6359f3b7172a66f3eb987a","modified":1668415301182},{"_id":"public/categories/技巧/index.html","hash":"7eeaca2bc79ed4a9edc15bbf3edc24ac7906f536","modified":1668850951662},{"_id":"public/tags/sql优化/index.html","hash":"9f7a2a3fc9050cd5891e0b87c000ee04da638cfa","modified":1668850951662},{"_id":"source/_posts/23种设计模式的通俗解释.md","hash":"6a570c12f01bdb7a63a9f497fc9f5e128eb5b57d","modified":1667553574320},{"_id":"public/2022/11/04/23-chong-she-ji-mo-shi-de-tong-su-jie-shi/index.html","hash":"17986a22c2e7f6cf42c279ec0b86b33b88916080","modified":1668415301182},{"_id":"public/tags/程序设计/index.html","hash":"926c8460ce7454dbad45928eacbb00ca229d0594","modified":1668850951662},{"_id":"source/_posts/不推荐使用-Autowired注解.md","hash":"34e7eacb7ed4cd7c5c9fe131ef50e20fb7709061","modified":1667553810759},{"_id":"public/2022/11/04/bu-tui-jian-shi-yong-autowired-zhu-jie/index.html","hash":"a2f15d2b8e1a15a190e6a625b9f8793afc56a197","modified":1668415301182},{"_id":"public/tags/ioc/index.html","hash":"2f79e8b6a29eb8129192c79e998b6396038fc428","modified":1668850951662},{"_id":"source/_posts/ConcurrentHashMap是如何保证线程安全/image_256782fc-20221104171702786.png","hash":"6428b4b8b284dc61645c9e22c7ec3d1348e669e4","modified":1667553455818},{"_id":"source/_posts/ConcurrentHashMap是如何保证线程安全.md","hash":"a96b4cc6fc780de8301a487f8f58d5fc160c60e5","modified":1667554105831},{"_id":"source/_posts/ConcurrentHashMap是如何保证线程安全/image_4be279cf-20221104171705595.png","hash":"26df1c10f31e14c343f96873087eacb60ce87ec6","modified":1667553455809},{"_id":"public/2022/11/04/concurrenthashmap-shi-ru-he-bao-zheng-xian-cheng-an-quan/index.html","hash":"e3090c411c2c8c8a09c8f35a0c8d423aed13da2c","modified":1668415301182},{"_id":"public/archives/page/2/index.html","hash":"4723f998086dadcaa1a4335fec3c57ef4748361c","modified":1668850951662},{"_id":"public/archives/2022/page/2/index.html","hash":"d673898c094e4ea6a491289fa75927a0c32e91cc","modified":1668850951662},{"_id":"public/archives/2022/11/page/2/index.html","hash":"6abce490e86f06178cff9b3dd7b2261b9cb19a40","modified":1668850951662},{"_id":"public/page/2/index.html","hash":"41d58941dd6e76c0cf54cb905a94243660a4e8fc","modified":1668850951662},{"_id":"public/2022/11/04/concurrenthashmap-shi-ru-he-bao-zheng-xian-cheng-an-quan/image_256782fc-20221104171702786.png","hash":"6428b4b8b284dc61645c9e22c7ec3d1348e669e4","modified":1667553467924},{"_id":"public/2022/11/04/concurrenthashmap-shi-ru-he-bao-zheng-xian-cheng-an-quan/image_4be279cf-20221104171705595.png","hash":"26df1c10f31e14c343f96873087eacb60ce87ec6","modified":1667553467924},{"_id":"public/tags/源码/index.html","hash":"95437466afd2eb30189583a94a15b71b10c0aa6c","modified":1668850951662},{"_id":"themes/hexo-theme-matery/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1667555593303},{"_id":"source/_posts/SpringBoot内置工具类.md","hash":"95569adc17841cc38fb21907c2e689684bcebfc2","modified":1667787248219},{"_id":"source/_posts/java中高级面试题总结.md","hash":"388188c3241a7399e0f7635989e0e93cb03bfaea","modified":1667786046334},{"_id":"public/2022/11/07/springboot-nei-zhi-gong-ju-lei/index.html","hash":"cdc7c9cbaa2874c945d1227013397fa6eca8b947","modified":1668415301182},{"_id":"public/2022/11/07/java-zhong-gao-ji-mian-shi-ti-zong-jie/index.html","hash":"703744f1989061a150dd25ef7591b7e1436bddc5","modified":1668415301182},{"_id":"public/categories/java/spring/index.html","hash":"a9aacd443bd1c33221c54133cefd42fad4809b56","modified":1668850951662},{"_id":"public/tags/java面试/index.html","hash":"28fe1db028a1951a75f98936ceb64e381270ce94","modified":1668850951662},{"_id":"public/tags/工具轮子/index.html","hash":"6800635bb8700624fc08135f6bb72776f0bbaa7d","modified":1668850951662},{"_id":"source/_posts/JDK源码中NB的设计模式.md","hash":"4c8f0b30f0e50b896c469dd4c645ff8a0fa43983","modified":1667787949685},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/index.html","hash":"af5a2f4a9e22973a86be7f8bf5ce93fa6fa0ed37","modified":1668415301182},{"_id":"public/categories/java/page/2/index.html","hash":"e7c0e38777e3a66ebfd796b360e20aa5a4389db1","modified":1668850951662},{"_id":"public/tags/jdk源码/index.html","hash":"44a4ec15d59a51c2c4380c27c7760fc8f3de1d02","modified":1668850951662},{"_id":"source/_posts/JDK源码中NB的设计模式/image_056a7a91.png","hash":"a94f5828297f0ca2b7e783eb7dbc2d26a3fc25c1","modified":1667789394860},{"_id":"source/_posts/JDK源码中NB的设计模式/image_0f3aa81b.png","hash":"d8de7389160e7938d90072e11ac02b4b64f2a3f6","modified":1667789394824},{"_id":"source/_posts/JDK源码中NB的设计模式/image_09845ad7.png","hash":"ed254ce9b7591ae9ba6c7a1c41e15d26069ad93d","modified":1667789394794},{"_id":"source/_posts/JDK源码中NB的设计模式/image_0db7343e.png","hash":"39c9d3209977d5b75ee1b8479dbd9b2eed121b8a","modified":1667789396311},{"_id":"source/_posts/JDK源码中NB的设计模式/image_26b58e72.png","hash":"e16834721ef76602c5a6f37c9ac788c6ae43ce55","modified":1667789395193},{"_id":"source/_posts/JDK源码中NB的设计模式/image_12478821.png","hash":"2193baecfcc8b58488c3db808e0b8c45a5d90ac6","modified":1667789395155},{"_id":"source/_posts/JDK源码中NB的设计模式/image_3135fcc2.png","hash":"2ab0334415ddf00f1ac754710afa498310d5b674","modified":1667789395285},{"_id":"source/_posts/JDK源码中NB的设计模式/image_56c75850.png","hash":"cf11320bd32b56c9189dbfaf01462ba894586a25","modified":1667789395085},{"_id":"source/_posts/JDK源码中NB的设计模式/image_4cc8d46f.png","hash":"8696c968eee720e2cf6a56911674979403e849cf","modified":1667789395032},{"_id":"source/_posts/JDK源码中NB的设计模式/image_6794e25f.png","hash":"c061c9deabf9bb9e60a346475b20503304a64998","modified":1667789394980},{"_id":"source/_posts/JDK源码中NB的设计模式/image_7cbd31c6.png","hash":"03564db781e7fb1be6fd959d649200fb92f5c6cf","modified":1667789394919},{"_id":"source/_posts/JDK源码中NB的设计模式/image_7f6ad923.png","hash":"665bf4f106115dd97c511b0b5317c09f32b16297","modified":1667789394952},{"_id":"source/_posts/JDK源码中NB的设计模式/image_80280cd4.png","hash":"4d4f7e3046bfbac126925faa1d3df43528ab74de","modified":1667789396242},{"_id":"source/_posts/JDK源码中NB的设计模式/image_8826e899.png","hash":"6358794746f30f765e336e51a69d7f56d8d5ce48","modified":1667789394886},{"_id":"source/_posts/JDK源码中NB的设计模式/image_a76314fe.png","hash":"90f425c189889ccb6461c886049e016c96a5fd92","modified":1667789395123},{"_id":"source/_posts/JDK源码中NB的设计模式/image_a62166f6.png","hash":"785a12d24f71bb88fd042db6e98b0c9dc92b5665","modified":1667789396164},{"_id":"source/_posts/JDK源码中NB的设计模式/image_b2dcd320.png","hash":"0edd9157e7ce22ff15321f542b176152a3d7f2ec","modified":1667789395330},{"_id":"source/_posts/JDK源码中NB的设计模式/image_a7e0d82b.png","hash":"4c4c8e3cae9f18099cd079035651211920a0f31f","modified":1667789395654},{"_id":"source/_posts/JDK源码中NB的设计模式/image_cabc5bfb.png","hash":"985e39d983d8c92dfbd3e5e38658c47c1bed8b3b","modified":1667789396118},{"_id":"source/_posts/JDK源码中NB的设计模式/image_da86596b.png","hash":"3e4869aad4dfdbd5eb77041c137933c5c9262786","modified":1667789396202},{"_id":"source/_posts/JDK源码中NB的设计模式/image_db731042.png","hash":"7624f3a191ad874c24a0cb956ca517a3bcf19694","modified":1667789396085},{"_id":"source/_posts/JDK源码中NB的设计模式/image_e9562544.png","hash":"4436ac3ea0e9fa861b02cbe820a93775d3d743a0","modified":1667789396002},{"_id":"source/_posts/JDK源码中NB的设计模式/image_f4c365cb.png","hash":"62aef5b24d084cdc0e0ce3b89693ed4402045771","modified":1667789395235},{"_id":"source/_posts/JDK源码中NB的设计模式/image_fbd05a32.png","hash":"04bf809d3a099e25c9a0bdc22f24aa4382077b33","modified":1667789395875},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_056a7a91.png","hash":"a94f5828297f0ca2b7e783eb7dbc2d26a3fc25c1","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_09845ad7.png","hash":"ed254ce9b7591ae9ba6c7a1c41e15d26069ad93d","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_0db7343e.png","hash":"39c9d3209977d5b75ee1b8479dbd9b2eed121b8a","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_0f3aa81b.png","hash":"d8de7389160e7938d90072e11ac02b4b64f2a3f6","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_12478821.png","hash":"2193baecfcc8b58488c3db808e0b8c45a5d90ac6","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_26b58e72.png","hash":"e16834721ef76602c5a6f37c9ac788c6ae43ce55","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_3135fcc2.png","hash":"2ab0334415ddf00f1ac754710afa498310d5b674","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_4cc8d46f.png","hash":"8696c968eee720e2cf6a56911674979403e849cf","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_56c75850.png","hash":"cf11320bd32b56c9189dbfaf01462ba894586a25","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_7cbd31c6.png","hash":"03564db781e7fb1be6fd959d649200fb92f5c6cf","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_6794e25f.png","hash":"c061c9deabf9bb9e60a346475b20503304a64998","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_7f6ad923.png","hash":"665bf4f106115dd97c511b0b5317c09f32b16297","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_80280cd4.png","hash":"4d4f7e3046bfbac126925faa1d3df43528ab74de","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_8826e899.png","hash":"6358794746f30f765e336e51a69d7f56d8d5ce48","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_a62166f6.png","hash":"785a12d24f71bb88fd042db6e98b0c9dc92b5665","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_a76314fe.png","hash":"90f425c189889ccb6461c886049e016c96a5fd92","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_a7e0d82b.png","hash":"4c4c8e3cae9f18099cd079035651211920a0f31f","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_b2dcd320.png","hash":"0edd9157e7ce22ff15321f542b176152a3d7f2ec","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_cabc5bfb.png","hash":"985e39d983d8c92dfbd3e5e38658c47c1bed8b3b","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_da86596b.png","hash":"3e4869aad4dfdbd5eb77041c137933c5c9262786","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_db731042.png","hash":"7624f3a191ad874c24a0cb956ca517a3bcf19694","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_e9562544.png","hash":"4436ac3ea0e9fa861b02cbe820a93775d3d743a0","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_f4c365cb.png","hash":"62aef5b24d084cdc0e0ce3b89693ed4402045771","modified":1667789403361},{"_id":"public/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_fbd05a32.png","hash":"04bf809d3a099e25c9a0bdc22f24aa4382077b33","modified":1667789403361},{"_id":"source/_posts/常见代码重构技巧.md","hash":"ef158d8609d2199d9295fad0105be323a323a676","modified":1667872656379},{"_id":"source/_posts/常见代码重构技巧/image_41c09a5c.png","hash":"b850fa1510cddd78351996f2d63215d921623dbb","modified":1667872690853},{"_id":"source/_posts/常见代码重构技巧/image_450be2e5.png","hash":"a00c30e108854711734db91ca1fe5b352604a7e9","modified":1667872690758},{"_id":"source/_posts/常见代码重构技巧/image_2c6e506b.png","hash":"a2c601a5fa7013696af2cd00a5d6b56188c027af","modified":1667872690888},{"_id":"source/_posts/常见代码重构技巧/image_8fa858cb.png","hash":"f538bfe9a1801e6f4e5025b19fe1d11135aec435","modified":1667872690827},{"_id":"source/_posts/常见代码重构技巧/image_83a6a12c.png","hash":"1535e63fb1b4e878c449c2d6c4c4a320141e0139","modified":1667872690730},{"_id":"source/_posts/常见代码重构技巧/image_d67b805c-20221108095355391.png","hash":"f09809b8957784979f9b41848be97b88c26b8153","modified":1667872690877},{"_id":"source/_posts/常见代码重构技巧/image_e59205e3.png","hash":"678c411ad95c6df6ed86e10b82ae1feaaaeb8707","modified":1667872690744},{"_id":"source/_posts/常见代码重构技巧/image_ff852d0e.png","hash":"9cd548d8d56aba3acce2a7d011cb1bb5ba2c7735","modified":1667872690799},{"_id":"source/_posts/常见代码重构技巧/image_047389be-20221108095355455.png","hash":"0f3e4efb89602fc72d70d525e2cccb31cd1fc356","modified":1667872690813},{"_id":"source/_posts/常见代码重构技巧/image_598a46ba.png","hash":"7afa5c56c9f5efc309fdfbee37391a78f5f811c1","modified":1667872690785},{"_id":"source/_posts/常见代码重构技巧/image_83d6de95-20221108095355418.png","hash":"04f2b91b904ecb01e54682bb988973d69aff76ae","modified":1667872690865},{"_id":"source/_posts/常见代码重构技巧/image_9db0426b-20221108095355436.png","hash":"898a2d72ed6241fff102ad7eb839ba219664e20d","modified":1667872690840},{"_id":"source/_posts/常见代码重构技巧/image_24ceb509.png","hash":"f621758007c5809ccfaf6f27b1d8dcc0910349f7","modified":1667872690706},{"_id":"source/_posts/常见代码重构技巧/image_4605e609.png","hash":"38d80935b4b7fda646fbe2a59809b11c0d72e955","modified":1667872690718},{"_id":"source/_posts/常见代码重构技巧/image_f864e546-20221108095355479.png","hash":"90de9f1e6d0ed244358830582856ac75f405c113","modified":1667872690773},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/index.html","hash":"e0875165a1f95e3b2e97b09fafc465557604a6ad","modified":1668415301182},{"_id":"public/tags/重构/index.html","hash":"cd5d4cd0ffab38f3087d233914dad2352f655374","modified":1668850951662},{"_id":"public/tags/技巧/index.html","hash":"23ac410dc0ae320659260933a846761159017dfe","modified":1668850951662},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_2c6e506b.png","hash":"a2c601a5fa7013696af2cd00a5d6b56188c027af","modified":1667872701237},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_450be2e5.png","hash":"a00c30e108854711734db91ca1fe5b352604a7e9","modified":1667872701237},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_41c09a5c.png","hash":"b850fa1510cddd78351996f2d63215d921623dbb","modified":1667872701237},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_8fa858cb.png","hash":"f538bfe9a1801e6f4e5025b19fe1d11135aec435","modified":1667872701237},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_e59205e3.png","hash":"678c411ad95c6df6ed86e10b82ae1feaaaeb8707","modified":1667872701237},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_83a6a12c.png","hash":"1535e63fb1b4e878c449c2d6c4c4a320141e0139","modified":1667872701237},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_d67b805c-20221108095355391.png","hash":"f09809b8957784979f9b41848be97b88c26b8153","modified":1667872701237},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_ff852d0e.png","hash":"9cd548d8d56aba3acce2a7d011cb1bb5ba2c7735","modified":1667872701237},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_047389be-20221108095355455.png","hash":"0f3e4efb89602fc72d70d525e2cccb31cd1fc356","modified":1667872701237},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_598a46ba.png","hash":"7afa5c56c9f5efc309fdfbee37391a78f5f811c1","modified":1667872701237},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_83d6de95-20221108095355418.png","hash":"04f2b91b904ecb01e54682bb988973d69aff76ae","modified":1667872701237},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_9db0426b-20221108095355436.png","hash":"898a2d72ed6241fff102ad7eb839ba219664e20d","modified":1667872701237},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_24ceb509.png","hash":"f621758007c5809ccfaf6f27b1d8dcc0910349f7","modified":1667872701237},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_4605e609.png","hash":"38d80935b4b7fda646fbe2a59809b11c0d72e955","modified":1667872701237},{"_id":"public/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_f864e546-20221108095355479.png","hash":"90de9f1e6d0ed244358830582856ac75f405c113","modified":1667872701237},{"_id":"source/_posts/消息队列原理和选型.md","hash":"38d71b3a60c981da3e77908e65630bd2f7059b3f","modified":1667873936723},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/index.html","hash":"da7612320ed447ffc634f2982b32c3cd7d547c9e","modified":1668415301182},{"_id":"public/categories/消息队列/index.html","hash":"5dc5f32cca809316c26db2fd2017cd5b2ffd7dbc","modified":1668850951662},{"_id":"public/tags/mq/index.html","hash":"63c0d9408930dfe1db1c37e1011970e9621e4994","modified":1668850951662},{"_id":"public/tags/中间件/index.html","hash":"1f051f15ef24be4b9b287b3f91c3de0d291a2d14","modified":1668850951662},{"_id":"source/_posts/消息队列原理和选型/image_175157f1.png","hash":"fdceecf75131970433c0fa4eae37b40efb8ac141","modified":1667873684669},{"_id":"source/_posts/消息队列原理和选型/image_97d0e8f2.png","hash":"203cdac0db84147920f394a6b138a16a247e6e32","modified":1667873684719},{"_id":"source/_posts/消息队列原理和选型/image_743e1430.png","hash":"eafe8226087555bf05219db21d118a86a0b00586","modified":1667873684537},{"_id":"source/_posts/消息队列原理和选型/image_d1df2887.png","hash":"8e7c7813732f695e32559a095d001c439076accb","modified":1667873684755},{"_id":"source/_posts/消息队列原理和选型/image_6d065553.png","hash":"d6ac4d92027741b80e4ef05edefd9515246e7460","modified":1667873684689},{"_id":"source/_posts/消息队列原理和选型/image_0eb903df.png","hash":"8d8d0ab1d82f2874996cdff1efa762a7f688444d","modified":1667873684552},{"_id":"source/_posts/消息队列原理和选型/image_8b2ddfc9.png","hash":"2a84d1f65bfbf92786fb81b5ae89dde60e71d0da","modified":1667873684443},{"_id":"source/_posts/消息队列原理和选型/image_9ea86f58.png","hash":"df0096d145dcb50e0f121d549da999bae070f471","modified":1667873684490},{"_id":"source/_posts/消息队列原理和选型/image_c57014d0.png","hash":"77f27aef3cee710efb66990927b728ffc8f6d444","modified":1667873684620},{"_id":"source/_posts/消息队列原理和选型/image_a36c2593.png","hash":"b20c3207ba69daee2f61830ec7c773fa82cfa0f2","modified":1667873684649},{"_id":"source/_posts/消息队列原理和选型/image_14d8f72e.png","hash":"b02abec55ddca6097b4df61c5ad7626ac041e570","modified":1667873684512},{"_id":"source/_posts/消息队列原理和选型/image_0325f376.png","hash":"dd2c743cd132f6dd43c43e82ae0ea6ad538075d3","modified":1667873684606},{"_id":"source/_posts/消息队列原理和选型/image_ae0ce795.png","hash":"389e9c73cfb147c3e87cac7e16379bfa204bdb28","modified":1667873684585},{"_id":"source/_posts/消息队列原理和选型/image_ea5d47d1.png","hash":"29164d64741d8122c0c5ad22779f387526ef4867","modified":1667873684469},{"_id":"source/_posts/消息队列原理和选型/image_de577e1c.png","hash":"20b84fd09af7031bec2d84f9b7da2ee1dfd63c85","modified":1667873684414},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_175157f1.png","hash":"fdceecf75131970433c0fa4eae37b40efb8ac141","modified":1667873692315},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_97d0e8f2.png","hash":"203cdac0db84147920f394a6b138a16a247e6e32","modified":1667873692315},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_743e1430.png","hash":"eafe8226087555bf05219db21d118a86a0b00586","modified":1667873692315},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_d1df2887.png","hash":"8e7c7813732f695e32559a095d001c439076accb","modified":1667873692315},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_6d065553.png","hash":"d6ac4d92027741b80e4ef05edefd9515246e7460","modified":1667873692315},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_0eb903df.png","hash":"8d8d0ab1d82f2874996cdff1efa762a7f688444d","modified":1667873692315},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_8b2ddfc9.png","hash":"2a84d1f65bfbf92786fb81b5ae89dde60e71d0da","modified":1667873692315},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_a36c2593.png","hash":"b20c3207ba69daee2f61830ec7c773fa82cfa0f2","modified":1667873692315},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_9ea86f58.png","hash":"df0096d145dcb50e0f121d549da999bae070f471","modified":1667873692315},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_c57014d0.png","hash":"77f27aef3cee710efb66990927b728ffc8f6d444","modified":1667873692315},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_14d8f72e.png","hash":"b02abec55ddca6097b4df61c5ad7626ac041e570","modified":1667873692315},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_0325f376.png","hash":"dd2c743cd132f6dd43c43e82ae0ea6ad538075d3","modified":1667873692315},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_ae0ce795.png","hash":"389e9c73cfb147c3e87cac7e16379bfa204bdb28","modified":1667873692315},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_ea5d47d1.png","hash":"29164d64741d8122c0c5ad22779f387526ef4867","modified":1667873692315},{"_id":"public/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_de577e1c.png","hash":"20b84fd09af7031bec2d84f9b7da2ee1dfd63c85","modified":1667873692315},{"_id":"source/_posts/分布式锁的多种实现.md","hash":"c48431fd46f1c84e3f484dcbcf1a5d2479b740d4","modified":1667964526407},{"_id":"source/_posts/分布式锁的多种实现/image_d2f64ca3-20221109112215527.png","hash":"2f6b948af138b6cb606a86599e8a91c2d6034328","modified":1667964211761},{"_id":"source/_posts/分布式锁的多种实现/image_f90141b7-20221109112215523.png","hash":"3d4ccb4eb5f14edceb115a67f1dd50e37c9880bc","modified":1667964211775},{"_id":"source/_posts/分布式锁的多种实现/image_bd68a96a-20221109112215522.png","hash":"489899826db3a7c5e4a78b617fb90c88b94ed824","modified":1667964211805},{"_id":"source/_posts/分布式锁的多种实现/image_1cec9bce-20221109112215610.png","hash":"c42a5e46665c88815071bda301ba473cd7a9814c","modified":1667964211567},{"_id":"source/_posts/分布式锁的多种实现/image_071b7d88-20221109112215596.png","hash":"0acd27ba24716227e0e86940e4acd42075345f23","modified":1667964211672},{"_id":"source/_posts/分布式锁的多种实现/image_5b5c8168-20221109112215631.png","hash":"e03a16987a21026d4b072b9c40d3885e2c08ac40","modified":1667964211499},{"_id":"source/_posts/分布式锁的多种实现/image_6ae9d764-20221109112215556.png","hash":"eb7eb4394876397761ff881609ba2c24e05d4584","modified":1667964211693},{"_id":"source/_posts/分布式锁的多种实现/image_92a9dd04-20221109112215540.png","hash":"3323ad2aaa2321da79e5cf9aba33f7dd67d60f7b","modified":1667964211709},{"_id":"source/_posts/分布式锁的多种实现/image_93a8ea85-20221109112215608.png","hash":"c4fd1300a9bb2042c7dfccdf031e15e36212b9eb","modified":1667964211602},{"_id":"source/_posts/分布式锁的多种实现/image_aa38b5f6-20221109112215600.png","hash":"60d2e73d247d14ba1e98719c25e4b61824a2a59b","modified":1667964211614},{"_id":"source/_posts/分布式锁的多种实现/image_b489bef9-20221109112215598.png","hash":"ff0aa8bf744d7ac2d0fefa48d627288f7ca5a1a2","modified":1667964211648},{"_id":"source/_posts/分布式锁的多种实现/image_669de3e0-20221109112215539.png","hash":"5d07b65fca5281389fe98f33c4c9a57deeb87edf","modified":1667964211740},{"_id":"source/_posts/分布式锁的多种实现/image_e929ee6e-20221109112215669.png","hash":"d62171f74a5cb4bdc8cabbcbfb4fc371267351a5","modified":1667964211459},{"_id":"public/2022/11/09/fen-bu-shi-suo-de-duo-chong-shi-xian/index.html","hash":"3d9fb45d82f63671ec820342cc82c1fbeea03b62","modified":1668415301182},{"_id":"public/categories/java/分布式/index.html","hash":"0d1582dc089c1b2a699fb3fa69b5063a2cc36e16","modified":1668850951662},{"_id":"public/tags/锁/index.html","hash":"32e3156e30f8724c37d5ef73cd101a8dd0d8e8c4","modified":1668850951662},{"_id":"public/2022/11/09/fen-bu-shi-suo-de-duo-chong-shi-xian/image_bd68a96a-20221109112215522.png","hash":"489899826db3a7c5e4a78b617fb90c88b94ed824","modified":1667964251144},{"_id":"public/2022/11/09/fen-bu-shi-suo-de-duo-chong-shi-xian/image_f90141b7-20221109112215523.png","hash":"3d4ccb4eb5f14edceb115a67f1dd50e37c9880bc","modified":1667964251144},{"_id":"public/2022/11/09/fen-bu-shi-suo-de-duo-chong-shi-xian/image_d2f64ca3-20221109112215527.png","hash":"2f6b948af138b6cb606a86599e8a91c2d6034328","modified":1667964251144},{"_id":"public/2022/11/09/fen-bu-shi-suo-de-duo-chong-shi-xian/image_5b5c8168-20221109112215631.png","hash":"e03a16987a21026d4b072b9c40d3885e2c08ac40","modified":1667964251144},{"_id":"public/2022/11/09/fen-bu-shi-suo-de-duo-chong-shi-xian/image_071b7d88-20221109112215596.png","hash":"0acd27ba24716227e0e86940e4acd42075345f23","modified":1667964251144},{"_id":"public/2022/11/09/fen-bu-shi-suo-de-duo-chong-shi-xian/image_669de3e0-20221109112215539.png","hash":"5d07b65fca5281389fe98f33c4c9a57deeb87edf","modified":1667964251144},{"_id":"public/2022/11/09/fen-bu-shi-suo-de-duo-chong-shi-xian/image_1cec9bce-20221109112215610.png","hash":"c42a5e46665c88815071bda301ba473cd7a9814c","modified":1667964251144},{"_id":"public/2022/11/09/fen-bu-shi-suo-de-duo-chong-shi-xian/image_6ae9d764-20221109112215556.png","hash":"eb7eb4394876397761ff881609ba2c24e05d4584","modified":1667964251144},{"_id":"public/2022/11/09/fen-bu-shi-suo-de-duo-chong-shi-xian/image_92a9dd04-20221109112215540.png","hash":"3323ad2aaa2321da79e5cf9aba33f7dd67d60f7b","modified":1667964251144},{"_id":"public/2022/11/09/fen-bu-shi-suo-de-duo-chong-shi-xian/image_93a8ea85-20221109112215608.png","hash":"c4fd1300a9bb2042c7dfccdf031e15e36212b9eb","modified":1667964251144},{"_id":"public/2022/11/09/fen-bu-shi-suo-de-duo-chong-shi-xian/image_aa38b5f6-20221109112215600.png","hash":"60d2e73d247d14ba1e98719c25e4b61824a2a59b","modified":1667964251144},{"_id":"public/2022/11/09/fen-bu-shi-suo-de-duo-chong-shi-xian/image_b489bef9-20221109112215598.png","hash":"ff0aa8bf744d7ac2d0fefa48d627288f7ca5a1a2","modified":1667964251144},{"_id":"public/2022/11/09/fen-bu-shi-suo-de-duo-chong-shi-xian/image_e929ee6e-20221109112215669.png","hash":"d62171f74a5cb4bdc8cabbcbfb4fc371267351a5","modified":1667964251144},{"_id":"source/_posts/推荐17个提升开发效率轮子.md","hash":"384c7035bfc5f1117ec35297533f0225c0800781","modified":1667965151326},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/index.html","hash":"eb932e5698f1def06df7f6197a193e808ee5b097","modified":1668415301182},{"_id":"public/categories/java/工具/index.html","hash":"89ed9405c9a687991185ba47d77f626e5da1c92b","modified":1668850951662},{"_id":"public/tags/轮子/index.html","hash":"14c67bb2ce19a1ad687c7e6f0623ad402fa1b68e","modified":1668850951662},{"_id":"source/_posts/目瞪口呆的Java代码技巧.md","hash":"fc3f7da25ceb2dee8ad72f3dec1a451e22d02bb7","modified":1667967192591},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_d64a89cc.png","hash":"25b120f09c7e4185f260608811dd97f3b96cf05b","modified":1667965209667},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_98de130d.png","hash":"9d5abf214f623e190c5d7443ed0ccc55753ab3fc","modified":1667965209702},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_d1a5a95c.png","hash":"9ad4c1b98ae6cb37b04efaf8ae936711f89e7b5e","modified":1667965209457},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_f8deb8c1.png","hash":"df0f4614c61730e8f5691af67076c243d5bb4e17","modified":1667965209689},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_fec0346f.png","hash":"efa048b0361a7ccca4ee058189a6c947384452e1","modified":1667965209491},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_040afd70.png","hash":"a8365db5c7b3c797c03e278b6ff4de2905dc5a90","modified":1667965209655},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_48270fb5.png","hash":"33ca196cb50cd420062f9e05f8e47b6544b344b1","modified":1667965209555},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_5cf672b2.png","hash":"dfd88e6ed5dbdc1b34c4bfe49146b5a55f29dcc2","modified":1667965209600},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_71d4889f.png","hash":"688afd75d4d13edbeb08d58d1c01a55cf893d3d5","modified":1667965209616},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_56af129c.png","hash":"201f525522f02e701e815a5271bb37bd7dfe802d","modified":1667965209571},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_77defa60.png","hash":"83c70c275274428091279f819294af2e5a5681a5","modified":1667965209522},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_7eeac46e.png","hash":"a8e38512a929244d9b9791055dfddfec604c4e8e","modified":1667965209509},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_22c2f25a.png","hash":"7cdcf4571988cf5be8a70386bbd206b6ae525f37","modified":1667965209587},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_ea531c2a.png","hash":"dfad2a74a8654354679d5ce115c1b55ff586f70c","modified":1667965209444},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_fadda8b7.png","hash":"5f4555fe0c67517a528cfcf925ec724c32099a50","modified":1667965209475},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_b1853624.png","hash":"082a12f97b4f79ecfe1eceb102753ce8f490ab77","modified":1667965209537},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_dec3e504.png","hash":"ed0485c64d47671e6e9bc4c2441ea361fc4b0781","modified":1667965209427},{"_id":"public/2022/11/09/mu-deng-kou-ai-de-java-dai-ma-ji-qiao/index.html","hash":"046f73ec1fe22608abb7fce9cb0e17fa82adb16c","modified":1668415301182},{"_id":"public/page/3/index.html","hash":"65f53c2f0847ba84fbb922ae4ccfc6b4536128ff","modified":1668850951662},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_d64a89cc.png","hash":"25b120f09c7e4185f260608811dd97f3b96cf05b","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_d1a5a95c.png","hash":"9ad4c1b98ae6cb37b04efaf8ae936711f89e7b5e","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_98de130d.png","hash":"9d5abf214f623e190c5d7443ed0ccc55753ab3fc","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_fec0346f.png","hash":"efa048b0361a7ccca4ee058189a6c947384452e1","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_f8deb8c1.png","hash":"df0f4614c61730e8f5691af67076c243d5bb4e17","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_040afd70.png","hash":"a8365db5c7b3c797c03e278b6ff4de2905dc5a90","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_48270fb5.png","hash":"33ca196cb50cd420062f9e05f8e47b6544b344b1","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_5cf672b2.png","hash":"dfd88e6ed5dbdc1b34c4bfe49146b5a55f29dcc2","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_71d4889f.png","hash":"688afd75d4d13edbeb08d58d1c01a55cf893d3d5","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_7eeac46e.png","hash":"a8e38512a929244d9b9791055dfddfec604c4e8e","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_77defa60.png","hash":"83c70c275274428091279f819294af2e5a5681a5","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_56af129c.png","hash":"201f525522f02e701e815a5271bb37bd7dfe802d","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_ea531c2a.png","hash":"dfad2a74a8654354679d5ce115c1b55ff586f70c","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_fadda8b7.png","hash":"5f4555fe0c67517a528cfcf925ec724c32099a50","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_22c2f25a.png","hash":"7cdcf4571988cf5be8a70386bbd206b6ae525f37","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_b1853624.png","hash":"082a12f97b4f79ecfe1eceb102753ce8f490ab77","modified":1667967197283},{"_id":"public/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_dec3e504.png","hash":"ed0485c64d47671e6e9bc4c2441ea361fc4b0781","modified":1667967197283},{"_id":"source/_posts/Mysql中join的那些事.md","hash":"1fcf4bcfa310b35db5949a2912ade6906bded187","modified":1668415118174},{"_id":"source/_posts/精通Mysql索引.md","hash":"940c5c5f9ce2c782006165275824c4d589bc8e61","modified":1668415279447},{"_id":"source/_posts/Mysql中join的那些事/image_58fd8737.png","hash":"7b3c89bd1e3765241803ef413340fdc9822b3e95","modified":1668415091691},{"_id":"source/_posts/Mysql中join的那些事/image_9f6ce7ed.png","hash":"3df29c2900ae8cfc31ece88e6744fca16e84a610","modified":1668415091708},{"_id":"source/_posts/Mysql中join的那些事/image_942c82dc.png","hash":"8f4ef58315af268e10bc578bb9cebba07a6d61ab","modified":1668415091670},{"_id":"source/_posts/精通Mysql索引/image_0c7be26a.png","hash":"5b108ef7091383a9c9c48d1e6adcebaa3a064085","modified":1668415292475},{"_id":"source/_posts/精通Mysql索引/image_1f0bbe29.png","hash":"2a727a3e26465b3542344cf1835ceeba76b85f16","modified":1668415292745},{"_id":"source/_posts/精通Mysql索引/image_248c75e6.png","hash":"0e6b433e1bc0d4e96889fd16892641491f17d039","modified":1668415292277},{"_id":"source/_posts/精通Mysql索引/image_36b4ad4c.png","hash":"2b0660bdfbd31b22ea090fd6603e46d7507c0bb5","modified":1668415292798},{"_id":"source/_posts/精通Mysql索引/image_417b1a31.png","hash":"ee6ab1d19afcbb23b7ce26e8bdfeec54e1182c61","modified":1668415292144},{"_id":"source/_posts/精通Mysql索引/image_4030cc20.png","hash":"23a4211588e847a8ba6d31e9d718eda742feac51","modified":1668415292956},{"_id":"source/_posts/精通Mysql索引/image_471404dc.png","hash":"a597a089e54084fc3ed6f2747b4698814c8c34b7","modified":1668415292358},{"_id":"source/_posts/精通Mysql索引/image_5eb3208c.png","hash":"13cb52f250f85fc2abb31e012a30f57460a3b8d6","modified":1668415292991},{"_id":"source/_posts/精通Mysql索引/image_66710eac.png","hash":"1fb53c9e39e14dfcd9735d3db0eade34db2fc985","modified":1668415292251},{"_id":"source/_posts/精通Mysql索引/image_af5b5697.png","hash":"f348e4da6147b9d83f7b2e4eca24e6c7583c12a8","modified":1668415292198},{"_id":"source/_posts/精通Mysql索引/image_c1987417.png","hash":"fdf774064462884a27464193e2d6b2d51a7f1596","modified":1668415293153},{"_id":"source/_posts/精通Mysql索引/image_d3894bcc.png","hash":"0f1680aa9a823c03c236e5ae9aceea005977398e","modified":1668415292913},{"_id":"source/_posts/精通Mysql索引/image_cee886ce.png","hash":"dfebd6dcacbc1a2b5ff46688ea9485fe06862deb","modified":1668415292842},{"_id":"source/_posts/精通Mysql索引/image_e986da4f.png","hash":"cec23abb2f012cc19fb70a8034cfb3353695477d","modified":1668415292854},{"_id":"source/_posts/精通Mysql索引/image_ea5a8c1e.png","hash":"2e86e62f1d5b1240e597a89be6ab2be178881084","modified":1668415292873},{"_id":"source/_posts/精通Mysql索引/image_f327aac4.png","hash":"441722e0eaa1d25785812a4424ba3906375054b8","modified":1668415293098},{"_id":"source/_posts/精通Mysql索引/image_f9e7e1af.png","hash":"fecbc201af66e13a4ddd1d44c11552c1311111a3","modified":1668415292884},{"_id":"source/_posts/精通Mysql索引/image_00bb0428.png","hash":"80bd65356a15ec75c5c626f2e54c1e31909fd5a8","modified":1668415292382},{"_id":"source/_posts/精通Mysql索引/image_275a1cfe.png","hash":"13aa619f2439f482a431df52c5ca07e968f4a068","modified":1668415293164},{"_id":"source/_posts/精通Mysql索引/image_33b5701e.png","hash":"f2a324563e5008442cb85aac1b4de05cb749d3df","modified":1668415293015},{"_id":"source/_posts/精通Mysql索引/image_3c03677f.png","hash":"234c340ca62b1c914a66b75acde279cd71464aea","modified":1668415292063},{"_id":"source/_posts/精通Mysql索引/image_354ee4ca.png","hash":"1234044dbf5a10284eedb9a6ab1febc5c15bce18","modified":1668415292772},{"_id":"source/_posts/精通Mysql索引/image_41ed6d48.png","hash":"09c657ca57fc78ba1150c92a4e74393902210900","modified":1668415292605},{"_id":"source/_posts/精通Mysql索引/image_4d67662e.png","hash":"6eda2cdc6028a45dc2832400d24cf4bcfaf15ff6","modified":1668415293083},{"_id":"source/_posts/精通Mysql索引/image_4925de1e.png","hash":"c3ce5481d60c44b34f5da55c7deb002d90aaf7f0","modified":1668415292171},{"_id":"source/_posts/精通Mysql索引/image_6c304aa6.png","hash":"ec192e0b648d1958d6e445dd390363ec5bbba735","modified":1668415292691},{"_id":"source/_posts/精通Mysql索引/image_73608ecd.png","hash":"2523ff656f2555313aa0a69e61434caa2885f7da","modified":1668415292924},{"_id":"source/_posts/精通Mysql索引/image_8d791fe4.png","hash":"1b514417cf9b2fee5ff1f7d1e8472265ffd6eb23","modified":1668415292331},{"_id":"source/_posts/精通Mysql索引/image_a669396a.png","hash":"98341ba149c43b4a647fa9032e877c5fd4af54d2","modified":1668415292417},{"_id":"source/_posts/精通Mysql索引/image_e6679248.png","hash":"454dcc3f83ccda19d31a3c9ef0ea07a92eae8339","modified":1668415293065},{"_id":"source/_posts/精通Mysql索引/image_fb64a8df.png","hash":"ca60efe9fe7d0a8f70034084381e09e7ba5f1b11","modified":1668415292667},{"_id":"source/_posts/精通Mysql索引/image_f552bbb6.png","hash":"a8cd8c8483f9d05fa3f6e7ddc27cdeb1a504943f","modified":1668415292118},{"_id":"source/_posts/精通Mysql索引/image_19f2ed1c.png","hash":"0315464f1f017bfebed34ef8400c726b067d44ef","modified":1668415292224},{"_id":"source/_posts/精通Mysql索引/image_2c3f6cae.png","hash":"156e2d253e0fe1cb66f4100420294d46d17fbc5d","modified":1668415293039},{"_id":"source/_posts/精通Mysql索引/image_33774441.png","hash":"9fd2550707730479a42511414824bec56f4db01a","modified":1668415292645},{"_id":"source/_posts/精通Mysql索引/image_506be7f7.png","hash":"1a9061a89c16ca85a378ecc7e372e255b64f156f","modified":1668415292580},{"_id":"source/_posts/精通Mysql索引/image_5661add7.png","hash":"1bcf4b86feb3f5750bef4163c7c38f1c16e7cece","modified":1668415292618},{"_id":"source/_posts/精通Mysql索引/image_5f5f8f2e.png","hash":"3a14082e1c4223ed0f698435d5ba35bc10f50f13","modified":1668415292303},{"_id":"source/_posts/精通Mysql索引/image_6b8b2a8d.png","hash":"dade7ea8f88be1bebeab9211add9ca4673f18ec0","modified":1668415292553},{"_id":"source/_posts/精通Mysql索引/image_6bcc4698.png","hash":"c6bcee84c77d94cb80d7f43e466b75d3e22f619d","modified":1668415292718},{"_id":"source/_posts/精通Mysql索引/image_700a6b0b.png","hash":"881b01fbb1df6d130265fcc4db7fcd8e7c66fc92","modified":1668415292977},{"_id":"source/_posts/精通Mysql索引/image_ccf98553.png","hash":"dade7ea8f88be1bebeab9211add9ca4673f18ec0","modified":1668415292092},{"_id":"source/_posts/精通Mysql索引/image_3e3d131e.png","hash":"dcaa26e7fe2011db70a76ca7e3a36be87c12fa9a","modified":1668415292517},{"_id":"source/_posts/精通Mysql索引/image_5bee3c9f.png","hash":"6fc7275e35db8b9869de4fd5b39c232a30adcf6e","modified":1668415293128},{"_id":"source/_posts/精通Mysql索引/image_f50b3c32.png","hash":"9930ca5670c73b4ccacb029dfed3864942389c91","modified":1668415292822},{"_id":"source/_posts/Mysql中join的那些事/image_65df1467.png","hash":"7625e718cca265d62684094872232e9145a0974c","modified":1668415091652},{"_id":"source/_posts/Mysql中join的那些事/image_ec6b3fe7.png","hash":"d508087e4991bea8e9d2da8d8a7e9486140c37bc","modified":1668415091633},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/index.html","hash":"0f483f8be4ac6ce43cfb05baabe75e3b9ef12176","modified":1668850951662},{"_id":"public/2022/11/14/mysql-zhong-join-de-na-xie-shi/index.html","hash":"14c997d1d4015b7a783662778ba6411a4ae6e6e0","modified":1668415301182},{"_id":"public/categories/mysql/index.html","hash":"a3ca2133b8ef66c5f721c7cfa01bb041c39f779b","modified":1668850951662},{"_id":"public/tags/join/index.html","hash":"da9a711003fd686e13f9aeaebbf8392a4f87ab8f","modified":1668850951662},{"_id":"public/tags/sql/index.html","hash":"083b6d2e2d9bbe82c994d050b37f98118d0b2997","modified":1668850951662},{"_id":"public/tags/索引/index.html","hash":"d2eec6b3c3aa0214ca12cd6d8e9df269754b91f0","modified":1668850951662},{"_id":"public/archives/page/3/index.html","hash":"0bf972185ccbd25e87efed3d9679a2a8395d51b4","modified":1668850951662},{"_id":"public/archives/2022/11/page/3/index.html","hash":"9560c36ebcaa6a6c1ac39fadc20d426cc62c5cae","modified":1668850951662},{"_id":"public/archives/2022/page/3/index.html","hash":"faa67f683c8b4c6b8ca1eb6310bfdbe0d714ad37","modified":1668850951662},{"_id":"public/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_58fd8737.png","hash":"7b3c89bd1e3765241803ef413340fdc9822b3e95","modified":1668415301182},{"_id":"public/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_942c82dc.png","hash":"8f4ef58315af268e10bc578bb9cebba07a6d61ab","modified":1668415301182},{"_id":"public/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_9f6ce7ed.png","hash":"3df29c2900ae8cfc31ece88e6744fca16e84a610","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_0c7be26a.png","hash":"5b108ef7091383a9c9c48d1e6adcebaa3a064085","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_1f0bbe29.png","hash":"2a727a3e26465b3542344cf1835ceeba76b85f16","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_248c75e6.png","hash":"0e6b433e1bc0d4e96889fd16892641491f17d039","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_36b4ad4c.png","hash":"2b0660bdfbd31b22ea090fd6603e46d7507c0bb5","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_4030cc20.png","hash":"23a4211588e847a8ba6d31e9d718eda742feac51","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_417b1a31.png","hash":"ee6ab1d19afcbb23b7ce26e8bdfeec54e1182c61","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_471404dc.png","hash":"a597a089e54084fc3ed6f2747b4698814c8c34b7","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_5eb3208c.png","hash":"13cb52f250f85fc2abb31e012a30f57460a3b8d6","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_66710eac.png","hash":"1fb53c9e39e14dfcd9735d3db0eade34db2fc985","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_c1987417.png","hash":"fdf774064462884a27464193e2d6b2d51a7f1596","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_d3894bcc.png","hash":"0f1680aa9a823c03c236e5ae9aceea005977398e","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_cee886ce.png","hash":"dfebd6dcacbc1a2b5ff46688ea9485fe06862deb","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_e986da4f.png","hash":"cec23abb2f012cc19fb70a8034cfb3353695477d","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_ea5a8c1e.png","hash":"2e86e62f1d5b1240e597a89be6ab2be178881084","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_f327aac4.png","hash":"441722e0eaa1d25785812a4424ba3906375054b8","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_f9e7e1af.png","hash":"fecbc201af66e13a4ddd1d44c11552c1311111a3","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_af5b5697.png","hash":"f348e4da6147b9d83f7b2e4eca24e6c7583c12a8","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_00bb0428.png","hash":"80bd65356a15ec75c5c626f2e54c1e31909fd5a8","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_275a1cfe.png","hash":"13aa619f2439f482a431df52c5ca07e968f4a068","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_33b5701e.png","hash":"f2a324563e5008442cb85aac1b4de05cb749d3df","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_3c03677f.png","hash":"234c340ca62b1c914a66b75acde279cd71464aea","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_354ee4ca.png","hash":"1234044dbf5a10284eedb9a6ab1febc5c15bce18","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_41ed6d48.png","hash":"09c657ca57fc78ba1150c92a4e74393902210900","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_4925de1e.png","hash":"c3ce5481d60c44b34f5da55c7deb002d90aaf7f0","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_4d67662e.png","hash":"6eda2cdc6028a45dc2832400d24cf4bcfaf15ff6","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_6c304aa6.png","hash":"ec192e0b648d1958d6e445dd390363ec5bbba735","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_73608ecd.png","hash":"2523ff656f2555313aa0a69e61434caa2885f7da","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_a669396a.png","hash":"98341ba149c43b4a647fa9032e877c5fd4af54d2","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_8d791fe4.png","hash":"1b514417cf9b2fee5ff1f7d1e8472265ffd6eb23","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_e6679248.png","hash":"454dcc3f83ccda19d31a3c9ef0ea07a92eae8339","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_f552bbb6.png","hash":"a8cd8c8483f9d05fa3f6e7ddc27cdeb1a504943f","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_fb64a8df.png","hash":"ca60efe9fe7d0a8f70034084381e09e7ba5f1b11","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_19f2ed1c.png","hash":"0315464f1f017bfebed34ef8400c726b067d44ef","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_2c3f6cae.png","hash":"156e2d253e0fe1cb66f4100420294d46d17fbc5d","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_33774441.png","hash":"9fd2550707730479a42511414824bec56f4db01a","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_5661add7.png","hash":"1bcf4b86feb3f5750bef4163c7c38f1c16e7cece","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_506be7f7.png","hash":"1a9061a89c16ca85a378ecc7e372e255b64f156f","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_5f5f8f2e.png","hash":"3a14082e1c4223ed0f698435d5ba35bc10f50f13","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_6b8b2a8d.png","hash":"dade7ea8f88be1bebeab9211add9ca4673f18ec0","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_6bcc4698.png","hash":"c6bcee84c77d94cb80d7f43e466b75d3e22f619d","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_700a6b0b.png","hash":"881b01fbb1df6d130265fcc4db7fcd8e7c66fc92","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_ccf98553.png","hash":"dade7ea8f88be1bebeab9211add9ca4673f18ec0","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_3e3d131e.png","hash":"dcaa26e7fe2011db70a76ca7e3a36be87c12fa9a","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_5bee3c9f.png","hash":"6fc7275e35db8b9869de4fd5b39c232a30adcf6e","modified":1668415301182},{"_id":"public/2022/11/14/jing-tong-mysql-suo-yin/image_f50b3c32.png","hash":"9930ca5670c73b4ccacb029dfed3864942389c91","modified":1668415301182},{"_id":"public/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_65df1467.png","hash":"7625e718cca265d62684094872232e9145a0974c","modified":1668415301182},{"_id":"public/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_ec6b3fe7.png","hash":"d508087e4991bea8e9d2da8d8a7e9486140c37bc","modified":1668415301182},{"_id":"source/_posts/SpringBoot单元测试.md","hash":"e93bf365c5b7a2d9bb21df9a800a8b1140c503ba","modified":1668850895322},{"_id":"source/_posts/SpringBoot单元测试/image_a6c1a6d0.png","hash":"f474bb1b8b6eb6ae547a181f78ea214d744ec3ac","modified":1668850942360},{"_id":"source/_posts/SpringBoot单元测试/image_00758bcb.png","hash":"315838e5eaeb140a540621d936b63c6f63d07fe2","modified":1668850942317},{"_id":"source/_posts/SpringBoot单元测试/image_2bf8a627.png","hash":"1ca2848fbf887f2f9de183045a5f545b3cca7a1d","modified":1668850942229},{"_id":"source/_posts/SpringBoot单元测试/image_3e75da01.png","hash":"06bacc3c18bf187bca9662a7e2edbf1203117767","modified":1668850942198},{"_id":"source/_posts/SpringBoot单元测试/image_30360d29.png","hash":"49b2ae335f2aee46b24213ad5a6ff5b3aa4b767f","modified":1668850942168},{"_id":"source/_posts/SpringBoot单元测试/image_e9aafc0d.png","hash":"abe6132515ee8d559cb78c8b146a54979b5d6e08","modified":1668850942291},{"_id":"source/_posts/SpringBoot单元测试/image_9e077c9d.png","hash":"946866c9de68f3a716891e4b91e1ef68de814141","modified":1668850942138},{"_id":"source/_posts/SpringBoot单元测试/image_faa9f8ba.png","hash":"f3574c49d16731e3a6faf08e3b8ea06b13b4b376","modified":1668850942261},{"_id":"public/2022/11/19/springboot-dan-yuan-ce-shi/index.html","hash":"d84f056944a4ab9874876d3be0a9ada5c60bded8","modified":1668850951662},{"_id":"public/categories/junit/index.html","hash":"80209e210afce178e9ff04d0ece8c8da59441a6e","modified":1668850951662},{"_id":"public/tags/junit/index.html","hash":"e4f85714567df67767de15559618f70029f795ca","modified":1668850951662},{"_id":"public/tags/单元测试/index.html","hash":"a09caf15a42b6eda6a9a6fdad7c5f69788d461a4","modified":1668850951662},{"_id":"public/2022/11/19/springboot-dan-yuan-ce-shi/image_a6c1a6d0.png","hash":"f474bb1b8b6eb6ae547a181f78ea214d744ec3ac","modified":1668850951662},{"_id":"public/2022/11/19/springboot-dan-yuan-ce-shi/image_2bf8a627.png","hash":"1ca2848fbf887f2f9de183045a5f545b3cca7a1d","modified":1668850951662},{"_id":"public/2022/11/19/springboot-dan-yuan-ce-shi/image_30360d29.png","hash":"49b2ae335f2aee46b24213ad5a6ff5b3aa4b767f","modified":1668850951662},{"_id":"public/2022/11/19/springboot-dan-yuan-ce-shi/image_3e75da01.png","hash":"06bacc3c18bf187bca9662a7e2edbf1203117767","modified":1668850951662},{"_id":"public/2022/11/19/springboot-dan-yuan-ce-shi/image_00758bcb.png","hash":"315838e5eaeb140a540621d936b63c6f63d07fe2","modified":1668850951662},{"_id":"public/2022/11/19/springboot-dan-yuan-ce-shi/image_e9aafc0d.png","hash":"abe6132515ee8d559cb78c8b146a54979b5d6e08","modified":1668850951662},{"_id":"public/2022/11/19/springboot-dan-yuan-ce-shi/image_faa9f8ba.png","hash":"f3574c49d16731e3a6faf08e3b8ea06b13b4b376","modified":1668850951662},{"_id":"public/2022/11/19/springboot-dan-yuan-ce-shi/image_9e077c9d.png","hash":"946866c9de68f3a716891e4b91e1ef68de814141","modified":1668850951662}],"Category":[{"name":"ios","_id":"cl8ye4pnu00043eld4hw29j7v"},{"name":"java","_id":"cl8ye4pnx00093eld9k027sjj"},{"name":"web3.0","_id":"cl9w6c3kl0001yzld94rlcmy9"},{"name":"jdk1.8","_id":"cla1u1fnp00014sld6y8t6vme"},{"name":"lambda","parent":"cla1u1fnp00014sld6y8t6vme","_id":"cla1u1fnr00044sld7vi5a4kd"},{"name":"函数式编程","parent":"cla1u1fnr00044sld7vi5a4kd","_id":"cla1u1fns00054sld3clq8076"},{"name":"hexo","_id":"cla1uku9o0001wwldfw4makkm"},{"name":"git","_id":"cla1wfs1q0001hzld8czpfcpj"},{"name":"技巧","_id":"cla22kxoo0001cxldaj0hanny"},{"name":"spring","parent":"cl8ye4pnx00093eld9k027sjj","_id":"cla65gxie0002msld1jjxcm48"},{"name":"消息队列","_id":"cla7kwx9c00014sld6qfdhxv5"},{"name":"分布式","parent":"cl8ye4pnx00093eld9k027sjj","_id":"cla92ulur0002fdlddpjgawpn"},{"name":"工具","parent":"cl8ye4pnx00093eld9k027sjj","_id":"cla93e2m70002jkldhjnr0sm0"},{"name":"mysql","_id":"clagje6cq0001v6ldbm22fm3r"},{"name":"junit","_id":"clanqroe30001x6ld32av5qtc"}],"Data":[{"_id":"friends","data":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}],"Page":[{"title":"404","date":"2020-05-29T16:00:00.000Z","type":"404","layout":"404","description":"Cannot find the page you want :(","_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2020-05-30 00:00:00\ntype: \"404\"\nlayout: \"404\"\ndescription: \"Cannot find the page you want :(\"\n---","updated":"2022-10-07T10:19:59.412Z","path":"404/index.html","comments":1,"_id":"cl8ye4pnm00003eld0dcx32ji","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-09-30 17:25:30\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2022-10-07T10:19:59.417Z","path":"categories/index.html","comments":1,"_id":"cl8ye4pns00023eld80cgcxyp","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","type":"contact","layout":"contact","_content":"","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2018-09-30 17:25:30\ntype: \"contact\"\nlayout: \"contact\"\n---\n","updated":"2022-10-07T10:19:59.417Z","path":"contact/index.html","comments":1,"_id":"cl8ye4pnw00063eldc9spavac","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","type":"friends","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2018-12-12 21:25:30\ntype: \"friends\"\nlayout: \"friends\"\n---\n","updated":"2022-10-07T10:19:59.418Z","path":"friends/index.html","comments":1,"_id":"cl8ye4pnx00073eld4d4gbgx3","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":""},{"title":"about","date":"2018-09-30T09:25:30.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-09-30 17:25:30\ntype: \"about\"\nlayout: \"about\"\n---\n","updated":"2022-10-07T10:19:59.417Z","path":"about/index.html","comments":1,"_id":"cl8ye4pnx00083eldc1n5dly8","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":""},{"title":"tags","date":"2018-09-10T10:23:38.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-09-10 18:23:38\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2022-10-07T10:19:59.418Z","path":"tags/index.html","comments":1,"_id":"cl8ye4pnz000b3eld0q3u06j3","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":""}],"Post":[{"title":"感受java8后lambda之美","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-11-04T01:41:09.000Z","password":null,"summary":"函数式编程，可以将行为进行传递","_content":"\n\n一、引言\n\njava8最大的特性就是引入Lambda表达式，即函数式编程，可以将行为进行传递。总结就是：使用不可变值与函数，函数对不可变值进行处理，映射成另一个值。\n\n## 二、java重要的函数式接口 \n\n### 1、什么是函数式接口 \n\n函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。\n\n#### 1.1 java8自带的常用函数式接口。 \n\n![image_ec9c4260.png](感受java8后lambda之美/image_ec9c4260.png)\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Predicate<Integer> predicate = x -> x > 185;\n        Student student = new Student(\"9龙\", 23, 175);\n        System.out.println(\n            \"9龙的身高高于185吗？：\" + predicate.test(student.getStature()));\n\n        Consumer<String> consumer = System.out::println;\n        consumer.accept(\"命运由我不由天\");\n\n        Function<Student, String> function = Student::getName;\n        String name = function.apply(student);\n        System.out.println(name);\n\n        Supplier<Integer> supplier = \n            () -> Integer.valueOf(BigDecimal.TEN.toString());\n        System.out.println(supplier.get());\n\n        UnaryOperator<Boolean> unaryOperator = uglily -> !uglily;\n        Boolean apply2 = unaryOperator.apply(true);\n        System.out.println(apply2);\n\n        BinaryOperator<Integer> operator = (x, y) -> x * y;\n        Integer integer = operator.apply(2, 3);\n        System.out.println(integer);\n\n        test(() -> \"我是一个演示的函数式接口\");\n    }\n\n    /**\n     * 演示自定义函数式接口使用\n     *\n     * @param worker\n     */\n    public static void test(Worker worker) {\n        String work = worker.work();\n        System.out.println(work);\n    }\n\n    public interface Worker {\n        String work();\n    }\n}\n//9龙的身高高于185吗？：false\n//命运由我不由天\n//9龙\n//10\n//false\n//6\n//我是一个演示的函数式接口\n```\n\n以上演示了lambda接口的使用及自定义一个函数式接口并使用。下面，我们看看java8将函数式接口封装到流中如何高效的帮助我们处理集合。  \n\n\n注意：Student::getName例子中这种编写lambda表达式的方式称为方法引用。格式为ClassNmae::methodName。是不是很神奇，java8就是这么迷人。\n\n> 示例：本篇所有示例都基于以下三个类。OutstandingClass：班级；Student：学生；SpecialityEnum：特长。\n\n#### ![image_7771b4fe.png](感受java8后lambda之美/image_7771b4fe.png) \n\n#### 1.2 惰性求值与及早求值 \n\n惰性求值：只描述Stream，操作的结果也是Stream，这样的操作称为惰性求值。惰性求值可以像建造者模式一样链式使用，最后再使用及早求值得到最终结果。\n\n及早求值：得到最终的结果而不是Stream，这样的操作称为及早求值。\n\n### 2、常用的流 \n\n#### 2.1 collect(Collectors.toList()) \n\n将流转换为list。还有toSet()，toMap()等。及早求值。\n\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        List<Student> studentList = Stream.of(new Student(\"路飞\", 22, 175),\n                new Student(\"红发\", 40, 180),\n                new Student(\"白胡子\", 50, 185)).collect(Collectors.toList());\n        System.out.println(studentList);\n    }\n}\n//输出结果\n//[Student{name='路飞', age=22, stature=175, specialities=null}, \n//Student{name='红发', age=40, stature=180, specialities=null}, \n//Student{name='白胡子', age=50, stature=185, specialities=null}]\n```\n\n#### 2.2 filter \n\n顾名思义，起过滤筛选的作用。内部就是Predicate接口。惰性求值。\n\n![image_eba0197b.png](感受java8后lambda之美/image_eba0197b.png)\n\n比如我们筛选出出身高小于180的同学。\n\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>(3);\n        students.add(new Student(\"路飞\", 22, 175));\n        students.add(new Student(\"红发\", 40, 180));\n        students.add(new Student(\"白胡子\", 50, 185));\n\n        List<Student> list = students.stream()\n            .filter(stu -> stu.getStature() < 180)\n            .collect(Collectors.toList());\n        System.out.println(list);\n    }\n}\n//输出结果\n//[Student{name='路飞', age=22, stature=175, specialities=null}]\n```\n\n#### 2.3 map    \n\n转换功能，内部就是Function接口。惰性求值\n\n![image_23fab375.png](感受java8后lambda之美/image_23fab375.png)\n\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>(3);\n        students.add(new Student(\"路飞\", 22, 175));\n        students.add(new Student(\"红发\", 40, 180));\n        students.add(new Student(\"白胡子\", 50, 185));\n\n        List<String> names = students.stream().map(student -> student.getName())\n                .collect(Collectors.toList());\n        System.out.println(names);\n    }\n}\n//输出结果\n//[路飞, 红发, 白胡子]\n```\n\n例子中将student对象转换为String对象，获取student的名字。  \n\n\n#### 2.4 flatMap \n\n将多个Stream合并为一个Stream。惰性求值\n\n![image_c1ac2536.png](感受java8后lambda之美/image_c1ac2536.png)\n\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>(3);\n        students.add(new Student(\"路飞\", 22, 175));\n        students.add(new Student(\"红发\", 40, 180));\n        students.add(new Student(\"白胡子\", 50, 185));\n\n        List<Student> studentList = Stream.of(students,\n                asList(new Student(\"艾斯\", 25, 183),\n                        new Student(\"雷利\", 48, 176)))\n                .flatMap(students1 -> students1.stream()).collect(Collectors.toList());\n        System.out.println(studentList);\n    }\n}\n//输出结果\n//[Student{name='路飞', age=22, stature=175, specialities=null}, \n//Student{name='红发', age=40, stature=180, specialities=null}, \n//Student{name='白胡子', age=50, stature=185, specialities=null}, \n//Student{name='艾斯', age=25, stature=183, specialities=null},\n//Student{name='雷利', age=48, stature=176, specialities=null}]\n```\n\n调用Stream.of的静态方法将两个list转换为Stream，再通过flatMap将两个流合并为一个。  \n\n\n#### 2.5 max和min \n\n我们经常会在集合中求最大或最小值，使用流就很方便。及早求值。\n\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>(3);\n        students.add(new Student(\"路飞\", 22, 175));\n        students.add(new Student(\"红发\", 40, 180));\n        students.add(new Student(\"白胡子\", 50, 185));\n\n        Optional<Student> max = students.stream()\n            .max(Comparator.comparing(stu -> stu.getAge()));\n        Optional<Student> min = students.stream()\n            .min(Comparator.comparing(stu -> stu.getAge()));\n        //判断是否有值\n        if (max.isPresent()) {\n            System.out.println(max.get());\n        }\n        if (min.isPresent()) {\n            System.out.println(min.get());\n        }\n    }\n}\n//输出结果\n//Student{name='白胡子', age=50, stature=185, specialities=null}\n//Student{name='路飞', age=22, stature=175, specialities=null}\n```\n\nmax、min接收一个Comparator（例子中使用java8自带的静态函数，只需要传进需要比较值即可。）并且返回一个Optional对象，该对象是java8新增的类，专门为了防止null引发的空指针异常。  \n\n\n可以使用max.isPresent()判断是否有值；可以使用max.orElse(new Student())，当值为null时就使用给定值；也可以使用max.orElseGet(() -> new Student());这需要传入一个Supplier的lambda表达式。\n\n#### 2.6 count \n\n统计功能，一般都是结合filter使用，因为先筛选出我们需要的再统计即可。及早求值\n\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>(3);\n        students.add(new Student(\"路飞\", 22, 175));\n        students.add(new Student(\"红发\", 40, 180));\n        students.add(new Student(\"白胡子\", 50, 185));\n\n        long count = students.stream().filter(s1 -> s1.getAge() < 45).count();\n        System.out.println(\"年龄小于45岁的人数是：\" + count);\n    }\n}\n//输出结果\n//年龄小于45岁的人数是：2\n```\n\n#### 2.7 reduce    \n\nreduce 操作可以实现从一组值中生成一个值。在上述例子中用到的 count 、 min 和 max 方法，因为常用而被纳入标准库中。事实上，这些方法都是 reduce 操作。及早求值。\n\n![image_9186bf98.png](感受java8后lambda之美/image_9186bf98.png)\n\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        Integer reduce = Stream.of(1, 2, 3, 4).reduce(0, (acc, x) -> acc+ x);\n        System.out.println(reduce);\n    }\n}\n//输出结果\n//10\n```\n\n我们看得reduce接收了一个初始值为0的累加器，依次取出值与累加器相加，最后累加器的值就是最终的结果。\n\n## 三、高级集合类及收集器 \n\n### 3.1 转换成值 \n\n收集器，一种通用的、从流生成复杂值的结构。只要将它传给 collect 方法，所有的流就都可以使用它了。标准类库已经提供了一些有用的收集器，以下示例代码中的收集器都是从 java.util.stream.Collectors 类中静态导入的。\n\n```java\npublic class CollectorsTest {\n    public static void main(String[] args) {\n        List<Student> students1 = new ArrayList<>(3);\n        students1.add(new Student(\"路飞\", 23, 175));\n        students1.add(new Student(\"红发\", 40, 180));\n        students1.add(new Student(\"白胡子\", 50, 185));\n\n        OutstandingClass ostClass1 = new OutstandingClass(\"一班\", students1);\n        //复制students1，并移除一个学生\n        List<Student> students2 = new ArrayList<>(students1);\n        students2.remove(1);\n        OutstandingClass ostClass2 = new OutstandingClass(\"二班\", students2);\n        //将ostClass1、ostClass2转换为Stream\n        Stream<OutstandingClass> classStream = Stream.of(ostClass1, ostClass2);\n        OutstandingClass outstandingClass = biggestGroup(classStream);\n        System.out.println(\"人数最多的班级是：\" + outstandingClass.getName());\n\n        System.out.println(\"一班平均年龄是：\" + averageNumberOfStudent(students1));\n    }\n\n    /**\n     * 获取人数最多的班级\n     */\n    private static OutstandingClass biggestGroup(Stream<OutstandingClass> outstandingClasses) {\n        return outstandingClasses.collect(\n                maxBy(comparing(ostClass -> ostClass.getStudents().size())))\n                .orElseGet(OutstandingClass::new);\n    }\n\n    /**\n     * 计算平均年龄\n     */\n    private static double averageNumberOfStudent(List<Student> students) {\n        return students.stream().collect(averagingInt(Student::getAge));\n    }\n}\n//输出结果\n//人数最多的班级是：一班\n//一班平均年龄是：37.666666666666664\n```\n\nmaxBy或者minBy就是求最大值与最小值。  \n\n\n### 3.2 转换成块 \n\n常用的流操作是将其分解成两个集合，Collectors.partitioningBy帮我们实现了，接收一个Predicate函数式接口。\n\n![image_16155432.png](感受java8后lambda之美/image_16155432.png)\n\n将示例学生分为会唱歌与不会唱歌的两个集合。\n\n```java\npublic class PartitioningByTest {\n    public static void main(String[] args) {\n        //省略List<student> students的初始化\n        Map<Boolean, List<Student>> listMap = students.stream().collect(\n            Collectors.partitioningBy(student -> student.getSpecialities().\n                                      contains(SpecialityEnum.SING)));\n    }\n}\n```\n\n### 3.3 数据分组 \n\n数据分组是一种更自然的分割数据操作，与将数据分成 ture 和 false 两部分不同，可以使用任意值对数据分组。Collectors.groupingBy接收一个Function做转换。\n\n![image_79d304da.png](感受java8后lambda之美/image_79d304da.png)\n\n如图，我们使用groupingBy将根据进行分组为圆形一组，三角形一组，正方形一组。\n\n例子：根据学生第一个特长进行分组\n\n```java\npublic class GroupingByTest {\n    public static void main(String[] args) {\n        //省略List<student> students的初始化\n         Map<SpecialityEnum, List<Student>> listMap = \n             students.stream().collect(\n             Collectors.groupingBy(student -> student.getSpecialities().get(0)));\n    }\n}\n```\n\nCollectors.groupingBy与SQL 中的 group by 操作是一样的。\n\n### 3.4 字符串拼接 \n\n如果将所有学生的名字拼接起来，怎么做呢？通常只能创建一个StringBuilder，循环拼接。使用Stream，使用Collectors.joining()简单容易。\n\n```java\npublic class JoiningTest {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>(3);\n        students.add(new Student(\"路飞\", 22, 175));\n        students.add(new Student(\"红发\", 40, 180));\n        students.add(new Student(\"白胡子\", 50, 185));\n\n         String names = students.stream()\n             .map(Student::getName).collect(Collectors.joining(\",\",\"[\",\"]\"));\n        System.out.println(names);\n    }\n}\n//输出结果\n//[路飞,红发,白胡子]\n```\n\njoining接收三个参数，第一个是分界符，第二个是前缀符，第三个是结束符。也可以不传入参数Collectors.joining()，这样就是直接拼接。  \n\n\n## 四、总结 \n\n本篇主要从实际使用讲述了常用的方法及流，使用java8可以很清晰表达你要做什么，代码也很简洁。本篇例子主要是为了讲解较为简单，大家可以去使用java8重构自己现有的代码，自行领会lambda的奥妙。\n\n本文说的Stream要组合使用才会发挥更大的功能，链式调用很迷人，根据自己的业务去做吧。","source":"_posts/感受java8后lambda之美.md","raw":"---\ntitle: 感受java8后lambda之美\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-11-04 09:41:09\npassword:\nsummary: 函数式编程，可以将行为进行传递\ntags: \n    - jdk1.8\n    - lambda\n    - 函数式编程\ncategories:\n    - java\n---\n\n\n一、引言\n\njava8最大的特性就是引入Lambda表达式，即函数式编程，可以将行为进行传递。总结就是：使用不可变值与函数，函数对不可变值进行处理，映射成另一个值。\n\n## 二、java重要的函数式接口 \n\n### 1、什么是函数式接口 \n\n函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。\n\n#### 1.1 java8自带的常用函数式接口。 \n\n![image_ec9c4260.png](感受java8后lambda之美/image_ec9c4260.png)\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Predicate<Integer> predicate = x -> x > 185;\n        Student student = new Student(\"9龙\", 23, 175);\n        System.out.println(\n            \"9龙的身高高于185吗？：\" + predicate.test(student.getStature()));\n\n        Consumer<String> consumer = System.out::println;\n        consumer.accept(\"命运由我不由天\");\n\n        Function<Student, String> function = Student::getName;\n        String name = function.apply(student);\n        System.out.println(name);\n\n        Supplier<Integer> supplier = \n            () -> Integer.valueOf(BigDecimal.TEN.toString());\n        System.out.println(supplier.get());\n\n        UnaryOperator<Boolean> unaryOperator = uglily -> !uglily;\n        Boolean apply2 = unaryOperator.apply(true);\n        System.out.println(apply2);\n\n        BinaryOperator<Integer> operator = (x, y) -> x * y;\n        Integer integer = operator.apply(2, 3);\n        System.out.println(integer);\n\n        test(() -> \"我是一个演示的函数式接口\");\n    }\n\n    /**\n     * 演示自定义函数式接口使用\n     *\n     * @param worker\n     */\n    public static void test(Worker worker) {\n        String work = worker.work();\n        System.out.println(work);\n    }\n\n    public interface Worker {\n        String work();\n    }\n}\n//9龙的身高高于185吗？：false\n//命运由我不由天\n//9龙\n//10\n//false\n//6\n//我是一个演示的函数式接口\n```\n\n以上演示了lambda接口的使用及自定义一个函数式接口并使用。下面，我们看看java8将函数式接口封装到流中如何高效的帮助我们处理集合。  \n\n\n注意：Student::getName例子中这种编写lambda表达式的方式称为方法引用。格式为ClassNmae::methodName。是不是很神奇，java8就是这么迷人。\n\n> 示例：本篇所有示例都基于以下三个类。OutstandingClass：班级；Student：学生；SpecialityEnum：特长。\n\n#### ![image_7771b4fe.png](感受java8后lambda之美/image_7771b4fe.png) \n\n#### 1.2 惰性求值与及早求值 \n\n惰性求值：只描述Stream，操作的结果也是Stream，这样的操作称为惰性求值。惰性求值可以像建造者模式一样链式使用，最后再使用及早求值得到最终结果。\n\n及早求值：得到最终的结果而不是Stream，这样的操作称为及早求值。\n\n### 2、常用的流 \n\n#### 2.1 collect(Collectors.toList()) \n\n将流转换为list。还有toSet()，toMap()等。及早求值。\n\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        List<Student> studentList = Stream.of(new Student(\"路飞\", 22, 175),\n                new Student(\"红发\", 40, 180),\n                new Student(\"白胡子\", 50, 185)).collect(Collectors.toList());\n        System.out.println(studentList);\n    }\n}\n//输出结果\n//[Student{name='路飞', age=22, stature=175, specialities=null}, \n//Student{name='红发', age=40, stature=180, specialities=null}, \n//Student{name='白胡子', age=50, stature=185, specialities=null}]\n```\n\n#### 2.2 filter \n\n顾名思义，起过滤筛选的作用。内部就是Predicate接口。惰性求值。\n\n![image_eba0197b.png](感受java8后lambda之美/image_eba0197b.png)\n\n比如我们筛选出出身高小于180的同学。\n\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>(3);\n        students.add(new Student(\"路飞\", 22, 175));\n        students.add(new Student(\"红发\", 40, 180));\n        students.add(new Student(\"白胡子\", 50, 185));\n\n        List<Student> list = students.stream()\n            .filter(stu -> stu.getStature() < 180)\n            .collect(Collectors.toList());\n        System.out.println(list);\n    }\n}\n//输出结果\n//[Student{name='路飞', age=22, stature=175, specialities=null}]\n```\n\n#### 2.3 map    \n\n转换功能，内部就是Function接口。惰性求值\n\n![image_23fab375.png](感受java8后lambda之美/image_23fab375.png)\n\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>(3);\n        students.add(new Student(\"路飞\", 22, 175));\n        students.add(new Student(\"红发\", 40, 180));\n        students.add(new Student(\"白胡子\", 50, 185));\n\n        List<String> names = students.stream().map(student -> student.getName())\n                .collect(Collectors.toList());\n        System.out.println(names);\n    }\n}\n//输出结果\n//[路飞, 红发, 白胡子]\n```\n\n例子中将student对象转换为String对象，获取student的名字。  \n\n\n#### 2.4 flatMap \n\n将多个Stream合并为一个Stream。惰性求值\n\n![image_c1ac2536.png](感受java8后lambda之美/image_c1ac2536.png)\n\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>(3);\n        students.add(new Student(\"路飞\", 22, 175));\n        students.add(new Student(\"红发\", 40, 180));\n        students.add(new Student(\"白胡子\", 50, 185));\n\n        List<Student> studentList = Stream.of(students,\n                asList(new Student(\"艾斯\", 25, 183),\n                        new Student(\"雷利\", 48, 176)))\n                .flatMap(students1 -> students1.stream()).collect(Collectors.toList());\n        System.out.println(studentList);\n    }\n}\n//输出结果\n//[Student{name='路飞', age=22, stature=175, specialities=null}, \n//Student{name='红发', age=40, stature=180, specialities=null}, \n//Student{name='白胡子', age=50, stature=185, specialities=null}, \n//Student{name='艾斯', age=25, stature=183, specialities=null},\n//Student{name='雷利', age=48, stature=176, specialities=null}]\n```\n\n调用Stream.of的静态方法将两个list转换为Stream，再通过flatMap将两个流合并为一个。  \n\n\n#### 2.5 max和min \n\n我们经常会在集合中求最大或最小值，使用流就很方便。及早求值。\n\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>(3);\n        students.add(new Student(\"路飞\", 22, 175));\n        students.add(new Student(\"红发\", 40, 180));\n        students.add(new Student(\"白胡子\", 50, 185));\n\n        Optional<Student> max = students.stream()\n            .max(Comparator.comparing(stu -> stu.getAge()));\n        Optional<Student> min = students.stream()\n            .min(Comparator.comparing(stu -> stu.getAge()));\n        //判断是否有值\n        if (max.isPresent()) {\n            System.out.println(max.get());\n        }\n        if (min.isPresent()) {\n            System.out.println(min.get());\n        }\n    }\n}\n//输出结果\n//Student{name='白胡子', age=50, stature=185, specialities=null}\n//Student{name='路飞', age=22, stature=175, specialities=null}\n```\n\nmax、min接收一个Comparator（例子中使用java8自带的静态函数，只需要传进需要比较值即可。）并且返回一个Optional对象，该对象是java8新增的类，专门为了防止null引发的空指针异常。  \n\n\n可以使用max.isPresent()判断是否有值；可以使用max.orElse(new Student())，当值为null时就使用给定值；也可以使用max.orElseGet(() -> new Student());这需要传入一个Supplier的lambda表达式。\n\n#### 2.6 count \n\n统计功能，一般都是结合filter使用，因为先筛选出我们需要的再统计即可。及早求值\n\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>(3);\n        students.add(new Student(\"路飞\", 22, 175));\n        students.add(new Student(\"红发\", 40, 180));\n        students.add(new Student(\"白胡子\", 50, 185));\n\n        long count = students.stream().filter(s1 -> s1.getAge() < 45).count();\n        System.out.println(\"年龄小于45岁的人数是：\" + count);\n    }\n}\n//输出结果\n//年龄小于45岁的人数是：2\n```\n\n#### 2.7 reduce    \n\nreduce 操作可以实现从一组值中生成一个值。在上述例子中用到的 count 、 min 和 max 方法，因为常用而被纳入标准库中。事实上，这些方法都是 reduce 操作。及早求值。\n\n![image_9186bf98.png](感受java8后lambda之美/image_9186bf98.png)\n\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        Integer reduce = Stream.of(1, 2, 3, 4).reduce(0, (acc, x) -> acc+ x);\n        System.out.println(reduce);\n    }\n}\n//输出结果\n//10\n```\n\n我们看得reduce接收了一个初始值为0的累加器，依次取出值与累加器相加，最后累加器的值就是最终的结果。\n\n## 三、高级集合类及收集器 \n\n### 3.1 转换成值 \n\n收集器，一种通用的、从流生成复杂值的结构。只要将它传给 collect 方法，所有的流就都可以使用它了。标准类库已经提供了一些有用的收集器，以下示例代码中的收集器都是从 java.util.stream.Collectors 类中静态导入的。\n\n```java\npublic class CollectorsTest {\n    public static void main(String[] args) {\n        List<Student> students1 = new ArrayList<>(3);\n        students1.add(new Student(\"路飞\", 23, 175));\n        students1.add(new Student(\"红发\", 40, 180));\n        students1.add(new Student(\"白胡子\", 50, 185));\n\n        OutstandingClass ostClass1 = new OutstandingClass(\"一班\", students1);\n        //复制students1，并移除一个学生\n        List<Student> students2 = new ArrayList<>(students1);\n        students2.remove(1);\n        OutstandingClass ostClass2 = new OutstandingClass(\"二班\", students2);\n        //将ostClass1、ostClass2转换为Stream\n        Stream<OutstandingClass> classStream = Stream.of(ostClass1, ostClass2);\n        OutstandingClass outstandingClass = biggestGroup(classStream);\n        System.out.println(\"人数最多的班级是：\" + outstandingClass.getName());\n\n        System.out.println(\"一班平均年龄是：\" + averageNumberOfStudent(students1));\n    }\n\n    /**\n     * 获取人数最多的班级\n     */\n    private static OutstandingClass biggestGroup(Stream<OutstandingClass> outstandingClasses) {\n        return outstandingClasses.collect(\n                maxBy(comparing(ostClass -> ostClass.getStudents().size())))\n                .orElseGet(OutstandingClass::new);\n    }\n\n    /**\n     * 计算平均年龄\n     */\n    private static double averageNumberOfStudent(List<Student> students) {\n        return students.stream().collect(averagingInt(Student::getAge));\n    }\n}\n//输出结果\n//人数最多的班级是：一班\n//一班平均年龄是：37.666666666666664\n```\n\nmaxBy或者minBy就是求最大值与最小值。  \n\n\n### 3.2 转换成块 \n\n常用的流操作是将其分解成两个集合，Collectors.partitioningBy帮我们实现了，接收一个Predicate函数式接口。\n\n![image_16155432.png](感受java8后lambda之美/image_16155432.png)\n\n将示例学生分为会唱歌与不会唱歌的两个集合。\n\n```java\npublic class PartitioningByTest {\n    public static void main(String[] args) {\n        //省略List<student> students的初始化\n        Map<Boolean, List<Student>> listMap = students.stream().collect(\n            Collectors.partitioningBy(student -> student.getSpecialities().\n                                      contains(SpecialityEnum.SING)));\n    }\n}\n```\n\n### 3.3 数据分组 \n\n数据分组是一种更自然的分割数据操作，与将数据分成 ture 和 false 两部分不同，可以使用任意值对数据分组。Collectors.groupingBy接收一个Function做转换。\n\n![image_79d304da.png](感受java8后lambda之美/image_79d304da.png)\n\n如图，我们使用groupingBy将根据进行分组为圆形一组，三角形一组，正方形一组。\n\n例子：根据学生第一个特长进行分组\n\n```java\npublic class GroupingByTest {\n    public static void main(String[] args) {\n        //省略List<student> students的初始化\n         Map<SpecialityEnum, List<Student>> listMap = \n             students.stream().collect(\n             Collectors.groupingBy(student -> student.getSpecialities().get(0)));\n    }\n}\n```\n\nCollectors.groupingBy与SQL 中的 group by 操作是一样的。\n\n### 3.4 字符串拼接 \n\n如果将所有学生的名字拼接起来，怎么做呢？通常只能创建一个StringBuilder，循环拼接。使用Stream，使用Collectors.joining()简单容易。\n\n```java\npublic class JoiningTest {\n    public static void main(String[] args) {\n        List<Student> students = new ArrayList<>(3);\n        students.add(new Student(\"路飞\", 22, 175));\n        students.add(new Student(\"红发\", 40, 180));\n        students.add(new Student(\"白胡子\", 50, 185));\n\n         String names = students.stream()\n             .map(Student::getName).collect(Collectors.joining(\",\",\"[\",\"]\"));\n        System.out.println(names);\n    }\n}\n//输出结果\n//[路飞,红发,白胡子]\n```\n\njoining接收三个参数，第一个是分界符，第二个是前缀符，第三个是结束符。也可以不传入参数Collectors.joining()，这样就是直接拼接。  \n\n\n## 四、总结 \n\n本篇主要从实际使用讲述了常用的方法及流，使用java8可以很清晰表达你要做什么，代码也很简洁。本篇例子主要是为了讲解较为简单，大家可以去使用java8重构自己现有的代码，自行领会lambda的奥妙。\n\n本文说的Stream要组合使用才会发挥更大的功能，链式调用很迷人，根据自己的业务去做吧。","slug":"感受java8后lambda之美","published":1,"updated":"2022-11-04T05:47:48.306Z","_id":"cla1u1fni00004sld4m8lg8sb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>一、引言</p>\n<p>java8最大的特性就是引入Lambda表达式，即函数式编程，可以将行为进行传递。总结就是：使用不可变值与函数，函数对不可变值进行处理，映射成另一个值。</p>\n<h2 id=\"二、java重要的函数式接口\"><a href=\"#二、java重要的函数式接口\" class=\"headerlink\" title=\"二、java重要的函数式接口\"></a>二、java重要的函数式接口</h2><h3 id=\"1、什么是函数式接口\"><a href=\"#1、什么是函数式接口\" class=\"headerlink\" title=\"1、什么是函数式接口\"></a>1、什么是函数式接口</h3><p>函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。</p>\n<h4 id=\"1-1-java8自带的常用函数式接口。\"><a href=\"#1-1-java8自带的常用函数式接口。\" class=\"headerlink\" title=\"1.1 java8自带的常用函数式接口。\"></a>1.1 java8自带的常用函数式接口。</h4><p><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_ec9c4260.png\" alt=\"image_ec9c4260.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Predicate</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> predicate <span class=\"token operator\">=</span> x <span class=\"token operator\">-></span> x <span class=\"token operator\">></span> <span class=\"token number\">185</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"9龙\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">23</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>\n            <span class=\"token string\">\"9龙的身高高于185吗？：\"</span> <span class=\"token operator\">+</span> predicate<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>student<span class=\"token punctuation\">.</span><span class=\"token function\">getStature</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">Consumer</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> consumer <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token operator\">::</span><span class=\"token function\">println</span><span class=\"token punctuation\">;</span>\n        consumer<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"命运由我不由天\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">Function</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> function <span class=\"token operator\">=</span> <span class=\"token class-name\">Student</span><span class=\"token operator\">::</span><span class=\"token function\">getName</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">String</span> name <span class=\"token operator\">=</span> function<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>student<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">Supplier</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> supplier <span class=\"token operator\">=</span> \n            <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span>TEN<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>supplier<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">UnaryOperator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">></span></span> unaryOperator <span class=\"token operator\">=</span> uglily <span class=\"token operator\">-></span> <span class=\"token operator\">!</span>uglily<span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Boolean</span> apply2 <span class=\"token operator\">=</span> unaryOperator<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>apply2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">BinaryOperator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> operator <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> x <span class=\"token operator\">*</span> y<span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Integer</span> integer <span class=\"token operator\">=</span> operator<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token string\">\"我是一个演示的函数式接口\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 演示自定义函数式接口使用\n     *\n     * @param worker\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Worker</span> worker<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">String</span> work <span class=\"token operator\">=</span> worker<span class=\"token punctuation\">.</span><span class=\"token function\">work</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>work<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Worker</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">String</span> <span class=\"token function\">work</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//9龙的身高高于185吗？：false</span>\n<span class=\"token comment\">//命运由我不由天</span>\n<span class=\"token comment\">//9龙</span>\n<span class=\"token comment\">//10</span>\n<span class=\"token comment\">//false</span>\n<span class=\"token comment\">//6</span>\n<span class=\"token comment\">//我是一个演示的函数式接口</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上演示了lambda接口的使用及自定义一个函数式接口并使用。下面，我们看看java8将函数式接口封装到流中如何高效的帮助我们处理集合。  </p>\n<p>注意：Student::getName例子中这种编写lambda表达式的方式称为方法引用。格式为ClassNmae::methodName。是不是很神奇，java8就是这么迷人。</p>\n<blockquote>\n<p>示例：本篇所有示例都基于以下三个类。OutstandingClass：班级；Student：学生；SpecialityEnum：特长。</p>\n</blockquote>\n<h4 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_7771b4fe.png\" alt=\"image_7771b4fe.png\"></h4><h4 id=\"1-2-惰性求值与及早求值\"><a href=\"#1-2-惰性求值与及早求值\" class=\"headerlink\" title=\"1.2 惰性求值与及早求值\"></a>1.2 惰性求值与及早求值</h4><p>惰性求值：只描述Stream，操作的结果也是Stream，这样的操作称为惰性求值。惰性求值可以像建造者模式一样链式使用，最后再使用及早求值得到最终结果。</p>\n<p>及早求值：得到最终的结果而不是Stream，这样的操作称为及早求值。</p>\n<h3 id=\"2、常用的流\"><a href=\"#2、常用的流\" class=\"headerlink\" title=\"2、常用的流\"></a>2、常用的流</h3><h4 id=\"2-1-collect-Collectors-toList\"><a href=\"#2-1-collect-Collectors-toList\" class=\"headerlink\" title=\"2.1 collect(Collectors.toList())\"></a>2.1 collect(Collectors.toList())</h4><p>将流转换为list。还有toSet()，toMap()等。及早求值。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestCase</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> studentList <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>studentList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//[Student&#123;name='路飞', age=22, stature=175, specialities=null&#125;, </span>\n<span class=\"token comment\">//Student&#123;name='红发', age=40, stature=180, specialities=null&#125;, </span>\n<span class=\"token comment\">//Student&#123;name='白胡子', age=50, stature=185, specialities=null&#125;]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"2-2-filter\"><a href=\"#2-2-filter\" class=\"headerlink\" title=\"2.2 filter\"></a>2.2 filter</h4><p>顾名思义，起过滤筛选的作用。内部就是Predicate接口。惰性求值。</p>\n<p><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_eba0197b.png\" alt=\"image_eba0197b.png\"></p>\n<p>比如我们筛选出出身高小于180的同学。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestCase</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>stu <span class=\"token operator\">-></span> stu<span class=\"token punctuation\">.</span><span class=\"token function\">getStature</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//[Student&#123;name='路飞', age=22, stature=175, specialities=null&#125;]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"2-3-map\"><a href=\"#2-3-map\" class=\"headerlink\" title=\"2.3 map\"></a>2.3 map</h4><p>转换功能，内部就是Function接口。惰性求值</p>\n<p><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_23fab375.png\" alt=\"image_23fab375.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestCase</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> names <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>student <span class=\"token operator\">-></span> student<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>names<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//[路飞, 红发, 白胡子]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>例子中将student对象转换为String对象，获取student的名字。  </p>\n<h4 id=\"2-4-flatMap\"><a href=\"#2-4-flatMap\" class=\"headerlink\" title=\"2.4 flatMap\"></a>2.4 flatMap</h4><p>将多个Stream合并为一个Stream。惰性求值</p>\n<p><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_c1ac2536.png\" alt=\"image_c1ac2536.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestCase</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> studentList <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span>students<span class=\"token punctuation\">,</span>\n                <span class=\"token function\">asList</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"艾斯\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">25</span><span class=\"token punctuation\">,</span> <span class=\"token number\">183</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"雷利\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">48</span><span class=\"token punctuation\">,</span> <span class=\"token number\">176</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span>students1 <span class=\"token operator\">-></span> students1<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>studentList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//[Student&#123;name='路飞', age=22, stature=175, specialities=null&#125;, </span>\n<span class=\"token comment\">//Student&#123;name='红发', age=40, stature=180, specialities=null&#125;, </span>\n<span class=\"token comment\">//Student&#123;name='白胡子', age=50, stature=185, specialities=null&#125;, </span>\n<span class=\"token comment\">//Student&#123;name='艾斯', age=25, stature=183, specialities=null&#125;,</span>\n<span class=\"token comment\">//Student&#123;name='雷利', age=48, stature=176, specialities=null&#125;]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>调用Stream.of的静态方法将两个list转换为Stream，再通过flatMap将两个流合并为一个。  </p>\n<h4 id=\"2-5-max和min\"><a href=\"#2-5-max和min\" class=\"headerlink\" title=\"2.5 max和min\"></a>2.5 max和min</h4><p>我们经常会在集合中求最大或最小值，使用流就很方便。及早求值。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestCase</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">Optional</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> max <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Comparator</span><span class=\"token punctuation\">.</span><span class=\"token function\">comparing</span><span class=\"token punctuation\">(</span>stu <span class=\"token operator\">-></span> stu<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Optional</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> min <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Comparator</span><span class=\"token punctuation\">.</span><span class=\"token function\">comparing</span><span class=\"token punctuation\">(</span>stu <span class=\"token operator\">-></span> stu<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//判断是否有值</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">.</span><span class=\"token function\">isPresent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">.</span><span class=\"token function\">isPresent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//Student&#123;name='白胡子', age=50, stature=185, specialities=null&#125;</span>\n<span class=\"token comment\">//Student&#123;name='路飞', age=22, stature=175, specialities=null&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>max、min接收一个Comparator（例子中使用java8自带的静态函数，只需要传进需要比较值即可。）并且返回一个Optional对象，该对象是java8新增的类，专门为了防止null引发的空指针异常。  </p>\n<p>可以使用max.isPresent()判断是否有值；可以使用max.orElse(new Student())，当值为null时就使用给定值；也可以使用max.orElseGet(() -&gt; new Student());这需要传入一个Supplier的lambda表达式。</p>\n<h4 id=\"2-6-count\"><a href=\"#2-6-count\" class=\"headerlink\" title=\"2.6 count\"></a>2.6 count</h4><p>统计功能，一般都是结合filter使用，因为先筛选出我们需要的再统计即可。及早求值</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestCase</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">long</span> count <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>s1 <span class=\"token operator\">-></span> s1<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">45</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"年龄小于45岁的人数是：\"</span> <span class=\"token operator\">+</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//年龄小于45岁的人数是：2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"2-7-reduce\"><a href=\"#2-7-reduce\" class=\"headerlink\" title=\"2.7 reduce\"></a>2.7 reduce</h4><p>reduce 操作可以实现从一组值中生成一个值。在上述例子中用到的 count 、 min 和 max 方法，因为常用而被纳入标准库中。事实上，这些方法都是 reduce 操作。及早求值。</p>\n<p><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_9186bf98.png\" alt=\"image_9186bf98.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestCase</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Integer</span> reduce <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>acc<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> acc<span class=\"token operator\">+</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>reduce<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//10</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们看得reduce接收了一个初始值为0的累加器，依次取出值与累加器相加，最后累加器的值就是最终的结果。</p>\n<h2 id=\"三、高级集合类及收集器\"><a href=\"#三、高级集合类及收集器\" class=\"headerlink\" title=\"三、高级集合类及收集器\"></a>三、高级集合类及收集器</h2><h3 id=\"3-1-转换成值\"><a href=\"#3-1-转换成值\" class=\"headerlink\" title=\"3.1 转换成值\"></a>3.1 转换成值</h3><p>收集器，一种通用的、从流生成复杂值的结构。只要将它传给 collect 方法，所有的流就都可以使用它了。标准类库已经提供了一些有用的收集器，以下示例代码中的收集器都是从 java.util.stream.Collectors 类中静态导入的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CollectorsTest</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students1<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">23</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students1<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students1<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">OutstandingClass</span> ostClass1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OutstandingClass</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"一班\"</span><span class=\"token punctuation\">,</span> students1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//复制students1，并移除一个学生</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>students1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students2<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">OutstandingClass</span> ostClass2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OutstandingClass</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"二班\"</span><span class=\"token punctuation\">,</span> students2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//将ostClass1、ostClass2转换为Stream</span>\n        <span class=\"token class-name\">Stream</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">OutstandingClass</span><span class=\"token punctuation\">></span></span> classStream <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span>ostClass1<span class=\"token punctuation\">,</span> ostClass2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">OutstandingClass</span> outstandingClass <span class=\"token operator\">=</span> <span class=\"token function\">biggestGroup</span><span class=\"token punctuation\">(</span>classStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"人数最多的班级是：\"</span> <span class=\"token operator\">+</span> outstandingClass<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"一班平均年龄是：\"</span> <span class=\"token operator\">+</span> <span class=\"token function\">averageNumberOfStudent</span><span class=\"token punctuation\">(</span>students1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 获取人数最多的班级\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">OutstandingClass</span> <span class=\"token function\">biggestGroup</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Stream</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">OutstandingClass</span><span class=\"token punctuation\">></span></span> outstandingClasses<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> outstandingClasses<span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span>\n                <span class=\"token function\">maxBy</span><span class=\"token punctuation\">(</span><span class=\"token function\">comparing</span><span class=\"token punctuation\">(</span>ostClass <span class=\"token operator\">-></span> ostClass<span class=\"token punctuation\">.</span><span class=\"token function\">getStudents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">orElseGet</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">OutstandingClass</span><span class=\"token operator\">::</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 计算平均年龄\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">double</span> <span class=\"token function\">averageNumberOfStudent</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token function\">averagingInt</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Student</span><span class=\"token operator\">::</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//人数最多的班级是：一班</span>\n<span class=\"token comment\">//一班平均年龄是：37.666666666666664</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>maxBy或者minBy就是求最大值与最小值。  </p>\n<h3 id=\"3-2-转换成块\"><a href=\"#3-2-转换成块\" class=\"headerlink\" title=\"3.2 转换成块\"></a>3.2 转换成块</h3><p>常用的流操作是将其分解成两个集合，Collectors.partitioningBy帮我们实现了，接收一个Predicate函数式接口。</p>\n<p><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_16155432.png\" alt=\"image_16155432.png\"></p>\n<p>将示例学生分为会唱歌与不会唱歌的两个集合。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PartitioningByTest</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//省略List&lt;student> students的初始化</span>\n        <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> listMap <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span>\n            <span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">partitioningBy</span><span class=\"token punctuation\">(</span>student <span class=\"token operator\">-></span> student<span class=\"token punctuation\">.</span><span class=\"token function\">getSpecialities</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n                                      <span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SpecialityEnum</span><span class=\"token punctuation\">.</span>SING<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"3-3-数据分组\"><a href=\"#3-3-数据分组\" class=\"headerlink\" title=\"3.3 数据分组\"></a>3.3 数据分组</h3><p>数据分组是一种更自然的分割数据操作，与将数据分成 ture 和 false 两部分不同，可以使用任意值对数据分组。Collectors.groupingBy接收一个Function做转换。</p>\n<p><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_79d304da.png\" alt=\"image_79d304da.png\"></p>\n<p>如图，我们使用groupingBy将根据进行分组为圆形一组，三角形一组，正方形一组。</p>\n<p>例子：根据学生第一个特长进行分组</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GroupingByTest</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//省略List&lt;student> students的初始化</span>\n         <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SpecialityEnum</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> listMap <span class=\"token operator\">=</span> \n             students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span>\n             <span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">groupingBy</span><span class=\"token punctuation\">(</span>student <span class=\"token operator\">-></span> student<span class=\"token punctuation\">.</span><span class=\"token function\">getSpecialities</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Collectors.groupingBy与SQL 中的 group by 操作是一样的。</p>\n<h3 id=\"3-4-字符串拼接\"><a href=\"#3-4-字符串拼接\" class=\"headerlink\" title=\"3.4 字符串拼接\"></a>3.4 字符串拼接</h3><p>如果将所有学生的名字拼接起来，怎么做呢？通常只能创建一个StringBuilder，循环拼接。使用Stream，使用Collectors.joining()简单容易。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">JoiningTest</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n         <span class=\"token class-name\">String</span> names <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n             <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Student</span><span class=\"token operator\">::</span><span class=\"token function\">getName</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">joining</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"[\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"]\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>names<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//[路飞,红发,白胡子]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>joining接收三个参数，第一个是分界符，第二个是前缀符，第三个是结束符。也可以不传入参数Collectors.joining()，这样就是直接拼接。  </p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>本篇主要从实际使用讲述了常用的方法及流，使用java8可以很清晰表达你要做什么，代码也很简洁。本篇例子主要是为了讲解较为简单，大家可以去使用java8重构自己现有的代码，自行领会lambda的奥妙。</p>\n<p>本文说的Stream要组合使用才会发挥更大的功能，链式调用很迷人，根据自己的业务去做吧。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<p>一、引言</p>\n<p>java8最大的特性就是引入Lambda表达式，即函数式编程，可以将行为进行传递。总结就是：使用不可变值与函数，函数对不可变值进行处理，映射成另一个值。</p>\n<h2 id=\"二、java重要的函数式接口\"><a href=\"#二、java重要的函数式接口\" class=\"headerlink\" title=\"二、java重要的函数式接口\"></a>二、java重要的函数式接口</h2><h3 id=\"1、什么是函数式接口\"><a href=\"#1、什么是函数式接口\" class=\"headerlink\" title=\"1、什么是函数式接口\"></a>1、什么是函数式接口</h3><p>函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。使用@FunctionalInterface注解修饰的类，编译器会检测该类是否只有一个抽象方法或接口，否则，会报错。可以有多个默认方法，静态方法。</p>\n<h4 id=\"1-1-java8自带的常用函数式接口。\"><a href=\"#1-1-java8自带的常用函数式接口。\" class=\"headerlink\" title=\"1.1 java8自带的常用函数式接口。\"></a>1.1 java8自带的常用函数式接口。</h4><p><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_ec9c4260.png\" alt=\"image_ec9c4260.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Predicate</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> predicate <span class=\"token operator\">=</span> x <span class=\"token operator\">-></span> x <span class=\"token operator\">></span> <span class=\"token number\">185</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"9龙\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">23</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>\n            <span class=\"token string\">\"9龙的身高高于185吗？：\"</span> <span class=\"token operator\">+</span> predicate<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>student<span class=\"token punctuation\">.</span><span class=\"token function\">getStature</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">Consumer</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> consumer <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token operator\">::</span><span class=\"token function\">println</span><span class=\"token punctuation\">;</span>\n        consumer<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"命运由我不由天\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">Function</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> function <span class=\"token operator\">=</span> <span class=\"token class-name\">Student</span><span class=\"token operator\">::</span><span class=\"token function\">getName</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">String</span> name <span class=\"token operator\">=</span> function<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>student<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">Supplier</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> supplier <span class=\"token operator\">=</span> \n            <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BigDecimal</span><span class=\"token punctuation\">.</span>TEN<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>supplier<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">UnaryOperator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">></span></span> unaryOperator <span class=\"token operator\">=</span> uglily <span class=\"token operator\">-></span> <span class=\"token operator\">!</span>uglily<span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Boolean</span> apply2 <span class=\"token operator\">=</span> unaryOperator<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>apply2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">BinaryOperator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> operator <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> x <span class=\"token operator\">*</span> y<span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Integer</span> integer <span class=\"token operator\">=</span> operator<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token string\">\"我是一个演示的函数式接口\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 演示自定义函数式接口使用\n     *\n     * @param worker\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Worker</span> worker<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">String</span> work <span class=\"token operator\">=</span> worker<span class=\"token punctuation\">.</span><span class=\"token function\">work</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>work<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Worker</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">String</span> <span class=\"token function\">work</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//9龙的身高高于185吗？：false</span>\n<span class=\"token comment\">//命运由我不由天</span>\n<span class=\"token comment\">//9龙</span>\n<span class=\"token comment\">//10</span>\n<span class=\"token comment\">//false</span>\n<span class=\"token comment\">//6</span>\n<span class=\"token comment\">//我是一个演示的函数式接口</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上演示了lambda接口的使用及自定义一个函数式接口并使用。下面，我们看看java8将函数式接口封装到流中如何高效的帮助我们处理集合。  </p>\n<p>注意：Student::getName例子中这种编写lambda表达式的方式称为方法引用。格式为ClassNmae::methodName。是不是很神奇，java8就是这么迷人。</p>\n<blockquote>\n<p>示例：本篇所有示例都基于以下三个类。OutstandingClass：班级；Student：学生；SpecialityEnum：特长。</p>\n</blockquote>\n<h4 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_7771b4fe.png\" alt=\"image_7771b4fe.png\"></h4><h4 id=\"1-2-惰性求值与及早求值\"><a href=\"#1-2-惰性求值与及早求值\" class=\"headerlink\" title=\"1.2 惰性求值与及早求值\"></a>1.2 惰性求值与及早求值</h4><p>惰性求值：只描述Stream，操作的结果也是Stream，这样的操作称为惰性求值。惰性求值可以像建造者模式一样链式使用，最后再使用及早求值得到最终结果。</p>\n<p>及早求值：得到最终的结果而不是Stream，这样的操作称为及早求值。</p>\n<h3 id=\"2、常用的流\"><a href=\"#2、常用的流\" class=\"headerlink\" title=\"2、常用的流\"></a>2、常用的流</h3><h4 id=\"2-1-collect-Collectors-toList\"><a href=\"#2-1-collect-Collectors-toList\" class=\"headerlink\" title=\"2.1 collect(Collectors.toList())\"></a>2.1 collect(Collectors.toList())</h4><p>将流转换为list。还有toSet()，toMap()等。及早求值。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestCase</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> studentList <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>studentList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//[Student&#123;name='路飞', age=22, stature=175, specialities=null&#125;, </span>\n<span class=\"token comment\">//Student&#123;name='红发', age=40, stature=180, specialities=null&#125;, </span>\n<span class=\"token comment\">//Student&#123;name='白胡子', age=50, stature=185, specialities=null&#125;]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"2-2-filter\"><a href=\"#2-2-filter\" class=\"headerlink\" title=\"2.2 filter\"></a>2.2 filter</h4><p>顾名思义，起过滤筛选的作用。内部就是Predicate接口。惰性求值。</p>\n<p><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_eba0197b.png\" alt=\"image_eba0197b.png\"></p>\n<p>比如我们筛选出出身高小于180的同学。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestCase</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>stu <span class=\"token operator\">-></span> stu<span class=\"token punctuation\">.</span><span class=\"token function\">getStature</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//[Student&#123;name='路飞', age=22, stature=175, specialities=null&#125;]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"2-3-map\"><a href=\"#2-3-map\" class=\"headerlink\" title=\"2.3 map\"></a>2.3 map</h4><p>转换功能，内部就是Function接口。惰性求值</p>\n<p><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_23fab375.png\" alt=\"image_23fab375.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestCase</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> names <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>student <span class=\"token operator\">-></span> student<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>names<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//[路飞, 红发, 白胡子]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>例子中将student对象转换为String对象，获取student的名字。  </p>\n<h4 id=\"2-4-flatMap\"><a href=\"#2-4-flatMap\" class=\"headerlink\" title=\"2.4 flatMap\"></a>2.4 flatMap</h4><p>将多个Stream合并为一个Stream。惰性求值</p>\n<p><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_c1ac2536.png\" alt=\"image_c1ac2536.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestCase</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> studentList <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span>students<span class=\"token punctuation\">,</span>\n                <span class=\"token function\">asList</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"艾斯\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">25</span><span class=\"token punctuation\">,</span> <span class=\"token number\">183</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"雷利\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">48</span><span class=\"token punctuation\">,</span> <span class=\"token number\">176</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span>students1 <span class=\"token operator\">-></span> students1<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>studentList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//[Student&#123;name='路飞', age=22, stature=175, specialities=null&#125;, </span>\n<span class=\"token comment\">//Student&#123;name='红发', age=40, stature=180, specialities=null&#125;, </span>\n<span class=\"token comment\">//Student&#123;name='白胡子', age=50, stature=185, specialities=null&#125;, </span>\n<span class=\"token comment\">//Student&#123;name='艾斯', age=25, stature=183, specialities=null&#125;,</span>\n<span class=\"token comment\">//Student&#123;name='雷利', age=48, stature=176, specialities=null&#125;]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>调用Stream.of的静态方法将两个list转换为Stream，再通过flatMap将两个流合并为一个。  </p>\n<h4 id=\"2-5-max和min\"><a href=\"#2-5-max和min\" class=\"headerlink\" title=\"2.5 max和min\"></a>2.5 max和min</h4><p>我们经常会在集合中求最大或最小值，使用流就很方便。及早求值。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestCase</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">Optional</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> max <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Comparator</span><span class=\"token punctuation\">.</span><span class=\"token function\">comparing</span><span class=\"token punctuation\">(</span>stu <span class=\"token operator\">-></span> stu<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">Optional</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> min <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Comparator</span><span class=\"token punctuation\">.</span><span class=\"token function\">comparing</span><span class=\"token punctuation\">(</span>stu <span class=\"token operator\">-></span> stu<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//判断是否有值</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">.</span><span class=\"token function\">isPresent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">.</span><span class=\"token function\">isPresent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//Student&#123;name='白胡子', age=50, stature=185, specialities=null&#125;</span>\n<span class=\"token comment\">//Student&#123;name='路飞', age=22, stature=175, specialities=null&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>max、min接收一个Comparator（例子中使用java8自带的静态函数，只需要传进需要比较值即可。）并且返回一个Optional对象，该对象是java8新增的类，专门为了防止null引发的空指针异常。  </p>\n<p>可以使用max.isPresent()判断是否有值；可以使用max.orElse(new Student())，当值为null时就使用给定值；也可以使用max.orElseGet(() -&gt; new Student());这需要传入一个Supplier的lambda表达式。</p>\n<h4 id=\"2-6-count\"><a href=\"#2-6-count\" class=\"headerlink\" title=\"2.6 count\"></a>2.6 count</h4><p>统计功能，一般都是结合filter使用，因为先筛选出我们需要的再统计即可。及早求值</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestCase</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">long</span> count <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>s1 <span class=\"token operator\">-></span> s1<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">45</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"年龄小于45岁的人数是：\"</span> <span class=\"token operator\">+</span> count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//年龄小于45岁的人数是：2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"2-7-reduce\"><a href=\"#2-7-reduce\" class=\"headerlink\" title=\"2.7 reduce\"></a>2.7 reduce</h4><p>reduce 操作可以实现从一组值中生成一个值。在上述例子中用到的 count 、 min 和 max 方法，因为常用而被纳入标准库中。事实上，这些方法都是 reduce 操作。及早求值。</p>\n<p><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_9186bf98.png\" alt=\"image_9186bf98.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestCase</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Integer</span> reduce <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>acc<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> acc<span class=\"token operator\">+</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>reduce<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//10</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们看得reduce接收了一个初始值为0的累加器，依次取出值与累加器相加，最后累加器的值就是最终的结果。</p>\n<h2 id=\"三、高级集合类及收集器\"><a href=\"#三、高级集合类及收集器\" class=\"headerlink\" title=\"三、高级集合类及收集器\"></a>三、高级集合类及收集器</h2><h3 id=\"3-1-转换成值\"><a href=\"#3-1-转换成值\" class=\"headerlink\" title=\"3.1 转换成值\"></a>3.1 转换成值</h3><p>收集器，一种通用的、从流生成复杂值的结构。只要将它传给 collect 方法，所有的流就都可以使用它了。标准类库已经提供了一些有用的收集器，以下示例代码中的收集器都是从 java.util.stream.Collectors 类中静态导入的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CollectorsTest</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students1<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">23</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students1<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students1<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">OutstandingClass</span> ostClass1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OutstandingClass</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"一班\"</span><span class=\"token punctuation\">,</span> students1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//复制students1，并移除一个学生</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>students1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students2<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">OutstandingClass</span> ostClass2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OutstandingClass</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"二班\"</span><span class=\"token punctuation\">,</span> students2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//将ostClass1、ostClass2转换为Stream</span>\n        <span class=\"token class-name\">Stream</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">OutstandingClass</span><span class=\"token punctuation\">></span></span> classStream <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span>ostClass1<span class=\"token punctuation\">,</span> ostClass2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">OutstandingClass</span> outstandingClass <span class=\"token operator\">=</span> <span class=\"token function\">biggestGroup</span><span class=\"token punctuation\">(</span>classStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"人数最多的班级是：\"</span> <span class=\"token operator\">+</span> outstandingClass<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"一班平均年龄是：\"</span> <span class=\"token operator\">+</span> <span class=\"token function\">averageNumberOfStudent</span><span class=\"token punctuation\">(</span>students1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 获取人数最多的班级\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">OutstandingClass</span> <span class=\"token function\">biggestGroup</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Stream</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">OutstandingClass</span><span class=\"token punctuation\">></span></span> outstandingClasses<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> outstandingClasses<span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span>\n                <span class=\"token function\">maxBy</span><span class=\"token punctuation\">(</span><span class=\"token function\">comparing</span><span class=\"token punctuation\">(</span>ostClass <span class=\"token operator\">-></span> ostClass<span class=\"token punctuation\">.</span><span class=\"token function\">getStudents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">orElseGet</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">OutstandingClass</span><span class=\"token operator\">::</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n     * 计算平均年龄\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">double</span> <span class=\"token function\">averageNumberOfStudent</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token function\">averagingInt</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Student</span><span class=\"token operator\">::</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//人数最多的班级是：一班</span>\n<span class=\"token comment\">//一班平均年龄是：37.666666666666664</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>maxBy或者minBy就是求最大值与最小值。  </p>\n<h3 id=\"3-2-转换成块\"><a href=\"#3-2-转换成块\" class=\"headerlink\" title=\"3.2 转换成块\"></a>3.2 转换成块</h3><p>常用的流操作是将其分解成两个集合，Collectors.partitioningBy帮我们实现了，接收一个Predicate函数式接口。</p>\n<p><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_16155432.png\" alt=\"image_16155432.png\"></p>\n<p>将示例学生分为会唱歌与不会唱歌的两个集合。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PartitioningByTest</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//省略List&lt;student> students的初始化</span>\n        <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> listMap <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span>\n            <span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">partitioningBy</span><span class=\"token punctuation\">(</span>student <span class=\"token operator\">-></span> student<span class=\"token punctuation\">.</span><span class=\"token function\">getSpecialities</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n                                      <span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SpecialityEnum</span><span class=\"token punctuation\">.</span>SING<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"3-3-数据分组\"><a href=\"#3-3-数据分组\" class=\"headerlink\" title=\"3.3 数据分组\"></a>3.3 数据分组</h3><p>数据分组是一种更自然的分割数据操作，与将数据分成 ture 和 false 两部分不同，可以使用任意值对数据分组。Collectors.groupingBy接收一个Function做转换。</p>\n<p><img src=\"/2022/11/04/gan-shou-java8-hou-lambda-zhi-mei/image_79d304da.png\" alt=\"image_79d304da.png\"></p>\n<p>如图，我们使用groupingBy将根据进行分组为圆形一组，三角形一组，正方形一组。</p>\n<p>例子：根据学生第一个特长进行分组</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GroupingByTest</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//省略List&lt;student> students的初始化</span>\n         <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">SpecialityEnum</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> listMap <span class=\"token operator\">=</span> \n             students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span>\n             <span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">groupingBy</span><span class=\"token punctuation\">(</span>student <span class=\"token operator\">-></span> student<span class=\"token punctuation\">.</span><span class=\"token function\">getSpecialities</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Collectors.groupingBy与SQL 中的 group by 操作是一样的。</p>\n<h3 id=\"3-4-字符串拼接\"><a href=\"#3-4-字符串拼接\" class=\"headerlink\" title=\"3.4 字符串拼接\"></a>3.4 字符串拼接</h3><p>如果将所有学生的名字拼接起来，怎么做呢？通常只能创建一个StringBuilder，循环拼接。使用Stream，使用Collectors.joining()简单容易。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">JoiningTest</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Student</span><span class=\"token punctuation\">></span></span> students <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"路飞\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">175</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"红发\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">40</span><span class=\"token punctuation\">,</span> <span class=\"token number\">180</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        students<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"白胡子\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">185</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n         <span class=\"token class-name\">String</span> names <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n             <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Student</span><span class=\"token operator\">::</span><span class=\"token function\">getName</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">joining</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"[\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"]\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>names<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">//输出结果</span>\n<span class=\"token comment\">//[路飞,红发,白胡子]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>joining接收三个参数，第一个是分界符，第二个是前缀符，第三个是结束符。也可以不传入参数Collectors.joining()，这样就是直接拼接。  </p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>本篇主要从实际使用讲述了常用的方法及流，使用java8可以很清晰表达你要做什么，代码也很简洁。本篇例子主要是为了讲解较为简单，大家可以去使用java8重构自己现有的代码，自行领会lambda的奥妙。</p>\n<p>本文说的Stream要组合使用才会发挥更大的功能，链式调用很迷人，根据自己的业务去做吧。</p>\n"},{"title":"在hexo中无痛使用本地图片","top":false,"cover":false,"toc":false,"mathjax":true,"date":"2022-11-04T01:57:08.000Z","password":null,"summary":"hexo中使用本地图片是件非常让人纠结的事情","_content":"\n## 1 起因 \n\n在 hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。\n\n这些问题使得我一度不愿意使用本地图片而选择用图床，但被移动运营商无耻的横条广告逼得打算上 https，图床只支持 http 就成了问题。\n\nhexo 下插入图片现在大概有几个方案\n\n### 1.1 放在根目录 \n\n早期大部分的方案是把图片放在 `source/img` 下，然后在 markdown 里写 `![img](/source/img/img.png)` 。显然这样在本地的编辑器里完全不能正确识别图片的位置。\n\n### 1.2 asset-image \n\n在 hexo 2.x 时出现的插件，后来被吸纳进 `hexo 3 core` ，用法的介绍见 [资源文件夹 | Hexo][_ Hexo] 。比较尴尬的是，这种方法直接放弃了 markdown 原来的语法，使用类似 ``的语法，。markdown 本来有插入图片的语法不好好支持，专门用一个新的语法来插入本地图片，让我这种强迫症不太能接受。\n\n## 2 解决方案 \n\n\n### 2.1 使用 \n\n首先确认 `_config.yml` 中有 `post_asset_folder:true` 。\n\n在 hexo 目录，执行\n\n```java\nnpm install https://github.com/CodeFalling/hexo-asset-image --save\n```\n\n假设在\n\n```java\nMacGesture2-Publish\n├── apppicker.jpg\n├── logo.jpg\n└── rules.jpg MacGesture2-Publish.md\n```\n\n这样的目录结构（目录名和文章名一致），只要使用 `![logo](MacGesture2-Publish/logo.jpg)`就可以插入图片。\n\n生成的结构为\n\n```java\npublic/2015/10/18/MacGesture2-Publish\n├── apppicker.jpg\n├── index.html\n├── logo.jpg\n└── rules.jpg\n```\n\n同时，生成的 html 是\n\n```java\n<img src=\"/2015/10/18/MacGesture2-Publish/logo.jpg\" alt=\"logo\">\n```\n\n而不是愚蠢的\n\n```java\n<img src=\"MacGesture2-Publish/logo.jpg\" alt=\"logo\">\n```\n\n值得一提的是，这个插件对于 [CodeFalling/hexo-renderer-org][CodeFalling_hexo-renderer-org] 同样有效。","source":"_posts/在hexo中无痛使用本地图片.md","raw":"---\ntitle: 在hexo中无痛使用本地图片\ntop: false\ncover: false\ntoc: false\nmathjax: true\ndate: 2022-11-04 09:57:08\npassword:\nsummary: hexo中使用本地图片是件非常让人纠结的事情\ntags:\n    hexo\ncategories:\n    - hexo\n---\n\n## 1 起因 \n\n在 hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。\n\n这些问题使得我一度不愿意使用本地图片而选择用图床，但被移动运营商无耻的横条广告逼得打算上 https，图床只支持 http 就成了问题。\n\nhexo 下插入图片现在大概有几个方案\n\n### 1.1 放在根目录 \n\n早期大部分的方案是把图片放在 `source/img` 下，然后在 markdown 里写 `![img](/source/img/img.png)` 。显然这样在本地的编辑器里完全不能正确识别图片的位置。\n\n### 1.2 asset-image \n\n在 hexo 2.x 时出现的插件，后来被吸纳进 `hexo 3 core` ，用法的介绍见 [资源文件夹 | Hexo][_ Hexo] 。比较尴尬的是，这种方法直接放弃了 markdown 原来的语法，使用类似 ``的语法，。markdown 本来有插入图片的语法不好好支持，专门用一个新的语法来插入本地图片，让我这种强迫症不太能接受。\n\n## 2 解决方案 \n\n\n### 2.1 使用 \n\n首先确认 `_config.yml` 中有 `post_asset_folder:true` 。\n\n在 hexo 目录，执行\n\n```java\nnpm install https://github.com/CodeFalling/hexo-asset-image --save\n```\n\n假设在\n\n```java\nMacGesture2-Publish\n├── apppicker.jpg\n├── logo.jpg\n└── rules.jpg MacGesture2-Publish.md\n```\n\n这样的目录结构（目录名和文章名一致），只要使用 `![logo](MacGesture2-Publish/logo.jpg)`就可以插入图片。\n\n生成的结构为\n\n```java\npublic/2015/10/18/MacGesture2-Publish\n├── apppicker.jpg\n├── index.html\n├── logo.jpg\n└── rules.jpg\n```\n\n同时，生成的 html 是\n\n```java\n<img src=\"/2015/10/18/MacGesture2-Publish/logo.jpg\" alt=\"logo\">\n```\n\n而不是愚蠢的\n\n```java\n<img src=\"MacGesture2-Publish/logo.jpg\" alt=\"logo\">\n```\n\n值得一提的是，这个插件对于 [CodeFalling/hexo-renderer-org][CodeFalling_hexo-renderer-org] 同样有效。","slug":"在hexo中无痛使用本地图片","published":1,"updated":"2022-11-04T09:29:09.359Z","_id":"cla1uku9k0000wwld3jap61ky","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-起因\"><a href=\"#1-起因\" class=\"headerlink\" title=\"1 起因\"></a>1 起因</h2><p>在 hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。</p>\n<p>这些问题使得我一度不愿意使用本地图片而选择用图床，但被移动运营商无耻的横条广告逼得打算上 https，图床只支持 http 就成了问题。</p>\n<p>hexo 下插入图片现在大概有几个方案</p>\n<h3 id=\"1-1-放在根目录\"><a href=\"#1-1-放在根目录\" class=\"headerlink\" title=\"1.1 放在根目录\"></a>1.1 放在根目录</h3><p>早期大部分的方案是把图片放在 <code>source/img</code> 下，然后在 markdown 里写 <code>![img](/source/img/img.png)</code> 。显然这样在本地的编辑器里完全不能正确识别图片的位置。</p>\n<h3 id=\"1-2-asset-image\"><a href=\"#1-2-asset-image\" class=\"headerlink\" title=\"1.2 asset-image\"></a>1.2 asset-image</h3><p>在 hexo 2.x 时出现的插件，后来被吸纳进 <code>hexo 3 core</code> ，用法的介绍见 [资源文件夹 | Hexo][_ Hexo] 。比较尴尬的是，这种方法直接放弃了 markdown 原来的语法，使用类似 ``的语法，。markdown 本来有插入图片的语法不好好支持，专门用一个新的语法来插入本地图片，让我这种强迫症不太能接受。</p>\n<h2 id=\"2-解决方案\"><a href=\"#2-解决方案\" class=\"headerlink\" title=\"2 解决方案\"></a>2 解决方案</h2><h3 id=\"2-1-使用\"><a href=\"#2-1-使用\" class=\"headerlink\" title=\"2.1 使用\"></a>2.1 使用</h3><p>首先确认 <code>_config.yml</code> 中有 <code>post_asset_folder:true</code> 。</p>\n<p>在 hexo 目录，执行</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">npm install https<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>github<span class=\"token punctuation\">.</span>com<span class=\"token operator\">/</span><span class=\"token class-name\">CodeFalling</span><span class=\"token operator\">/</span>hexo<span class=\"token operator\">-</span>asset<span class=\"token operator\">-</span>image <span class=\"token operator\">--</span>save<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>假设在</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">MacGesture2</span><span class=\"token operator\">-</span><span class=\"token class-name\">Publish</span>\n├── apppicker<span class=\"token punctuation\">.</span>jpg\n├── logo<span class=\"token punctuation\">.</span>jpg\n└── rules<span class=\"token punctuation\">.</span>jpg <span class=\"token class-name\">MacGesture2</span><span class=\"token operator\">-</span><span class=\"token class-name\">Publish</span><span class=\"token punctuation\">.</span>md<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这样的目录结构（目录名和文章名一致），只要使用 <code>![logo](MacGesture2-Publish/logo.jpg)</code>就可以插入图片。</p>\n<p>生成的结构为</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span><span class=\"token operator\">/</span><span class=\"token number\">2015</span><span class=\"token operator\">/</span><span class=\"token number\">10</span><span class=\"token operator\">/</span><span class=\"token number\">18</span><span class=\"token operator\">/</span><span class=\"token class-name\">MacGesture2</span><span class=\"token operator\">-</span><span class=\"token class-name\">Publish</span>\n├── apppicker<span class=\"token punctuation\">.</span>jpg\n├── index<span class=\"token punctuation\">.</span>html\n├── logo<span class=\"token punctuation\">.</span>jpg\n└── rules<span class=\"token punctuation\">.</span>jpg<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>同时，生成的 html 是</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token operator\">&lt;</span>img src<span class=\"token operator\">=</span><span class=\"token string\">\"/2015/10/18/MacGesture2-Publish/logo.jpg\"</span> alt<span class=\"token operator\">=</span><span class=\"token string\">\"logo\"</span><span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>而不是愚蠢的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token operator\">&lt;</span>img src<span class=\"token operator\">=</span><span class=\"token string\">\"MacGesture2-Publish/logo.jpg\"</span> alt<span class=\"token operator\">=</span><span class=\"token string\">\"logo\"</span><span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>值得一提的是，这个插件对于 [CodeFalling/hexo-renderer-org][CodeFalling_hexo-renderer-org] 同样有效。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<h2 id=\"1-起因\"><a href=\"#1-起因\" class=\"headerlink\" title=\"1 起因\"></a>1 起因</h2><p>在 hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。</p>\n<p>这些问题使得我一度不愿意使用本地图片而选择用图床，但被移动运营商无耻的横条广告逼得打算上 https，图床只支持 http 就成了问题。</p>\n<p>hexo 下插入图片现在大概有几个方案</p>\n<h3 id=\"1-1-放在根目录\"><a href=\"#1-1-放在根目录\" class=\"headerlink\" title=\"1.1 放在根目录\"></a>1.1 放在根目录</h3><p>早期大部分的方案是把图片放在 <code>source/img</code> 下，然后在 markdown 里写 <code>![img](/source/img/img.png)</code> 。显然这样在本地的编辑器里完全不能正确识别图片的位置。</p>\n<h3 id=\"1-2-asset-image\"><a href=\"#1-2-asset-image\" class=\"headerlink\" title=\"1.2 asset-image\"></a>1.2 asset-image</h3><p>在 hexo 2.x 时出现的插件，后来被吸纳进 <code>hexo 3 core</code> ，用法的介绍见 [资源文件夹 | Hexo][_ Hexo] 。比较尴尬的是，这种方法直接放弃了 markdown 原来的语法，使用类似 ``的语法，。markdown 本来有插入图片的语法不好好支持，专门用一个新的语法来插入本地图片，让我这种强迫症不太能接受。</p>\n<h2 id=\"2-解决方案\"><a href=\"#2-解决方案\" class=\"headerlink\" title=\"2 解决方案\"></a>2 解决方案</h2><h3 id=\"2-1-使用\"><a href=\"#2-1-使用\" class=\"headerlink\" title=\"2.1 使用\"></a>2.1 使用</h3><p>首先确认 <code>_config.yml</code> 中有 <code>post_asset_folder:true</code> 。</p>\n<p>在 hexo 目录，执行</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">npm install https<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>github<span class=\"token punctuation\">.</span>com<span class=\"token operator\">/</span><span class=\"token class-name\">CodeFalling</span><span class=\"token operator\">/</span>hexo<span class=\"token operator\">-</span>asset<span class=\"token operator\">-</span>image <span class=\"token operator\">--</span>save<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>假设在</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">MacGesture2</span><span class=\"token operator\">-</span><span class=\"token class-name\">Publish</span>\n├── apppicker<span class=\"token punctuation\">.</span>jpg\n├── logo<span class=\"token punctuation\">.</span>jpg\n└── rules<span class=\"token punctuation\">.</span>jpg <span class=\"token class-name\">MacGesture2</span><span class=\"token operator\">-</span><span class=\"token class-name\">Publish</span><span class=\"token punctuation\">.</span>md<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这样的目录结构（目录名和文章名一致），只要使用 <code>![logo](MacGesture2-Publish/logo.jpg)</code>就可以插入图片。</p>\n<p>生成的结构为</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span><span class=\"token operator\">/</span><span class=\"token number\">2015</span><span class=\"token operator\">/</span><span class=\"token number\">10</span><span class=\"token operator\">/</span><span class=\"token number\">18</span><span class=\"token operator\">/</span><span class=\"token class-name\">MacGesture2</span><span class=\"token operator\">-</span><span class=\"token class-name\">Publish</span>\n├── apppicker<span class=\"token punctuation\">.</span>jpg\n├── index<span class=\"token punctuation\">.</span>html\n├── logo<span class=\"token punctuation\">.</span>jpg\n└── rules<span class=\"token punctuation\">.</span>jpg<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>同时，生成的 html 是</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token operator\">&lt;</span>img src<span class=\"token operator\">=</span><span class=\"token string\">\"/2015/10/18/MacGesture2-Publish/logo.jpg\"</span> alt<span class=\"token operator\">=</span><span class=\"token string\">\"logo\"</span><span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>而不是愚蠢的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token operator\">&lt;</span>img src<span class=\"token operator\">=</span><span class=\"token string\">\"MacGesture2-Publish/logo.jpg\"</span> alt<span class=\"token operator\">=</span><span class=\"token string\">\"logo\"</span><span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>值得一提的是，这个插件对于 [CodeFalling/hexo-renderer-org][CodeFalling_hexo-renderer-org] 同样有效。</p>\n"},{"title":"Java8Stream实战系列","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-11-04T02:02:54.000Z","password":null,"summary":"就目前而言，Java8之类的仍然是主流","_content":"\n就目前而言，Java8之类的仍然是主流，即使用比较广泛，其次就是JDK11之类的，毕竟对于企业研发而言，求稳第一。  \n\n\n## 一、Java8有哪些新特性？ \n\n *  1.Lambda表达式；\n *  2.新的日期API；\n *  3.引入Optional；\n *  4.新增Base64加解密API；\n *  5.接口的默认方法和静态方法；\n *  6.新增方法引用格式；\n *  7.新增Stream类；\n *  8.注解相关的改变；\n *  9.支持并行数组；\n *  10.对并发类的扩展。\n\n这里不一一讲解，只讲Stream相关系列的实战和应用。\n\n## 二、我在实践应用Stream相关的是如何提高开发效率的？ \n\n以下以实用为主(实际应用比较多的)，进行分类划分。在实际中这些通常以组合的形式进行使用，不局限于单单使用某一个。这样做的目的就是为了提高研发效率以及更快更好的解决问题。不然，使用Stream这些新特性的意义也就不存在了。\n\n\n### 1.分组 \n\n\n```java\nMap<String, List<T>> groupMapData = originData.stream().collect(Collectors.groupingBy(T::getType));\n```\n\n### 2.条件筛选 \n\n\n```java\nList<T> filterList = originData.stream().filter(a -> a.getName().equals(\"YC\")).collect(Collectors.toList());\n```\n\n### 3.排序 \n\n```java\nList<T> filterOBDHourData = originData.stream()                       .sorted(Comparator.comparing(T::getId).reversed())                       .collect(Collectors.toList());\n```\n\n  \n\n\n### 4.去重 \n\n```java\nList<T> dataVOS = originData.stream().collect(        Collectors.collectingAndThen(            Collectors.toCollection(() -> new TreeSet<>(Comparator.comparing(T::getName))), ArrayList::new)\n```\n\n### 5.数组转List \n  \n\n```java\nList<String> codes = new ArrayList<>();String[] arr = target.trim().split(\",\");if (arr.length > 0) {  codes = Stream.of(arr).collect(Collectors.toList());}\n```\n\n### 6.数据合并(含去重以及不去重) \n\n\n```java\nList<String> result = Stream.of(Lists.newArrayList(\"A\", \"B\", \"C\"), Lists.newArrayList(\"A\", \"B\")).flatMap(Collection::stream).distinct().collect(Collectors.toList());\nList<String> result = Stream.of(Lists.newArrayList(\"A\", \"B\", \"C\"), Lists.newArrayList(\"A\", \"B\")).flatMap(Collection::stream).collect(Collectors.toList());\n```\n\n  \n\n\n### 7.分页 \n\n\n```java\nList<T> dataList = originData.stream().skip((dto.getPageNum() - 1) * dto.getPageSize()).limit(dto.getPageSize()).collect(Collectors.toList());\n```\n  \n### 8.统计 \n\n\n```java\n//求最大值BigDecimal max = dataList.stream().map(T::getPrice).max((x1, x2) -> x1.compareTo(x2)).get();\n//求最小值BigDecimal min = dataList.stream().map(T::getPrice).min((x1, x2) -> x1.compareTo(x2)).get();\n//求和 空指针异常排除BigDecimal sum = dataList.stream().map(vo -> ObjectUtils.isEmpty(vo.getPrice()) ? new BigDecimal(0) : vo.getPrice()).reduce(BigDecimal.ZERO, BigDecimal::add);\n//求平均值BigDecimal average = dataList.stream().map(vo -> ObjectUtils.isEmpty(vo.getPrice()) ? new BigDecimal(0) : vo.getPrice()).reduce(BigDecimal.ZERO, BigDecimal::add).divide(BigDecimal.valueOf(dataList.size()), 2, BigDecimal.ROUND_HALF_UP);\n```\n\n### 9.拼接 \n\n```java\nString nameJoin = dataList.stream().map(T::getName).collect(Collectors.joining(\",\"));\n```\n\n### 10.归集 \n\n\n```java\nMap<String, T> mapNameObject = dataList.stream().collect(Collectors.toMap(T::getName, item -> item));\n```\n\n### 11.映射Map \n\n\n```java\nList<String> strList = Arrays.asList(\"1,2,3\", \"4,5,6\");List<String> newStrList = strList.stream().flatMap(item -> {  return Arrays.stream(item.split(\",\"));}).collect(Collectors.toList());\n```\n\n### 12.搜索 \n\n\n```java\noriginData.stream().filter(data -> Boolean.FALSE ? data.getName().equals(dto.getName()) :data.getName().contains(dto    .getName())).collect(Collectors.toList());\n```\n","source":"_posts/Java8Stream实战系列.md","raw":"---\ntitle: Java8Stream实战系列\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-11-04 10:02:54\npassword:\nsummary: 就目前而言，Java8之类的仍然是主流\ntags:\n    - jdk1.8\n    - stream\n    - lambda操作\ncategories:\n    - java\n---\n\n就目前而言，Java8之类的仍然是主流，即使用比较广泛，其次就是JDK11之类的，毕竟对于企业研发而言，求稳第一。  \n\n\n## 一、Java8有哪些新特性？ \n\n *  1.Lambda表达式；\n *  2.新的日期API；\n *  3.引入Optional；\n *  4.新增Base64加解密API；\n *  5.接口的默认方法和静态方法；\n *  6.新增方法引用格式；\n *  7.新增Stream类；\n *  8.注解相关的改变；\n *  9.支持并行数组；\n *  10.对并发类的扩展。\n\n这里不一一讲解，只讲Stream相关系列的实战和应用。\n\n## 二、我在实践应用Stream相关的是如何提高开发效率的？ \n\n以下以实用为主(实际应用比较多的)，进行分类划分。在实际中这些通常以组合的形式进行使用，不局限于单单使用某一个。这样做的目的就是为了提高研发效率以及更快更好的解决问题。不然，使用Stream这些新特性的意义也就不存在了。\n\n\n### 1.分组 \n\n\n```java\nMap<String, List<T>> groupMapData = originData.stream().collect(Collectors.groupingBy(T::getType));\n```\n\n### 2.条件筛选 \n\n\n```java\nList<T> filterList = originData.stream().filter(a -> a.getName().equals(\"YC\")).collect(Collectors.toList());\n```\n\n### 3.排序 \n\n```java\nList<T> filterOBDHourData = originData.stream()                       .sorted(Comparator.comparing(T::getId).reversed())                       .collect(Collectors.toList());\n```\n\n  \n\n\n### 4.去重 \n\n```java\nList<T> dataVOS = originData.stream().collect(        Collectors.collectingAndThen(            Collectors.toCollection(() -> new TreeSet<>(Comparator.comparing(T::getName))), ArrayList::new)\n```\n\n### 5.数组转List \n  \n\n```java\nList<String> codes = new ArrayList<>();String[] arr = target.trim().split(\",\");if (arr.length > 0) {  codes = Stream.of(arr).collect(Collectors.toList());}\n```\n\n### 6.数据合并(含去重以及不去重) \n\n\n```java\nList<String> result = Stream.of(Lists.newArrayList(\"A\", \"B\", \"C\"), Lists.newArrayList(\"A\", \"B\")).flatMap(Collection::stream).distinct().collect(Collectors.toList());\nList<String> result = Stream.of(Lists.newArrayList(\"A\", \"B\", \"C\"), Lists.newArrayList(\"A\", \"B\")).flatMap(Collection::stream).collect(Collectors.toList());\n```\n\n  \n\n\n### 7.分页 \n\n\n```java\nList<T> dataList = originData.stream().skip((dto.getPageNum() - 1) * dto.getPageSize()).limit(dto.getPageSize()).collect(Collectors.toList());\n```\n  \n### 8.统计 \n\n\n```java\n//求最大值BigDecimal max = dataList.stream().map(T::getPrice).max((x1, x2) -> x1.compareTo(x2)).get();\n//求最小值BigDecimal min = dataList.stream().map(T::getPrice).min((x1, x2) -> x1.compareTo(x2)).get();\n//求和 空指针异常排除BigDecimal sum = dataList.stream().map(vo -> ObjectUtils.isEmpty(vo.getPrice()) ? new BigDecimal(0) : vo.getPrice()).reduce(BigDecimal.ZERO, BigDecimal::add);\n//求平均值BigDecimal average = dataList.stream().map(vo -> ObjectUtils.isEmpty(vo.getPrice()) ? new BigDecimal(0) : vo.getPrice()).reduce(BigDecimal.ZERO, BigDecimal::add).divide(BigDecimal.valueOf(dataList.size()), 2, BigDecimal.ROUND_HALF_UP);\n```\n\n### 9.拼接 \n\n```java\nString nameJoin = dataList.stream().map(T::getName).collect(Collectors.joining(\",\"));\n```\n\n### 10.归集 \n\n\n```java\nMap<String, T> mapNameObject = dataList.stream().collect(Collectors.toMap(T::getName, item -> item));\n```\n\n### 11.映射Map \n\n\n```java\nList<String> strList = Arrays.asList(\"1,2,3\", \"4,5,6\");List<String> newStrList = strList.stream().flatMap(item -> {  return Arrays.stream(item.split(\",\"));}).collect(Collectors.toList());\n```\n\n### 12.搜索 \n\n\n```java\noriginData.stream().filter(data -> Boolean.FALSE ? data.getName().equals(dto.getName()) :data.getName().contains(dto    .getName())).collect(Collectors.toList());\n```\n","slug":"Java8Stream实战系列","published":1,"updated":"2022-11-04T05:13:57.194Z","_id":"cla1ut5bv00006llddor7gqde","comments":1,"layout":"post","photos":[],"link":"","content":"<p>就目前而言，Java8之类的仍然是主流，即使用比较广泛，其次就是JDK11之类的，毕竟对于企业研发而言，求稳第一。  </p>\n<h2 id=\"一、Java8有哪些新特性？\"><a href=\"#一、Java8有哪些新特性？\" class=\"headerlink\" title=\"一、Java8有哪些新特性？\"></a>一、Java8有哪些新特性？</h2><ul>\n<li> 1.Lambda表达式；</li>\n<li> 2.新的日期API；</li>\n<li> 3.引入Optional；</li>\n<li> 4.新增Base64加解密API；</li>\n<li> 5.接口的默认方法和静态方法；</li>\n<li> 6.新增方法引用格式；</li>\n<li> 7.新增Stream类；</li>\n<li> 8.注解相关的改变；</li>\n<li> 9.支持并行数组；</li>\n<li> 10.对并发类的扩展。</li>\n</ul>\n<p>这里不一一讲解，只讲Stream相关系列的实战和应用。</p>\n<h2 id=\"二、我在实践应用Stream相关的是如何提高开发效率的？\"><a href=\"#二、我在实践应用Stream相关的是如何提高开发效率的？\" class=\"headerlink\" title=\"二、我在实践应用Stream相关的是如何提高开发效率的？\"></a>二、我在实践应用Stream相关的是如何提高开发效率的？</h2><p>以下以实用为主(实际应用比较多的)，进行分类划分。在实际中这些通常以组合的形式进行使用，不局限于单单使用某一个。这样做的目的就是为了提高研发效率以及更快更好的解决问题。不然，使用Stream这些新特性的意义也就不存在了。</p>\n<h3 id=\"1-分组\"><a href=\"#1-分组\" class=\"headerlink\" title=\"1.分组\"></a>1.分组</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> groupMapData <span class=\"token operator\">=</span> originData<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">groupingBy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token operator\">::</span><span class=\"token function\">getType</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"2-条件筛选\"><a href=\"#2-条件筛选\" class=\"headerlink\" title=\"2.条件筛选\"></a>2.条件筛选</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> filterList <span class=\"token operator\">=</span> originData<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">-></span> a<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"YC\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-排序\"><a href=\"#3-排序\" class=\"headerlink\" title=\"3.排序\"></a>3.排序</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> filterOBDHourData <span class=\"token operator\">=</span> originData<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                       <span class=\"token punctuation\">.</span><span class=\"token function\">sorted</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Comparator</span><span class=\"token punctuation\">.</span><span class=\"token function\">comparing</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token operator\">::</span><span class=\"token function\">getId</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reversed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>                       <span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"4-去重\"><a href=\"#4-去重\" class=\"headerlink\" title=\"4.去重\"></a>4.去重</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> dataVOS <span class=\"token operator\">=</span> originData<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span>        <span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">collectingAndThen</span><span class=\"token punctuation\">(</span>            <span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toCollection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TreeSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Comparator</span><span class=\"token punctuation\">.</span><span class=\"token function\">comparing</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token operator\">::</span><span class=\"token function\">getName</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">::</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"5-数组转List\"><a href=\"#5-数组转List\" class=\"headerlink\" title=\"5.数组转List\"></a>5.数组转List</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> codes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> target<span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>  codes <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"6-数据合并-含去重以及不去重\"><a href=\"#6-数据合并-含去重以及不去重\" class=\"headerlink\" title=\"6.数据合并(含去重以及不去重)\"></a>6.数据合并(含去重以及不去重)</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> result <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"C\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token operator\">::</span><span class=\"token function\">stream</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">distinct</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> result <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"C\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token operator\">::</span><span class=\"token function\">stream</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"7-分页\"><a href=\"#7-分页\" class=\"headerlink\" title=\"7.分页\"></a>7.分页</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> dataList <span class=\"token operator\">=</span> originData<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">skip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>dto<span class=\"token punctuation\">.</span><span class=\"token function\">getPageNum</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> dto<span class=\"token punctuation\">.</span><span class=\"token function\">getPageSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">limit</span><span class=\"token punctuation\">(</span>dto<span class=\"token punctuation\">.</span><span class=\"token function\">getPageSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"8-统计\"><a href=\"#8-统计\" class=\"headerlink\" title=\"8.统计\"></a>8.统计</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//求最大值BigDecimal max = dataList.stream().map(T::getPrice).max((x1, x2) -> x1.compareTo(x2)).get();</span>\n<span class=\"token comment\">//求最小值BigDecimal min = dataList.stream().map(T::getPrice).min((x1, x2) -> x1.compareTo(x2)).get();</span>\n<span class=\"token comment\">//求和 空指针异常排除BigDecimal sum = dataList.stream().map(vo -> ObjectUtils.isEmpty(vo.getPrice()) ? new BigDecimal(0) : vo.getPrice()).reduce(BigDecimal.ZERO, BigDecimal::add);</span>\n<span class=\"token comment\">//求平均值BigDecimal average = dataList.stream().map(vo -> ObjectUtils.isEmpty(vo.getPrice()) ? new BigDecimal(0) : vo.getPrice()).reduce(BigDecimal.ZERO, BigDecimal::add).divide(BigDecimal.valueOf(dataList.size()), 2, BigDecimal.ROUND_HALF_UP);</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"9-拼接\"><a href=\"#9-拼接\" class=\"headerlink\" title=\"9.拼接\"></a>9.拼接</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> nameJoin <span class=\"token operator\">=</span> dataList<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token operator\">::</span><span class=\"token function\">getName</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">joining</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"10-归集\"><a href=\"#10-归集\" class=\"headerlink\" title=\"10.归集\"></a>10.归集</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> mapNameObject <span class=\"token operator\">=</span> dataList<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toMap</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token operator\">::</span><span class=\"token function\">getName</span><span class=\"token punctuation\">,</span> item <span class=\"token operator\">-></span> item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"11-映射Map\"><a href=\"#11-映射Map\" class=\"headerlink\" title=\"11.映射Map\"></a>11.映射Map</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> strList <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1,2,3\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"4,5,6\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> newStrList <span class=\"token operator\">=</span> strList<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span>item <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span>  <span class=\"token keyword\">return</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"12-搜索\"><a href=\"#12-搜索\" class=\"headerlink\" title=\"12.搜索\"></a>12.搜索</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">originData<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>data <span class=\"token operator\">-></span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">.</span>FALSE <span class=\"token operator\">?</span> data<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>dto<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span>data<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>dto    <span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<p>就目前而言，Java8之类的仍然是主流，即使用比较广泛，其次就是JDK11之类的，毕竟对于企业研发而言，求稳第一。  </p>\n<h2 id=\"一、Java8有哪些新特性？\"><a href=\"#一、Java8有哪些新特性？\" class=\"headerlink\" title=\"一、Java8有哪些新特性？\"></a>一、Java8有哪些新特性？</h2><ul>\n<li> 1.Lambda表达式；</li>\n<li> 2.新的日期API；</li>\n<li> 3.引入Optional；</li>\n<li> 4.新增Base64加解密API；</li>\n<li> 5.接口的默认方法和静态方法；</li>\n<li> 6.新增方法引用格式；</li>\n<li> 7.新增Stream类；</li>\n<li> 8.注解相关的改变；</li>\n<li> 9.支持并行数组；</li>\n<li> 10.对并发类的扩展。</li>\n</ul>\n<p>这里不一一讲解，只讲Stream相关系列的实战和应用。</p>\n<h2 id=\"二、我在实践应用Stream相关的是如何提高开发效率的？\"><a href=\"#二、我在实践应用Stream相关的是如何提高开发效率的？\" class=\"headerlink\" title=\"二、我在实践应用Stream相关的是如何提高开发效率的？\"></a>二、我在实践应用Stream相关的是如何提高开发效率的？</h2><p>以下以实用为主(实际应用比较多的)，进行分类划分。在实际中这些通常以组合的形式进行使用，不局限于单单使用某一个。这样做的目的就是为了提高研发效率以及更快更好的解决问题。不然，使用Stream这些新特性的意义也就不存在了。</p>\n<h3 id=\"1-分组\"><a href=\"#1-分组\" class=\"headerlink\" title=\"1.分组\"></a>1.分组</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> groupMapData <span class=\"token operator\">=</span> originData<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">groupingBy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token operator\">::</span><span class=\"token function\">getType</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"2-条件筛选\"><a href=\"#2-条件筛选\" class=\"headerlink\" title=\"2.条件筛选\"></a>2.条件筛选</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> filterList <span class=\"token operator\">=</span> originData<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">-></span> a<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"YC\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-排序\"><a href=\"#3-排序\" class=\"headerlink\" title=\"3.排序\"></a>3.排序</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> filterOBDHourData <span class=\"token operator\">=</span> originData<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>                       <span class=\"token punctuation\">.</span><span class=\"token function\">sorted</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Comparator</span><span class=\"token punctuation\">.</span><span class=\"token function\">comparing</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token operator\">::</span><span class=\"token function\">getId</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reversed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>                       <span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"4-去重\"><a href=\"#4-去重\" class=\"headerlink\" title=\"4.去重\"></a>4.去重</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> dataVOS <span class=\"token operator\">=</span> originData<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span>        <span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">collectingAndThen</span><span class=\"token punctuation\">(</span>            <span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toCollection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TreeSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Comparator</span><span class=\"token punctuation\">.</span><span class=\"token function\">comparing</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token operator\">::</span><span class=\"token function\">getName</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">::</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"5-数组转List\"><a href=\"#5-数组转List\" class=\"headerlink\" title=\"5.数组转List\"></a>5.数组转List</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> codes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arr <span class=\"token operator\">=</span> target<span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>  codes <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"6-数据合并-含去重以及不去重\"><a href=\"#6-数据合并-含去重以及不去重\" class=\"headerlink\" title=\"6.数据合并(含去重以及不去重)\"></a>6.数据合并(含去重以及不去重)</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> result <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"C\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token operator\">::</span><span class=\"token function\">stream</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">distinct</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> result <span class=\"token operator\">=</span> <span class=\"token class-name\">Stream</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"C\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token operator\">::</span><span class=\"token function\">stream</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"7-分页\"><a href=\"#7-分页\" class=\"headerlink\" title=\"7.分页\"></a>7.分页</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> dataList <span class=\"token operator\">=</span> originData<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">skip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>dto<span class=\"token punctuation\">.</span><span class=\"token function\">getPageNum</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> dto<span class=\"token punctuation\">.</span><span class=\"token function\">getPageSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">limit</span><span class=\"token punctuation\">(</span>dto<span class=\"token punctuation\">.</span><span class=\"token function\">getPageSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"8-统计\"><a href=\"#8-统计\" class=\"headerlink\" title=\"8.统计\"></a>8.统计</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//求最大值BigDecimal max = dataList.stream().map(T::getPrice).max((x1, x2) -> x1.compareTo(x2)).get();</span>\n<span class=\"token comment\">//求最小值BigDecimal min = dataList.stream().map(T::getPrice).min((x1, x2) -> x1.compareTo(x2)).get();</span>\n<span class=\"token comment\">//求和 空指针异常排除BigDecimal sum = dataList.stream().map(vo -> ObjectUtils.isEmpty(vo.getPrice()) ? new BigDecimal(0) : vo.getPrice()).reduce(BigDecimal.ZERO, BigDecimal::add);</span>\n<span class=\"token comment\">//求平均值BigDecimal average = dataList.stream().map(vo -> ObjectUtils.isEmpty(vo.getPrice()) ? new BigDecimal(0) : vo.getPrice()).reduce(BigDecimal.ZERO, BigDecimal::add).divide(BigDecimal.valueOf(dataList.size()), 2, BigDecimal.ROUND_HALF_UP);</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"9-拼接\"><a href=\"#9-拼接\" class=\"headerlink\" title=\"9.拼接\"></a>9.拼接</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> nameJoin <span class=\"token operator\">=</span> dataList<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token operator\">::</span><span class=\"token function\">getName</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">joining</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"10-归集\"><a href=\"#10-归集\" class=\"headerlink\" title=\"10.归集\"></a>10.归集</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> mapNameObject <span class=\"token operator\">=</span> dataList<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toMap</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token operator\">::</span><span class=\"token function\">getName</span><span class=\"token punctuation\">,</span> item <span class=\"token operator\">-></span> item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"11-映射Map\"><a href=\"#11-映射Map\" class=\"headerlink\" title=\"11.映射Map\"></a>11.映射Map</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> strList <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1,2,3\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"4,5,6\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> newStrList <span class=\"token operator\">=</span> strList<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span>item <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span>  <span class=\"token keyword\">return</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"12-搜索\"><a href=\"#12-搜索\" class=\"headerlink\" title=\"12.搜索\"></a>12.搜索</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">originData<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>data <span class=\"token operator\">-></span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">.</span>FALSE <span class=\"token operator\">?</span> data<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>dto<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span>data<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>dto    <span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectors</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n"},{"title":"45个日常用git合代码的经典操作场景","top":false,"cover":false,"toc":false,"mathjax":true,"date":"2022-11-04T02:49:16.000Z","password":null,"summary":"整理了45个日常用git操作","_content":"  \n\n\ngit对于大家应该都不太陌生，熟练使用git已经成为程序员的一项基本技能，尽管在工作中有诸如 `Sourcetree`这样牛X的客户端工具，使得合并代码变的很方便。但找工作面试和一些需彰显个人实力的场景，仍然需要我们掌握足够多的git命令。  \n\n\n下边我们整理了45个日常用git合代码的经典操作场景，基本覆盖了工作中的需求。  \n\n\n### 我刚才提交了什么? \n\n如果你用 `git commit -a` 提交了一次变化(changes)，而你又不确定到底这次提交了哪些内容。你就可以用下面的命令显示当前`HEAD`上的最近一次的提交(commit):\n\n```java\n(main)$ git show\n```\n\n或者\n\n```java\n$ git log -n1 -p\n```\n\n### 我的提交信息(commit message)写错了 \n\n如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message):\n\n```java\n$ git commit --amend --only\n```\n\n这会打开你的默认编辑器, 在这里你可以编辑信息. 另一方面, 你也可以用一条命令一次完成:\n\n```java\n$ git commit --amend --only -m 'xxxxxxx'\n```\n\n如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做。\n\n### 我提交(commit)里的用户名和邮箱不对 \n\n如果这只是单个提交(commit)，修改它：\n\n```java\n$ git commit --amend --author \"New Authorname <authoremail@mydomain.com>\"\n```\n\n如果你需要修改所有历史, 参考 'git filter-branch'的指南页.\n\n### 我想从一个提交(commit)里移除一个文件 \n\n通过下面的方法，从一个提交(commit)里移除一个文件:\n\n```java\n$ git checkout HEAD^ myfile\n$ git add -A\n$ git commit --amend\n```\n\n这将非常有用，当你有一个开放的补丁(open patch)，你往上面提交了一个不必要的文件，你需要强推(force push)去更新这个远程补丁。\n\n### 我想删除我的的最后一次提交(commit) \n\n如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。\n\n```java\n$ git reset HEAD^ --hard\n$ git push -f [remote] [branch]\n```\n\n如果你还没有推到远程, 把Git重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化):\n\n```java\n(my-branch*)$ git reset --soft HEAD@{1}\n```\n\n这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 `git revert SHAofBadCommit`， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)；或者, 如果你推的这个分支是rebase-safe的 (例如：其它开发者不会从这个分支拉), 只需要使用 `git push -f`。\n\n### 删除任意提交(commit) \n\n同样的警告：不到万不得已的时候不要这么做.\n\n```java\n$ git rebase --onto SHA1_OF_BAD_COMMIT^ SHA1_OF_BAD_COMMIT\n$ git push -f [remote] [branch]\n```\n\n或者做一个 交互式rebase 删除那些你想要删除的提交(commit)里所对应的行。\n\n### 我尝试推一个修正后的提交(amended commit)到远程，但是报错： \n\n```java\nTo https://github.com/yourusername/repo.git\n! [rejected]        mybranch -> mybranch (non-fast-forward)\nerror: failed to push some refs to 'https://github.com/tanay1337/webmaker.org.git'\nhint: Updates were rejected because the tip of your current branch is behind\nhint: its remote counterpart. Integrate the remote changes (e.g.\nhint: 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```\n\n注意, rebasing(见下面)和修正(amending)会用一个新的提交(commit)代替旧的, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (`-f`)。注意 – 总是 确保你指明一个分支!\n\n```java\n(my-branch)$ git push origin mybranch -f\n```\n\n一般来说, 要避免强推. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。\n\n### 我意外的做了一次硬重置(hard reset)，我想找回我的内容 \n\n如果你意外的做了 `git reset --hard`, 你通常能找回你的提交(commit), 因为Git对每件事都会有日志，且都会保存几天。\n\n```java\n(main)$ git reflog\n```\n\n你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。选择你想要回到的提交(commit)的SHA，再重置一次:\n\n```java\n(main)$ git reset --hard SHA1234\n```\n\n这样就完成了。\n\n## 暂存(Staging) \n\n### 我需要把暂存的内容添加到上一次的提交(commit) \n\n```java\n(my-branch*)$ git commit --amend\n```\n\n### 我想要暂存一个新文件的一部分，而不是这个文件的全部 \n\n一般来说, 如果你想暂存一个文件的一部分, 你可这样做:\n\n```java\n$ git add --patch filename.x\n```\n\n`-p` 简写。这会打开交互模式， 你将能够用 `s` 选项来分隔提交(commit)；然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时, 这样做:\n\n```java\n$ git add -N filename.x\n```\n\n然后, 你需要用 `e` 选项来手动选择需要添加的行，执行 `git diff --cached` 将会显示哪些行暂存了哪些行只是保存在本地了。\n\n### 我想把在一个文件里的变化(changes)加到两个提交(commit)里 \n\n`git add` 会把整个文件加入到一个提交. `git add -p` 允许交互式的选择你想要提交的部分.\n\n### 我想把暂存的内容变成未暂存，把未暂存的内容暂存起来 \n\n多数情况下，你应该将所有的内容变为未暂存，然后再选择你想要的内容进行commit。但假定你就是想要这么做，这里你可以创建一个临时的commit来保存你已暂存的内容，然后暂存你的未暂存的内容并进行stash。然后reset最后一个commit将原本暂存的内容变为未暂存，最后stash pop回来。\n\n```java\n$ git commit -m \"WIP\"\n$ git add .\n$ git stash\n$ git reset HEAD^\n$ git stash pop --index 0\n```\n\n注意1: 这里使用`pop`仅仅是因为想尽可能保持幂等。注意2: 假如你不加上`--index`你会把暂存的文件标记为为存储。\n\n## 未暂存(Unstaged)的内容 \n\n### 我想把未暂存的内容移动到一个新分支 \n\n```java\n$ git checkout -b my-branch\n```\n\n### 我想把未暂存的内容移动到另一个已存在的分支 \n\n```java\n$ git stash\n$ git checkout my-branch\n$ git stash pop\n```\n\n### 我想丢弃本地未提交的变化(uncommitted changes) \n\n如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以：\n\n```java\n# one commit\n(my-branch)$ git reset --hard HEAD^\n# two commits\n(my-branch)$ git reset --hard HEAD^^\n# four commits\n(my-branch)$ git reset --hard HEAD~4\n# or\n(main)$ git checkout -f\n```\n\n重置某个特殊的文件, 你可以用文件名做为参数:\n\n```java\n$ git reset filename\n```\n\n### 我想丢弃某些未暂存的内容 \n\n如果你想丢弃工作拷贝中的一部分内容，而不是全部。\n\n签出(checkout)不需要的内容，保留需要的。\n\n```java\n$ git checkout -p\n# Answer y to all of the snippets you want to drop\n```\n\n另外一个方法是使用 `stash`， Stash所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。\n\n```java\n$ git stash -p\n# Select all of the snippets you want to save\n$ git reset --hard\n$ git stash pop\n```\n\n或者, stash 你不需要的部分, 然后stash drop。\n\n```java\n$ git stash -p\n# Select all of the snippets you don't want to save\n$ git stash drop\n```\n\n## 分支(Branches) \n\n### 我从错误的分支拉取了内容，或把内容拉取到了错误的分支 \n\n这是另外一种使用 `git reflog` 情况，找到在这次错误拉(pull) 之前HEAD的指向。\n\n```java\n(main)$ git reflog\nab7555f HEAD@{0}: pull origin wrong-branch: Fast-forward\nc5bc55a HEAD@{1}: checkout: checkout message goes here\n```\n\n重置分支到你所需的提交(desired commit):\n\n```java\n$ git reset --hard c5bc55a\n```\n\n完成。\n\n### 我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致 \n\n先确认你没有推(push)你的内容到远程。\n\n`git status` 会显示你领先(ahead)源(origin)多少个提交:\n\n```java\n(my-branch)$ git status\n# On branch my-branch\n# Your branch is ahead of 'origin/my-branch' by 2 commits.\n#   (use \"git push\" to publish your local commits)\n#\n```\n\n一种方法是:\n\n```java\n(main)$ git reset --hard origin/my-branch\n```\n\n### 我需要提交到一个新分支，但错误的提交到了main \n\n在main下创建一个新分支，不切换到新分支,仍在main下:\n\n```java\n(main)$ git branch my-branch\n```\n\n把main分支重置到前一个提交:\n\n```java\n(main)$ git reset --hard HEAD^\n```\n\n`HEAD^` 是 `HEAD^1` 的简写，你可以通过指定要设置的`HEAD`来进一步重置。\n\n或者, 如果你不想使用 `HEAD^`, 找到你想重置到的提交(commit)的hash(`git log` 能够完成)， 然后重置到这个hash。使用`git push` 同步内容到远程。\n\n例如, main分支想重置到的提交的hash为`a13b85e`:\n\n```java\n(main)$ git reset --hard a13b85e\nHEAD is now at a13b85e\n```\n\n签出(checkout)刚才新建的分支继续工作:\n\n```java\n(main)$ git checkout my-branch\n```\n\n### 我想保留来自另外一个ref-ish的整个文件 \n\n假设你正在做一个原型方案(原文为working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容:微信搜索公众号：Java后端编程，回复：java 领取资料 。\n\n```java\n(solution)$ git add -A && git commit -m \"Adding all changes from this spike into one big commit.\"\n```\n\n当你想要把它放到一个分支里 (可能是`feature`, 或者 `develop`), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。\n\n假设你有:\n\n *  分支 `solution`, 拥有原型方案， 领先 `develop` 分支。\n *  分支 `develop`, 在这里你应用原型方案的一些内容。\n\n我去可以通过把内容拿到你的分支里，来解决这个问题:\n\n```java\n(develop)$ git checkout solution -- file1.txt\n```\n\n这会把这个文件内容从分支 `solution` 拿到分支 `develop` 里来:\n\n```java\n# On branch develop\n# Your branch is up-to-date with 'origin/develop'.\n# Changes to be committed:\n#  (use \"git reset HEAD <file>...\" to unstage)\n#\n#        modified:   file1.txt\n```\n\n然后, 正常提交。\n\nNote: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem.\n\n### 我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里 \n\n假设你有一个`main`分支， 执行`git log`, 你看到你做过两次提交:\n\n```java\n(main)$ git log\n\ncommit e3851e817c451cc36f2e6f3049db528415e3c114\nAuthor: Alex Lee <alexlee@example.com>\nDate:   Tue Jul 22 15:39:27 2014 -0400\n\n    Bug #21 - Added CSRF protection\n\ncommit 5ea51731d150f7ddc4a365437931cd8be3bf3131\nAuthor: Alex Lee <alexlee@example.com>\nDate:   Tue Jul 22 15:39:12 2014 -0400\n\n    Bug #14 - Fixed spacing on title\n\ncommit a13b85e984171c6e2a1729bb061994525f626d14\nAuthor: Aki Rose <akirose@example.com>\nDate:   Tue Jul 21 01:12:48 2014 -0400\n\n    First commit\n```\n\n让我们用提交hash(commit hash)标记bug (`e3851e8` for \\#21, `5ea5173` for \\#14).\n\n首先, 我们把`main`分支重置到正确的提交(`a13b85e`):\n\n```java\n(main)$ git reset --hard a13b85e\nHEAD is now at a13b85e\n```\n\n现在, 我们对 bug \\#21 创建一个新的分支:\n\n```java\n(main)$ git checkout -b 21\n(21)$\n```\n\n接着, 我们用 cherry-pick 把对bug \\#21的提交放入当前分支。这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在HEAD上面。\n\n```java\n(21)$ git cherry-pick e3851e8\n```\n\n这时候, 这里可能会产生冲突， 参见交互式 rebasing 章 冲突节 解决冲突.\n\n再者， 我们为bug \\#14 创建一个新的分支, 也基于`main`分支\n\n```java\n(21)$ git checkout main\n(main)$ git checkout -b 14\n(14)$\n```\n\n最后, 为 bug \\#14 执行 `cherry-pick`:\n\n```java\n(14)$ git cherry-pick 5ea5173\n```\n\n### 我想删除上游(upstream)分支被删除了的本地分支 \n\n一旦你在github 上面合并(merge)了一个pull request, 你就可以删除你fork里被合并的分支。如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中（[IDEA 中玩转 Git][IDEA _ Git]）。\n\n```java\n$ git fetch -p\n```\n\n### 我不小心删除了我的分支 \n\n如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。让我们先创建一个分支和一个新的文件:\n\n```java\n(main)$ git checkout -b my-branch\n(my-branch)$ git branch\n(my-branch)$ touch foo.txt\n(my-branch)$ ls\nREADME.md foo.txt\n```\n\n添加文件并做一次提交\n\n```java\n(my-branch)$ git add .\n(my-branch)$ git commit -m 'foo.txt added'\n(my-branch)$ foo.txt added\n 1 files changed, 1 insertions(+)\n create mode 100644 foo.txt\n(my-branch)$ git log\n\ncommit 4e3cd85a670ced7cc17a2b5d8d3d809ac88d5012\nAuthor: siemiatj <siemiatj@example.com>\nDate:   Wed Jul 30 00:34:10 2014 +0200\n\n    foo.txt added\n\ncommit 69204cdf0acbab201619d95ad8295928e7f411d5\nAuthor: Kate Hudson <katehudson@example.com>\nDate:   Tue Jul 29 13:14:46 2014 -0400\n\n    Fixes #6: Force pushing after amending commits\n```\n\n现在我们切回到主(main)分支，‘不小心的’删除`my-branch`分支\n\n```java\n(my-branch)$ git checkout main\nSwitched to branch 'main'\nYour branch is up-to-date with 'origin/main'.\n(main)$ git branch -D my-branch\nDeleted branch my-branch (was 4e3cd85).\n(main)$ echo oh noes, deleted my branch!\noh noes, deleted my branch!\n```\n\n在这时候你应该想起了`reflog`, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。\n\n```java\n(main)$ git reflog\n69204cd HEAD@{0}: checkout: moving from my-branch to main\n4e3cd85 HEAD@{1}: commit: foo.txt added\n69204cd HEAD@{2}: checkout: moving from main to my-branch\n```\n\n正如你所见，我们有一个来自删除分支的提交hash(commit hash)，接下来看看是否能恢复删除了的分支。\n\n```java\n(main)$ git checkout -b my-branch-help\nSwitched to a new branch 'my-branch-help'\n(my-branch-help)$ git reset --hard 4e3cd85\nHEAD is now at 4e3cd85 foo.txt added\n(my-branch-help)$ ls\nREADME.md foo.txt\n```\n\n看! 我们把删除的文件找回来了。Git的 `reflog` 在rebasing出错的时候也是同样有用的。\n\n### 我想删除一个分支 \n\n删除一个远程分支:\n\n```java\n(main)$ git push origin --delete my-branch\n```\n\n你也可以:\n\n```java\n(main)$ git push origin :my-branch\n```\n\n删除一个本地分支:\n\n```java\n(main)$ git branch -D my-branch\n```\n\n### 我想从别人正在工作的远程分支签出(checkout)一个分支 \n\n首先, 从远程拉取(fetch) 所有分支:\n\n```java\n(main)$ git fetch --all\n```\n\n假设你想要从远程的`daves`分支签出到本地的`daves`\n\n```java\n(main)$ git checkout --track origin/daves\nBranch daves set up to track remote branch daves from origin.\nSwitched to a new branch 'daves'\n```\n\n(`--track` 是 `git checkout -b [branch] [remotename]/[branch]` 的简写)\n\n这样就得到了一个`daves`分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到.\n\n## Rebasing 和合并(Merging) \n\n### 我想撤销rebase/merge \n\n你可以合并(merge)或rebase了一个错误的分支, 或者完成不了一个进行中的rebase/merge。Git 在进行危险操作的时候会把原始的HEAD保存在一个叫ORIG\\_HEAD的变量里, 所以要把分支恢复到rebase/merge前的状态是很容易的。\n\n```java\n(my-branch)$ git reset --hard ORIG_HEAD\n```\n\n### 我已经rebase过, 但是我不想强推(force push) \n\n不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。是因你快进(Fast forward)了提交，改变了Git历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做:\n\n```java\n(main)$ git checkout my-branch\n(my-branch)$ git rebase -i main\n(my-branch)$ git checkout main\n(main)$ git merge --ff-only my-branch\n```\n\n### 我需要组合(combine)几个提交(commit) \n\n假设你的工作分支将会做对于 `main` 的pull-request。一般情况下你不关心提交(commit)的时间戳，只想组合 所有 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。确保主(main)分支是最新的和你的变化都已经提交了, 然后:\n\n```java\n(my-branch)$ git reset --soft main\n(my-branch)$ git commit -am \"New awesome feature\"\n```\n\n如果你想要更多的控制, 想要保留时间戳, 你需要做交互式rebase (interactive rebase):\n\n```java\n(my-branch)$ git rebase -i main\n```\n\n如果没有相对的其它分支， 你将不得不相对自己的`HEAD` 进行 rebase。例如：你想组合最近的两次提交(commit), 你将相对于`HEAD~2` 进行rebase， 组合最近3次提交(commit), 相对于`HEAD~3`, 等等。\n\n```java\n(main)$ git rebase -i HEAD~2\n```\n\n在你执行了交互式 rebase的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容:\n\n```java\npick a9c8a1d Some refactoring\npick 01b2fd8 New awesome feature\npick b729ad5 fixup\npick e3851e8 another fix\n\n# Rebase 8074d12..b729ad5 onto 8074d12\n#\n# Commands:\n#  p, pick = use commit\n#  r, reword = use commit, but edit the commit message\n#  e, edit = use commit, but stop for amending\n#  s, squash = use commit, but meld into previous commit\n#  f, fixup = like \"squash\", but discard this commit's log message\n#  x, exec = run command (the rest of the line) using shell\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n```\n\n所有以 `#` 开头的行都是注释, 不会影响 rebase.\n\n然后，你可以用任何上面命令列表的命令替换 `pick`, 你也可以通过删除对应的行来删除一个提交(commit)。\n\n例如, 如果你想 单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 `f`:\n\n```java\npick a9c8a1d Some refactoring\npick 01b2fd8 New awesome feature\nf b729ad5 fixup\nf e3851e8 another fix\n```\n\n如果你想组合这些提交(commit) 并重命名这个提交(commit), 你应该在第二个提交(commit)旁边添加一个`r`，或者更简单的用`s` 替代 `f`:\n\n```java\npick a9c8a1d Some refactoring\npick 01b2fd8 New awesome feature\ns b729ad5 fixup\ns e3851e8 another fix\n```\n\n你可以在接下来弹出的文本提示框里重命名提交(commit)。\n\n```java\nNewer, awesomer features\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n# rebase in progress; onto 8074d12\n# You are currently editing a commit while rebasing branch 'main' on '8074d12'.\n#\n# Changes to be committed:\n#\tmodified:   README.md\n#\n```\n\n如果成功了, 你应该看到类似下面的内容:\n\n```java\n(main)$ Successfully rebased and updated refs/heads/main.\n```\n\n#### 安全合并(merging)策略 \n\n`--no-commit` 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。`no-ff` 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致（更多Git资料，参见[IDEA 中如何完成 Git 版本回退？][IDEA _ Git 1]）。\n\n```java\n(main)$ git merge --no-ff --no-commit my-branch\n```\n\n#### 我需要将一个分支合并成一个提交(commit) \n\n```java\n(main)$ git merge --squash my-branch\n```\n\n#### 我只想组合(combine)未推的提交(unpushed commit) \n\n有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。\n\n```java\n(main)$ git rebase -i @{u}\n```\n\n这会产生一次交互式的rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行reorder/fix/squash 都是安全的。\n\n### 检查是否分支上的所有提交(commit)都合并(merge)过了 \n\n检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的head(或任何 commits)之间做一次diff:\n\n```java\n(main)$ git log --graph --left-right --cherry-pick --oneline HEAD...feature/120-on-scroll\n```\n\n这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。另一个做法可以是:\n\n```java\n(main)$ git log main ^feature/120-on-scroll --no-merges\n```\n\n### 交互式rebase(interactive rebase)可能出现的问题 \n\n#### 这个rebase 编辑屏幕出现'noop' \n\n如果你看到的是这样:\n\n```java\nnoop\n```\n\n这意味着你rebase的分支和当前分支在同一个提交(commit)上, 或者 领先(ahead) 当前分支。你可以尝试:\n\n *  检查确保主(main)分支没有问题\n *  rebase `HEAD~2` 或者更早\n\n#### 有冲突的情况 \n\n如果你不能成功的完成rebase, 你可能必须要解决冲突。\n\n首先执行 `git status` 找出哪些文件有冲突:\n\n```java\n(my-branch)$ git status\nOn branch my-branch\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n modified:   README.md\n```\n\n在这个例子里面, `README.md` 有冲突。打开这个文件找到类似下面的内容:\n\n```java\n<<<<<<< HEAD\n   some code\n   =========\n   some code\n   >>>>>>> new-commit\n```\n\n你需要解决新提交的代码(示例里, 从中间`==`线到`new-commit`的地方)与`HEAD` 之间不一样的地方.\n\n有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor):\n\n```java\n(main*)$ git mergetool -t opendiff\n```\n\n在你解决完所有冲突和测试过后, `git add` 变化了的(changed)文件, 然后用`git rebase --continue` 继续rebase。\n\n```java\n(my-branch)$ git add README.md\n(my-branch)$ git rebase --continue\n```\n\n如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行`git rebase --skip`。\n\n任何时候你想结束整个rebase 过程，回来rebase前的分支状态, 你可以做:\n\n```java\n(my-branch)$ git rebase --abort\n```\n\n## Stash \n\n### 暂存所有改动 \n\n暂存你工作目录下的所有改动\n\n```java\n$ git stash\n```\n\n你可以使用`-u`来排除一些文件\n\n```java\n$ git stash -u\n```\n\n### 暂存指定文件 \n\n假设你只想暂存某一个文件\n\n```java\n$ git stash push working-directory-path/filename.ext\n```\n\n假设你想暂存多个文件\n\n```java\n$ git stash push working-directory-path/filename1.ext working-directory-path/filename2.ext\n```\n\n### 暂存时记录消息 \n\n这样你可以在`list`时看到它\n\n```java\n$ git stash save <message>\n```\n\n或\n\n```java\n$ git stash push -m <message>\n```\n\n### 使用某个指定暂存 \n\n首先你可以查看你的`stash`记录\n\n```java\n$ git stash list\n```\n\n然后你可以`apply`某个`stash`\n\n```java\n$ git stash apply \"stash@{n}\"\n```\n\n此处， 'n'是`stash`在栈中的位置，最上层的`stash`会是0\n\n除此之外，也可以使用时间标记(假如你能记得的话)。\n\n```java\n$ git stash apply \"stash@{2.hours.ago}\"\n```\n\n### 暂存时保留未暂存的内容 \n\n你需要手动create一个`stash commit`， 然后使用`git stash store`。\n\n```java\n$ git stash create\n$ git stash store -m \"commit-message\" CREATED_SHA1\n```\n\n## 杂项(Miscellaneous Objects) \n\n### 克隆所有子模块 \n\n```java\n$ git clone --recursive git://github.com/foo/bar.git\n```\n\n如果已经克隆了:\n\n```java\n$ git submodule update --init --recursive\n```\n\n### 删除标签(tag) \n\n```java\n$ git tag -d <tag_name>\n$ git push <remote> :refs/tags/<tag_name>\n```\n\n### 恢复已删除标签(tag) \n\n如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag):\n\n```java\n$ git fsck --unreachable | grep tag\n```\n\n记下这个标签(tag)的hash，然后用Git的 update-ref\n\n```java\n$ git update-ref refs/tags/<tag_name> <hash>\n```\n\n这时你的标签(tag)应该已经恢复了。\n\n### 已删除补丁(patch) \n\n如果某人在 GitHub 上给你发了一个pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 `git am`。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。\n\n做完提交后, 再修改作者，参见变更作者。然后, 应用变化, 再发起一个新的pull request。\n\n## 跟踪文件(Tracking Files) \n\n### 我只想改变一个文件名字的大小写，而不修改内容 \n\n```java\n(main)$ git mv --force myfile MyFile\n```\n\n### 我想从Git删除一个文件，但保留该文件 \n\n```java\n(main)$ git rm --cached log.txt\n```\n\n## 配置(Configuration) \n\n### 我想给一些Git命令添加别名(alias) \n\n在 OS X 和 Linux 下, 你的 Git的配置文件储存在 `~/.gitconfig`。我在`[alias]` 部分添加了一些快捷别名(和一些我容易拼写错误的)，如下:\n\n```java\n[alias]\n    a = add\n    amend = commit --amend\n    c = commit\n    ca = commit --amend\n    ci = commit -a\n    co = checkout\n    d = diff\n    dc = diff --changed\n    ds = diff --staged\n    f = fetch\n    loll = log --graph --decorate --pretty=oneline --abbrev-commit\n    m = merge\n    one = log --pretty=oneline\n    outstanding = rebase -i @{u}\n    s = status\n    unpushed = log @{u}\n    wc = whatchanged\n    wip = rebase -i @{u}\n    zap = fetch -p\n```\n\n### 我想缓存一个仓库(repository)的用户名和密码 \n\n你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推/拉(push/pull)的时候都输入，Credential helper能帮你。\n\n```java\n$ git config --global credential.helper cache\n# Set git to use the credential memory cache\n```\n\n```java\n$ git config --global credential.helper 'cache --timeout=3600'\n# Set the cache to timeout after 1 hour (setting is in seconds)\n```\n\n### 我不知道我做错了些什么 \n\n你把事情搞砸了：你 `重置(reset)` 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。\n\n这就是 `git reflog` 的目的， `reflog` 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次HEAD的改变, 一条新的记录就会增加到`reflog`。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。\n\n```java\n(main)$ git reflog\n0a2e358 HEAD@{0}: reset: moving to HEAD~2\n0254ea7 HEAD@{1}: checkout: moving from 2.2 to main\nc10f740 HEAD@{2}: checkout: moving from main to 2.2\n```\n\n上面的reflog展示了从main分支签出(checkout)到2.2 分支，然后再签回。那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 `HEAD@{0}`标识.\n\n如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前main上指向的提交(0254ea7)。\n\n```java\n$ git reset --hard 0254ea7\n```\n\n然后使用git reset就可以把main改回到之前的commit，这提供了一个在历史被意外更改情况下的安全网。","source":"_posts/45个日常用git合代码的经典操作场景.md","raw":"---\ntitle: 45个日常用git合代码的经典操作场景\ntop: false\ncover: false\ntoc: false\nmathjax: true\ndate: 2022-11-04 10:49:16\npassword:\nsummary: 整理了45个日常用git操作\ntags:\n    - git\n    - 代码合并\ncategories:\n    - git\n---\n  \n\n\ngit对于大家应该都不太陌生，熟练使用git已经成为程序员的一项基本技能，尽管在工作中有诸如 `Sourcetree`这样牛X的客户端工具，使得合并代码变的很方便。但找工作面试和一些需彰显个人实力的场景，仍然需要我们掌握足够多的git命令。  \n\n\n下边我们整理了45个日常用git合代码的经典操作场景，基本覆盖了工作中的需求。  \n\n\n### 我刚才提交了什么? \n\n如果你用 `git commit -a` 提交了一次变化(changes)，而你又不确定到底这次提交了哪些内容。你就可以用下面的命令显示当前`HEAD`上的最近一次的提交(commit):\n\n```java\n(main)$ git show\n```\n\n或者\n\n```java\n$ git log -n1 -p\n```\n\n### 我的提交信息(commit message)写错了 \n\n如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message):\n\n```java\n$ git commit --amend --only\n```\n\n这会打开你的默认编辑器, 在这里你可以编辑信息. 另一方面, 你也可以用一条命令一次完成:\n\n```java\n$ git commit --amend --only -m 'xxxxxxx'\n```\n\n如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做。\n\n### 我提交(commit)里的用户名和邮箱不对 \n\n如果这只是单个提交(commit)，修改它：\n\n```java\n$ git commit --amend --author \"New Authorname <authoremail@mydomain.com>\"\n```\n\n如果你需要修改所有历史, 参考 'git filter-branch'的指南页.\n\n### 我想从一个提交(commit)里移除一个文件 \n\n通过下面的方法，从一个提交(commit)里移除一个文件:\n\n```java\n$ git checkout HEAD^ myfile\n$ git add -A\n$ git commit --amend\n```\n\n这将非常有用，当你有一个开放的补丁(open patch)，你往上面提交了一个不必要的文件，你需要强推(force push)去更新这个远程补丁。\n\n### 我想删除我的的最后一次提交(commit) \n\n如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。\n\n```java\n$ git reset HEAD^ --hard\n$ git push -f [remote] [branch]\n```\n\n如果你还没有推到远程, 把Git重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化):\n\n```java\n(my-branch*)$ git reset --soft HEAD@{1}\n```\n\n这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 `git revert SHAofBadCommit`， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)；或者, 如果你推的这个分支是rebase-safe的 (例如：其它开发者不会从这个分支拉), 只需要使用 `git push -f`。\n\n### 删除任意提交(commit) \n\n同样的警告：不到万不得已的时候不要这么做.\n\n```java\n$ git rebase --onto SHA1_OF_BAD_COMMIT^ SHA1_OF_BAD_COMMIT\n$ git push -f [remote] [branch]\n```\n\n或者做一个 交互式rebase 删除那些你想要删除的提交(commit)里所对应的行。\n\n### 我尝试推一个修正后的提交(amended commit)到远程，但是报错： \n\n```java\nTo https://github.com/yourusername/repo.git\n! [rejected]        mybranch -> mybranch (non-fast-forward)\nerror: failed to push some refs to 'https://github.com/tanay1337/webmaker.org.git'\nhint: Updates were rejected because the tip of your current branch is behind\nhint: its remote counterpart. Integrate the remote changes (e.g.\nhint: 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```\n\n注意, rebasing(见下面)和修正(amending)会用一个新的提交(commit)代替旧的, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (`-f`)。注意 – 总是 确保你指明一个分支!\n\n```java\n(my-branch)$ git push origin mybranch -f\n```\n\n一般来说, 要避免强推. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。\n\n### 我意外的做了一次硬重置(hard reset)，我想找回我的内容 \n\n如果你意外的做了 `git reset --hard`, 你通常能找回你的提交(commit), 因为Git对每件事都会有日志，且都会保存几天。\n\n```java\n(main)$ git reflog\n```\n\n你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。选择你想要回到的提交(commit)的SHA，再重置一次:\n\n```java\n(main)$ git reset --hard SHA1234\n```\n\n这样就完成了。\n\n## 暂存(Staging) \n\n### 我需要把暂存的内容添加到上一次的提交(commit) \n\n```java\n(my-branch*)$ git commit --amend\n```\n\n### 我想要暂存一个新文件的一部分，而不是这个文件的全部 \n\n一般来说, 如果你想暂存一个文件的一部分, 你可这样做:\n\n```java\n$ git add --patch filename.x\n```\n\n`-p` 简写。这会打开交互模式， 你将能够用 `s` 选项来分隔提交(commit)；然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时, 这样做:\n\n```java\n$ git add -N filename.x\n```\n\n然后, 你需要用 `e` 选项来手动选择需要添加的行，执行 `git diff --cached` 将会显示哪些行暂存了哪些行只是保存在本地了。\n\n### 我想把在一个文件里的变化(changes)加到两个提交(commit)里 \n\n`git add` 会把整个文件加入到一个提交. `git add -p` 允许交互式的选择你想要提交的部分.\n\n### 我想把暂存的内容变成未暂存，把未暂存的内容暂存起来 \n\n多数情况下，你应该将所有的内容变为未暂存，然后再选择你想要的内容进行commit。但假定你就是想要这么做，这里你可以创建一个临时的commit来保存你已暂存的内容，然后暂存你的未暂存的内容并进行stash。然后reset最后一个commit将原本暂存的内容变为未暂存，最后stash pop回来。\n\n```java\n$ git commit -m \"WIP\"\n$ git add .\n$ git stash\n$ git reset HEAD^\n$ git stash pop --index 0\n```\n\n注意1: 这里使用`pop`仅仅是因为想尽可能保持幂等。注意2: 假如你不加上`--index`你会把暂存的文件标记为为存储。\n\n## 未暂存(Unstaged)的内容 \n\n### 我想把未暂存的内容移动到一个新分支 \n\n```java\n$ git checkout -b my-branch\n```\n\n### 我想把未暂存的内容移动到另一个已存在的分支 \n\n```java\n$ git stash\n$ git checkout my-branch\n$ git stash pop\n```\n\n### 我想丢弃本地未提交的变化(uncommitted changes) \n\n如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以：\n\n```java\n# one commit\n(my-branch)$ git reset --hard HEAD^\n# two commits\n(my-branch)$ git reset --hard HEAD^^\n# four commits\n(my-branch)$ git reset --hard HEAD~4\n# or\n(main)$ git checkout -f\n```\n\n重置某个特殊的文件, 你可以用文件名做为参数:\n\n```java\n$ git reset filename\n```\n\n### 我想丢弃某些未暂存的内容 \n\n如果你想丢弃工作拷贝中的一部分内容，而不是全部。\n\n签出(checkout)不需要的内容，保留需要的。\n\n```java\n$ git checkout -p\n# Answer y to all of the snippets you want to drop\n```\n\n另外一个方法是使用 `stash`， Stash所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。\n\n```java\n$ git stash -p\n# Select all of the snippets you want to save\n$ git reset --hard\n$ git stash pop\n```\n\n或者, stash 你不需要的部分, 然后stash drop。\n\n```java\n$ git stash -p\n# Select all of the snippets you don't want to save\n$ git stash drop\n```\n\n## 分支(Branches) \n\n### 我从错误的分支拉取了内容，或把内容拉取到了错误的分支 \n\n这是另外一种使用 `git reflog` 情况，找到在这次错误拉(pull) 之前HEAD的指向。\n\n```java\n(main)$ git reflog\nab7555f HEAD@{0}: pull origin wrong-branch: Fast-forward\nc5bc55a HEAD@{1}: checkout: checkout message goes here\n```\n\n重置分支到你所需的提交(desired commit):\n\n```java\n$ git reset --hard c5bc55a\n```\n\n完成。\n\n### 我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致 \n\n先确认你没有推(push)你的内容到远程。\n\n`git status` 会显示你领先(ahead)源(origin)多少个提交:\n\n```java\n(my-branch)$ git status\n# On branch my-branch\n# Your branch is ahead of 'origin/my-branch' by 2 commits.\n#   (use \"git push\" to publish your local commits)\n#\n```\n\n一种方法是:\n\n```java\n(main)$ git reset --hard origin/my-branch\n```\n\n### 我需要提交到一个新分支，但错误的提交到了main \n\n在main下创建一个新分支，不切换到新分支,仍在main下:\n\n```java\n(main)$ git branch my-branch\n```\n\n把main分支重置到前一个提交:\n\n```java\n(main)$ git reset --hard HEAD^\n```\n\n`HEAD^` 是 `HEAD^1` 的简写，你可以通过指定要设置的`HEAD`来进一步重置。\n\n或者, 如果你不想使用 `HEAD^`, 找到你想重置到的提交(commit)的hash(`git log` 能够完成)， 然后重置到这个hash。使用`git push` 同步内容到远程。\n\n例如, main分支想重置到的提交的hash为`a13b85e`:\n\n```java\n(main)$ git reset --hard a13b85e\nHEAD is now at a13b85e\n```\n\n签出(checkout)刚才新建的分支继续工作:\n\n```java\n(main)$ git checkout my-branch\n```\n\n### 我想保留来自另外一个ref-ish的整个文件 \n\n假设你正在做一个原型方案(原文为working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容:微信搜索公众号：Java后端编程，回复：java 领取资料 。\n\n```java\n(solution)$ git add -A && git commit -m \"Adding all changes from this spike into one big commit.\"\n```\n\n当你想要把它放到一个分支里 (可能是`feature`, 或者 `develop`), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。\n\n假设你有:\n\n *  分支 `solution`, 拥有原型方案， 领先 `develop` 分支。\n *  分支 `develop`, 在这里你应用原型方案的一些内容。\n\n我去可以通过把内容拿到你的分支里，来解决这个问题:\n\n```java\n(develop)$ git checkout solution -- file1.txt\n```\n\n这会把这个文件内容从分支 `solution` 拿到分支 `develop` 里来:\n\n```java\n# On branch develop\n# Your branch is up-to-date with 'origin/develop'.\n# Changes to be committed:\n#  (use \"git reset HEAD <file>...\" to unstage)\n#\n#        modified:   file1.txt\n```\n\n然后, 正常提交。\n\nNote: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem.\n\n### 我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里 \n\n假设你有一个`main`分支， 执行`git log`, 你看到你做过两次提交:\n\n```java\n(main)$ git log\n\ncommit e3851e817c451cc36f2e6f3049db528415e3c114\nAuthor: Alex Lee <alexlee@example.com>\nDate:   Tue Jul 22 15:39:27 2014 -0400\n\n    Bug #21 - Added CSRF protection\n\ncommit 5ea51731d150f7ddc4a365437931cd8be3bf3131\nAuthor: Alex Lee <alexlee@example.com>\nDate:   Tue Jul 22 15:39:12 2014 -0400\n\n    Bug #14 - Fixed spacing on title\n\ncommit a13b85e984171c6e2a1729bb061994525f626d14\nAuthor: Aki Rose <akirose@example.com>\nDate:   Tue Jul 21 01:12:48 2014 -0400\n\n    First commit\n```\n\n让我们用提交hash(commit hash)标记bug (`e3851e8` for \\#21, `5ea5173` for \\#14).\n\n首先, 我们把`main`分支重置到正确的提交(`a13b85e`):\n\n```java\n(main)$ git reset --hard a13b85e\nHEAD is now at a13b85e\n```\n\n现在, 我们对 bug \\#21 创建一个新的分支:\n\n```java\n(main)$ git checkout -b 21\n(21)$\n```\n\n接着, 我们用 cherry-pick 把对bug \\#21的提交放入当前分支。这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在HEAD上面。\n\n```java\n(21)$ git cherry-pick e3851e8\n```\n\n这时候, 这里可能会产生冲突， 参见交互式 rebasing 章 冲突节 解决冲突.\n\n再者， 我们为bug \\#14 创建一个新的分支, 也基于`main`分支\n\n```java\n(21)$ git checkout main\n(main)$ git checkout -b 14\n(14)$\n```\n\n最后, 为 bug \\#14 执行 `cherry-pick`:\n\n```java\n(14)$ git cherry-pick 5ea5173\n```\n\n### 我想删除上游(upstream)分支被删除了的本地分支 \n\n一旦你在github 上面合并(merge)了一个pull request, 你就可以删除你fork里被合并的分支。如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中（[IDEA 中玩转 Git][IDEA _ Git]）。\n\n```java\n$ git fetch -p\n```\n\n### 我不小心删除了我的分支 \n\n如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。让我们先创建一个分支和一个新的文件:\n\n```java\n(main)$ git checkout -b my-branch\n(my-branch)$ git branch\n(my-branch)$ touch foo.txt\n(my-branch)$ ls\nREADME.md foo.txt\n```\n\n添加文件并做一次提交\n\n```java\n(my-branch)$ git add .\n(my-branch)$ git commit -m 'foo.txt added'\n(my-branch)$ foo.txt added\n 1 files changed, 1 insertions(+)\n create mode 100644 foo.txt\n(my-branch)$ git log\n\ncommit 4e3cd85a670ced7cc17a2b5d8d3d809ac88d5012\nAuthor: siemiatj <siemiatj@example.com>\nDate:   Wed Jul 30 00:34:10 2014 +0200\n\n    foo.txt added\n\ncommit 69204cdf0acbab201619d95ad8295928e7f411d5\nAuthor: Kate Hudson <katehudson@example.com>\nDate:   Tue Jul 29 13:14:46 2014 -0400\n\n    Fixes #6: Force pushing after amending commits\n```\n\n现在我们切回到主(main)分支，‘不小心的’删除`my-branch`分支\n\n```java\n(my-branch)$ git checkout main\nSwitched to branch 'main'\nYour branch is up-to-date with 'origin/main'.\n(main)$ git branch -D my-branch\nDeleted branch my-branch (was 4e3cd85).\n(main)$ echo oh noes, deleted my branch!\noh noes, deleted my branch!\n```\n\n在这时候你应该想起了`reflog`, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。\n\n```java\n(main)$ git reflog\n69204cd HEAD@{0}: checkout: moving from my-branch to main\n4e3cd85 HEAD@{1}: commit: foo.txt added\n69204cd HEAD@{2}: checkout: moving from main to my-branch\n```\n\n正如你所见，我们有一个来自删除分支的提交hash(commit hash)，接下来看看是否能恢复删除了的分支。\n\n```java\n(main)$ git checkout -b my-branch-help\nSwitched to a new branch 'my-branch-help'\n(my-branch-help)$ git reset --hard 4e3cd85\nHEAD is now at 4e3cd85 foo.txt added\n(my-branch-help)$ ls\nREADME.md foo.txt\n```\n\n看! 我们把删除的文件找回来了。Git的 `reflog` 在rebasing出错的时候也是同样有用的。\n\n### 我想删除一个分支 \n\n删除一个远程分支:\n\n```java\n(main)$ git push origin --delete my-branch\n```\n\n你也可以:\n\n```java\n(main)$ git push origin :my-branch\n```\n\n删除一个本地分支:\n\n```java\n(main)$ git branch -D my-branch\n```\n\n### 我想从别人正在工作的远程分支签出(checkout)一个分支 \n\n首先, 从远程拉取(fetch) 所有分支:\n\n```java\n(main)$ git fetch --all\n```\n\n假设你想要从远程的`daves`分支签出到本地的`daves`\n\n```java\n(main)$ git checkout --track origin/daves\nBranch daves set up to track remote branch daves from origin.\nSwitched to a new branch 'daves'\n```\n\n(`--track` 是 `git checkout -b [branch] [remotename]/[branch]` 的简写)\n\n这样就得到了一个`daves`分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到.\n\n## Rebasing 和合并(Merging) \n\n### 我想撤销rebase/merge \n\n你可以合并(merge)或rebase了一个错误的分支, 或者完成不了一个进行中的rebase/merge。Git 在进行危险操作的时候会把原始的HEAD保存在一个叫ORIG\\_HEAD的变量里, 所以要把分支恢复到rebase/merge前的状态是很容易的。\n\n```java\n(my-branch)$ git reset --hard ORIG_HEAD\n```\n\n### 我已经rebase过, 但是我不想强推(force push) \n\n不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。是因你快进(Fast forward)了提交，改变了Git历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做:\n\n```java\n(main)$ git checkout my-branch\n(my-branch)$ git rebase -i main\n(my-branch)$ git checkout main\n(main)$ git merge --ff-only my-branch\n```\n\n### 我需要组合(combine)几个提交(commit) \n\n假设你的工作分支将会做对于 `main` 的pull-request。一般情况下你不关心提交(commit)的时间戳，只想组合 所有 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。确保主(main)分支是最新的和你的变化都已经提交了, 然后:\n\n```java\n(my-branch)$ git reset --soft main\n(my-branch)$ git commit -am \"New awesome feature\"\n```\n\n如果你想要更多的控制, 想要保留时间戳, 你需要做交互式rebase (interactive rebase):\n\n```java\n(my-branch)$ git rebase -i main\n```\n\n如果没有相对的其它分支， 你将不得不相对自己的`HEAD` 进行 rebase。例如：你想组合最近的两次提交(commit), 你将相对于`HEAD~2` 进行rebase， 组合最近3次提交(commit), 相对于`HEAD~3`, 等等。\n\n```java\n(main)$ git rebase -i HEAD~2\n```\n\n在你执行了交互式 rebase的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容:\n\n```java\npick a9c8a1d Some refactoring\npick 01b2fd8 New awesome feature\npick b729ad5 fixup\npick e3851e8 another fix\n\n# Rebase 8074d12..b729ad5 onto 8074d12\n#\n# Commands:\n#  p, pick = use commit\n#  r, reword = use commit, but edit the commit message\n#  e, edit = use commit, but stop for amending\n#  s, squash = use commit, but meld into previous commit\n#  f, fixup = like \"squash\", but discard this commit's log message\n#  x, exec = run command (the rest of the line) using shell\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n```\n\n所有以 `#` 开头的行都是注释, 不会影响 rebase.\n\n然后，你可以用任何上面命令列表的命令替换 `pick`, 你也可以通过删除对应的行来删除一个提交(commit)。\n\n例如, 如果你想 单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 `f`:\n\n```java\npick a9c8a1d Some refactoring\npick 01b2fd8 New awesome feature\nf b729ad5 fixup\nf e3851e8 another fix\n```\n\n如果你想组合这些提交(commit) 并重命名这个提交(commit), 你应该在第二个提交(commit)旁边添加一个`r`，或者更简单的用`s` 替代 `f`:\n\n```java\npick a9c8a1d Some refactoring\npick 01b2fd8 New awesome feature\ns b729ad5 fixup\ns e3851e8 another fix\n```\n\n你可以在接下来弹出的文本提示框里重命名提交(commit)。\n\n```java\nNewer, awesomer features\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n# rebase in progress; onto 8074d12\n# You are currently editing a commit while rebasing branch 'main' on '8074d12'.\n#\n# Changes to be committed:\n#\tmodified:   README.md\n#\n```\n\n如果成功了, 你应该看到类似下面的内容:\n\n```java\n(main)$ Successfully rebased and updated refs/heads/main.\n```\n\n#### 安全合并(merging)策略 \n\n`--no-commit` 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。`no-ff` 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致（更多Git资料，参见[IDEA 中如何完成 Git 版本回退？][IDEA _ Git 1]）。\n\n```java\n(main)$ git merge --no-ff --no-commit my-branch\n```\n\n#### 我需要将一个分支合并成一个提交(commit) \n\n```java\n(main)$ git merge --squash my-branch\n```\n\n#### 我只想组合(combine)未推的提交(unpushed commit) \n\n有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。\n\n```java\n(main)$ git rebase -i @{u}\n```\n\n这会产生一次交互式的rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行reorder/fix/squash 都是安全的。\n\n### 检查是否分支上的所有提交(commit)都合并(merge)过了 \n\n检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的head(或任何 commits)之间做一次diff:\n\n```java\n(main)$ git log --graph --left-right --cherry-pick --oneline HEAD...feature/120-on-scroll\n```\n\n这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。另一个做法可以是:\n\n```java\n(main)$ git log main ^feature/120-on-scroll --no-merges\n```\n\n### 交互式rebase(interactive rebase)可能出现的问题 \n\n#### 这个rebase 编辑屏幕出现'noop' \n\n如果你看到的是这样:\n\n```java\nnoop\n```\n\n这意味着你rebase的分支和当前分支在同一个提交(commit)上, 或者 领先(ahead) 当前分支。你可以尝试:\n\n *  检查确保主(main)分支没有问题\n *  rebase `HEAD~2` 或者更早\n\n#### 有冲突的情况 \n\n如果你不能成功的完成rebase, 你可能必须要解决冲突。\n\n首先执行 `git status` 找出哪些文件有冲突:\n\n```java\n(my-branch)$ git status\nOn branch my-branch\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n modified:   README.md\n```\n\n在这个例子里面, `README.md` 有冲突。打开这个文件找到类似下面的内容:\n\n```java\n<<<<<<< HEAD\n   some code\n   =========\n   some code\n   >>>>>>> new-commit\n```\n\n你需要解决新提交的代码(示例里, 从中间`==`线到`new-commit`的地方)与`HEAD` 之间不一样的地方.\n\n有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor):\n\n```java\n(main*)$ git mergetool -t opendiff\n```\n\n在你解决完所有冲突和测试过后, `git add` 变化了的(changed)文件, 然后用`git rebase --continue` 继续rebase。\n\n```java\n(my-branch)$ git add README.md\n(my-branch)$ git rebase --continue\n```\n\n如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行`git rebase --skip`。\n\n任何时候你想结束整个rebase 过程，回来rebase前的分支状态, 你可以做:\n\n```java\n(my-branch)$ git rebase --abort\n```\n\n## Stash \n\n### 暂存所有改动 \n\n暂存你工作目录下的所有改动\n\n```java\n$ git stash\n```\n\n你可以使用`-u`来排除一些文件\n\n```java\n$ git stash -u\n```\n\n### 暂存指定文件 \n\n假设你只想暂存某一个文件\n\n```java\n$ git stash push working-directory-path/filename.ext\n```\n\n假设你想暂存多个文件\n\n```java\n$ git stash push working-directory-path/filename1.ext working-directory-path/filename2.ext\n```\n\n### 暂存时记录消息 \n\n这样你可以在`list`时看到它\n\n```java\n$ git stash save <message>\n```\n\n或\n\n```java\n$ git stash push -m <message>\n```\n\n### 使用某个指定暂存 \n\n首先你可以查看你的`stash`记录\n\n```java\n$ git stash list\n```\n\n然后你可以`apply`某个`stash`\n\n```java\n$ git stash apply \"stash@{n}\"\n```\n\n此处， 'n'是`stash`在栈中的位置，最上层的`stash`会是0\n\n除此之外，也可以使用时间标记(假如你能记得的话)。\n\n```java\n$ git stash apply \"stash@{2.hours.ago}\"\n```\n\n### 暂存时保留未暂存的内容 \n\n你需要手动create一个`stash commit`， 然后使用`git stash store`。\n\n```java\n$ git stash create\n$ git stash store -m \"commit-message\" CREATED_SHA1\n```\n\n## 杂项(Miscellaneous Objects) \n\n### 克隆所有子模块 \n\n```java\n$ git clone --recursive git://github.com/foo/bar.git\n```\n\n如果已经克隆了:\n\n```java\n$ git submodule update --init --recursive\n```\n\n### 删除标签(tag) \n\n```java\n$ git tag -d <tag_name>\n$ git push <remote> :refs/tags/<tag_name>\n```\n\n### 恢复已删除标签(tag) \n\n如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag):\n\n```java\n$ git fsck --unreachable | grep tag\n```\n\n记下这个标签(tag)的hash，然后用Git的 update-ref\n\n```java\n$ git update-ref refs/tags/<tag_name> <hash>\n```\n\n这时你的标签(tag)应该已经恢复了。\n\n### 已删除补丁(patch) \n\n如果某人在 GitHub 上给你发了一个pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 `git am`。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。\n\n做完提交后, 再修改作者，参见变更作者。然后, 应用变化, 再发起一个新的pull request。\n\n## 跟踪文件(Tracking Files) \n\n### 我只想改变一个文件名字的大小写，而不修改内容 \n\n```java\n(main)$ git mv --force myfile MyFile\n```\n\n### 我想从Git删除一个文件，但保留该文件 \n\n```java\n(main)$ git rm --cached log.txt\n```\n\n## 配置(Configuration) \n\n### 我想给一些Git命令添加别名(alias) \n\n在 OS X 和 Linux 下, 你的 Git的配置文件储存在 `~/.gitconfig`。我在`[alias]` 部分添加了一些快捷别名(和一些我容易拼写错误的)，如下:\n\n```java\n[alias]\n    a = add\n    amend = commit --amend\n    c = commit\n    ca = commit --amend\n    ci = commit -a\n    co = checkout\n    d = diff\n    dc = diff --changed\n    ds = diff --staged\n    f = fetch\n    loll = log --graph --decorate --pretty=oneline --abbrev-commit\n    m = merge\n    one = log --pretty=oneline\n    outstanding = rebase -i @{u}\n    s = status\n    unpushed = log @{u}\n    wc = whatchanged\n    wip = rebase -i @{u}\n    zap = fetch -p\n```\n\n### 我想缓存一个仓库(repository)的用户名和密码 \n\n你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推/拉(push/pull)的时候都输入，Credential helper能帮你。\n\n```java\n$ git config --global credential.helper cache\n# Set git to use the credential memory cache\n```\n\n```java\n$ git config --global credential.helper 'cache --timeout=3600'\n# Set the cache to timeout after 1 hour (setting is in seconds)\n```\n\n### 我不知道我做错了些什么 \n\n你把事情搞砸了：你 `重置(reset)` 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。\n\n这就是 `git reflog` 的目的， `reflog` 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次HEAD的改变, 一条新的记录就会增加到`reflog`。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。\n\n```java\n(main)$ git reflog\n0a2e358 HEAD@{0}: reset: moving to HEAD~2\n0254ea7 HEAD@{1}: checkout: moving from 2.2 to main\nc10f740 HEAD@{2}: checkout: moving from main to 2.2\n```\n\n上面的reflog展示了从main分支签出(checkout)到2.2 分支，然后再签回。那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 `HEAD@{0}`标识.\n\n如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前main上指向的提交(0254ea7)。\n\n```java\n$ git reset --hard 0254ea7\n```\n\n然后使用git reset就可以把main改回到之前的commit，这提供了一个在历史被意外更改情况下的安全网。","slug":"45个日常用git合代码的经典操作场景","published":1,"updated":"2022-11-04T09:19:39.054Z","_id":"cla1wfs1m0000hzld2zuj5k6i","comments":1,"layout":"post","photos":[],"link":"","content":"<p>git对于大家应该都不太陌生，熟练使用git已经成为程序员的一项基本技能，尽管在工作中有诸如 <code>Sourcetree</code>这样牛X的客户端工具，使得合并代码变的很方便。但找工作面试和一些需彰显个人实力的场景，仍然需要我们掌握足够多的git命令。  </p>\n<p>下边我们整理了45个日常用git合代码的经典操作场景，基本覆盖了工作中的需求。  </p>\n<h3 id=\"我刚才提交了什么\"><a href=\"#我刚才提交了什么\" class=\"headerlink\" title=\"我刚才提交了什么?\"></a>我刚才提交了什么?</h3><p>如果你用 <code>git commit -a</code> 提交了一次变化(changes)，而你又不确定到底这次提交了哪些内容。你就可以用下面的命令显示当前<code>HEAD</code>上的最近一次的提交(commit):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git show<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>或者</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git log <span class=\"token operator\">-</span>n1 <span class=\"token operator\">-</span>p<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我的提交信息-commit-message-写错了\"><a href=\"#我的提交信息-commit-message-写错了\" class=\"headerlink\" title=\"我的提交信息(commit message)写错了\"></a>我的提交信息(commit message)写错了</h3><p>如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git commit <span class=\"token operator\">--</span>amend <span class=\"token operator\">--</span>only<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这会打开你的默认编辑器, 在这里你可以编辑信息. 另一方面, 你也可以用一条命令一次完成:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git commit <span class=\"token operator\">--</span>amend <span class=\"token operator\">--</span>only <span class=\"token operator\">-</span>m <span class=\"token string\">'xxxxxxx'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做。</p>\n<h3 id=\"我提交-commit-里的用户名和邮箱不对\"><a href=\"#我提交-commit-里的用户名和邮箱不对\" class=\"headerlink\" title=\"我提交(commit)里的用户名和邮箱不对\"></a>我提交(commit)里的用户名和邮箱不对</h3><p>如果这只是单个提交(commit)，修改它：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git commit <span class=\"token operator\">--</span>amend <span class=\"token operator\">--</span>author <span class=\"token string\">\"New Authorname &lt;authoremail@mydomain.com>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果你需要修改所有历史, 参考 ‘git filter-branch’的指南页.</p>\n<h3 id=\"我想从一个提交-commit-里移除一个文件\"><a href=\"#我想从一个提交-commit-里移除一个文件\" class=\"headerlink\" title=\"我想从一个提交(commit)里移除一个文件\"></a>我想从一个提交(commit)里移除一个文件</h3><p>通过下面的方法，从一个提交(commit)里移除一个文件:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git checkout HEAD<span class=\"token operator\">^</span> myfile\n$ git add <span class=\"token operator\">-</span><span class=\"token class-name\">A</span>\n$ git commit <span class=\"token operator\">--</span>amend<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>这将非常有用，当你有一个开放的补丁(open patch)，你往上面提交了一个不必要的文件，你需要强推(force push)去更新这个远程补丁。</p>\n<h3 id=\"我想删除我的的最后一次提交-commit\"><a href=\"#我想删除我的的最后一次提交-commit\" class=\"headerlink\" title=\"我想删除我的的最后一次提交(commit)\"></a>我想删除我的的最后一次提交(commit)</h3><p>如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git reset HEAD<span class=\"token operator\">^</span> <span class=\"token operator\">--</span>hard\n$ git push <span class=\"token operator\">-</span>f <span class=\"token punctuation\">[</span>remote<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>branch<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>如果你还没有推到远程, 把Git重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>soft HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 <code>git revert SHAofBadCommit</code>， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)；或者, 如果你推的这个分支是rebase-safe的 (例如：其它开发者不会从这个分支拉), 只需要使用 <code>git push -f</code>。</p>\n<h3 id=\"删除任意提交-commit\"><a href=\"#删除任意提交-commit\" class=\"headerlink\" title=\"删除任意提交(commit)\"></a>删除任意提交(commit)</h3><p>同样的警告：不到万不得已的时候不要这么做.</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git rebase <span class=\"token operator\">--</span>onto SHA1_OF_BAD_COMMIT<span class=\"token operator\">^</span> SHA1_OF_BAD_COMMIT\n$ git push <span class=\"token operator\">-</span>f <span class=\"token punctuation\">[</span>remote<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>branch<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>或者做一个 交互式rebase 删除那些你想要删除的提交(commit)里所对应的行。</p>\n<h3 id=\"我尝试推一个修正后的提交-amended-commit-到远程，但是报错：\"><a href=\"#我尝试推一个修正后的提交-amended-commit-到远程，但是报错：\" class=\"headerlink\" title=\"我尝试推一个修正后的提交(amended commit)到远程，但是报错：\"></a>我尝试推一个修正后的提交(amended commit)到远程，但是报错：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">To</span> https<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>github<span class=\"token punctuation\">.</span>com<span class=\"token operator\">/</span>yourusername<span class=\"token operator\">/</span>repo<span class=\"token punctuation\">.</span>git\n<span class=\"token operator\">!</span> <span class=\"token punctuation\">[</span>rejected<span class=\"token punctuation\">]</span>        mybranch <span class=\"token operator\">-></span> mybranch <span class=\"token punctuation\">(</span>non<span class=\"token operator\">-</span>fast<span class=\"token operator\">-</span>forward<span class=\"token punctuation\">)</span>\nerror<span class=\"token operator\">:</span> failed <span class=\"token keyword\">to</span> <span class=\"token namespace\">push</span> some refs <span class=\"token keyword\">to</span> <span class=\"token string\">'https://github.com/tanay1337/webmaker.org.git'</span>\nhint<span class=\"token operator\">:</span> <span class=\"token class-name\">Updates</span> were rejected because the tip of your current branch is behind\nhint<span class=\"token operator\">:</span> its remote <span class=\"token class-name\"><span class=\"token namespace\">counterpart<span class=\"token punctuation\">.</span></span> Integrate</span> the remote changes <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>g<span class=\"token punctuation\">.</span>\nhint<span class=\"token operator\">:</span> <span class=\"token string\">'git pull ...'</span><span class=\"token punctuation\">)</span> before pushing again<span class=\"token punctuation\">.</span>\nhint<span class=\"token operator\">:</span> <span class=\"token class-name\">See</span> the <span class=\"token string\">'Note about fast-forwards'</span> in <span class=\"token string\">'git push --help'</span> <span class=\"token keyword\">for</span> details<span class=\"token punctuation\">.</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意, rebasing(见下面)和修正(amending)会用一个新的提交(commit)代替旧的, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (<code>-f</code>)。注意 – 总是 确保你指明一个分支!</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git push origin mybranch <span class=\"token operator\">-</span>f<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>一般来说, 要避免强推. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。</p>\n<h3 id=\"我意外的做了一次硬重置-hard-reset-，我想找回我的内容\"><a href=\"#我意外的做了一次硬重置-hard-reset-，我想找回我的内容\" class=\"headerlink\" title=\"我意外的做了一次硬重置(hard reset)，我想找回我的内容\"></a>我意外的做了一次硬重置(hard reset)，我想找回我的内容</h3><p>如果你意外的做了 <code>git reset --hard</code>, 你通常能找回你的提交(commit), 因为Git对每件事都会有日志，且都会保存几天。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reflog<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。选择你想要回到的提交(commit)的SHA，再重置一次:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard SHA1234<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这样就完成了。</p>\n<h2 id=\"暂存-Staging\"><a href=\"#暂存-Staging\" class=\"headerlink\" title=\"暂存(Staging)\"></a>暂存(Staging)</h2><h3 id=\"我需要把暂存的内容添加到上一次的提交-commit\"><a href=\"#我需要把暂存的内容添加到上一次的提交-commit\" class=\"headerlink\" title=\"我需要把暂存的内容添加到上一次的提交(commit)\"></a>我需要把暂存的内容添加到上一次的提交(commit)</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>$ git commit <span class=\"token operator\">--</span>amend<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我想要暂存一个新文件的一部分，而不是这个文件的全部\"><a href=\"#我想要暂存一个新文件的一部分，而不是这个文件的全部\" class=\"headerlink\" title=\"我想要暂存一个新文件的一部分，而不是这个文件的全部\"></a>我想要暂存一个新文件的一部分，而不是这个文件的全部</h3><p>一般来说, 如果你想暂存一个文件的一部分, 你可这样做:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git add <span class=\"token operator\">--</span>patch filename<span class=\"token punctuation\">.</span>x<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><code>-p</code> 简写。这会打开交互模式， 你将能够用 <code>s</code> 选项来分隔提交(commit)；然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时, 这样做:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git add <span class=\"token operator\">-</span><span class=\"token class-name\">N</span> filename<span class=\"token punctuation\">.</span>x<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>然后, 你需要用 <code>e</code> 选项来手动选择需要添加的行，执行 <code>git diff --cached</code> 将会显示哪些行暂存了哪些行只是保存在本地了。</p>\n<h3 id=\"我想把在一个文件里的变化-changes-加到两个提交-commit-里\"><a href=\"#我想把在一个文件里的变化-changes-加到两个提交-commit-里\" class=\"headerlink\" title=\"我想把在一个文件里的变化(changes)加到两个提交(commit)里\"></a>我想把在一个文件里的变化(changes)加到两个提交(commit)里</h3><p><code>git add</code> 会把整个文件加入到一个提交. <code>git add -p</code> 允许交互式的选择你想要提交的部分.</p>\n<h3 id=\"我想把暂存的内容变成未暂存，把未暂存的内容暂存起来\"><a href=\"#我想把暂存的内容变成未暂存，把未暂存的内容暂存起来\" class=\"headerlink\" title=\"我想把暂存的内容变成未暂存，把未暂存的内容暂存起来\"></a>我想把暂存的内容变成未暂存，把未暂存的内容暂存起来</h3><p>多数情况下，你应该将所有的内容变为未暂存，然后再选择你想要的内容进行commit。但假定你就是想要这么做，这里你可以创建一个临时的commit来保存你已暂存的内容，然后暂存你的未暂存的内容并进行stash。然后reset最后一个commit将原本暂存的内容变为未暂存，最后stash pop回来。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git commit <span class=\"token operator\">-</span>m <span class=\"token string\">\"WIP\"</span>\n$ git add <span class=\"token punctuation\">.</span>\n$ git stash\n$ git reset HEAD<span class=\"token operator\">^</span>\n$ git stash pop <span class=\"token operator\">--</span>index <span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意1: 这里使用<code>pop</code>仅仅是因为想尽可能保持幂等。注意2: 假如你不加上<code>--index</code>你会把暂存的文件标记为为存储。</p>\n<h2 id=\"未暂存-Unstaged-的内容\"><a href=\"#未暂存-Unstaged-的内容\" class=\"headerlink\" title=\"未暂存(Unstaged)的内容\"></a>未暂存(Unstaged)的内容</h2><h3 id=\"我想把未暂存的内容移动到一个新分支\"><a href=\"#我想把未暂存的内容移动到一个新分支\" class=\"headerlink\" title=\"我想把未暂存的内容移动到一个新分支\"></a>我想把未暂存的内容移动到一个新分支</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git checkout <span class=\"token operator\">-</span>b my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我想把未暂存的内容移动到另一个已存在的分支\"><a href=\"#我想把未暂存的内容移动到另一个已存在的分支\" class=\"headerlink\" title=\"我想把未暂存的内容移动到另一个已存在的分支\"></a>我想把未暂存的内容移动到另一个已存在的分支</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash\n$ git checkout my<span class=\"token operator\">-</span>branch\n$ git stash pop<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"我想丢弃本地未提交的变化-uncommitted-changes\"><a href=\"#我想丢弃本地未提交的变化-uncommitted-changes\" class=\"headerlink\" title=\"我想丢弃本地未提交的变化(uncommitted changes)\"></a>我想丢弃本地未提交的变化(uncommitted changes)</h3><p>如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"># one commit\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard HEAD<span class=\"token operator\">^</span>\n# two commits\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard HEAD<span class=\"token operator\">^</span><span class=\"token operator\">^</span>\n# four commits\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard HEAD<span class=\"token operator\">~</span><span class=\"token number\">4</span>\n# or\n<span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout <span class=\"token operator\">-</span>f<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>重置某个特殊的文件, 你可以用文件名做为参数:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git reset filename<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我想丢弃某些未暂存的内容\"><a href=\"#我想丢弃某些未暂存的内容\" class=\"headerlink\" title=\"我想丢弃某些未暂存的内容\"></a>我想丢弃某些未暂存的内容</h3><p>如果你想丢弃工作拷贝中的一部分内容，而不是全部。</p>\n<p>签出(checkout)不需要的内容，保留需要的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git checkout <span class=\"token operator\">-</span>p\n# <span class=\"token class-name\">Answer</span> y <span class=\"token keyword\">to</span> <span class=\"token namespace\">all</span> of the snippets you want <span class=\"token keyword\">to</span> <span class=\"token namespace\">drop</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>另外一个方法是使用 <code>stash</code>， Stash所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash <span class=\"token operator\">-</span>p\n# <span class=\"token class-name\">Select</span> all of the snippets you want <span class=\"token keyword\">to</span> <span class=\"token namespace\">save</span>\n$ git reset <span class=\"token operator\">--</span>hard\n$ git stash pop<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>或者, stash 你不需要的部分, 然后stash drop。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash <span class=\"token operator\">-</span>p\n# <span class=\"token class-name\">Select</span> all of the snippets you don't want <span class=\"token keyword\">to</span> <span class=\"token namespace\">save</span>\n$ git stash drop<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"分支-Branches\"><a href=\"#分支-Branches\" class=\"headerlink\" title=\"分支(Branches)\"></a>分支(Branches)</h2><h3 id=\"我从错误的分支拉取了内容，或把内容拉取到了错误的分支\"><a href=\"#我从错误的分支拉取了内容，或把内容拉取到了错误的分支\" class=\"headerlink\" title=\"我从错误的分支拉取了内容，或把内容拉取到了错误的分支\"></a>我从错误的分支拉取了内容，或把内容拉取到了错误的分支</h3><p>这是另外一种使用 <code>git reflog</code> 情况，找到在这次错误拉(pull) 之前HEAD的指向。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reflog\nab7555f HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> pull origin wrong<span class=\"token operator\">-</span>branch<span class=\"token operator\">:</span> <span class=\"token class-name\">Fast</span><span class=\"token operator\">-</span>forward\nc5bc55a HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> checkout<span class=\"token operator\">:</span> checkout message goes here<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>重置分支到你所需的提交(desired commit):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git reset <span class=\"token operator\">--</span>hard c5bc55a<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>完成。</p>\n<h3 id=\"我想扔掉本地的提交-commit-，以便我的分支与远程的保持一致\"><a href=\"#我想扔掉本地的提交-commit-，以便我的分支与远程的保持一致\" class=\"headerlink\" title=\"我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致\"></a>我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致</h3><p>先确认你没有推(push)你的内容到远程。</p>\n<p><code>git status</code> 会显示你领先(ahead)源(origin)多少个提交:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git status\n# <span class=\"token class-name\">On</span> branch my<span class=\"token operator\">-</span>branch\n# <span class=\"token class-name\">Your</span> branch is ahead of <span class=\"token string\">'origin/my-branch'</span> by <span class=\"token number\">2</span> commits<span class=\"token punctuation\">.</span>\n#   <span class=\"token punctuation\">(</span>use <span class=\"token string\">\"git push\"</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">publish</span> your local commits<span class=\"token punctuation\">)</span>\n#<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>一种方法是:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard origin<span class=\"token operator\">/</span>my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我需要提交到一个新分支，但错误的提交到了main\"><a href=\"#我需要提交到一个新分支，但错误的提交到了main\" class=\"headerlink\" title=\"我需要提交到一个新分支，但错误的提交到了main\"></a>我需要提交到一个新分支，但错误的提交到了main</h3><p>在main下创建一个新分支，不切换到新分支,仍在main下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git branch my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>把main分支重置到前一个提交:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard HEAD<span class=\"token operator\">^</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><code>HEAD^</code> 是 <code>HEAD^1</code> 的简写，你可以通过指定要设置的<code>HEAD</code>来进一步重置。</p>\n<p>或者, 如果你不想使用 <code>HEAD^</code>, 找到你想重置到的提交(commit)的hash(<code>git log</code> 能够完成)， 然后重置到这个hash。使用<code>git push</code> 同步内容到远程。</p>\n<p>例如, main分支想重置到的提交的hash为<code>a13b85e</code>:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard a13b85e\nHEAD is now at a13b85e<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>签出(checkout)刚才新建的分支继续工作:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我想保留来自另外一个ref-ish的整个文件\"><a href=\"#我想保留来自另外一个ref-ish的整个文件\" class=\"headerlink\" title=\"我想保留来自另外一个ref-ish的整个文件\"></a>我想保留来自另外一个ref-ish的整个文件</h3><p>假设你正在做一个原型方案(原文为working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容:微信搜索公众号：Java后端编程，回复：java 领取资料 。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>solution<span class=\"token punctuation\">)</span>$ git add <span class=\"token operator\">-</span><span class=\"token class-name\">A</span> <span class=\"token operator\">&amp;&amp;</span> git commit <span class=\"token operator\">-</span>m <span class=\"token string\">\"Adding all changes from this spike into one big commit.\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>当你想要把它放到一个分支里 (可能是<code>feature</code>, 或者 <code>develop</code>), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。</p>\n<p>假设你有:</p>\n<ul>\n<li> 分支 <code>solution</code>, 拥有原型方案， 领先 <code>develop</code> 分支。</li>\n<li> 分支 <code>develop</code>, 在这里你应用原型方案的一些内容。</li>\n</ul>\n<p>我去可以通过把内容拿到你的分支里，来解决这个问题:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>develop<span class=\"token punctuation\">)</span>$ git checkout solution <span class=\"token operator\">--</span> file1<span class=\"token punctuation\">.</span>txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这会把这个文件内容从分支 <code>solution</code> 拿到分支 <code>develop</code> 里来:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"># <span class=\"token class-name\">On</span> branch develop\n# <span class=\"token class-name\">Your</span> branch is up<span class=\"token operator\">-</span><span class=\"token keyword\">to</span><span class=\"token operator\">-</span>date <span class=\"token keyword\">with</span> <span class=\"token string\">'origin/develop'</span><span class=\"token punctuation\">.</span>\n# <span class=\"token class-name\">Changes</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">be</span> committed<span class=\"token operator\">:</span>\n#  <span class=\"token punctuation\">(</span>use <span class=\"token string\">\"git reset HEAD &lt;file>...\"</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">unstage</span><span class=\"token punctuation\">)</span>\n#\n#        modified<span class=\"token operator\">:</span>   file1<span class=\"token punctuation\">.</span>txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后, 正常提交。</p>\n<p>Note: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem.</p>\n<h3 id=\"我把几个提交-commit-提交到了同一个分支，而这些提交应该分布在不同的分支里\"><a href=\"#我把几个提交-commit-提交到了同一个分支，而这些提交应该分布在不同的分支里\" class=\"headerlink\" title=\"我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里\"></a>我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里</h3><p>假设你有一个<code>main</code>分支， 执行<code>git log</code>, 你看到你做过两次提交:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git log\n\ncommit e3851e817c451cc36f2e6f3049db528415e3c114\n<span class=\"token class-name\">Author</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Alex</span> <span class=\"token class-name\">Lee</span> <span class=\"token operator\">&lt;</span>alexlee<span class=\"token annotation punctuation\">@example.com</span><span class=\"token operator\">></span>\n<span class=\"token class-name\">Date</span><span class=\"token operator\">:</span>   <span class=\"token class-name\">Tue</span> <span class=\"token class-name\">Jul</span> <span class=\"token number\">22</span> <span class=\"token number\">15</span><span class=\"token operator\">:</span><span class=\"token number\">39</span><span class=\"token operator\">:</span><span class=\"token number\">27</span> <span class=\"token number\">2014</span> <span class=\"token operator\">-</span><span class=\"token number\">0400</span>\n\n    <span class=\"token class-name\">Bug</span> #<span class=\"token number\">21</span> <span class=\"token operator\">-</span> <span class=\"token class-name\">Added</span> CSRF protection\n\ncommit <span class=\"token number\">5</span>ea51731d150f7ddc4a365437931cd8be3bf3131\n<span class=\"token class-name\">Author</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Alex</span> <span class=\"token class-name\">Lee</span> <span class=\"token operator\">&lt;</span>alexlee<span class=\"token annotation punctuation\">@example.com</span><span class=\"token operator\">></span>\n<span class=\"token class-name\">Date</span><span class=\"token operator\">:</span>   <span class=\"token class-name\">Tue</span> <span class=\"token class-name\">Jul</span> <span class=\"token number\">22</span> <span class=\"token number\">15</span><span class=\"token operator\">:</span><span class=\"token number\">39</span><span class=\"token operator\">:</span><span class=\"token number\">12</span> <span class=\"token number\">2014</span> <span class=\"token operator\">-</span><span class=\"token number\">0400</span>\n\n    <span class=\"token class-name\">Bug</span> #<span class=\"token number\">14</span> <span class=\"token operator\">-</span> <span class=\"token class-name\">Fixed</span> spacing on title\n\ncommit a13b85e984171c6e2a1729bb061994525f626d14\n<span class=\"token class-name\">Author</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Aki</span> <span class=\"token class-name\">Rose</span> <span class=\"token operator\">&lt;</span>akirose<span class=\"token annotation punctuation\">@example.com</span><span class=\"token operator\">></span>\n<span class=\"token class-name\">Date</span><span class=\"token operator\">:</span>   <span class=\"token class-name\">Tue</span> <span class=\"token class-name\">Jul</span> <span class=\"token number\">21</span> <span class=\"token number\">01</span><span class=\"token operator\">:</span><span class=\"token number\">12</span><span class=\"token operator\">:</span><span class=\"token number\">48</span> <span class=\"token number\">2014</span> <span class=\"token operator\">-</span><span class=\"token number\">0400</span>\n\n    <span class=\"token class-name\">First</span> commit<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>让我们用提交hash(commit hash)标记bug (<code>e3851e8</code> for #21, <code>5ea5173</code> for #14).</p>\n<p>首先, 我们把<code>main</code>分支重置到正确的提交(<code>a13b85e</code>):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard a13b85e\nHEAD is now at a13b85e<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>现在, 我们对 bug #21 创建一个新的分支:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout <span class=\"token operator\">-</span>b <span class=\"token number\">21</span>\n<span class=\"token punctuation\">(</span><span class=\"token number\">21</span><span class=\"token punctuation\">)</span>$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>接着, 我们用 cherry-pick 把对bug #21的提交放入当前分支。这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在HEAD上面。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span><span class=\"token number\">21</span><span class=\"token punctuation\">)</span>$ git cherry<span class=\"token operator\">-</span>pick e3851e8<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这时候, 这里可能会产生冲突， 参见交互式 rebasing 章 冲突节 解决冲突.</p>\n<p>再者， 我们为bug #14 创建一个新的分支, 也基于<code>main</code>分支</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span><span class=\"token number\">21</span><span class=\"token punctuation\">)</span>$ git checkout main\n<span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout <span class=\"token operator\">-</span>b <span class=\"token number\">14</span>\n<span class=\"token punctuation\">(</span><span class=\"token number\">14</span><span class=\"token punctuation\">)</span>$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>最后, 为 bug #14 执行 <code>cherry-pick</code>:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span><span class=\"token number\">14</span><span class=\"token punctuation\">)</span>$ git cherry<span class=\"token operator\">-</span>pick <span class=\"token number\">5</span>ea5173<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我想删除上游-upstream-分支被删除了的本地分支\"><a href=\"#我想删除上游-upstream-分支被删除了的本地分支\" class=\"headerlink\" title=\"我想删除上游(upstream)分支被删除了的本地分支\"></a>我想删除上游(upstream)分支被删除了的本地分支</h3><p>一旦你在github 上面合并(merge)了一个pull request, 你就可以删除你fork里被合并的分支。如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中（[IDEA 中玩转 Git][IDEA _ Git]）。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git fetch <span class=\"token operator\">-</span>p<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我不小心删除了我的分支\"><a href=\"#我不小心删除了我的分支\" class=\"headerlink\" title=\"我不小心删除了我的分支\"></a>我不小心删除了我的分支</h3><p>如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。让我们先创建一个分支和一个新的文件:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout <span class=\"token operator\">-</span>b my<span class=\"token operator\">-</span>branch\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git branch\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ touch foo<span class=\"token punctuation\">.</span>txt\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ ls\nREADME<span class=\"token punctuation\">.</span>md foo<span class=\"token punctuation\">.</span>txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>添加文件并做一次提交</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git add <span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git commit <span class=\"token operator\">-</span>m <span class=\"token string\">'foo.txt added'</span>\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ foo<span class=\"token punctuation\">.</span>txt added\n <span class=\"token number\">1</span> files changed<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span> <span class=\"token function\">insertions</span><span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span>\n create mode <span class=\"token number\">100644</span> foo<span class=\"token punctuation\">.</span>txt\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git log\n\ncommit <span class=\"token number\">4e3</span>cd85a670ced7cc17a2b5d8d3d809ac88d5012\n<span class=\"token class-name\">Author</span><span class=\"token operator\">:</span> siemiatj <span class=\"token operator\">&lt;</span>siemiatj<span class=\"token annotation punctuation\">@example.com</span><span class=\"token operator\">></span>\n<span class=\"token class-name\">Date</span><span class=\"token operator\">:</span>   <span class=\"token class-name\">Wed</span> <span class=\"token class-name\">Jul</span> <span class=\"token number\">30</span> <span class=\"token number\">00</span><span class=\"token operator\">:</span><span class=\"token number\">34</span><span class=\"token operator\">:</span><span class=\"token number\">10</span> <span class=\"token number\">2014</span> <span class=\"token operator\">+</span><span class=\"token number\">0200</span>\n\n    foo<span class=\"token punctuation\">.</span>txt added\n\ncommit <span class=\"token number\">69204</span>cdf0acbab201619d95ad8295928e7f411d5\n<span class=\"token class-name\">Author</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Kate</span> <span class=\"token class-name\">Hudson</span> <span class=\"token operator\">&lt;</span>katehudson<span class=\"token annotation punctuation\">@example.com</span><span class=\"token operator\">></span>\n<span class=\"token class-name\">Date</span><span class=\"token operator\">:</span>   <span class=\"token class-name\">Tue</span> <span class=\"token class-name\">Jul</span> <span class=\"token number\">29</span> <span class=\"token number\">13</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">46</span> <span class=\"token number\">2014</span> <span class=\"token operator\">-</span><span class=\"token number\">0400</span>\n\n    <span class=\"token class-name\">Fixes</span> #<span class=\"token number\">6</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Force</span> pushing after amending commits<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>现在我们切回到主(main)分支，‘不小心的’删除<code>my-branch</code>分支</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git checkout main\n<span class=\"token class-name\">Switched</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">branch</span> <span class=\"token string\">'main'</span>\n<span class=\"token class-name\">Your</span> branch is up<span class=\"token operator\">-</span><span class=\"token keyword\">to</span><span class=\"token operator\">-</span>date <span class=\"token keyword\">with</span> <span class=\"token string\">'origin/main'</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git branch <span class=\"token operator\">-</span><span class=\"token class-name\">D</span> my<span class=\"token operator\">-</span>branch\n<span class=\"token class-name\">Deleted</span> branch my<span class=\"token operator\">-</span>branch <span class=\"token punctuation\">(</span>was <span class=\"token number\">4e3</span>cd85<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ echo oh noes<span class=\"token punctuation\">,</span> deleted my branch<span class=\"token operator\">!</span>\noh noes<span class=\"token punctuation\">,</span> deleted my branch<span class=\"token operator\">!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在这时候你应该想起了<code>reflog</code>, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reflog\n<span class=\"token number\">69204</span>cd HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> checkout<span class=\"token operator\">:</span> moving from my<span class=\"token operator\">-</span>branch <span class=\"token keyword\">to</span> <span class=\"token namespace\">main</span>\n<span class=\"token number\">4e3</span>cd85 HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> commit<span class=\"token operator\">:</span> foo<span class=\"token punctuation\">.</span>txt added\n<span class=\"token number\">69204</span>cd HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> checkout<span class=\"token operator\">:</span> moving from main <span class=\"token keyword\">to</span> <span class=\"token namespace\">my</span><span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>正如你所见，我们有一个来自删除分支的提交hash(commit hash)，接下来看看是否能恢复删除了的分支。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout <span class=\"token operator\">-</span>b my<span class=\"token operator\">-</span>branch<span class=\"token operator\">-</span>help\n<span class=\"token class-name\">Switched</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">a</span> <span class=\"token keyword\">new</span> branch <span class=\"token string\">'my-branch-help'</span>\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token operator\">-</span>help<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard <span class=\"token number\">4e3</span>cd85\nHEAD is now at <span class=\"token number\">4e3</span>cd85 foo<span class=\"token punctuation\">.</span>txt added\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token operator\">-</span>help<span class=\"token punctuation\">)</span>$ ls\nREADME<span class=\"token punctuation\">.</span>md foo<span class=\"token punctuation\">.</span>txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看! 我们把删除的文件找回来了。Git的 <code>reflog</code> 在rebasing出错的时候也是同样有用的。</p>\n<h3 id=\"我想删除一个分支\"><a href=\"#我想删除一个分支\" class=\"headerlink\" title=\"我想删除一个分支\"></a>我想删除一个分支</h3><p>删除一个远程分支:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git push origin <span class=\"token operator\">--</span>delete my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>你也可以:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git push origin <span class=\"token operator\">:</span>my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>删除一个本地分支:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git branch <span class=\"token operator\">-</span><span class=\"token class-name\">D</span> my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我想从别人正在工作的远程分支签出-checkout-一个分支\"><a href=\"#我想从别人正在工作的远程分支签出-checkout-一个分支\" class=\"headerlink\" title=\"我想从别人正在工作的远程分支签出(checkout)一个分支\"></a>我想从别人正在工作的远程分支签出(checkout)一个分支</h3><p>首先, 从远程拉取(fetch) 所有分支:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git fetch <span class=\"token operator\">--</span>all<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>假设你想要从远程的<code>daves</code>分支签出到本地的<code>daves</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout <span class=\"token operator\">--</span>track origin<span class=\"token operator\">/</span>daves\n<span class=\"token class-name\">Branch</span> daves set up <span class=\"token keyword\">to</span> <span class=\"token namespace\">track</span> remote branch daves from <span class=\"token class-name\"><span class=\"token namespace\">origin<span class=\"token punctuation\">.</span></span>\nSwitched</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">a</span> <span class=\"token keyword\">new</span> branch <span class=\"token string\">'daves'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>(<code>--track</code> 是 <code>git checkout -b [branch] [remotename]/[branch]</code> 的简写)</p>\n<p>这样就得到了一个<code>daves</code>分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到.</p>\n<h2 id=\"Rebasing-和合并-Merging\"><a href=\"#Rebasing-和合并-Merging\" class=\"headerlink\" title=\"Rebasing 和合并(Merging)\"></a>Rebasing 和合并(Merging)</h2><h3 id=\"我想撤销rebase-merge\"><a href=\"#我想撤销rebase-merge\" class=\"headerlink\" title=\"我想撤销rebase/merge\"></a>我想撤销rebase/merge</h3><p>你可以合并(merge)或rebase了一个错误的分支, 或者完成不了一个进行中的rebase/merge。Git 在进行危险操作的时候会把原始的HEAD保存在一个叫ORIG_HEAD的变量里, 所以要把分支恢复到rebase/merge前的状态是很容易的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard ORIG_HEAD<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我已经rebase过-但是我不想强推-force-push\"><a href=\"#我已经rebase过-但是我不想强推-force-push\" class=\"headerlink\" title=\"我已经rebase过, 但是我不想强推(force push)\"></a>我已经rebase过, 但是我不想强推(force push)</h3><p>不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。是因你快进(Fast forward)了提交，改变了Git历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout my<span class=\"token operator\">-</span>branch\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git rebase <span class=\"token operator\">-</span>i main\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git checkout main\n<span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git merge <span class=\"token operator\">--</span>ff<span class=\"token operator\">-</span>only my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"我需要组合-combine-几个提交-commit\"><a href=\"#我需要组合-combine-几个提交-commit\" class=\"headerlink\" title=\"我需要组合(combine)几个提交(commit)\"></a>我需要组合(combine)几个提交(commit)</h3><p>假设你的工作分支将会做对于 <code>main</code> 的pull-request。一般情况下你不关心提交(commit)的时间戳，只想组合 所有 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。确保主(main)分支是最新的和你的变化都已经提交了, 然后:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>soft main\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git commit <span class=\"token operator\">-</span>am <span class=\"token string\">\"New awesome feature\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>如果你想要更多的控制, 想要保留时间戳, 你需要做交互式rebase (interactive rebase):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git rebase <span class=\"token operator\">-</span>i main<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果没有相对的其它分支， 你将不得不相对自己的<code>HEAD</code> 进行 rebase。例如：你想组合最近的两次提交(commit), 你将相对于<code>HEAD~2</code> 进行rebase， 组合最近3次提交(commit), 相对于<code>HEAD~3</code>, 等等。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git rebase <span class=\"token operator\">-</span>i HEAD<span class=\"token operator\">~</span><span class=\"token number\">2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>在你执行了交互式 rebase的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">pick a9c8a1d <span class=\"token class-name\">Some</span> refactoring\npick <span class=\"token number\">01</span>b2fd8 <span class=\"token class-name\">New</span> awesome feature\npick b729ad5 fixup\npick e3851e8 another fix\n\n# <span class=\"token class-name\">Rebase</span> <span class=\"token number\">8074d</span><span class=\"token number\">12.</span><span class=\"token punctuation\">.</span>b729ad5 onto <span class=\"token number\">8074d</span><span class=\"token number\">12</span>\n#\n# <span class=\"token class-name\">Commands</span><span class=\"token operator\">:</span>\n#  p<span class=\"token punctuation\">,</span> pick <span class=\"token operator\">=</span> use commit\n#  r<span class=\"token punctuation\">,</span> reword <span class=\"token operator\">=</span> use commit<span class=\"token punctuation\">,</span> but edit the commit message\n#  e<span class=\"token punctuation\">,</span> edit <span class=\"token operator\">=</span> use commit<span class=\"token punctuation\">,</span> but stop <span class=\"token keyword\">for</span> amending\n#  s<span class=\"token punctuation\">,</span> squash <span class=\"token operator\">=</span> use commit<span class=\"token punctuation\">,</span> but meld into previous commit\n#  f<span class=\"token punctuation\">,</span> fixup <span class=\"token operator\">=</span> like <span class=\"token string\">\"squash\"</span><span class=\"token punctuation\">,</span> but discard <span class=\"token keyword\">this</span> commit's log message\n#  x<span class=\"token punctuation\">,</span> exec <span class=\"token operator\">=</span> run command <span class=\"token punctuation\">(</span>the rest of the line<span class=\"token punctuation\">)</span> using shell\n#\n# <span class=\"token class-name\">These</span> lines can be re<span class=\"token operator\">-</span>ordered<span class=\"token punctuation\">;</span> they are executed from top <span class=\"token keyword\">to</span> <span class=\"token namespace\">bottom<span class=\"token punctuation\">.</span></span>\n#\n# <span class=\"token class-name\">If</span> you remove a line here THAT COMMIT WILL BE LOST<span class=\"token punctuation\">.</span>\n#\n# <span class=\"token class-name\">However</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">if</span> you remove everything<span class=\"token punctuation\">,</span> the rebase will be aborted<span class=\"token punctuation\">.</span>\n#\n# <span class=\"token class-name\">Note</span> that empty commits are commented out<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>所有以 <code>#</code> 开头的行都是注释, 不会影响 rebase.</p>\n<p>然后，你可以用任何上面命令列表的命令替换 <code>pick</code>, 你也可以通过删除对应的行来删除一个提交(commit)。</p>\n<p>例如, 如果你想 单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 <code>f</code>:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">pick a9c8a1d <span class=\"token class-name\">Some</span> refactoring\npick <span class=\"token number\">01</span>b2fd8 <span class=\"token class-name\">New</span> awesome feature\nf b729ad5 fixup\nf e3851e8 another fix<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果你想组合这些提交(commit) 并重命名这个提交(commit), 你应该在第二个提交(commit)旁边添加一个<code>r</code>，或者更简单的用<code>s</code> 替代 <code>f</code>:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">pick a9c8a1d <span class=\"token class-name\">Some</span> refactoring\npick <span class=\"token number\">01</span>b2fd8 <span class=\"token class-name\">New</span> awesome feature\ns b729ad5 fixup\ns e3851e8 another fix<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>你可以在接下来弹出的文本提示框里重命名提交(commit)。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Newer</span><span class=\"token punctuation\">,</span> awesomer features\n\n# <span class=\"token class-name\">Please</span> enter the commit message <span class=\"token keyword\">for</span> your <span class=\"token class-name\"><span class=\"token namespace\">changes<span class=\"token punctuation\">.</span></span> Lines</span> starting\n# <span class=\"token keyword\">with</span> <span class=\"token string\">'#'</span> will be ignored<span class=\"token punctuation\">,</span> and an empty message aborts the commit<span class=\"token punctuation\">.</span>\n# rebase in progress<span class=\"token punctuation\">;</span> onto <span class=\"token number\">8074d</span><span class=\"token number\">12</span>\n# <span class=\"token class-name\">You</span> are currently editing a commit <span class=\"token keyword\">while</span> rebasing branch <span class=\"token string\">'main'</span> on <span class=\"token string\">'8074d12'</span><span class=\"token punctuation\">.</span>\n#\n# <span class=\"token class-name\">Changes</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">be</span> committed<span class=\"token operator\">:</span>\n#\tmodified<span class=\"token operator\">:</span>   README<span class=\"token punctuation\">.</span>md\n#<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果成功了, 你应该看到类似下面的内容:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ <span class=\"token class-name\">Successfully</span> rebased and updated refs<span class=\"token operator\">/</span>heads<span class=\"token operator\">/</span>main<span class=\"token punctuation\">.</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"安全合并-merging-策略\"><a href=\"#安全合并-merging-策略\" class=\"headerlink\" title=\"安全合并(merging)策略\"></a>安全合并(merging)策略</h4><p><code>--no-commit</code> 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。<code>no-ff</code> 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致（更多Git资料，参见[IDEA 中如何完成 Git 版本回退？][IDEA _ Git 1]）。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git merge <span class=\"token operator\">--</span>no<span class=\"token operator\">-</span>ff <span class=\"token operator\">--</span>no<span class=\"token operator\">-</span>commit my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"我需要将一个分支合并成一个提交-commit\"><a href=\"#我需要将一个分支合并成一个提交-commit\" class=\"headerlink\" title=\"我需要将一个分支合并成一个提交(commit)\"></a>我需要将一个分支合并成一个提交(commit)</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git merge <span class=\"token operator\">--</span>squash my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"我只想组合-combine-未推的提交-unpushed-commit\"><a href=\"#我只想组合-combine-未推的提交-unpushed-commit\" class=\"headerlink\" title=\"我只想组合(combine)未推的提交(unpushed commit)\"></a>我只想组合(combine)未推的提交(unpushed commit)</h4><p>有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git rebase <span class=\"token operator\">-</span>i @<span class=\"token punctuation\">&#123;</span>u<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这会产生一次交互式的rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行reorder/fix/squash 都是安全的。</p>\n<h3 id=\"检查是否分支上的所有提交-commit-都合并-merge-过了\"><a href=\"#检查是否分支上的所有提交-commit-都合并-merge-过了\" class=\"headerlink\" title=\"检查是否分支上的所有提交(commit)都合并(merge)过了\"></a>检查是否分支上的所有提交(commit)都合并(merge)过了</h3><p>检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的head(或任何 commits)之间做一次diff:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git log <span class=\"token operator\">--</span>graph <span class=\"token operator\">--</span>left<span class=\"token operator\">-</span>right <span class=\"token operator\">--</span>cherry<span class=\"token operator\">-</span>pick <span class=\"token operator\">--</span>oneline HEAD<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>feature<span class=\"token operator\">/</span><span class=\"token number\">120</span><span class=\"token operator\">-</span>on<span class=\"token operator\">-</span>scroll<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。另一个做法可以是:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git log main <span class=\"token operator\">^</span>feature<span class=\"token operator\">/</span><span class=\"token number\">120</span><span class=\"token operator\">-</span>on<span class=\"token operator\">-</span>scroll <span class=\"token operator\">--</span>no<span class=\"token operator\">-</span>merges<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"交互式rebase-interactive-rebase-可能出现的问题\"><a href=\"#交互式rebase-interactive-rebase-可能出现的问题\" class=\"headerlink\" title=\"交互式rebase(interactive rebase)可能出现的问题\"></a>交互式rebase(interactive rebase)可能出现的问题</h3><h4 id=\"这个rebase-编辑屏幕出现’noop’\"><a href=\"#这个rebase-编辑屏幕出现’noop’\" class=\"headerlink\" title=\"这个rebase 编辑屏幕出现’noop’\"></a>这个rebase 编辑屏幕出现’noop’</h4><p>如果你看到的是这样:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">noop<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这意味着你rebase的分支和当前分支在同一个提交(commit)上, 或者 领先(ahead) 当前分支。你可以尝试:</p>\n<ul>\n<li> 检查确保主(main)分支没有问题</li>\n<li> rebase <code>HEAD~2</code> 或者更早</li>\n</ul>\n<h4 id=\"有冲突的情况\"><a href=\"#有冲突的情况\" class=\"headerlink\" title=\"有冲突的情况\"></a>有冲突的情况</h4><p>如果你不能成功的完成rebase, 你可能必须要解决冲突。</p>\n<p>首先执行 <code>git status</code> 找出哪些文件有冲突:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git status\n<span class=\"token class-name\">On</span> branch my<span class=\"token operator\">-</span>branch\n<span class=\"token class-name\">Changes</span> not staged <span class=\"token keyword\">for</span> commit<span class=\"token operator\">:</span>\n  <span class=\"token punctuation\">(</span>use <span class=\"token string\">\"git add &lt;file>...\"</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">update</span> what will be committed<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span>use <span class=\"token string\">\"git checkout -- &lt;file>...\"</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">discard</span> changes in working directory<span class=\"token punctuation\">)</span>\n\n modified<span class=\"token operator\">:</span>   README<span class=\"token punctuation\">.</span>md<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在这个例子里面, <code>README.md</code> 有冲突。打开这个文件找到类似下面的内容:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token operator\">&lt;&lt;</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token operator\">&lt;</span> HEAD\n   some code\n   <span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>\n   some code\n   <span class=\"token operator\">>>></span><span class=\"token operator\">>>></span><span class=\"token operator\">></span> <span class=\"token keyword\">new</span><span class=\"token operator\">-</span>commit<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>你需要解决新提交的代码(示例里, 从中间<code>==</code>线到<code>new-commit</code>的地方)与<code>HEAD</code> 之间不一样的地方.</p>\n<p>有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>$ git mergetool <span class=\"token operator\">-</span>t opendiff<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>在你解决完所有冲突和测试过后, <code>git add</code> 变化了的(changed)文件, 然后用<code>git rebase --continue</code> 继续rebase。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git add README<span class=\"token punctuation\">.</span>md\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git rebase <span class=\"token operator\">--</span><span class=\"token keyword\">continue</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行<code>git rebase --skip</code>。</p>\n<p>任何时候你想结束整个rebase 过程，回来rebase前的分支状态, 你可以做:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git rebase <span class=\"token operator\">--</span>abort<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"Stash\"><a href=\"#Stash\" class=\"headerlink\" title=\"Stash\"></a>Stash</h2><h3 id=\"暂存所有改动\"><a href=\"#暂存所有改动\" class=\"headerlink\" title=\"暂存所有改动\"></a>暂存所有改动</h3><p>暂存你工作目录下的所有改动</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>你可以使用<code>-u</code>来排除一些文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash <span class=\"token operator\">-</span>u<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"暂存指定文件\"><a href=\"#暂存指定文件\" class=\"headerlink\" title=\"暂存指定文件\"></a>暂存指定文件</h3><p>假设你只想暂存某一个文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash push working<span class=\"token operator\">-</span>directory<span class=\"token operator\">-</span>path<span class=\"token operator\">/</span>filename<span class=\"token punctuation\">.</span>ext<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>假设你想暂存多个文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash push working<span class=\"token operator\">-</span>directory<span class=\"token operator\">-</span>path<span class=\"token operator\">/</span>filename1<span class=\"token punctuation\">.</span>ext working<span class=\"token operator\">-</span>directory<span class=\"token operator\">-</span>path<span class=\"token operator\">/</span>filename2<span class=\"token punctuation\">.</span>ext<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"暂存时记录消息\"><a href=\"#暂存时记录消息\" class=\"headerlink\" title=\"暂存时记录消息\"></a>暂存时记录消息</h3><p>这样你可以在<code>list</code>时看到它</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash save <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>message<span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>或</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash push <span class=\"token operator\">-</span>m <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>message<span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"使用某个指定暂存\"><a href=\"#使用某个指定暂存\" class=\"headerlink\" title=\"使用某个指定暂存\"></a>使用某个指定暂存</h3><p>首先你可以查看你的<code>stash</code>记录</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash list<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>然后你可以<code>apply</code>某个<code>stash</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash apply <span class=\"token string\">\"stash@&#123;n&#125;\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>此处， ‘n’是<code>stash</code>在栈中的位置，最上层的<code>stash</code>会是0</p>\n<p>除此之外，也可以使用时间标记(假如你能记得的话)。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash apply <span class=\"token string\">\"stash@&#123;2.hours.ago&#125;\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"暂存时保留未暂存的内容\"><a href=\"#暂存时保留未暂存的内容\" class=\"headerlink\" title=\"暂存时保留未暂存的内容\"></a>暂存时保留未暂存的内容</h3><p>你需要手动create一个<code>stash commit</code>， 然后使用<code>git stash store</code>。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash create\n$ git stash store <span class=\"token operator\">-</span>m <span class=\"token string\">\"commit-message\"</span> CREATED_SHA1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"杂项-Miscellaneous-Objects\"><a href=\"#杂项-Miscellaneous-Objects\" class=\"headerlink\" title=\"杂项(Miscellaneous Objects)\"></a>杂项(Miscellaneous Objects)</h2><h3 id=\"克隆所有子模块\"><a href=\"#克隆所有子模块\" class=\"headerlink\" title=\"克隆所有子模块\"></a>克隆所有子模块</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git clone <span class=\"token operator\">--</span>recursive git<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>github<span class=\"token punctuation\">.</span>com<span class=\"token operator\">/</span>foo<span class=\"token operator\">/</span>bar<span class=\"token punctuation\">.</span>git<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果已经克隆了:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git submodule update <span class=\"token operator\">--</span>init <span class=\"token operator\">--</span>recursive<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"删除标签-tag\"><a href=\"#删除标签-tag\" class=\"headerlink\" title=\"删除标签(tag)\"></a>删除标签(tag)</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git tag <span class=\"token operator\">-</span>d <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>tag_name<span class=\"token punctuation\">></span></span>\n$ git push <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>remote<span class=\"token punctuation\">></span></span> <span class=\"token operator\">:</span>refs<span class=\"token operator\">/</span>tags<span class=\"token operator\">/</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>tag_name<span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"恢复已删除标签-tag\"><a href=\"#恢复已删除标签-tag\" class=\"headerlink\" title=\"恢复已删除标签(tag)\"></a>恢复已删除标签(tag)</h3><p>如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git fsck <span class=\"token operator\">--</span>unreachable <span class=\"token operator\">|</span> grep tag<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>记下这个标签(tag)的hash，然后用Git的 update-ref</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git update<span class=\"token operator\">-</span>ref refs<span class=\"token operator\">/</span>tags<span class=\"token operator\">/</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>tag_name<span class=\"token punctuation\">></span></span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>hash<span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这时你的标签(tag)应该已经恢复了。</p>\n<h3 id=\"已删除补丁-patch\"><a href=\"#已删除补丁-patch\" class=\"headerlink\" title=\"已删除补丁(patch)\"></a>已删除补丁(patch)</h3><p>如果某人在 GitHub 上给你发了一个pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 <code>git am</code>。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。</p>\n<p>做完提交后, 再修改作者，参见变更作者。然后, 应用变化, 再发起一个新的pull request。</p>\n<h2 id=\"跟踪文件-Tracking-Files\"><a href=\"#跟踪文件-Tracking-Files\" class=\"headerlink\" title=\"跟踪文件(Tracking Files)\"></a>跟踪文件(Tracking Files)</h2><h3 id=\"我只想改变一个文件名字的大小写，而不修改内容\"><a href=\"#我只想改变一个文件名字的大小写，而不修改内容\" class=\"headerlink\" title=\"我只想改变一个文件名字的大小写，而不修改内容\"></a>我只想改变一个文件名字的大小写，而不修改内容</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git mv <span class=\"token operator\">--</span>force myfile <span class=\"token class-name\">MyFile</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我想从Git删除一个文件，但保留该文件\"><a href=\"#我想从Git删除一个文件，但保留该文件\" class=\"headerlink\" title=\"我想从Git删除一个文件，但保留该文件\"></a>我想从Git删除一个文件，但保留该文件</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git rm <span class=\"token operator\">--</span>cached log<span class=\"token punctuation\">.</span>txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"配置-Configuration\"><a href=\"#配置-Configuration\" class=\"headerlink\" title=\"配置(Configuration)\"></a>配置(Configuration)</h2><h3 id=\"我想给一些Git命令添加别名-alias\"><a href=\"#我想给一些Git命令添加别名-alias\" class=\"headerlink\" title=\"我想给一些Git命令添加别名(alias)\"></a>我想给一些Git命令添加别名(alias)</h3><p>在 OS X 和 Linux 下, 你的 Git的配置文件储存在 <code>~/.gitconfig</code>。我在<code>[alias]</code> 部分添加了一些快捷别名(和一些我容易拼写错误的)，如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span>alias<span class=\"token punctuation\">]</span>\n    a <span class=\"token operator\">=</span> add\n    amend <span class=\"token operator\">=</span> commit <span class=\"token operator\">--</span>amend\n    c <span class=\"token operator\">=</span> commit\n    ca <span class=\"token operator\">=</span> commit <span class=\"token operator\">--</span>amend\n    ci <span class=\"token operator\">=</span> commit <span class=\"token operator\">-</span>a\n    co <span class=\"token operator\">=</span> checkout\n    d <span class=\"token operator\">=</span> diff\n    dc <span class=\"token operator\">=</span> diff <span class=\"token operator\">--</span>changed\n    ds <span class=\"token operator\">=</span> diff <span class=\"token operator\">--</span>staged\n    f <span class=\"token operator\">=</span> fetch\n    loll <span class=\"token operator\">=</span> log <span class=\"token operator\">--</span>graph <span class=\"token operator\">--</span>decorate <span class=\"token operator\">--</span>pretty<span class=\"token operator\">=</span>oneline <span class=\"token operator\">--</span>abbrev<span class=\"token operator\">-</span>commit\n    m <span class=\"token operator\">=</span> merge\n    one <span class=\"token operator\">=</span> log <span class=\"token operator\">--</span>pretty<span class=\"token operator\">=</span>oneline\n    outstanding <span class=\"token operator\">=</span> rebase <span class=\"token operator\">-</span>i @<span class=\"token punctuation\">&#123;</span>u<span class=\"token punctuation\">&#125;</span>\n    s <span class=\"token operator\">=</span> status\n    unpushed <span class=\"token operator\">=</span> log @<span class=\"token punctuation\">&#123;</span>u<span class=\"token punctuation\">&#125;</span>\n    wc <span class=\"token operator\">=</span> whatchanged\n    wip <span class=\"token operator\">=</span> rebase <span class=\"token operator\">-</span>i @<span class=\"token punctuation\">&#123;</span>u<span class=\"token punctuation\">&#125;</span>\n    zap <span class=\"token operator\">=</span> fetch <span class=\"token operator\">-</span>p<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"我想缓存一个仓库-repository-的用户名和密码\"><a href=\"#我想缓存一个仓库-repository-的用户名和密码\" class=\"headerlink\" title=\"我想缓存一个仓库(repository)的用户名和密码\"></a>我想缓存一个仓库(repository)的用户名和密码</h3><p>你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推/拉(push/pull)的时候都输入，Credential helper能帮你。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git config <span class=\"token operator\">--</span>global credential<span class=\"token punctuation\">.</span>helper cache\n# <span class=\"token class-name\">Set</span> git <span class=\"token keyword\">to</span> <span class=\"token namespace\">use</span> the credential memory cache<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git config <span class=\"token operator\">--</span>global credential<span class=\"token punctuation\">.</span>helper <span class=\"token string\">'cache --timeout=3600'</span>\n# <span class=\"token class-name\">Set</span> the cache <span class=\"token keyword\">to</span> <span class=\"token namespace\">timeout</span> after <span class=\"token number\">1</span> hour <span class=\"token punctuation\">(</span>setting is in seconds<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"我不知道我做错了些什么\"><a href=\"#我不知道我做错了些什么\" class=\"headerlink\" title=\"我不知道我做错了些什么\"></a>我不知道我做错了些什么</h3><p>你把事情搞砸了：你 <code>重置(reset)</code> 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。</p>\n<p>这就是 <code>git reflog</code> 的目的， <code>reflog</code> 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次HEAD的改变, 一条新的记录就会增加到<code>reflog</code>。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reflog\n<span class=\"token number\">0</span>a2e358 HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> reset<span class=\"token operator\">:</span> moving <span class=\"token keyword\">to</span> HEAD<span class=\"token operator\">~</span><span class=\"token number\">2</span>\n<span class=\"token number\">0254</span>ea7 HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> checkout<span class=\"token operator\">:</span> moving from <span class=\"token number\">2.2</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">main</span>\nc10f740 HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> checkout<span class=\"token operator\">:</span> moving from main <span class=\"token keyword\">to</span> <span class=\"token number\">2.2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面的reflog展示了从main分支签出(checkout)到2.2 分支，然后再签回。那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 <code>HEAD@&#123;0&#125;</code>标识.</p>\n<p>如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前main上指向的提交(0254ea7)。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git reset <span class=\"token operator\">--</span>hard <span class=\"token number\">0254</span>ea7<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>然后使用git reset就可以把main改回到之前的commit，这提供了一个在历史被意外更改情况下的安全网。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<p>git对于大家应该都不太陌生，熟练使用git已经成为程序员的一项基本技能，尽管在工作中有诸如 <code>Sourcetree</code>这样牛X的客户端工具，使得合并代码变的很方便。但找工作面试和一些需彰显个人实力的场景，仍然需要我们掌握足够多的git命令。  </p>\n<p>下边我们整理了45个日常用git合代码的经典操作场景，基本覆盖了工作中的需求。  </p>\n<h3 id=\"我刚才提交了什么\"><a href=\"#我刚才提交了什么\" class=\"headerlink\" title=\"我刚才提交了什么?\"></a>我刚才提交了什么?</h3><p>如果你用 <code>git commit -a</code> 提交了一次变化(changes)，而你又不确定到底这次提交了哪些内容。你就可以用下面的命令显示当前<code>HEAD</code>上的最近一次的提交(commit):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git show<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>或者</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git log <span class=\"token operator\">-</span>n1 <span class=\"token operator\">-</span>p<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我的提交信息-commit-message-写错了\"><a href=\"#我的提交信息-commit-message-写错了\" class=\"headerlink\" title=\"我的提交信息(commit message)写错了\"></a>我的提交信息(commit message)写错了</h3><p>如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git commit <span class=\"token operator\">--</span>amend <span class=\"token operator\">--</span>only<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这会打开你的默认编辑器, 在这里你可以编辑信息. 另一方面, 你也可以用一条命令一次完成:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git commit <span class=\"token operator\">--</span>amend <span class=\"token operator\">--</span>only <span class=\"token operator\">-</span>m <span class=\"token string\">'xxxxxxx'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做。</p>\n<h3 id=\"我提交-commit-里的用户名和邮箱不对\"><a href=\"#我提交-commit-里的用户名和邮箱不对\" class=\"headerlink\" title=\"我提交(commit)里的用户名和邮箱不对\"></a>我提交(commit)里的用户名和邮箱不对</h3><p>如果这只是单个提交(commit)，修改它：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git commit <span class=\"token operator\">--</span>amend <span class=\"token operator\">--</span>author <span class=\"token string\">\"New Authorname &lt;authoremail@mydomain.com>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果你需要修改所有历史, 参考 ‘git filter-branch’的指南页.</p>\n<h3 id=\"我想从一个提交-commit-里移除一个文件\"><a href=\"#我想从一个提交-commit-里移除一个文件\" class=\"headerlink\" title=\"我想从一个提交(commit)里移除一个文件\"></a>我想从一个提交(commit)里移除一个文件</h3><p>通过下面的方法，从一个提交(commit)里移除一个文件:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git checkout HEAD<span class=\"token operator\">^</span> myfile\n$ git add <span class=\"token operator\">-</span><span class=\"token class-name\">A</span>\n$ git commit <span class=\"token operator\">--</span>amend<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>这将非常有用，当你有一个开放的补丁(open patch)，你往上面提交了一个不必要的文件，你需要强推(force push)去更新这个远程补丁。</p>\n<h3 id=\"我想删除我的的最后一次提交-commit\"><a href=\"#我想删除我的的最后一次提交-commit\" class=\"headerlink\" title=\"我想删除我的的最后一次提交(commit)\"></a>我想删除我的的最后一次提交(commit)</h3><p>如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git reset HEAD<span class=\"token operator\">^</span> <span class=\"token operator\">--</span>hard\n$ git push <span class=\"token operator\">-</span>f <span class=\"token punctuation\">[</span>remote<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>branch<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>如果你还没有推到远程, 把Git重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>soft HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 <code>git revert SHAofBadCommit</code>， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)；或者, 如果你推的这个分支是rebase-safe的 (例如：其它开发者不会从这个分支拉), 只需要使用 <code>git push -f</code>。</p>\n<h3 id=\"删除任意提交-commit\"><a href=\"#删除任意提交-commit\" class=\"headerlink\" title=\"删除任意提交(commit)\"></a>删除任意提交(commit)</h3><p>同样的警告：不到万不得已的时候不要这么做.</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git rebase <span class=\"token operator\">--</span>onto SHA1_OF_BAD_COMMIT<span class=\"token operator\">^</span> SHA1_OF_BAD_COMMIT\n$ git push <span class=\"token operator\">-</span>f <span class=\"token punctuation\">[</span>remote<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>branch<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>或者做一个 交互式rebase 删除那些你想要删除的提交(commit)里所对应的行。</p>\n<h3 id=\"我尝试推一个修正后的提交-amended-commit-到远程，但是报错：\"><a href=\"#我尝试推一个修正后的提交-amended-commit-到远程，但是报错：\" class=\"headerlink\" title=\"我尝试推一个修正后的提交(amended commit)到远程，但是报错：\"></a>我尝试推一个修正后的提交(amended commit)到远程，但是报错：</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">To</span> https<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>github<span class=\"token punctuation\">.</span>com<span class=\"token operator\">/</span>yourusername<span class=\"token operator\">/</span>repo<span class=\"token punctuation\">.</span>git\n<span class=\"token operator\">!</span> <span class=\"token punctuation\">[</span>rejected<span class=\"token punctuation\">]</span>        mybranch <span class=\"token operator\">-></span> mybranch <span class=\"token punctuation\">(</span>non<span class=\"token operator\">-</span>fast<span class=\"token operator\">-</span>forward<span class=\"token punctuation\">)</span>\nerror<span class=\"token operator\">:</span> failed <span class=\"token keyword\">to</span> <span class=\"token namespace\">push</span> some refs <span class=\"token keyword\">to</span> <span class=\"token string\">'https://github.com/tanay1337/webmaker.org.git'</span>\nhint<span class=\"token operator\">:</span> <span class=\"token class-name\">Updates</span> were rejected because the tip of your current branch is behind\nhint<span class=\"token operator\">:</span> its remote <span class=\"token class-name\"><span class=\"token namespace\">counterpart<span class=\"token punctuation\">.</span></span> Integrate</span> the remote changes <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>g<span class=\"token punctuation\">.</span>\nhint<span class=\"token operator\">:</span> <span class=\"token string\">'git pull ...'</span><span class=\"token punctuation\">)</span> before pushing again<span class=\"token punctuation\">.</span>\nhint<span class=\"token operator\">:</span> <span class=\"token class-name\">See</span> the <span class=\"token string\">'Note about fast-forwards'</span> in <span class=\"token string\">'git push --help'</span> <span class=\"token keyword\">for</span> details<span class=\"token punctuation\">.</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意, rebasing(见下面)和修正(amending)会用一个新的提交(commit)代替旧的, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (<code>-f</code>)。注意 – 总是 确保你指明一个分支!</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git push origin mybranch <span class=\"token operator\">-</span>f<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>一般来说, 要避免强推. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。</p>\n<h3 id=\"我意外的做了一次硬重置-hard-reset-，我想找回我的内容\"><a href=\"#我意外的做了一次硬重置-hard-reset-，我想找回我的内容\" class=\"headerlink\" title=\"我意外的做了一次硬重置(hard reset)，我想找回我的内容\"></a>我意外的做了一次硬重置(hard reset)，我想找回我的内容</h3><p>如果你意外的做了 <code>git reset --hard</code>, 你通常能找回你的提交(commit), 因为Git对每件事都会有日志，且都会保存几天。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reflog<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。选择你想要回到的提交(commit)的SHA，再重置一次:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard SHA1234<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这样就完成了。</p>\n<h2 id=\"暂存-Staging\"><a href=\"#暂存-Staging\" class=\"headerlink\" title=\"暂存(Staging)\"></a>暂存(Staging)</h2><h3 id=\"我需要把暂存的内容添加到上一次的提交-commit\"><a href=\"#我需要把暂存的内容添加到上一次的提交-commit\" class=\"headerlink\" title=\"我需要把暂存的内容添加到上一次的提交(commit)\"></a>我需要把暂存的内容添加到上一次的提交(commit)</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>$ git commit <span class=\"token operator\">--</span>amend<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我想要暂存一个新文件的一部分，而不是这个文件的全部\"><a href=\"#我想要暂存一个新文件的一部分，而不是这个文件的全部\" class=\"headerlink\" title=\"我想要暂存一个新文件的一部分，而不是这个文件的全部\"></a>我想要暂存一个新文件的一部分，而不是这个文件的全部</h3><p>一般来说, 如果你想暂存一个文件的一部分, 你可这样做:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git add <span class=\"token operator\">--</span>patch filename<span class=\"token punctuation\">.</span>x<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><code>-p</code> 简写。这会打开交互模式， 你将能够用 <code>s</code> 选项来分隔提交(commit)；然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时, 这样做:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git add <span class=\"token operator\">-</span><span class=\"token class-name\">N</span> filename<span class=\"token punctuation\">.</span>x<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>然后, 你需要用 <code>e</code> 选项来手动选择需要添加的行，执行 <code>git diff --cached</code> 将会显示哪些行暂存了哪些行只是保存在本地了。</p>\n<h3 id=\"我想把在一个文件里的变化-changes-加到两个提交-commit-里\"><a href=\"#我想把在一个文件里的变化-changes-加到两个提交-commit-里\" class=\"headerlink\" title=\"我想把在一个文件里的变化(changes)加到两个提交(commit)里\"></a>我想把在一个文件里的变化(changes)加到两个提交(commit)里</h3><p><code>git add</code> 会把整个文件加入到一个提交. <code>git add -p</code> 允许交互式的选择你想要提交的部分.</p>\n<h3 id=\"我想把暂存的内容变成未暂存，把未暂存的内容暂存起来\"><a href=\"#我想把暂存的内容变成未暂存，把未暂存的内容暂存起来\" class=\"headerlink\" title=\"我想把暂存的内容变成未暂存，把未暂存的内容暂存起来\"></a>我想把暂存的内容变成未暂存，把未暂存的内容暂存起来</h3><p>多数情况下，你应该将所有的内容变为未暂存，然后再选择你想要的内容进行commit。但假定你就是想要这么做，这里你可以创建一个临时的commit来保存你已暂存的内容，然后暂存你的未暂存的内容并进行stash。然后reset最后一个commit将原本暂存的内容变为未暂存，最后stash pop回来。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git commit <span class=\"token operator\">-</span>m <span class=\"token string\">\"WIP\"</span>\n$ git add <span class=\"token punctuation\">.</span>\n$ git stash\n$ git reset HEAD<span class=\"token operator\">^</span>\n$ git stash pop <span class=\"token operator\">--</span>index <span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意1: 这里使用<code>pop</code>仅仅是因为想尽可能保持幂等。注意2: 假如你不加上<code>--index</code>你会把暂存的文件标记为为存储。</p>\n<h2 id=\"未暂存-Unstaged-的内容\"><a href=\"#未暂存-Unstaged-的内容\" class=\"headerlink\" title=\"未暂存(Unstaged)的内容\"></a>未暂存(Unstaged)的内容</h2><h3 id=\"我想把未暂存的内容移动到一个新分支\"><a href=\"#我想把未暂存的内容移动到一个新分支\" class=\"headerlink\" title=\"我想把未暂存的内容移动到一个新分支\"></a>我想把未暂存的内容移动到一个新分支</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git checkout <span class=\"token operator\">-</span>b my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我想把未暂存的内容移动到另一个已存在的分支\"><a href=\"#我想把未暂存的内容移动到另一个已存在的分支\" class=\"headerlink\" title=\"我想把未暂存的内容移动到另一个已存在的分支\"></a>我想把未暂存的内容移动到另一个已存在的分支</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash\n$ git checkout my<span class=\"token operator\">-</span>branch\n$ git stash pop<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"我想丢弃本地未提交的变化-uncommitted-changes\"><a href=\"#我想丢弃本地未提交的变化-uncommitted-changes\" class=\"headerlink\" title=\"我想丢弃本地未提交的变化(uncommitted changes)\"></a>我想丢弃本地未提交的变化(uncommitted changes)</h3><p>如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"># one commit\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard HEAD<span class=\"token operator\">^</span>\n# two commits\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard HEAD<span class=\"token operator\">^</span><span class=\"token operator\">^</span>\n# four commits\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard HEAD<span class=\"token operator\">~</span><span class=\"token number\">4</span>\n# or\n<span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout <span class=\"token operator\">-</span>f<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>重置某个特殊的文件, 你可以用文件名做为参数:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git reset filename<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我想丢弃某些未暂存的内容\"><a href=\"#我想丢弃某些未暂存的内容\" class=\"headerlink\" title=\"我想丢弃某些未暂存的内容\"></a>我想丢弃某些未暂存的内容</h3><p>如果你想丢弃工作拷贝中的一部分内容，而不是全部。</p>\n<p>签出(checkout)不需要的内容，保留需要的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git checkout <span class=\"token operator\">-</span>p\n# <span class=\"token class-name\">Answer</span> y <span class=\"token keyword\">to</span> <span class=\"token namespace\">all</span> of the snippets you want <span class=\"token keyword\">to</span> <span class=\"token namespace\">drop</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>另外一个方法是使用 <code>stash</code>， Stash所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash <span class=\"token operator\">-</span>p\n# <span class=\"token class-name\">Select</span> all of the snippets you want <span class=\"token keyword\">to</span> <span class=\"token namespace\">save</span>\n$ git reset <span class=\"token operator\">--</span>hard\n$ git stash pop<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>或者, stash 你不需要的部分, 然后stash drop。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash <span class=\"token operator\">-</span>p\n# <span class=\"token class-name\">Select</span> all of the snippets you don't want <span class=\"token keyword\">to</span> <span class=\"token namespace\">save</span>\n$ git stash drop<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"分支-Branches\"><a href=\"#分支-Branches\" class=\"headerlink\" title=\"分支(Branches)\"></a>分支(Branches)</h2><h3 id=\"我从错误的分支拉取了内容，或把内容拉取到了错误的分支\"><a href=\"#我从错误的分支拉取了内容，或把内容拉取到了错误的分支\" class=\"headerlink\" title=\"我从错误的分支拉取了内容，或把内容拉取到了错误的分支\"></a>我从错误的分支拉取了内容，或把内容拉取到了错误的分支</h3><p>这是另外一种使用 <code>git reflog</code> 情况，找到在这次错误拉(pull) 之前HEAD的指向。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reflog\nab7555f HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> pull origin wrong<span class=\"token operator\">-</span>branch<span class=\"token operator\">:</span> <span class=\"token class-name\">Fast</span><span class=\"token operator\">-</span>forward\nc5bc55a HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> checkout<span class=\"token operator\">:</span> checkout message goes here<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>重置分支到你所需的提交(desired commit):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git reset <span class=\"token operator\">--</span>hard c5bc55a<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>完成。</p>\n<h3 id=\"我想扔掉本地的提交-commit-，以便我的分支与远程的保持一致\"><a href=\"#我想扔掉本地的提交-commit-，以便我的分支与远程的保持一致\" class=\"headerlink\" title=\"我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致\"></a>我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致</h3><p>先确认你没有推(push)你的内容到远程。</p>\n<p><code>git status</code> 会显示你领先(ahead)源(origin)多少个提交:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git status\n# <span class=\"token class-name\">On</span> branch my<span class=\"token operator\">-</span>branch\n# <span class=\"token class-name\">Your</span> branch is ahead of <span class=\"token string\">'origin/my-branch'</span> by <span class=\"token number\">2</span> commits<span class=\"token punctuation\">.</span>\n#   <span class=\"token punctuation\">(</span>use <span class=\"token string\">\"git push\"</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">publish</span> your local commits<span class=\"token punctuation\">)</span>\n#<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>一种方法是:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard origin<span class=\"token operator\">/</span>my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我需要提交到一个新分支，但错误的提交到了main\"><a href=\"#我需要提交到一个新分支，但错误的提交到了main\" class=\"headerlink\" title=\"我需要提交到一个新分支，但错误的提交到了main\"></a>我需要提交到一个新分支，但错误的提交到了main</h3><p>在main下创建一个新分支，不切换到新分支,仍在main下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git branch my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>把main分支重置到前一个提交:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard HEAD<span class=\"token operator\">^</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><code>HEAD^</code> 是 <code>HEAD^1</code> 的简写，你可以通过指定要设置的<code>HEAD</code>来进一步重置。</p>\n<p>或者, 如果你不想使用 <code>HEAD^</code>, 找到你想重置到的提交(commit)的hash(<code>git log</code> 能够完成)， 然后重置到这个hash。使用<code>git push</code> 同步内容到远程。</p>\n<p>例如, main分支想重置到的提交的hash为<code>a13b85e</code>:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard a13b85e\nHEAD is now at a13b85e<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>签出(checkout)刚才新建的分支继续工作:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我想保留来自另外一个ref-ish的整个文件\"><a href=\"#我想保留来自另外一个ref-ish的整个文件\" class=\"headerlink\" title=\"我想保留来自另外一个ref-ish的整个文件\"></a>我想保留来自另外一个ref-ish的整个文件</h3><p>假设你正在做一个原型方案(原文为working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容:微信搜索公众号：Java后端编程，回复：java 领取资料 。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>solution<span class=\"token punctuation\">)</span>$ git add <span class=\"token operator\">-</span><span class=\"token class-name\">A</span> <span class=\"token operator\">&amp;&amp;</span> git commit <span class=\"token operator\">-</span>m <span class=\"token string\">\"Adding all changes from this spike into one big commit.\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>当你想要把它放到一个分支里 (可能是<code>feature</code>, 或者 <code>develop</code>), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。</p>\n<p>假设你有:</p>\n<ul>\n<li> 分支 <code>solution</code>, 拥有原型方案， 领先 <code>develop</code> 分支。</li>\n<li> 分支 <code>develop</code>, 在这里你应用原型方案的一些内容。</li>\n</ul>\n<p>我去可以通过把内容拿到你的分支里，来解决这个问题:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>develop<span class=\"token punctuation\">)</span>$ git checkout solution <span class=\"token operator\">--</span> file1<span class=\"token punctuation\">.</span>txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这会把这个文件内容从分支 <code>solution</code> 拿到分支 <code>develop</code> 里来:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"># <span class=\"token class-name\">On</span> branch develop\n# <span class=\"token class-name\">Your</span> branch is up<span class=\"token operator\">-</span><span class=\"token keyword\">to</span><span class=\"token operator\">-</span>date <span class=\"token keyword\">with</span> <span class=\"token string\">'origin/develop'</span><span class=\"token punctuation\">.</span>\n# <span class=\"token class-name\">Changes</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">be</span> committed<span class=\"token operator\">:</span>\n#  <span class=\"token punctuation\">(</span>use <span class=\"token string\">\"git reset HEAD &lt;file>...\"</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">unstage</span><span class=\"token punctuation\">)</span>\n#\n#        modified<span class=\"token operator\">:</span>   file1<span class=\"token punctuation\">.</span>txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后, 正常提交。</p>\n<p>Note: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem.</p>\n<h3 id=\"我把几个提交-commit-提交到了同一个分支，而这些提交应该分布在不同的分支里\"><a href=\"#我把几个提交-commit-提交到了同一个分支，而这些提交应该分布在不同的分支里\" class=\"headerlink\" title=\"我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里\"></a>我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里</h3><p>假设你有一个<code>main</code>分支， 执行<code>git log</code>, 你看到你做过两次提交:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git log\n\ncommit e3851e817c451cc36f2e6f3049db528415e3c114\n<span class=\"token class-name\">Author</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Alex</span> <span class=\"token class-name\">Lee</span> <span class=\"token operator\">&lt;</span>alexlee<span class=\"token annotation punctuation\">@example.com</span><span class=\"token operator\">></span>\n<span class=\"token class-name\">Date</span><span class=\"token operator\">:</span>   <span class=\"token class-name\">Tue</span> <span class=\"token class-name\">Jul</span> <span class=\"token number\">22</span> <span class=\"token number\">15</span><span class=\"token operator\">:</span><span class=\"token number\">39</span><span class=\"token operator\">:</span><span class=\"token number\">27</span> <span class=\"token number\">2014</span> <span class=\"token operator\">-</span><span class=\"token number\">0400</span>\n\n    <span class=\"token class-name\">Bug</span> #<span class=\"token number\">21</span> <span class=\"token operator\">-</span> <span class=\"token class-name\">Added</span> CSRF protection\n\ncommit <span class=\"token number\">5</span>ea51731d150f7ddc4a365437931cd8be3bf3131\n<span class=\"token class-name\">Author</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Alex</span> <span class=\"token class-name\">Lee</span> <span class=\"token operator\">&lt;</span>alexlee<span class=\"token annotation punctuation\">@example.com</span><span class=\"token operator\">></span>\n<span class=\"token class-name\">Date</span><span class=\"token operator\">:</span>   <span class=\"token class-name\">Tue</span> <span class=\"token class-name\">Jul</span> <span class=\"token number\">22</span> <span class=\"token number\">15</span><span class=\"token operator\">:</span><span class=\"token number\">39</span><span class=\"token operator\">:</span><span class=\"token number\">12</span> <span class=\"token number\">2014</span> <span class=\"token operator\">-</span><span class=\"token number\">0400</span>\n\n    <span class=\"token class-name\">Bug</span> #<span class=\"token number\">14</span> <span class=\"token operator\">-</span> <span class=\"token class-name\">Fixed</span> spacing on title\n\ncommit a13b85e984171c6e2a1729bb061994525f626d14\n<span class=\"token class-name\">Author</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Aki</span> <span class=\"token class-name\">Rose</span> <span class=\"token operator\">&lt;</span>akirose<span class=\"token annotation punctuation\">@example.com</span><span class=\"token operator\">></span>\n<span class=\"token class-name\">Date</span><span class=\"token operator\">:</span>   <span class=\"token class-name\">Tue</span> <span class=\"token class-name\">Jul</span> <span class=\"token number\">21</span> <span class=\"token number\">01</span><span class=\"token operator\">:</span><span class=\"token number\">12</span><span class=\"token operator\">:</span><span class=\"token number\">48</span> <span class=\"token number\">2014</span> <span class=\"token operator\">-</span><span class=\"token number\">0400</span>\n\n    <span class=\"token class-name\">First</span> commit<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>让我们用提交hash(commit hash)标记bug (<code>e3851e8</code> for #21, <code>5ea5173</code> for #14).</p>\n<p>首先, 我们把<code>main</code>分支重置到正确的提交(<code>a13b85e</code>):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard a13b85e\nHEAD is now at a13b85e<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>现在, 我们对 bug #21 创建一个新的分支:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout <span class=\"token operator\">-</span>b <span class=\"token number\">21</span>\n<span class=\"token punctuation\">(</span><span class=\"token number\">21</span><span class=\"token punctuation\">)</span>$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>接着, 我们用 cherry-pick 把对bug #21的提交放入当前分支。这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在HEAD上面。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span><span class=\"token number\">21</span><span class=\"token punctuation\">)</span>$ git cherry<span class=\"token operator\">-</span>pick e3851e8<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这时候, 这里可能会产生冲突， 参见交互式 rebasing 章 冲突节 解决冲突.</p>\n<p>再者， 我们为bug #14 创建一个新的分支, 也基于<code>main</code>分支</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span><span class=\"token number\">21</span><span class=\"token punctuation\">)</span>$ git checkout main\n<span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout <span class=\"token operator\">-</span>b <span class=\"token number\">14</span>\n<span class=\"token punctuation\">(</span><span class=\"token number\">14</span><span class=\"token punctuation\">)</span>$<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>最后, 为 bug #14 执行 <code>cherry-pick</code>:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span><span class=\"token number\">14</span><span class=\"token punctuation\">)</span>$ git cherry<span class=\"token operator\">-</span>pick <span class=\"token number\">5</span>ea5173<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我想删除上游-upstream-分支被删除了的本地分支\"><a href=\"#我想删除上游-upstream-分支被删除了的本地分支\" class=\"headerlink\" title=\"我想删除上游(upstream)分支被删除了的本地分支\"></a>我想删除上游(upstream)分支被删除了的本地分支</h3><p>一旦你在github 上面合并(merge)了一个pull request, 你就可以删除你fork里被合并的分支。如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中（[IDEA 中玩转 Git][IDEA _ Git]）。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git fetch <span class=\"token operator\">-</span>p<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我不小心删除了我的分支\"><a href=\"#我不小心删除了我的分支\" class=\"headerlink\" title=\"我不小心删除了我的分支\"></a>我不小心删除了我的分支</h3><p>如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。让我们先创建一个分支和一个新的文件:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout <span class=\"token operator\">-</span>b my<span class=\"token operator\">-</span>branch\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git branch\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ touch foo<span class=\"token punctuation\">.</span>txt\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ ls\nREADME<span class=\"token punctuation\">.</span>md foo<span class=\"token punctuation\">.</span>txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>添加文件并做一次提交</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git add <span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git commit <span class=\"token operator\">-</span>m <span class=\"token string\">'foo.txt added'</span>\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ foo<span class=\"token punctuation\">.</span>txt added\n <span class=\"token number\">1</span> files changed<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span> <span class=\"token function\">insertions</span><span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span>\n create mode <span class=\"token number\">100644</span> foo<span class=\"token punctuation\">.</span>txt\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git log\n\ncommit <span class=\"token number\">4e3</span>cd85a670ced7cc17a2b5d8d3d809ac88d5012\n<span class=\"token class-name\">Author</span><span class=\"token operator\">:</span> siemiatj <span class=\"token operator\">&lt;</span>siemiatj<span class=\"token annotation punctuation\">@example.com</span><span class=\"token operator\">></span>\n<span class=\"token class-name\">Date</span><span class=\"token operator\">:</span>   <span class=\"token class-name\">Wed</span> <span class=\"token class-name\">Jul</span> <span class=\"token number\">30</span> <span class=\"token number\">00</span><span class=\"token operator\">:</span><span class=\"token number\">34</span><span class=\"token operator\">:</span><span class=\"token number\">10</span> <span class=\"token number\">2014</span> <span class=\"token operator\">+</span><span class=\"token number\">0200</span>\n\n    foo<span class=\"token punctuation\">.</span>txt added\n\ncommit <span class=\"token number\">69204</span>cdf0acbab201619d95ad8295928e7f411d5\n<span class=\"token class-name\">Author</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Kate</span> <span class=\"token class-name\">Hudson</span> <span class=\"token operator\">&lt;</span>katehudson<span class=\"token annotation punctuation\">@example.com</span><span class=\"token operator\">></span>\n<span class=\"token class-name\">Date</span><span class=\"token operator\">:</span>   <span class=\"token class-name\">Tue</span> <span class=\"token class-name\">Jul</span> <span class=\"token number\">29</span> <span class=\"token number\">13</span><span class=\"token operator\">:</span><span class=\"token number\">14</span><span class=\"token operator\">:</span><span class=\"token number\">46</span> <span class=\"token number\">2014</span> <span class=\"token operator\">-</span><span class=\"token number\">0400</span>\n\n    <span class=\"token class-name\">Fixes</span> #<span class=\"token number\">6</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Force</span> pushing after amending commits<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>现在我们切回到主(main)分支，‘不小心的’删除<code>my-branch</code>分支</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git checkout main\n<span class=\"token class-name\">Switched</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">branch</span> <span class=\"token string\">'main'</span>\n<span class=\"token class-name\">Your</span> branch is up<span class=\"token operator\">-</span><span class=\"token keyword\">to</span><span class=\"token operator\">-</span>date <span class=\"token keyword\">with</span> <span class=\"token string\">'origin/main'</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git branch <span class=\"token operator\">-</span><span class=\"token class-name\">D</span> my<span class=\"token operator\">-</span>branch\n<span class=\"token class-name\">Deleted</span> branch my<span class=\"token operator\">-</span>branch <span class=\"token punctuation\">(</span>was <span class=\"token number\">4e3</span>cd85<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ echo oh noes<span class=\"token punctuation\">,</span> deleted my branch<span class=\"token operator\">!</span>\noh noes<span class=\"token punctuation\">,</span> deleted my branch<span class=\"token operator\">!</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在这时候你应该想起了<code>reflog</code>, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reflog\n<span class=\"token number\">69204</span>cd HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> checkout<span class=\"token operator\">:</span> moving from my<span class=\"token operator\">-</span>branch <span class=\"token keyword\">to</span> <span class=\"token namespace\">main</span>\n<span class=\"token number\">4e3</span>cd85 HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> commit<span class=\"token operator\">:</span> foo<span class=\"token punctuation\">.</span>txt added\n<span class=\"token number\">69204</span>cd HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> checkout<span class=\"token operator\">:</span> moving from main <span class=\"token keyword\">to</span> <span class=\"token namespace\">my</span><span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>正如你所见，我们有一个来自删除分支的提交hash(commit hash)，接下来看看是否能恢复删除了的分支。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout <span class=\"token operator\">-</span>b my<span class=\"token operator\">-</span>branch<span class=\"token operator\">-</span>help\n<span class=\"token class-name\">Switched</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">a</span> <span class=\"token keyword\">new</span> branch <span class=\"token string\">'my-branch-help'</span>\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token operator\">-</span>help<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard <span class=\"token number\">4e3</span>cd85\nHEAD is now at <span class=\"token number\">4e3</span>cd85 foo<span class=\"token punctuation\">.</span>txt added\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token operator\">-</span>help<span class=\"token punctuation\">)</span>$ ls\nREADME<span class=\"token punctuation\">.</span>md foo<span class=\"token punctuation\">.</span>txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看! 我们把删除的文件找回来了。Git的 <code>reflog</code> 在rebasing出错的时候也是同样有用的。</p>\n<h3 id=\"我想删除一个分支\"><a href=\"#我想删除一个分支\" class=\"headerlink\" title=\"我想删除一个分支\"></a>我想删除一个分支</h3><p>删除一个远程分支:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git push origin <span class=\"token operator\">--</span>delete my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>你也可以:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git push origin <span class=\"token operator\">:</span>my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>删除一个本地分支:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git branch <span class=\"token operator\">-</span><span class=\"token class-name\">D</span> my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我想从别人正在工作的远程分支签出-checkout-一个分支\"><a href=\"#我想从别人正在工作的远程分支签出-checkout-一个分支\" class=\"headerlink\" title=\"我想从别人正在工作的远程分支签出(checkout)一个分支\"></a>我想从别人正在工作的远程分支签出(checkout)一个分支</h3><p>首先, 从远程拉取(fetch) 所有分支:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git fetch <span class=\"token operator\">--</span>all<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>假设你想要从远程的<code>daves</code>分支签出到本地的<code>daves</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout <span class=\"token operator\">--</span>track origin<span class=\"token operator\">/</span>daves\n<span class=\"token class-name\">Branch</span> daves set up <span class=\"token keyword\">to</span> <span class=\"token namespace\">track</span> remote branch daves from <span class=\"token class-name\"><span class=\"token namespace\">origin<span class=\"token punctuation\">.</span></span>\nSwitched</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">a</span> <span class=\"token keyword\">new</span> branch <span class=\"token string\">'daves'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>(<code>--track</code> 是 <code>git checkout -b [branch] [remotename]/[branch]</code> 的简写)</p>\n<p>这样就得到了一个<code>daves</code>分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到.</p>\n<h2 id=\"Rebasing-和合并-Merging\"><a href=\"#Rebasing-和合并-Merging\" class=\"headerlink\" title=\"Rebasing 和合并(Merging)\"></a>Rebasing 和合并(Merging)</h2><h3 id=\"我想撤销rebase-merge\"><a href=\"#我想撤销rebase-merge\" class=\"headerlink\" title=\"我想撤销rebase/merge\"></a>我想撤销rebase/merge</h3><p>你可以合并(merge)或rebase了一个错误的分支, 或者完成不了一个进行中的rebase/merge。Git 在进行危险操作的时候会把原始的HEAD保存在一个叫ORIG_HEAD的变量里, 所以要把分支恢复到rebase/merge前的状态是很容易的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>hard ORIG_HEAD<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我已经rebase过-但是我不想强推-force-push\"><a href=\"#我已经rebase过-但是我不想强推-force-push\" class=\"headerlink\" title=\"我已经rebase过, 但是我不想强推(force push)\"></a>我已经rebase过, 但是我不想强推(force push)</h3><p>不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。是因你快进(Fast forward)了提交，改变了Git历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git checkout my<span class=\"token operator\">-</span>branch\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git rebase <span class=\"token operator\">-</span>i main\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git checkout main\n<span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git merge <span class=\"token operator\">--</span>ff<span class=\"token operator\">-</span>only my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"我需要组合-combine-几个提交-commit\"><a href=\"#我需要组合-combine-几个提交-commit\" class=\"headerlink\" title=\"我需要组合(combine)几个提交(commit)\"></a>我需要组合(combine)几个提交(commit)</h3><p>假设你的工作分支将会做对于 <code>main</code> 的pull-request。一般情况下你不关心提交(commit)的时间戳，只想组合 所有 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。确保主(main)分支是最新的和你的变化都已经提交了, 然后:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git reset <span class=\"token operator\">--</span>soft main\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git commit <span class=\"token operator\">-</span>am <span class=\"token string\">\"New awesome feature\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>如果你想要更多的控制, 想要保留时间戳, 你需要做交互式rebase (interactive rebase):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git rebase <span class=\"token operator\">-</span>i main<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果没有相对的其它分支， 你将不得不相对自己的<code>HEAD</code> 进行 rebase。例如：你想组合最近的两次提交(commit), 你将相对于<code>HEAD~2</code> 进行rebase， 组合最近3次提交(commit), 相对于<code>HEAD~3</code>, 等等。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git rebase <span class=\"token operator\">-</span>i HEAD<span class=\"token operator\">~</span><span class=\"token number\">2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>在你执行了交互式 rebase的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">pick a9c8a1d <span class=\"token class-name\">Some</span> refactoring\npick <span class=\"token number\">01</span>b2fd8 <span class=\"token class-name\">New</span> awesome feature\npick b729ad5 fixup\npick e3851e8 another fix\n\n# <span class=\"token class-name\">Rebase</span> <span class=\"token number\">8074d</span><span class=\"token number\">12.</span><span class=\"token punctuation\">.</span>b729ad5 onto <span class=\"token number\">8074d</span><span class=\"token number\">12</span>\n#\n# <span class=\"token class-name\">Commands</span><span class=\"token operator\">:</span>\n#  p<span class=\"token punctuation\">,</span> pick <span class=\"token operator\">=</span> use commit\n#  r<span class=\"token punctuation\">,</span> reword <span class=\"token operator\">=</span> use commit<span class=\"token punctuation\">,</span> but edit the commit message\n#  e<span class=\"token punctuation\">,</span> edit <span class=\"token operator\">=</span> use commit<span class=\"token punctuation\">,</span> but stop <span class=\"token keyword\">for</span> amending\n#  s<span class=\"token punctuation\">,</span> squash <span class=\"token operator\">=</span> use commit<span class=\"token punctuation\">,</span> but meld into previous commit\n#  f<span class=\"token punctuation\">,</span> fixup <span class=\"token operator\">=</span> like <span class=\"token string\">\"squash\"</span><span class=\"token punctuation\">,</span> but discard <span class=\"token keyword\">this</span> commit's log message\n#  x<span class=\"token punctuation\">,</span> exec <span class=\"token operator\">=</span> run command <span class=\"token punctuation\">(</span>the rest of the line<span class=\"token punctuation\">)</span> using shell\n#\n# <span class=\"token class-name\">These</span> lines can be re<span class=\"token operator\">-</span>ordered<span class=\"token punctuation\">;</span> they are executed from top <span class=\"token keyword\">to</span> <span class=\"token namespace\">bottom<span class=\"token punctuation\">.</span></span>\n#\n# <span class=\"token class-name\">If</span> you remove a line here THAT COMMIT WILL BE LOST<span class=\"token punctuation\">.</span>\n#\n# <span class=\"token class-name\">However</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">if</span> you remove everything<span class=\"token punctuation\">,</span> the rebase will be aborted<span class=\"token punctuation\">.</span>\n#\n# <span class=\"token class-name\">Note</span> that empty commits are commented out<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>所有以 <code>#</code> 开头的行都是注释, 不会影响 rebase.</p>\n<p>然后，你可以用任何上面命令列表的命令替换 <code>pick</code>, 你也可以通过删除对应的行来删除一个提交(commit)。</p>\n<p>例如, 如果你想 单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 <code>f</code>:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">pick a9c8a1d <span class=\"token class-name\">Some</span> refactoring\npick <span class=\"token number\">01</span>b2fd8 <span class=\"token class-name\">New</span> awesome feature\nf b729ad5 fixup\nf e3851e8 another fix<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果你想组合这些提交(commit) 并重命名这个提交(commit), 你应该在第二个提交(commit)旁边添加一个<code>r</code>，或者更简单的用<code>s</code> 替代 <code>f</code>:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">pick a9c8a1d <span class=\"token class-name\">Some</span> refactoring\npick <span class=\"token number\">01</span>b2fd8 <span class=\"token class-name\">New</span> awesome feature\ns b729ad5 fixup\ns e3851e8 another fix<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>你可以在接下来弹出的文本提示框里重命名提交(commit)。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Newer</span><span class=\"token punctuation\">,</span> awesomer features\n\n# <span class=\"token class-name\">Please</span> enter the commit message <span class=\"token keyword\">for</span> your <span class=\"token class-name\"><span class=\"token namespace\">changes<span class=\"token punctuation\">.</span></span> Lines</span> starting\n# <span class=\"token keyword\">with</span> <span class=\"token string\">'#'</span> will be ignored<span class=\"token punctuation\">,</span> and an empty message aborts the commit<span class=\"token punctuation\">.</span>\n# rebase in progress<span class=\"token punctuation\">;</span> onto <span class=\"token number\">8074d</span><span class=\"token number\">12</span>\n# <span class=\"token class-name\">You</span> are currently editing a commit <span class=\"token keyword\">while</span> rebasing branch <span class=\"token string\">'main'</span> on <span class=\"token string\">'8074d12'</span><span class=\"token punctuation\">.</span>\n#\n# <span class=\"token class-name\">Changes</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">be</span> committed<span class=\"token operator\">:</span>\n#\tmodified<span class=\"token operator\">:</span>   README<span class=\"token punctuation\">.</span>md\n#<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果成功了, 你应该看到类似下面的内容:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ <span class=\"token class-name\">Successfully</span> rebased and updated refs<span class=\"token operator\">/</span>heads<span class=\"token operator\">/</span>main<span class=\"token punctuation\">.</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"安全合并-merging-策略\"><a href=\"#安全合并-merging-策略\" class=\"headerlink\" title=\"安全合并(merging)策略\"></a>安全合并(merging)策略</h4><p><code>--no-commit</code> 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。<code>no-ff</code> 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致（更多Git资料，参见[IDEA 中如何完成 Git 版本回退？][IDEA _ Git 1]）。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git merge <span class=\"token operator\">--</span>no<span class=\"token operator\">-</span>ff <span class=\"token operator\">--</span>no<span class=\"token operator\">-</span>commit my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"我需要将一个分支合并成一个提交-commit\"><a href=\"#我需要将一个分支合并成一个提交-commit\" class=\"headerlink\" title=\"我需要将一个分支合并成一个提交(commit)\"></a>我需要将一个分支合并成一个提交(commit)</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git merge <span class=\"token operator\">--</span>squash my<span class=\"token operator\">-</span>branch<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"我只想组合-combine-未推的提交-unpushed-commit\"><a href=\"#我只想组合-combine-未推的提交-unpushed-commit\" class=\"headerlink\" title=\"我只想组合(combine)未推的提交(unpushed commit)\"></a>我只想组合(combine)未推的提交(unpushed commit)</h4><p>有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git rebase <span class=\"token operator\">-</span>i @<span class=\"token punctuation\">&#123;</span>u<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这会产生一次交互式的rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行reorder/fix/squash 都是安全的。</p>\n<h3 id=\"检查是否分支上的所有提交-commit-都合并-merge-过了\"><a href=\"#检查是否分支上的所有提交-commit-都合并-merge-过了\" class=\"headerlink\" title=\"检查是否分支上的所有提交(commit)都合并(merge)过了\"></a>检查是否分支上的所有提交(commit)都合并(merge)过了</h3><p>检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的head(或任何 commits)之间做一次diff:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git log <span class=\"token operator\">--</span>graph <span class=\"token operator\">--</span>left<span class=\"token operator\">-</span>right <span class=\"token operator\">--</span>cherry<span class=\"token operator\">-</span>pick <span class=\"token operator\">--</span>oneline HEAD<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>feature<span class=\"token operator\">/</span><span class=\"token number\">120</span><span class=\"token operator\">-</span>on<span class=\"token operator\">-</span>scroll<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。另一个做法可以是:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git log main <span class=\"token operator\">^</span>feature<span class=\"token operator\">/</span><span class=\"token number\">120</span><span class=\"token operator\">-</span>on<span class=\"token operator\">-</span>scroll <span class=\"token operator\">--</span>no<span class=\"token operator\">-</span>merges<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"交互式rebase-interactive-rebase-可能出现的问题\"><a href=\"#交互式rebase-interactive-rebase-可能出现的问题\" class=\"headerlink\" title=\"交互式rebase(interactive rebase)可能出现的问题\"></a>交互式rebase(interactive rebase)可能出现的问题</h3><h4 id=\"这个rebase-编辑屏幕出现’noop’\"><a href=\"#这个rebase-编辑屏幕出现’noop’\" class=\"headerlink\" title=\"这个rebase 编辑屏幕出现’noop’\"></a>这个rebase 编辑屏幕出现’noop’</h4><p>如果你看到的是这样:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">noop<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这意味着你rebase的分支和当前分支在同一个提交(commit)上, 或者 领先(ahead) 当前分支。你可以尝试:</p>\n<ul>\n<li> 检查确保主(main)分支没有问题</li>\n<li> rebase <code>HEAD~2</code> 或者更早</li>\n</ul>\n<h4 id=\"有冲突的情况\"><a href=\"#有冲突的情况\" class=\"headerlink\" title=\"有冲突的情况\"></a>有冲突的情况</h4><p>如果你不能成功的完成rebase, 你可能必须要解决冲突。</p>\n<p>首先执行 <code>git status</code> 找出哪些文件有冲突:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git status\n<span class=\"token class-name\">On</span> branch my<span class=\"token operator\">-</span>branch\n<span class=\"token class-name\">Changes</span> not staged <span class=\"token keyword\">for</span> commit<span class=\"token operator\">:</span>\n  <span class=\"token punctuation\">(</span>use <span class=\"token string\">\"git add &lt;file>...\"</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">update</span> what will be committed<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">(</span>use <span class=\"token string\">\"git checkout -- &lt;file>...\"</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">discard</span> changes in working directory<span class=\"token punctuation\">)</span>\n\n modified<span class=\"token operator\">:</span>   README<span class=\"token punctuation\">.</span>md<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在这个例子里面, <code>README.md</code> 有冲突。打开这个文件找到类似下面的内容:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token operator\">&lt;&lt;</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token operator\">&lt;</span> HEAD\n   some code\n   <span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>\n   some code\n   <span class=\"token operator\">>>></span><span class=\"token operator\">>>></span><span class=\"token operator\">></span> <span class=\"token keyword\">new</span><span class=\"token operator\">-</span>commit<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>你需要解决新提交的代码(示例里, 从中间<code>==</code>线到<code>new-commit</code>的地方)与<code>HEAD</code> 之间不一样的地方.</p>\n<p>有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>$ git mergetool <span class=\"token operator\">-</span>t opendiff<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>在你解决完所有冲突和测试过后, <code>git add</code> 变化了的(changed)文件, 然后用<code>git rebase --continue</code> 继续rebase。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git add README<span class=\"token punctuation\">.</span>md\n<span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git rebase <span class=\"token operator\">--</span><span class=\"token keyword\">continue</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行<code>git rebase --skip</code>。</p>\n<p>任何时候你想结束整个rebase 过程，回来rebase前的分支状态, 你可以做:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>my<span class=\"token operator\">-</span>branch<span class=\"token punctuation\">)</span>$ git rebase <span class=\"token operator\">--</span>abort<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"Stash\"><a href=\"#Stash\" class=\"headerlink\" title=\"Stash\"></a>Stash</h2><h3 id=\"暂存所有改动\"><a href=\"#暂存所有改动\" class=\"headerlink\" title=\"暂存所有改动\"></a>暂存所有改动</h3><p>暂存你工作目录下的所有改动</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>你可以使用<code>-u</code>来排除一些文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash <span class=\"token operator\">-</span>u<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"暂存指定文件\"><a href=\"#暂存指定文件\" class=\"headerlink\" title=\"暂存指定文件\"></a>暂存指定文件</h3><p>假设你只想暂存某一个文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash push working<span class=\"token operator\">-</span>directory<span class=\"token operator\">-</span>path<span class=\"token operator\">/</span>filename<span class=\"token punctuation\">.</span>ext<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>假设你想暂存多个文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash push working<span class=\"token operator\">-</span>directory<span class=\"token operator\">-</span>path<span class=\"token operator\">/</span>filename1<span class=\"token punctuation\">.</span>ext working<span class=\"token operator\">-</span>directory<span class=\"token operator\">-</span>path<span class=\"token operator\">/</span>filename2<span class=\"token punctuation\">.</span>ext<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"暂存时记录消息\"><a href=\"#暂存时记录消息\" class=\"headerlink\" title=\"暂存时记录消息\"></a>暂存时记录消息</h3><p>这样你可以在<code>list</code>时看到它</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash save <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>message<span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>或</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash push <span class=\"token operator\">-</span>m <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>message<span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"使用某个指定暂存\"><a href=\"#使用某个指定暂存\" class=\"headerlink\" title=\"使用某个指定暂存\"></a>使用某个指定暂存</h3><p>首先你可以查看你的<code>stash</code>记录</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash list<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>然后你可以<code>apply</code>某个<code>stash</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash apply <span class=\"token string\">\"stash@&#123;n&#125;\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>此处， ‘n’是<code>stash</code>在栈中的位置，最上层的<code>stash</code>会是0</p>\n<p>除此之外，也可以使用时间标记(假如你能记得的话)。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash apply <span class=\"token string\">\"stash@&#123;2.hours.ago&#125;\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"暂存时保留未暂存的内容\"><a href=\"#暂存时保留未暂存的内容\" class=\"headerlink\" title=\"暂存时保留未暂存的内容\"></a>暂存时保留未暂存的内容</h3><p>你需要手动create一个<code>stash commit</code>， 然后使用<code>git stash store</code>。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git stash create\n$ git stash store <span class=\"token operator\">-</span>m <span class=\"token string\">\"commit-message\"</span> CREATED_SHA1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"杂项-Miscellaneous-Objects\"><a href=\"#杂项-Miscellaneous-Objects\" class=\"headerlink\" title=\"杂项(Miscellaneous Objects)\"></a>杂项(Miscellaneous Objects)</h2><h3 id=\"克隆所有子模块\"><a href=\"#克隆所有子模块\" class=\"headerlink\" title=\"克隆所有子模块\"></a>克隆所有子模块</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git clone <span class=\"token operator\">--</span>recursive git<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>github<span class=\"token punctuation\">.</span>com<span class=\"token operator\">/</span>foo<span class=\"token operator\">/</span>bar<span class=\"token punctuation\">.</span>git<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果已经克隆了:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git submodule update <span class=\"token operator\">--</span>init <span class=\"token operator\">--</span>recursive<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"删除标签-tag\"><a href=\"#删除标签-tag\" class=\"headerlink\" title=\"删除标签(tag)\"></a>删除标签(tag)</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git tag <span class=\"token operator\">-</span>d <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>tag_name<span class=\"token punctuation\">></span></span>\n$ git push <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>remote<span class=\"token punctuation\">></span></span> <span class=\"token operator\">:</span>refs<span class=\"token operator\">/</span>tags<span class=\"token operator\">/</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>tag_name<span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"恢复已删除标签-tag\"><a href=\"#恢复已删除标签-tag\" class=\"headerlink\" title=\"恢复已删除标签(tag)\"></a>恢复已删除标签(tag)</h3><p>如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag):</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git fsck <span class=\"token operator\">--</span>unreachable <span class=\"token operator\">|</span> grep tag<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>记下这个标签(tag)的hash，然后用Git的 update-ref</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git update<span class=\"token operator\">-</span>ref refs<span class=\"token operator\">/</span>tags<span class=\"token operator\">/</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>tag_name<span class=\"token punctuation\">></span></span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span>hash<span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这时你的标签(tag)应该已经恢复了。</p>\n<h3 id=\"已删除补丁-patch\"><a href=\"#已删除补丁-patch\" class=\"headerlink\" title=\"已删除补丁(patch)\"></a>已删除补丁(patch)</h3><p>如果某人在 GitHub 上给你发了一个pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 <code>git am</code>。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。</p>\n<p>做完提交后, 再修改作者，参见变更作者。然后, 应用变化, 再发起一个新的pull request。</p>\n<h2 id=\"跟踪文件-Tracking-Files\"><a href=\"#跟踪文件-Tracking-Files\" class=\"headerlink\" title=\"跟踪文件(Tracking Files)\"></a>跟踪文件(Tracking Files)</h2><h3 id=\"我只想改变一个文件名字的大小写，而不修改内容\"><a href=\"#我只想改变一个文件名字的大小写，而不修改内容\" class=\"headerlink\" title=\"我只想改变一个文件名字的大小写，而不修改内容\"></a>我只想改变一个文件名字的大小写，而不修改内容</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git mv <span class=\"token operator\">--</span>force myfile <span class=\"token class-name\">MyFile</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"我想从Git删除一个文件，但保留该文件\"><a href=\"#我想从Git删除一个文件，但保留该文件\" class=\"headerlink\" title=\"我想从Git删除一个文件，但保留该文件\"></a>我想从Git删除一个文件，但保留该文件</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git rm <span class=\"token operator\">--</span>cached log<span class=\"token punctuation\">.</span>txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"配置-Configuration\"><a href=\"#配置-Configuration\" class=\"headerlink\" title=\"配置(Configuration)\"></a>配置(Configuration)</h2><h3 id=\"我想给一些Git命令添加别名-alias\"><a href=\"#我想给一些Git命令添加别名-alias\" class=\"headerlink\" title=\"我想给一些Git命令添加别名(alias)\"></a>我想给一些Git命令添加别名(alias)</h3><p>在 OS X 和 Linux 下, 你的 Git的配置文件储存在 <code>~/.gitconfig</code>。我在<code>[alias]</code> 部分添加了一些快捷别名(和一些我容易拼写错误的)，如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span>alias<span class=\"token punctuation\">]</span>\n    a <span class=\"token operator\">=</span> add\n    amend <span class=\"token operator\">=</span> commit <span class=\"token operator\">--</span>amend\n    c <span class=\"token operator\">=</span> commit\n    ca <span class=\"token operator\">=</span> commit <span class=\"token operator\">--</span>amend\n    ci <span class=\"token operator\">=</span> commit <span class=\"token operator\">-</span>a\n    co <span class=\"token operator\">=</span> checkout\n    d <span class=\"token operator\">=</span> diff\n    dc <span class=\"token operator\">=</span> diff <span class=\"token operator\">--</span>changed\n    ds <span class=\"token operator\">=</span> diff <span class=\"token operator\">--</span>staged\n    f <span class=\"token operator\">=</span> fetch\n    loll <span class=\"token operator\">=</span> log <span class=\"token operator\">--</span>graph <span class=\"token operator\">--</span>decorate <span class=\"token operator\">--</span>pretty<span class=\"token operator\">=</span>oneline <span class=\"token operator\">--</span>abbrev<span class=\"token operator\">-</span>commit\n    m <span class=\"token operator\">=</span> merge\n    one <span class=\"token operator\">=</span> log <span class=\"token operator\">--</span>pretty<span class=\"token operator\">=</span>oneline\n    outstanding <span class=\"token operator\">=</span> rebase <span class=\"token operator\">-</span>i @<span class=\"token punctuation\">&#123;</span>u<span class=\"token punctuation\">&#125;</span>\n    s <span class=\"token operator\">=</span> status\n    unpushed <span class=\"token operator\">=</span> log @<span class=\"token punctuation\">&#123;</span>u<span class=\"token punctuation\">&#125;</span>\n    wc <span class=\"token operator\">=</span> whatchanged\n    wip <span class=\"token operator\">=</span> rebase <span class=\"token operator\">-</span>i @<span class=\"token punctuation\">&#123;</span>u<span class=\"token punctuation\">&#125;</span>\n    zap <span class=\"token operator\">=</span> fetch <span class=\"token operator\">-</span>p<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"我想缓存一个仓库-repository-的用户名和密码\"><a href=\"#我想缓存一个仓库-repository-的用户名和密码\" class=\"headerlink\" title=\"我想缓存一个仓库(repository)的用户名和密码\"></a>我想缓存一个仓库(repository)的用户名和密码</h3><p>你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推/拉(push/pull)的时候都输入，Credential helper能帮你。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git config <span class=\"token operator\">--</span>global credential<span class=\"token punctuation\">.</span>helper cache\n# <span class=\"token class-name\">Set</span> git <span class=\"token keyword\">to</span> <span class=\"token namespace\">use</span> the credential memory cache<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git config <span class=\"token operator\">--</span>global credential<span class=\"token punctuation\">.</span>helper <span class=\"token string\">'cache --timeout=3600'</span>\n# <span class=\"token class-name\">Set</span> the cache <span class=\"token keyword\">to</span> <span class=\"token namespace\">timeout</span> after <span class=\"token number\">1</span> hour <span class=\"token punctuation\">(</span>setting is in seconds<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"我不知道我做错了些什么\"><a href=\"#我不知道我做错了些什么\" class=\"headerlink\" title=\"我不知道我做错了些什么\"></a>我不知道我做错了些什么</h3><p>你把事情搞砸了：你 <code>重置(reset)</code> 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。</p>\n<p>这就是 <code>git reflog</code> 的目的， <code>reflog</code> 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次HEAD的改变, 一条新的记录就会增加到<code>reflog</code>。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span>main<span class=\"token punctuation\">)</span>$ git reflog\n<span class=\"token number\">0</span>a2e358 HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> reset<span class=\"token operator\">:</span> moving <span class=\"token keyword\">to</span> HEAD<span class=\"token operator\">~</span><span class=\"token number\">2</span>\n<span class=\"token number\">0254</span>ea7 HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> checkout<span class=\"token operator\">:</span> moving from <span class=\"token number\">2.2</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">main</span>\nc10f740 HEAD@<span class=\"token punctuation\">&#123;</span><span class=\"token number\">2</span><span class=\"token punctuation\">&#125;</span><span class=\"token operator\">:</span> checkout<span class=\"token operator\">:</span> moving from main <span class=\"token keyword\">to</span> <span class=\"token number\">2.2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面的reflog展示了从main分支签出(checkout)到2.2 分支，然后再签回。那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 <code>HEAD@&#123;0&#125;</code>标识.</p>\n<p>如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前main上指向的提交(0254ea7)。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">$ git reset <span class=\"token operator\">--</span>hard <span class=\"token number\">0254</span>ea7<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>然后使用git reset就可以把main改回到之前的commit，这提供了一个在历史被意外更改情况下的安全网。</p>\n"},{"title":"Java基础篇的八股文","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-11-04T05:16:06.000Z","password":null,"summary":"java语言具有哪些特点？","_content":"### Java 语言具有哪些特点？ \n\n *  Java 为纯面向对象的语言。它能够直接反应现实生活中的对象。\n *  具有平台无关性。Java 利用 Java 虚拟机运行字节码，无论是在 Windows、Linux 还是 MacOS 等其它平台对 Java 程序进行编译，编译后的程序可在其它平台运行。\n *  Java 为解释型语言，编译器把 Java 代码编译成平台无关的中间代码，然后在 JVM 上解释运行，具有很好的可移植性。\n *  Java 提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收器。\n *  Java 具有较好的安全性和健壮性。Java 提供了异常处理和垃圾回收机制，去除了 C++中难以理解的指针特性。\n\n### JDK 与 JRE 有什么区别？ \n\n *  JDK：Java 开发工具包（Java Development Kit），提供了 Java 的开发环境和运行环境。\n *  JRE：Java 运行环境(Java Runtime Environment)，提供了 Java 运行所需的环境。\n *  JDK 包含了 JRE。如果只运行 Java 程序，安装 JRE 即可。要编写 Java 程序需安装 JDK.\n\n### 简述 Java 基本数据类型 \n\n *  byte: 占用 1 个字节，取值范围-128 ~ 127\n *  short: 占用 2 个字节，取值范围-2^15^ ~ 2^15^-1\n *  int：占用 4 个字节，取值范围-2^31^ ~ 2^31^-1\n *  long：占用 8 个字节\n *  float：占用 4 个字节\n *  double：占用 8 个字节\n *  char: 占用 2 个字节\n *  boolean：占用大小根据实现虚拟机不同有所差异\n\n### 简述自动装箱拆箱 \n\n对于 Java 基本数据类型，均对应一个包装类。\n\n装箱就是自动将基本数据类型转换为包装器类型，如 int->Integer\n\n拆箱就是自动将包装器类型转换为基本数据类型，如 Integer->int\n\n### 简述 Java 访问修饰符 \n\n *  default: 默认访问修饰符，在同一包内可见\n *  private: 在同一类内可见，不能修饰类\n *  protected : 对同一包内的类和所有子类可见，不能修饰类\n *  public: 对所有类可见\n\n### 构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？ \n\n先后顺序：静态成员变量、成员变量、构造方法。\n\n详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。\n\n### Java 代码块执行顺序 \n\n *  父类静态代码块（只执行一次）\n *  子类静态代码块（只执行一次）\n *  父类构造代码块\n *  父类构造函数\n *  子类构造代码块\n *  子类构造函数\n *  普通代码块\n\n### 面向对象的三大特性？ \n\n继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且派生类可以修改或新增新的方法使之更适合特殊的需求。\n\n封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。\n\n多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现行为是不一样的。\n\n### 为什么 Java 语言不支持多重继承？ \n\n为了程序的结构能够更加清晰从而便于维护。假设 Java 语言支持多重继承，类 C 继承自类 A 和类 B，如果类 A 和 B 都有自定义的成员方法 `f()`，那么当代码中调用类 C 的 `f()` 会产生二义性。\n\nJava 语言通过实现多个接口间接支持多重继承，接口由于只包含方法定义，不能有方法的实现，类 C 继承接口 A 与接口 B 时即使它们都有方法`f()`，也不能直接调用方法，需实现具体的`f()`方法才能调用，不会产生二义性。\n\n多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。\n\n### 简述 Java 的多态 \n\nJava 多态可以分为编译时多态和运行时多态。\n\n编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。\n\n运行时多态主要指继承父类和实现接口时，可使用父类引用指向子类对象。\n\n运行时多态的实现：主要依靠方法表，方法表中最先存放的是 Object 类的方法，接下来是该类的父类的方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个方法表项，都被认作是父类的方法。因此可以实现运行时多态。\n\n### Java 提供的多态机制？ \n\nJava 提供了两种用于多态的机制，分别是重载与覆盖。\n\n重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定调用哪个方法。\n\n覆盖：覆盖是指派生类重写基类的方法，使用基类指向其子类的实例对象，或接口的引用变量指向其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个对象的方法，即需要到运行期才能确定调用哪个方法。\n\n### 重载与覆盖的区别？ \n\n *  覆盖是父类与子类之间的关系，是垂直关系；重载是同一类中方法之间的关系，是水平关系。\n *  覆盖只能由一个方法或一对方法产生关系；重载是多个方法之间的关系。\n *  覆盖要求参数列表相同；重载要求参数列表不同。\n *  覆盖中，调用方法体是根据对象的类型来决定的，而重载是根据调用时实参表与形参表来对应选择方法体。\n *  重载方法可以改变返回值的类型，覆盖方法不能改变返回值的类型。\n\n### 接口和抽象类的相同点和不同点？ \n\n相同点:\n\n *  都不能被实例化。\n *  接口的实现类或抽象类的子类需实现接口或抽象类中相应的方法才能被实例化。\n\n不同点：\n\n *  接口只能有方法定义，不能有方法的实现，而抽象类可以有方法的定义与实现。\n *  实现接口的关键字为 implements，继承抽象类的关键字为 extends。一个类可以实现多个接口，只能继承一个抽象类。\n *  当子类和父类之间存在逻辑上的层次结构，推荐使用抽象类，有利于功能的累积。当功能不需要，希望支持差别较大的两个或更多对象间的特定交互行为，推荐使用接口。使用接口能降低软件系统的耦合度，便于日后维护或添加删除方法。\n\n### 简述抽象类与接口的区别 \n\n抽象类：体现的是 is-a 的关系，如对于 man is a person，就可以将 person 定义为抽象类。\n\n接口：体现的是 can 的关系。是作为模板实现的。如设置接口 fly，plane 类和 bird 类均可实现该接口。\n\n一个类只能继承一个抽象类，但可以实现多个接口。\n\n### 简述内部类及其作用 \n\n *  成员内部类：作为成员对象的内部类。可以访问 private 及以上外部类的属性和方法。外部类想要访问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法。外部类也可访问 private 修饰的内部类属性。\n *  局部内部类：存在于方法中的内部类。访问权限类似局部变量，只能访问外部类的 final 变量。\n *  匿名内部类：只能使用一次，没有类名，只能访问外部类的 final 变量。\n *  静态内部类：类似类的静态成员变量。\n\n### Java 语言中关键字 static 的作用是什么？ \n\nstatic 的主要作用有两个：\n\n *  为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。\n *  使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法或使用类的属性。\n\n具体而言 static 又可分为 4 种使用方式：\n\n *  修饰成员变量。用 static 关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加载，这个静态变量就会被分配空间，可以使用“类.静态变量”和“对象.静态变量”的方法使用。\n *  修饰成员方法。static 修饰的方法无需创建对象就可以被调用。static 方法中不能使用 this 和 super 关键字，不能调用非 static 方法，只能访问所属类的静态成员变量和静态成员方法。\n *  修饰代码块。JVM 在加载类的时候会执行 static 代码块。static 代码块常用于初始化静态变量。static 代码块只会被执行一次。\n *  修饰内部类。static 内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法。\n\n### 为什么要把 String 设计为不可变？ \n\n *  节省空间：字符串常量存储在 JVM 的字符串池中可以被用户共享。\n *  提高效率：String 可以被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。\n *  安全：String 常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修改。\n\n### 简述 String/StringBuffer 与 StringBuilder \n\nString 类采用利用 final 修饰的字符数组进行字符串保存，因此不可变。如果对 String 类型对象修改，需要新建对象，将老字符和新增加的字符一并存进去。\n\nStringBuilder，采用无 final 修饰的字符数组进行保存，因此可变。但线程不安全。\n\nStringBuffer，采用无 final 修饰的字符数组进行保存，可理解为实现线程安全的 StringBuilder。\n\n### 判等运算符==与 equals 的区别？ \n\n== 比较的是引用，equals 比较的是内容。\n\n如果变量是基础数据类型，== 用于比较其对应值是否相等。如果变量指向的是对象，== 用于比较两个对象是否指向同一块存储空间。\n\nequals 是 Object 类提供的方法之一，每个 Java 类都继承自 Object 类，所以每个对象都具有 equals 这个方法。Object 类中定义的 equals 方法内部是直接调用 == 比较对象的。但通过覆盖的方法可以让它不是比较引用而是比较数据内容。\n\n### 简述 Object 类常用方法 \n\n *  hashCode：通过对象计算出的散列码。用于 map 型或 equals 方法。需要保证同一个对象多次调用该方法，总返回相同的整型值。\n *  equals：判断两个对象是否一致。需保证 equals 方法相同对应的对象 hashCode 也相同。\n *  toString: 用字符串表示该对象\n *  clone:深拷贝一个对象\n\n### Java 中一维数组和二维数组的声明方式？ \n\n一维数组的声明方式：\n\n```java\ntype arrayName[]\ntype[] arrayName\n```\n\n二维数组的声明方式：\n\n```java\ntype arrayName[][]\ntype[][] arrayName\ntype[] arrayName[]\n```\n\n其中 type 为基本数据类型或类，arrayName 为数组名字\n\n### 简述 Java 异常的分类 \n\nJava 异常分为 Error（程序无法处理的错误），和 Exception（程序本身可以处理的异常）。这两个类均继承 Throwable。\n\nError 常见的有 StackOverFlowError、OutOfMemoryError 等等。\n\nException 可分为运行时异常和非运行时异常。对于运行时异常，可以利用 try catch 的方式进行处理，也可以不处理。对于非运行时异常，必须处理，不处理的话程序无法通过编译。\n\n### 简述 throw 与 throws 的区别 \n\nthrow 一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常。\n\nthrows 一般用于方法声明上，代表该方法可能会抛出的异常列表。\n\n### 出现在 Java 程序中的 finally 代码块是否一定会执行？ \n\n当遇到下面情况不会执行。\n\n *  当程序在进入 try 语句块之前就出现异常时会直接结束。\n *  当程序在 try 块中强制退出时，如使用 System.exit(0)，也不会执行 finally 块中的代码。\n\n其它情况下，在 try/catch/finally 语句执行的时候，try 块先执行，当有异常发生，catch 和 finally 进行处理后程序就结束了，当没有异常发生，在执行完 finally 中的代码后，后面代码会继续执行。值得注意的是，当 try/catch 语句块中有 return 时，finally 语句块中的代码会在 return 之前执行。如果 try/catch/finally 块中都有 return 语句，finally 块中的 return 语句会覆盖 try/catch 模块中的 return 语句。\n\n### final、finally 和 finalize 的区别是什么？ \n\n *  final 用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。\n *  finally 作为异常处理的一部分，只能在 try/catch 语句中使用，finally 附带一个语句块用来表示这个语句最终一定被执行，经常被用在需要释放资源的情况下。\n *  finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的 finalize()方法。当垃圾回收器准备好释放对象占用空间时，首先会调用 finalize()方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存。\n\n### 简述泛型 \n\n泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛型方法。\n\n### 简述泛型擦除 \n\nJava 编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程被称为泛型擦除。\n\n### 简述注解 \n\nJava 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。\n\n其可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代码，做对应操作。\n\n### 简述元注解 \n\n元注解可以理解为注解的注解，即在注解中使用，实现想要的功能。其具体分为：\n\n *  @Retention: 表示注解存在阶段是保留在源码，还是在字节码（类加载）或者运行期（JVM 中运行）。\n *  @Target：表示注解作用的范围。\n *  @Documented：将注解中的元素包含到 Javadoc 中去。\n *  @Inherited：一个被@Inherited 注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。\n *  @Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。\n\n### 简述 Java 中 Class 对象 \n\njava 中对象可以分为实例对象和 Class 对象，每一个类都有一个 Class 对象，其包含了与该类有关的信息。\n\n获取 Class 对象的方法：\n\n```java\nClass.forName(“类的全限定名”)\n实例对象.getClass()\n类名.class\n```\n\n### Java 反射机制是什么？ \n\nJava 反射机制是指在程序的运行过程中可以构造任意一个类的对象、获取任意一个类的成员变量和成员方法、获取任意一个对象所属的类信息、调用任意一个对象的属性和方法。反射机制使得 Java 具有动态获取程序信息和动态调用对象方法的能力。可以通过以下类调用反射 API。\n\n *  Class 类：可获得类属性方法\n *  Field 类：获得类的成员变量\n *  Method 类：获取类的方法信息\n *  Construct 类：获取类的构造方法等信息\n\n### 序列化是什么？ \n\n序列化是一种将对象转换成字节序列的过程，用于解决在对对象流进行读写操作时所引发的问题。序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把该流读取出来重新构造成一个相同的对象。\n\n### 简述 Java 序列化与反序列化的实现 \n\n序列化：将 java 对象转化为字节序列，由此可以通过网络对象进行传输。\n\n反序列化：将字节序列转化为 java 对象。\n\n具体实现：实现 Serializable 接口，或实现 Externalizable 接口中的 writeExternal()与 readExternal()方法。\n\n### 简述 Java 的 List \n\nList 是一个有序队列，在 Java 中有两种实现方式:\n\nArrayList 使用数组实现，是容量可变的非线程安全列表，随机访问快，集合扩容时会创建更大的数组，把原有数组复制到新数组。\n\nLinkedList 本质是双向链表，与 ArrayList 相比插入和删除速度更快，但随机访问元素很慢。\n\n### Java 中线程安全的基本数据结构有哪些 \n\n *  HashTable: 哈希表的线程安全版，效率低\n *  ConcurrentHashMap：哈希表的线程安全版，效率高，用于替代 HashTable\n *  Vector：线程安全版 Arraylist\n *  Stack：线程安全版栈\n *  BlockingQueue 及其子类：线程安全版队列\n\n### 简述 Java 的 Set \n\nSet 即集合，该数据结构不允许元素重复且无序。Java 对 Set 有三种实现方式：\n\nHashSet 通过 HashMap 实现，HashMap 的 Key 即 HashSet 存储的元素，Value 系统自定义一个名为 PRESENT 的 Object 类型常量。判断元素是否相同时，先比较 hashCode，相同后再利用 equals 比较，查询 O(1)\n\nLinkedHashSet 继承自 HashSet，通过 LinkedHashMap 实现，使用双向链表维护元素插入顺序。\n\nTreeSet 通过 TreeMap 实现的，底层数据结构是红黑树，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。查询 O(logn)\n\n### 简述 Java 的 HashMap \n\nJDK8 之前底层实现是数组 + 链表，JDK8 改为数组 + 链表/红黑树。主要成员变量包括存储数据的 table 数组、元素数量 size、加载因子 loadFactor。HashMap 中数据以键值对的形式存在，键对应的 hash 值用来计算数组下标，如果两个元素 key 的 hash 值一样，就会发生哈希冲突，被放到同一个链表上。\n\ntable 数组记录 HashMap 的数据，每个下标对应一条链表，所有哈希冲突的数据都会被存放到同一条链表，Node/Entry 节点包含四个成员变量：key、value、next 指针和 hash 值。在 JDK8 后链表超过 8 会转化为红黑树。\n\n若当前数据/总数据容量>负载因子，Hashmap 将执行扩容操作。默认初始化容量为 16，扩容容量必须是 2 的幂次方、最大容量为 1<< 30 、默认加载因子为 0.75。\n\n### 为何 HashMap 线程不安全 \n\n在 JDK1.7 中，HashMap 采用头插法插入元素，因此并发情况下会导致环形链表，产生死循环。\n\n虽然 JDK1.8 采用了尾插法解决了这个问题，但是并发下的 put 操作也会使前一个 key 被后一个 key 覆盖。\n\n由于 HashMap 有扩容机制存在，也存在 A 线程进行扩容后，B 线程执行 get 方法出现失误的情况。\n\n### 简述 Java 的 TreeMap \n\nTreeMap 是底层利用红黑树实现的 Map 结构，底层实现是一棵平衡的排序二叉树，由于红黑树的插入、删除、遍历时间复杂度都为 O(logN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树可以按照键的值的大小有序输出。\n\n### ArrayList、Vector 和 LinkedList 有什么共同点与区别？ \n\n *  ArrayList、Vector 和 LinkedList 都是可伸缩的数组，即可以动态改变长度的数组。\n *  ArrayList 和 Vector 都是基于存储元素的 Object\\[\\] array 来实现的，它们会在内存中开辟一块连续的空间来存储，支持下标、索引访问。但在涉及插入元素时可能需要移动容器中的元素，插入效率较低。当存储元素超过容器的初始化容量大小，ArrayList 与 Vector 均会进行扩容。\n *  Vector 是线程安全的，其大部分方法是直接或间接同步的。ArrayList 不是线程安全的，其方法不具有同步性质。LinkedList 也不是线程安全的。\n *  LinkedList 采用双向列表实现，对数据索引需要从头开始遍历，因此随机访问效率较低，但在插入元素的时候不需要对数据进行移动，插入效率较高。\n\n### HashMap 和 Hashtable 有什么区别？ \n\n *  HashMap 是 Hashtable 的轻量级实现，HashMap 允许 key 和 value 为 null，但最多允许一条记录的 key 为 null.而 HashTable 不允许。\n *  HashTable 中的方法是线程安全的，而 HashMap 不是。在多线程访问 HashMap 需要提供额外的同步机制。\n *  Hashtable 使用 Enumeration 进行遍历，HashMap 使用 Iterator 进行遍历。\n\n### 如何决定使用 HashMap 还是 TreeMap? \n\n如果对 Map 进行插入、删除或定位一个元素的操作更频繁，HashMap 是更好的选择。如果需要对 key 集合进行有序的遍历，TreeMap 是更好的选择。\n\n### HashSet 中，equals 与 hashCode 之间的关系？ \n\nequals 和 hashCode 这两个方法都是从 object 类中继承过来的，equals 主要用于判断对象的内存地址引用是否是同一个地址；hashCode 根据定义的哈希规则将对象的内存地址转换为一个哈希码。HashSet 中存储的元素是不能重复的，主要通过 hashCode 与 equals 两个方法来判断存储的对象是否相同：\n\n *  如果两个对象的 hashCode 值不同，说明两个对象不相同。\n *  如果两个对象的 hashCode 值相同，接着会调用对象的 equals 方法，如果 equlas 方法的返回结果为 true，那么说明两个对象相同，否则不相同。\n\n### fail-fast 和 fail-safe 迭代器的区别是什么？ \n\n *  fail-fast 直接在容器上进行，在遍历过程中，一旦发现容器中的数据被修改，就会立刻抛出 ConcurrentModificationException 异常从而导致遍历失败。常见的使用 fail-fast 方式的容器有 HashMap 和 ArrayList 等。\n *  fail-safe 这种遍历基于容器的一个克隆。因此对容器中的内容修改不影响遍历。常见的使用 fail-safe 方式遍历的容器有 ConcurrentHashMap 和 CopyOnWriteArrayList。\n\n### Collection 和 Collections 有什么区别？ \n\n *  Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。\n *  Collections 是一个包装类，包含了很多静态方法、不能被实例化，而是作为工具类使用，比如提供的排序方法：Collections.sort(list);提供的反转方法：Collections.reverse(list)。\n\n","source":"_posts/Java基础篇的八股文.md","raw":"---\ntitle: Java基础篇的八股文\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-11-04 13:16:06\npassword:\nsummary: java语言具有哪些特点？ \ntags:\n    - java基础\n    - 八股文\ncategories:\n    - java\n---\n### Java 语言具有哪些特点？ \n\n *  Java 为纯面向对象的语言。它能够直接反应现实生活中的对象。\n *  具有平台无关性。Java 利用 Java 虚拟机运行字节码，无论是在 Windows、Linux 还是 MacOS 等其它平台对 Java 程序进行编译，编译后的程序可在其它平台运行。\n *  Java 为解释型语言，编译器把 Java 代码编译成平台无关的中间代码，然后在 JVM 上解释运行，具有很好的可移植性。\n *  Java 提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收器。\n *  Java 具有较好的安全性和健壮性。Java 提供了异常处理和垃圾回收机制，去除了 C++中难以理解的指针特性。\n\n### JDK 与 JRE 有什么区别？ \n\n *  JDK：Java 开发工具包（Java Development Kit），提供了 Java 的开发环境和运行环境。\n *  JRE：Java 运行环境(Java Runtime Environment)，提供了 Java 运行所需的环境。\n *  JDK 包含了 JRE。如果只运行 Java 程序，安装 JRE 即可。要编写 Java 程序需安装 JDK.\n\n### 简述 Java 基本数据类型 \n\n *  byte: 占用 1 个字节，取值范围-128 ~ 127\n *  short: 占用 2 个字节，取值范围-2^15^ ~ 2^15^-1\n *  int：占用 4 个字节，取值范围-2^31^ ~ 2^31^-1\n *  long：占用 8 个字节\n *  float：占用 4 个字节\n *  double：占用 8 个字节\n *  char: 占用 2 个字节\n *  boolean：占用大小根据实现虚拟机不同有所差异\n\n### 简述自动装箱拆箱 \n\n对于 Java 基本数据类型，均对应一个包装类。\n\n装箱就是自动将基本数据类型转换为包装器类型，如 int->Integer\n\n拆箱就是自动将包装器类型转换为基本数据类型，如 Integer->int\n\n### 简述 Java 访问修饰符 \n\n *  default: 默认访问修饰符，在同一包内可见\n *  private: 在同一类内可见，不能修饰类\n *  protected : 对同一包内的类和所有子类可见，不能修饰类\n *  public: 对所有类可见\n\n### 构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？ \n\n先后顺序：静态成员变量、成员变量、构造方法。\n\n详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。\n\n### Java 代码块执行顺序 \n\n *  父类静态代码块（只执行一次）\n *  子类静态代码块（只执行一次）\n *  父类构造代码块\n *  父类构造函数\n *  子类构造代码块\n *  子类构造函数\n *  普通代码块\n\n### 面向对象的三大特性？ \n\n继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且派生类可以修改或新增新的方法使之更适合特殊的需求。\n\n封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。\n\n多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现行为是不一样的。\n\n### 为什么 Java 语言不支持多重继承？ \n\n为了程序的结构能够更加清晰从而便于维护。假设 Java 语言支持多重继承，类 C 继承自类 A 和类 B，如果类 A 和 B 都有自定义的成员方法 `f()`，那么当代码中调用类 C 的 `f()` 会产生二义性。\n\nJava 语言通过实现多个接口间接支持多重继承，接口由于只包含方法定义，不能有方法的实现，类 C 继承接口 A 与接口 B 时即使它们都有方法`f()`，也不能直接调用方法，需实现具体的`f()`方法才能调用，不会产生二义性。\n\n多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。\n\n### 简述 Java 的多态 \n\nJava 多态可以分为编译时多态和运行时多态。\n\n编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。\n\n运行时多态主要指继承父类和实现接口时，可使用父类引用指向子类对象。\n\n运行时多态的实现：主要依靠方法表，方法表中最先存放的是 Object 类的方法，接下来是该类的父类的方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个方法表项，都被认作是父类的方法。因此可以实现运行时多态。\n\n### Java 提供的多态机制？ \n\nJava 提供了两种用于多态的机制，分别是重载与覆盖。\n\n重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定调用哪个方法。\n\n覆盖：覆盖是指派生类重写基类的方法，使用基类指向其子类的实例对象，或接口的引用变量指向其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个对象的方法，即需要到运行期才能确定调用哪个方法。\n\n### 重载与覆盖的区别？ \n\n *  覆盖是父类与子类之间的关系，是垂直关系；重载是同一类中方法之间的关系，是水平关系。\n *  覆盖只能由一个方法或一对方法产生关系；重载是多个方法之间的关系。\n *  覆盖要求参数列表相同；重载要求参数列表不同。\n *  覆盖中，调用方法体是根据对象的类型来决定的，而重载是根据调用时实参表与形参表来对应选择方法体。\n *  重载方法可以改变返回值的类型，覆盖方法不能改变返回值的类型。\n\n### 接口和抽象类的相同点和不同点？ \n\n相同点:\n\n *  都不能被实例化。\n *  接口的实现类或抽象类的子类需实现接口或抽象类中相应的方法才能被实例化。\n\n不同点：\n\n *  接口只能有方法定义，不能有方法的实现，而抽象类可以有方法的定义与实现。\n *  实现接口的关键字为 implements，继承抽象类的关键字为 extends。一个类可以实现多个接口，只能继承一个抽象类。\n *  当子类和父类之间存在逻辑上的层次结构，推荐使用抽象类，有利于功能的累积。当功能不需要，希望支持差别较大的两个或更多对象间的特定交互行为，推荐使用接口。使用接口能降低软件系统的耦合度，便于日后维护或添加删除方法。\n\n### 简述抽象类与接口的区别 \n\n抽象类：体现的是 is-a 的关系，如对于 man is a person，就可以将 person 定义为抽象类。\n\n接口：体现的是 can 的关系。是作为模板实现的。如设置接口 fly，plane 类和 bird 类均可实现该接口。\n\n一个类只能继承一个抽象类，但可以实现多个接口。\n\n### 简述内部类及其作用 \n\n *  成员内部类：作为成员对象的内部类。可以访问 private 及以上外部类的属性和方法。外部类想要访问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法。外部类也可访问 private 修饰的内部类属性。\n *  局部内部类：存在于方法中的内部类。访问权限类似局部变量，只能访问外部类的 final 变量。\n *  匿名内部类：只能使用一次，没有类名，只能访问外部类的 final 变量。\n *  静态内部类：类似类的静态成员变量。\n\n### Java 语言中关键字 static 的作用是什么？ \n\nstatic 的主要作用有两个：\n\n *  为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。\n *  使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法或使用类的属性。\n\n具体而言 static 又可分为 4 种使用方式：\n\n *  修饰成员变量。用 static 关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加载，这个静态变量就会被分配空间，可以使用“类.静态变量”和“对象.静态变量”的方法使用。\n *  修饰成员方法。static 修饰的方法无需创建对象就可以被调用。static 方法中不能使用 this 和 super 关键字，不能调用非 static 方法，只能访问所属类的静态成员变量和静态成员方法。\n *  修饰代码块。JVM 在加载类的时候会执行 static 代码块。static 代码块常用于初始化静态变量。static 代码块只会被执行一次。\n *  修饰内部类。static 内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法。\n\n### 为什么要把 String 设计为不可变？ \n\n *  节省空间：字符串常量存储在 JVM 的字符串池中可以被用户共享。\n *  提高效率：String 可以被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。\n *  安全：String 常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修改。\n\n### 简述 String/StringBuffer 与 StringBuilder \n\nString 类采用利用 final 修饰的字符数组进行字符串保存，因此不可变。如果对 String 类型对象修改，需要新建对象，将老字符和新增加的字符一并存进去。\n\nStringBuilder，采用无 final 修饰的字符数组进行保存，因此可变。但线程不安全。\n\nStringBuffer，采用无 final 修饰的字符数组进行保存，可理解为实现线程安全的 StringBuilder。\n\n### 判等运算符==与 equals 的区别？ \n\n== 比较的是引用，equals 比较的是内容。\n\n如果变量是基础数据类型，== 用于比较其对应值是否相等。如果变量指向的是对象，== 用于比较两个对象是否指向同一块存储空间。\n\nequals 是 Object 类提供的方法之一，每个 Java 类都继承自 Object 类，所以每个对象都具有 equals 这个方法。Object 类中定义的 equals 方法内部是直接调用 == 比较对象的。但通过覆盖的方法可以让它不是比较引用而是比较数据内容。\n\n### 简述 Object 类常用方法 \n\n *  hashCode：通过对象计算出的散列码。用于 map 型或 equals 方法。需要保证同一个对象多次调用该方法，总返回相同的整型值。\n *  equals：判断两个对象是否一致。需保证 equals 方法相同对应的对象 hashCode 也相同。\n *  toString: 用字符串表示该对象\n *  clone:深拷贝一个对象\n\n### Java 中一维数组和二维数组的声明方式？ \n\n一维数组的声明方式：\n\n```java\ntype arrayName[]\ntype[] arrayName\n```\n\n二维数组的声明方式：\n\n```java\ntype arrayName[][]\ntype[][] arrayName\ntype[] arrayName[]\n```\n\n其中 type 为基本数据类型或类，arrayName 为数组名字\n\n### 简述 Java 异常的分类 \n\nJava 异常分为 Error（程序无法处理的错误），和 Exception（程序本身可以处理的异常）。这两个类均继承 Throwable。\n\nError 常见的有 StackOverFlowError、OutOfMemoryError 等等。\n\nException 可分为运行时异常和非运行时异常。对于运行时异常，可以利用 try catch 的方式进行处理，也可以不处理。对于非运行时异常，必须处理，不处理的话程序无法通过编译。\n\n### 简述 throw 与 throws 的区别 \n\nthrow 一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常。\n\nthrows 一般用于方法声明上，代表该方法可能会抛出的异常列表。\n\n### 出现在 Java 程序中的 finally 代码块是否一定会执行？ \n\n当遇到下面情况不会执行。\n\n *  当程序在进入 try 语句块之前就出现异常时会直接结束。\n *  当程序在 try 块中强制退出时，如使用 System.exit(0)，也不会执行 finally 块中的代码。\n\n其它情况下，在 try/catch/finally 语句执行的时候，try 块先执行，当有异常发生，catch 和 finally 进行处理后程序就结束了，当没有异常发生，在执行完 finally 中的代码后，后面代码会继续执行。值得注意的是，当 try/catch 语句块中有 return 时，finally 语句块中的代码会在 return 之前执行。如果 try/catch/finally 块中都有 return 语句，finally 块中的 return 语句会覆盖 try/catch 模块中的 return 语句。\n\n### final、finally 和 finalize 的区别是什么？ \n\n *  final 用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。\n *  finally 作为异常处理的一部分，只能在 try/catch 语句中使用，finally 附带一个语句块用来表示这个语句最终一定被执行，经常被用在需要释放资源的情况下。\n *  finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的 finalize()方法。当垃圾回收器准备好释放对象占用空间时，首先会调用 finalize()方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存。\n\n### 简述泛型 \n\n泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛型方法。\n\n### 简述泛型擦除 \n\nJava 编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程被称为泛型擦除。\n\n### 简述注解 \n\nJava 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。\n\n其可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代码，做对应操作。\n\n### 简述元注解 \n\n元注解可以理解为注解的注解，即在注解中使用，实现想要的功能。其具体分为：\n\n *  @Retention: 表示注解存在阶段是保留在源码，还是在字节码（类加载）或者运行期（JVM 中运行）。\n *  @Target：表示注解作用的范围。\n *  @Documented：将注解中的元素包含到 Javadoc 中去。\n *  @Inherited：一个被@Inherited 注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。\n *  @Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。\n\n### 简述 Java 中 Class 对象 \n\njava 中对象可以分为实例对象和 Class 对象，每一个类都有一个 Class 对象，其包含了与该类有关的信息。\n\n获取 Class 对象的方法：\n\n```java\nClass.forName(“类的全限定名”)\n实例对象.getClass()\n类名.class\n```\n\n### Java 反射机制是什么？ \n\nJava 反射机制是指在程序的运行过程中可以构造任意一个类的对象、获取任意一个类的成员变量和成员方法、获取任意一个对象所属的类信息、调用任意一个对象的属性和方法。反射机制使得 Java 具有动态获取程序信息和动态调用对象方法的能力。可以通过以下类调用反射 API。\n\n *  Class 类：可获得类属性方法\n *  Field 类：获得类的成员变量\n *  Method 类：获取类的方法信息\n *  Construct 类：获取类的构造方法等信息\n\n### 序列化是什么？ \n\n序列化是一种将对象转换成字节序列的过程，用于解决在对对象流进行读写操作时所引发的问题。序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把该流读取出来重新构造成一个相同的对象。\n\n### 简述 Java 序列化与反序列化的实现 \n\n序列化：将 java 对象转化为字节序列，由此可以通过网络对象进行传输。\n\n反序列化：将字节序列转化为 java 对象。\n\n具体实现：实现 Serializable 接口，或实现 Externalizable 接口中的 writeExternal()与 readExternal()方法。\n\n### 简述 Java 的 List \n\nList 是一个有序队列，在 Java 中有两种实现方式:\n\nArrayList 使用数组实现，是容量可变的非线程安全列表，随机访问快，集合扩容时会创建更大的数组，把原有数组复制到新数组。\n\nLinkedList 本质是双向链表，与 ArrayList 相比插入和删除速度更快，但随机访问元素很慢。\n\n### Java 中线程安全的基本数据结构有哪些 \n\n *  HashTable: 哈希表的线程安全版，效率低\n *  ConcurrentHashMap：哈希表的线程安全版，效率高，用于替代 HashTable\n *  Vector：线程安全版 Arraylist\n *  Stack：线程安全版栈\n *  BlockingQueue 及其子类：线程安全版队列\n\n### 简述 Java 的 Set \n\nSet 即集合，该数据结构不允许元素重复且无序。Java 对 Set 有三种实现方式：\n\nHashSet 通过 HashMap 实现，HashMap 的 Key 即 HashSet 存储的元素，Value 系统自定义一个名为 PRESENT 的 Object 类型常量。判断元素是否相同时，先比较 hashCode，相同后再利用 equals 比较，查询 O(1)\n\nLinkedHashSet 继承自 HashSet，通过 LinkedHashMap 实现，使用双向链表维护元素插入顺序。\n\nTreeSet 通过 TreeMap 实现的，底层数据结构是红黑树，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。查询 O(logn)\n\n### 简述 Java 的 HashMap \n\nJDK8 之前底层实现是数组 + 链表，JDK8 改为数组 + 链表/红黑树。主要成员变量包括存储数据的 table 数组、元素数量 size、加载因子 loadFactor。HashMap 中数据以键值对的形式存在，键对应的 hash 值用来计算数组下标，如果两个元素 key 的 hash 值一样，就会发生哈希冲突，被放到同一个链表上。\n\ntable 数组记录 HashMap 的数据，每个下标对应一条链表，所有哈希冲突的数据都会被存放到同一条链表，Node/Entry 节点包含四个成员变量：key、value、next 指针和 hash 值。在 JDK8 后链表超过 8 会转化为红黑树。\n\n若当前数据/总数据容量>负载因子，Hashmap 将执行扩容操作。默认初始化容量为 16，扩容容量必须是 2 的幂次方、最大容量为 1<< 30 、默认加载因子为 0.75。\n\n### 为何 HashMap 线程不安全 \n\n在 JDK1.7 中，HashMap 采用头插法插入元素，因此并发情况下会导致环形链表，产生死循环。\n\n虽然 JDK1.8 采用了尾插法解决了这个问题，但是并发下的 put 操作也会使前一个 key 被后一个 key 覆盖。\n\n由于 HashMap 有扩容机制存在，也存在 A 线程进行扩容后，B 线程执行 get 方法出现失误的情况。\n\n### 简述 Java 的 TreeMap \n\nTreeMap 是底层利用红黑树实现的 Map 结构，底层实现是一棵平衡的排序二叉树，由于红黑树的插入、删除、遍历时间复杂度都为 O(logN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树可以按照键的值的大小有序输出。\n\n### ArrayList、Vector 和 LinkedList 有什么共同点与区别？ \n\n *  ArrayList、Vector 和 LinkedList 都是可伸缩的数组，即可以动态改变长度的数组。\n *  ArrayList 和 Vector 都是基于存储元素的 Object\\[\\] array 来实现的，它们会在内存中开辟一块连续的空间来存储，支持下标、索引访问。但在涉及插入元素时可能需要移动容器中的元素，插入效率较低。当存储元素超过容器的初始化容量大小，ArrayList 与 Vector 均会进行扩容。\n *  Vector 是线程安全的，其大部分方法是直接或间接同步的。ArrayList 不是线程安全的，其方法不具有同步性质。LinkedList 也不是线程安全的。\n *  LinkedList 采用双向列表实现，对数据索引需要从头开始遍历，因此随机访问效率较低，但在插入元素的时候不需要对数据进行移动，插入效率较高。\n\n### HashMap 和 Hashtable 有什么区别？ \n\n *  HashMap 是 Hashtable 的轻量级实现，HashMap 允许 key 和 value 为 null，但最多允许一条记录的 key 为 null.而 HashTable 不允许。\n *  HashTable 中的方法是线程安全的，而 HashMap 不是。在多线程访问 HashMap 需要提供额外的同步机制。\n *  Hashtable 使用 Enumeration 进行遍历，HashMap 使用 Iterator 进行遍历。\n\n### 如何决定使用 HashMap 还是 TreeMap? \n\n如果对 Map 进行插入、删除或定位一个元素的操作更频繁，HashMap 是更好的选择。如果需要对 key 集合进行有序的遍历，TreeMap 是更好的选择。\n\n### HashSet 中，equals 与 hashCode 之间的关系？ \n\nequals 和 hashCode 这两个方法都是从 object 类中继承过来的，equals 主要用于判断对象的内存地址引用是否是同一个地址；hashCode 根据定义的哈希规则将对象的内存地址转换为一个哈希码。HashSet 中存储的元素是不能重复的，主要通过 hashCode 与 equals 两个方法来判断存储的对象是否相同：\n\n *  如果两个对象的 hashCode 值不同，说明两个对象不相同。\n *  如果两个对象的 hashCode 值相同，接着会调用对象的 equals 方法，如果 equlas 方法的返回结果为 true，那么说明两个对象相同，否则不相同。\n\n### fail-fast 和 fail-safe 迭代器的区别是什么？ \n\n *  fail-fast 直接在容器上进行，在遍历过程中，一旦发现容器中的数据被修改，就会立刻抛出 ConcurrentModificationException 异常从而导致遍历失败。常见的使用 fail-fast 方式的容器有 HashMap 和 ArrayList 等。\n *  fail-safe 这种遍历基于容器的一个克隆。因此对容器中的内容修改不影响遍历。常见的使用 fail-safe 方式遍历的容器有 ConcurrentHashMap 和 CopyOnWriteArrayList。\n\n### Collection 和 Collections 有什么区别？ \n\n *  Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。\n *  Collections 是一个包装类，包含了很多静态方法、不能被实例化，而是作为工具类使用，比如提供的排序方法：Collections.sort(list);提供的反转方法：Collections.reverse(list)。\n\n","slug":"Java基础篇的八股文","published":1,"updated":"2022-11-04T05:47:08.896Z","_id":"cla21kmyu000001ldd8hx7phc","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Java-语言具有哪些特点？\"><a href=\"#Java-语言具有哪些特点？\" class=\"headerlink\" title=\"Java 语言具有哪些特点？\"></a>Java 语言具有哪些特点？</h3><ul>\n<li> Java 为纯面向对象的语言。它能够直接反应现实生活中的对象。</li>\n<li> 具有平台无关性。Java 利用 Java 虚拟机运行字节码，无论是在 Windows、Linux 还是 MacOS 等其它平台对 Java 程序进行编译，编译后的程序可在其它平台运行。</li>\n<li> Java 为解释型语言，编译器把 Java 代码编译成平台无关的中间代码，然后在 JVM 上解释运行，具有很好的可移植性。</li>\n<li> Java 提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收器。</li>\n<li> Java 具有较好的安全性和健壮性。Java 提供了异常处理和垃圾回收机制，去除了 C++中难以理解的指针特性。</li>\n</ul>\n<h3 id=\"JDK-与-JRE-有什么区别？\"><a href=\"#JDK-与-JRE-有什么区别？\" class=\"headerlink\" title=\"JDK 与 JRE 有什么区别？\"></a>JDK 与 JRE 有什么区别？</h3><ul>\n<li> JDK：Java 开发工具包（Java Development Kit），提供了 Java 的开发环境和运行环境。</li>\n<li> JRE：Java 运行环境(Java Runtime Environment)，提供了 Java 运行所需的环境。</li>\n<li> JDK 包含了 JRE。如果只运行 Java 程序，安装 JRE 即可。要编写 Java 程序需安装 JDK.</li>\n</ul>\n<h3 id=\"简述-Java-基本数据类型\"><a href=\"#简述-Java-基本数据类型\" class=\"headerlink\" title=\"简述 Java 基本数据类型\"></a>简述 Java 基本数据类型</h3><ul>\n<li> byte: 占用 1 个字节，取值范围-128 ~ 127</li>\n<li> short: 占用 2 个字节，取值范围-2^15^ ~ 2^15^-1</li>\n<li> int：占用 4 个字节，取值范围-2^31^ ~ 2^31^-1</li>\n<li> long：占用 8 个字节</li>\n<li> float：占用 4 个字节</li>\n<li> double：占用 8 个字节</li>\n<li> char: 占用 2 个字节</li>\n<li> boolean：占用大小根据实现虚拟机不同有所差异</li>\n</ul>\n<h3 id=\"简述自动装箱拆箱\"><a href=\"#简述自动装箱拆箱\" class=\"headerlink\" title=\"简述自动装箱拆箱\"></a>简述自动装箱拆箱</h3><p>对于 Java 基本数据类型，均对应一个包装类。</p>\n<p>装箱就是自动将基本数据类型转换为包装器类型，如 int-&gt;Integer</p>\n<p>拆箱就是自动将包装器类型转换为基本数据类型，如 Integer-&gt;int</p>\n<h3 id=\"简述-Java-访问修饰符\"><a href=\"#简述-Java-访问修饰符\" class=\"headerlink\" title=\"简述 Java 访问修饰符\"></a>简述 Java 访问修饰符</h3><ul>\n<li> default: 默认访问修饰符，在同一包内可见</li>\n<li> private: 在同一类内可见，不能修饰类</li>\n<li> protected : 对同一包内的类和所有子类可见，不能修饰类</li>\n<li> public: 对所有类可见</li>\n</ul>\n<h3 id=\"构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？\"><a href=\"#构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？\" class=\"headerlink\" title=\"构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？\"></a>构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？</h3><p>先后顺序：静态成员变量、成员变量、构造方法。</p>\n<p>详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。</p>\n<h3 id=\"Java-代码块执行顺序\"><a href=\"#Java-代码块执行顺序\" class=\"headerlink\" title=\"Java 代码块执行顺序\"></a>Java 代码块执行顺序</h3><ul>\n<li> 父类静态代码块（只执行一次）</li>\n<li> 子类静态代码块（只执行一次）</li>\n<li> 父类构造代码块</li>\n<li> 父类构造函数</li>\n<li> 子类构造代码块</li>\n<li> 子类构造函数</li>\n<li> 普通代码块</li>\n</ul>\n<h3 id=\"面向对象的三大特性？\"><a href=\"#面向对象的三大特性？\" class=\"headerlink\" title=\"面向对象的三大特性？\"></a>面向对象的三大特性？</h3><p>继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且派生类可以修改或新增新的方法使之更适合特殊的需求。</p>\n<p>封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。</p>\n<p>多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现行为是不一样的。</p>\n<h3 id=\"为什么-Java-语言不支持多重继承？\"><a href=\"#为什么-Java-语言不支持多重继承？\" class=\"headerlink\" title=\"为什么 Java 语言不支持多重继承？\"></a>为什么 Java 语言不支持多重继承？</h3><p>为了程序的结构能够更加清晰从而便于维护。假设 Java 语言支持多重继承，类 C 继承自类 A 和类 B，如果类 A 和 B 都有自定义的成员方法 <code>f()</code>，那么当代码中调用类 C 的 <code>f()</code> 会产生二义性。</p>\n<p>Java 语言通过实现多个接口间接支持多重继承，接口由于只包含方法定义，不能有方法的实现，类 C 继承接口 A 与接口 B 时即使它们都有方法<code>f()</code>，也不能直接调用方法，需实现具体的<code>f()</code>方法才能调用，不会产生二义性。</p>\n<p>多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。</p>\n<h3 id=\"简述-Java-的多态\"><a href=\"#简述-Java-的多态\" class=\"headerlink\" title=\"简述 Java 的多态\"></a>简述 Java 的多态</h3><p>Java 多态可以分为编译时多态和运行时多态。</p>\n<p>编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。</p>\n<p>运行时多态主要指继承父类和实现接口时，可使用父类引用指向子类对象。</p>\n<p>运行时多态的实现：主要依靠方法表，方法表中最先存放的是 Object 类的方法，接下来是该类的父类的方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个方法表项，都被认作是父类的方法。因此可以实现运行时多态。</p>\n<h3 id=\"Java-提供的多态机制？\"><a href=\"#Java-提供的多态机制？\" class=\"headerlink\" title=\"Java 提供的多态机制？\"></a>Java 提供的多态机制？</h3><p>Java 提供了两种用于多态的机制，分别是重载与覆盖。</p>\n<p>重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定调用哪个方法。</p>\n<p>覆盖：覆盖是指派生类重写基类的方法，使用基类指向其子类的实例对象，或接口的引用变量指向其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个对象的方法，即需要到运行期才能确定调用哪个方法。</p>\n<h3 id=\"重载与覆盖的区别？\"><a href=\"#重载与覆盖的区别？\" class=\"headerlink\" title=\"重载与覆盖的区别？\"></a>重载与覆盖的区别？</h3><ul>\n<li> 覆盖是父类与子类之间的关系，是垂直关系；重载是同一类中方法之间的关系，是水平关系。</li>\n<li> 覆盖只能由一个方法或一对方法产生关系；重载是多个方法之间的关系。</li>\n<li> 覆盖要求参数列表相同；重载要求参数列表不同。</li>\n<li> 覆盖中，调用方法体是根据对象的类型来决定的，而重载是根据调用时实参表与形参表来对应选择方法体。</li>\n<li> 重载方法可以改变返回值的类型，覆盖方法不能改变返回值的类型。</li>\n</ul>\n<h3 id=\"接口和抽象类的相同点和不同点？\"><a href=\"#接口和抽象类的相同点和不同点？\" class=\"headerlink\" title=\"接口和抽象类的相同点和不同点？\"></a>接口和抽象类的相同点和不同点？</h3><p>相同点:</p>\n<ul>\n<li> 都不能被实例化。</li>\n<li> 接口的实现类或抽象类的子类需实现接口或抽象类中相应的方法才能被实例化。</li>\n</ul>\n<p>不同点：</p>\n<ul>\n<li> 接口只能有方法定义，不能有方法的实现，而抽象类可以有方法的定义与实现。</li>\n<li> 实现接口的关键字为 implements，继承抽象类的关键字为 extends。一个类可以实现多个接口，只能继承一个抽象类。</li>\n<li> 当子类和父类之间存在逻辑上的层次结构，推荐使用抽象类，有利于功能的累积。当功能不需要，希望支持差别较大的两个或更多对象间的特定交互行为，推荐使用接口。使用接口能降低软件系统的耦合度，便于日后维护或添加删除方法。</li>\n</ul>\n<h3 id=\"简述抽象类与接口的区别\"><a href=\"#简述抽象类与接口的区别\" class=\"headerlink\" title=\"简述抽象类与接口的区别\"></a>简述抽象类与接口的区别</h3><p>抽象类：体现的是 is-a 的关系，如对于 man is a person，就可以将 person 定义为抽象类。</p>\n<p>接口：体现的是 can 的关系。是作为模板实现的。如设置接口 fly，plane 类和 bird 类均可实现该接口。</p>\n<p>一个类只能继承一个抽象类，但可以实现多个接口。</p>\n<h3 id=\"简述内部类及其作用\"><a href=\"#简述内部类及其作用\" class=\"headerlink\" title=\"简述内部类及其作用\"></a>简述内部类及其作用</h3><ul>\n<li> 成员内部类：作为成员对象的内部类。可以访问 private 及以上外部类的属性和方法。外部类想要访问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法。外部类也可访问 private 修饰的内部类属性。</li>\n<li> 局部内部类：存在于方法中的内部类。访问权限类似局部变量，只能访问外部类的 final 变量。</li>\n<li> 匿名内部类：只能使用一次，没有类名，只能访问外部类的 final 变量。</li>\n<li> 静态内部类：类似类的静态成员变量。</li>\n</ul>\n<h3 id=\"Java-语言中关键字-static-的作用是什么？\"><a href=\"#Java-语言中关键字-static-的作用是什么？\" class=\"headerlink\" title=\"Java 语言中关键字 static 的作用是什么？\"></a>Java 语言中关键字 static 的作用是什么？</h3><p>static 的主要作用有两个：</p>\n<ul>\n<li> 为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。</li>\n<li> 使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法或使用类的属性。</li>\n</ul>\n<p>具体而言 static 又可分为 4 种使用方式：</p>\n<ul>\n<li> 修饰成员变量。用 static 关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加载，这个静态变量就会被分配空间，可以使用“类.静态变量”和“对象.静态变量”的方法使用。</li>\n<li> 修饰成员方法。static 修饰的方法无需创建对象就可以被调用。static 方法中不能使用 this 和 super 关键字，不能调用非 static 方法，只能访问所属类的静态成员变量和静态成员方法。</li>\n<li> 修饰代码块。JVM 在加载类的时候会执行 static 代码块。static 代码块常用于初始化静态变量。static 代码块只会被执行一次。</li>\n<li> 修饰内部类。static 内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法。</li>\n</ul>\n<h3 id=\"为什么要把-String-设计为不可变？\"><a href=\"#为什么要把-String-设计为不可变？\" class=\"headerlink\" title=\"为什么要把 String 设计为不可变？\"></a>为什么要把 String 设计为不可变？</h3><ul>\n<li> 节省空间：字符串常量存储在 JVM 的字符串池中可以被用户共享。</li>\n<li> 提高效率：String 可以被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。</li>\n<li> 安全：String 常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修改。</li>\n</ul>\n<h3 id=\"简述-String-StringBuffer-与-StringBuilder\"><a href=\"#简述-String-StringBuffer-与-StringBuilder\" class=\"headerlink\" title=\"简述 String/StringBuffer 与 StringBuilder\"></a>简述 String/StringBuffer 与 StringBuilder</h3><p>String 类采用利用 final 修饰的字符数组进行字符串保存，因此不可变。如果对 String 类型对象修改，需要新建对象，将老字符和新增加的字符一并存进去。</p>\n<p>StringBuilder，采用无 final 修饰的字符数组进行保存，因此可变。但线程不安全。</p>\n<p>StringBuffer，采用无 final 修饰的字符数组进行保存，可理解为实现线程安全的 StringBuilder。</p>\n<h3 id=\"判等运算符-与-equals-的区别？\"><a href=\"#判等运算符-与-equals-的区别？\" class=\"headerlink\" title=\"判等运算符==与 equals 的区别？\"></a>判等运算符==与 equals 的区别？</h3><p>== 比较的是引用，equals 比较的是内容。</p>\n<p>如果变量是基础数据类型，== 用于比较其对应值是否相等。如果变量指向的是对象，== 用于比较两个对象是否指向同一块存储空间。</p>\n<p>equals 是 Object 类提供的方法之一，每个 Java 类都继承自 Object 类，所以每个对象都具有 equals 这个方法。Object 类中定义的 equals 方法内部是直接调用 == 比较对象的。但通过覆盖的方法可以让它不是比较引用而是比较数据内容。</p>\n<h3 id=\"简述-Object-类常用方法\"><a href=\"#简述-Object-类常用方法\" class=\"headerlink\" title=\"简述 Object 类常用方法\"></a>简述 Object 类常用方法</h3><ul>\n<li> hashCode：通过对象计算出的散列码。用于 map 型或 equals 方法。需要保证同一个对象多次调用该方法，总返回相同的整型值。</li>\n<li> equals：判断两个对象是否一致。需保证 equals 方法相同对应的对象 hashCode 也相同。</li>\n<li> toString: 用字符串表示该对象</li>\n<li> clone:深拷贝一个对象</li>\n</ul>\n<h3 id=\"Java-中一维数组和二维数组的声明方式？\"><a href=\"#Java-中一维数组和二维数组的声明方式？\" class=\"headerlink\" title=\"Java 中一维数组和二维数组的声明方式？\"></a>Java 中一维数组和二维数组的声明方式？</h3><p>一维数组的声明方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">type arrayName<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\ntype<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arrayName<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>二维数组的声明方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">type arrayName<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\ntype<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arrayName\ntype<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arrayName<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>其中 type 为基本数据类型或类，arrayName 为数组名字</p>\n<h3 id=\"简述-Java-异常的分类\"><a href=\"#简述-Java-异常的分类\" class=\"headerlink\" title=\"简述 Java 异常的分类\"></a>简述 Java 异常的分类</h3><p>Java 异常分为 Error（程序无法处理的错误），和 Exception（程序本身可以处理的异常）。这两个类均继承 Throwable。</p>\n<p>Error 常见的有 StackOverFlowError、OutOfMemoryError 等等。</p>\n<p>Exception 可分为运行时异常和非运行时异常。对于运行时异常，可以利用 try catch 的方式进行处理，也可以不处理。对于非运行时异常，必须处理，不处理的话程序无法通过编译。</p>\n<h3 id=\"简述-throw-与-throws-的区别\"><a href=\"#简述-throw-与-throws-的区别\" class=\"headerlink\" title=\"简述 throw 与 throws 的区别\"></a>简述 throw 与 throws 的区别</h3><p>throw 一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常。</p>\n<p>throws 一般用于方法声明上，代表该方法可能会抛出的异常列表。</p>\n<h3 id=\"出现在-Java-程序中的-finally-代码块是否一定会执行？\"><a href=\"#出现在-Java-程序中的-finally-代码块是否一定会执行？\" class=\"headerlink\" title=\"出现在 Java 程序中的 finally 代码块是否一定会执行？\"></a>出现在 Java 程序中的 finally 代码块是否一定会执行？</h3><p>当遇到下面情况不会执行。</p>\n<ul>\n<li> 当程序在进入 try 语句块之前就出现异常时会直接结束。</li>\n<li> 当程序在 try 块中强制退出时，如使用 System.exit(0)，也不会执行 finally 块中的代码。</li>\n</ul>\n<p>其它情况下，在 try/catch/finally 语句执行的时候，try 块先执行，当有异常发生，catch 和 finally 进行处理后程序就结束了，当没有异常发生，在执行完 finally 中的代码后，后面代码会继续执行。值得注意的是，当 try/catch 语句块中有 return 时，finally 语句块中的代码会在 return 之前执行。如果 try/catch/finally 块中都有 return 语句，finally 块中的 return 语句会覆盖 try/catch 模块中的 return 语句。</p>\n<h3 id=\"final、finally-和-finalize-的区别是什么？\"><a href=\"#final、finally-和-finalize-的区别是什么？\" class=\"headerlink\" title=\"final、finally 和 finalize 的区别是什么？\"></a>final、finally 和 finalize 的区别是什么？</h3><ul>\n<li> final 用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。</li>\n<li> finally 作为异常处理的一部分，只能在 try/catch 语句中使用，finally 附带一个语句块用来表示这个语句最终一定被执行，经常被用在需要释放资源的情况下。</li>\n<li> finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的 finalize()方法。当垃圾回收器准备好释放对象占用空间时，首先会调用 finalize()方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存。</li>\n</ul>\n<h3 id=\"简述泛型\"><a href=\"#简述泛型\" class=\"headerlink\" title=\"简述泛型\"></a>简述泛型</h3><p>泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛型方法。</p>\n<h3 id=\"简述泛型擦除\"><a href=\"#简述泛型擦除\" class=\"headerlink\" title=\"简述泛型擦除\"></a>简述泛型擦除</h3><p>Java 编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程被称为泛型擦除。</p>\n<h3 id=\"简述注解\"><a href=\"#简述注解\" class=\"headerlink\" title=\"简述注解\"></a>简述注解</h3><p>Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。</p>\n<p>其可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代码，做对应操作。</p>\n<h3 id=\"简述元注解\"><a href=\"#简述元注解\" class=\"headerlink\" title=\"简述元注解\"></a>简述元注解</h3><p>元注解可以理解为注解的注解，即在注解中使用，实现想要的功能。其具体分为：</p>\n<ul>\n<li> @Retention: 表示注解存在阶段是保留在源码，还是在字节码（类加载）或者运行期（JVM 中运行）。</li>\n<li> @Target：表示注解作用的范围。</li>\n<li> @Documented：将注解中的元素包含到 Javadoc 中去。</li>\n<li> @Inherited：一个被@Inherited 注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。</li>\n<li> @Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。</li>\n</ul>\n<h3 id=\"简述-Java-中-Class-对象\"><a href=\"#简述-Java-中-Class-对象\" class=\"headerlink\" title=\"简述 Java 中 Class 对象\"></a>简述 Java 中 Class 对象</h3><p>java 中对象可以分为实例对象和 Class 对象，每一个类都有一个 Class 对象，其包含了与该类有关的信息。</p>\n<p>获取 Class 对象的方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>“类的全限定名”<span class=\"token punctuation\">)</span>\n实例对象<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n类名<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Java-反射机制是什么？\"><a href=\"#Java-反射机制是什么？\" class=\"headerlink\" title=\"Java 反射机制是什么？\"></a>Java 反射机制是什么？</h3><p>Java 反射机制是指在程序的运行过程中可以构造任意一个类的对象、获取任意一个类的成员变量和成员方法、获取任意一个对象所属的类信息、调用任意一个对象的属性和方法。反射机制使得 Java 具有动态获取程序信息和动态调用对象方法的能力。可以通过以下类调用反射 API。</p>\n<ul>\n<li> Class 类：可获得类属性方法</li>\n<li> Field 类：获得类的成员变量</li>\n<li> Method 类：获取类的方法信息</li>\n<li> Construct 类：获取类的构造方法等信息</li>\n</ul>\n<h3 id=\"序列化是什么？\"><a href=\"#序列化是什么？\" class=\"headerlink\" title=\"序列化是什么？\"></a>序列化是什么？</h3><p>序列化是一种将对象转换成字节序列的过程，用于解决在对对象流进行读写操作时所引发的问题。序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把该流读取出来重新构造成一个相同的对象。</p>\n<h3 id=\"简述-Java-序列化与反序列化的实现\"><a href=\"#简述-Java-序列化与反序列化的实现\" class=\"headerlink\" title=\"简述 Java 序列化与反序列化的实现\"></a>简述 Java 序列化与反序列化的实现</h3><p>序列化：将 java 对象转化为字节序列，由此可以通过网络对象进行传输。</p>\n<p>反序列化：将字节序列转化为 java 对象。</p>\n<p>具体实现：实现 Serializable 接口，或实现 Externalizable 接口中的 writeExternal()与 readExternal()方法。</p>\n<h3 id=\"简述-Java-的-List\"><a href=\"#简述-Java-的-List\" class=\"headerlink\" title=\"简述 Java 的 List\"></a>简述 Java 的 List</h3><p>List 是一个有序队列，在 Java 中有两种实现方式:</p>\n<p>ArrayList 使用数组实现，是容量可变的非线程安全列表，随机访问快，集合扩容时会创建更大的数组，把原有数组复制到新数组。</p>\n<p>LinkedList 本质是双向链表，与 ArrayList 相比插入和删除速度更快，但随机访问元素很慢。</p>\n<h3 id=\"Java-中线程安全的基本数据结构有哪些\"><a href=\"#Java-中线程安全的基本数据结构有哪些\" class=\"headerlink\" title=\"Java 中线程安全的基本数据结构有哪些\"></a>Java 中线程安全的基本数据结构有哪些</h3><ul>\n<li> HashTable: 哈希表的线程安全版，效率低</li>\n<li> ConcurrentHashMap：哈希表的线程安全版，效率高，用于替代 HashTable</li>\n<li> Vector：线程安全版 Arraylist</li>\n<li> Stack：线程安全版栈</li>\n<li> BlockingQueue 及其子类：线程安全版队列</li>\n</ul>\n<h3 id=\"简述-Java-的-Set\"><a href=\"#简述-Java-的-Set\" class=\"headerlink\" title=\"简述 Java 的 Set\"></a>简述 Java 的 Set</h3><p>Set 即集合，该数据结构不允许元素重复且无序。Java 对 Set 有三种实现方式：</p>\n<p>HashSet 通过 HashMap 实现，HashMap 的 Key 即 HashSet 存储的元素，Value 系统自定义一个名为 PRESENT 的 Object 类型常量。判断元素是否相同时，先比较 hashCode，相同后再利用 equals 比较，查询 O(1)</p>\n<p>LinkedHashSet 继承自 HashSet，通过 LinkedHashMap 实现，使用双向链表维护元素插入顺序。</p>\n<p>TreeSet 通过 TreeMap 实现的，底层数据结构是红黑树，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。查询 O(logn)</p>\n<h3 id=\"简述-Java-的-HashMap\"><a href=\"#简述-Java-的-HashMap\" class=\"headerlink\" title=\"简述 Java 的 HashMap\"></a>简述 Java 的 HashMap</h3><p>JDK8 之前底层实现是数组 + 链表，JDK8 改为数组 + 链表/红黑树。主要成员变量包括存储数据的 table 数组、元素数量 size、加载因子 loadFactor。HashMap 中数据以键值对的形式存在，键对应的 hash 值用来计算数组下标，如果两个元素 key 的 hash 值一样，就会发生哈希冲突，被放到同一个链表上。</p>\n<p>table 数组记录 HashMap 的数据，每个下标对应一条链表，所有哈希冲突的数据都会被存放到同一条链表，Node/Entry 节点包含四个成员变量：key、value、next 指针和 hash 值。在 JDK8 后链表超过 8 会转化为红黑树。</p>\n<p>若当前数据/总数据容量&gt;负载因子，Hashmap 将执行扩容操作。默认初始化容量为 16，扩容容量必须是 2 的幂次方、最大容量为 1&lt;&lt; 30 、默认加载因子为 0.75。</p>\n<h3 id=\"为何-HashMap-线程不安全\"><a href=\"#为何-HashMap-线程不安全\" class=\"headerlink\" title=\"为何 HashMap 线程不安全\"></a>为何 HashMap 线程不安全</h3><p>在 JDK1.7 中，HashMap 采用头插法插入元素，因此并发情况下会导致环形链表，产生死循环。</p>\n<p>虽然 JDK1.8 采用了尾插法解决了这个问题，但是并发下的 put 操作也会使前一个 key 被后一个 key 覆盖。</p>\n<p>由于 HashMap 有扩容机制存在，也存在 A 线程进行扩容后，B 线程执行 get 方法出现失误的情况。</p>\n<h3 id=\"简述-Java-的-TreeMap\"><a href=\"#简述-Java-的-TreeMap\" class=\"headerlink\" title=\"简述 Java 的 TreeMap\"></a>简述 Java 的 TreeMap</h3><p>TreeMap 是底层利用红黑树实现的 Map 结构，底层实现是一棵平衡的排序二叉树，由于红黑树的插入、删除、遍历时间复杂度都为 O(logN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树可以按照键的值的大小有序输出。</p>\n<h3 id=\"ArrayList、Vector-和-LinkedList-有什么共同点与区别？\"><a href=\"#ArrayList、Vector-和-LinkedList-有什么共同点与区别？\" class=\"headerlink\" title=\"ArrayList、Vector 和 LinkedList 有什么共同点与区别？\"></a>ArrayList、Vector 和 LinkedList 有什么共同点与区别？</h3><ul>\n<li> ArrayList、Vector 和 LinkedList 都是可伸缩的数组，即可以动态改变长度的数组。</li>\n<li> ArrayList 和 Vector 都是基于存储元素的 Object[] array 来实现的，它们会在内存中开辟一块连续的空间来存储，支持下标、索引访问。但在涉及插入元素时可能需要移动容器中的元素，插入效率较低。当存储元素超过容器的初始化容量大小，ArrayList 与 Vector 均会进行扩容。</li>\n<li> Vector 是线程安全的，其大部分方法是直接或间接同步的。ArrayList 不是线程安全的，其方法不具有同步性质。LinkedList 也不是线程安全的。</li>\n<li> LinkedList 采用双向列表实现，对数据索引需要从头开始遍历，因此随机访问效率较低，但在插入元素的时候不需要对数据进行移动，插入效率较高。</li>\n</ul>\n<h3 id=\"HashMap-和-Hashtable-有什么区别？\"><a href=\"#HashMap-和-Hashtable-有什么区别？\" class=\"headerlink\" title=\"HashMap 和 Hashtable 有什么区别？\"></a>HashMap 和 Hashtable 有什么区别？</h3><ul>\n<li> HashMap 是 Hashtable 的轻量级实现，HashMap 允许 key 和 value 为 null，但最多允许一条记录的 key 为 null.而 HashTable 不允许。</li>\n<li> HashTable 中的方法是线程安全的，而 HashMap 不是。在多线程访问 HashMap 需要提供额外的同步机制。</li>\n<li> Hashtable 使用 Enumeration 进行遍历，HashMap 使用 Iterator 进行遍历。</li>\n</ul>\n<h3 id=\"如何决定使用-HashMap-还是-TreeMap\"><a href=\"#如何决定使用-HashMap-还是-TreeMap\" class=\"headerlink\" title=\"如何决定使用 HashMap 还是 TreeMap?\"></a>如何决定使用 HashMap 还是 TreeMap?</h3><p>如果对 Map 进行插入、删除或定位一个元素的操作更频繁，HashMap 是更好的选择。如果需要对 key 集合进行有序的遍历，TreeMap 是更好的选择。</p>\n<h3 id=\"HashSet-中，equals-与-hashCode-之间的关系？\"><a href=\"#HashSet-中，equals-与-hashCode-之间的关系？\" class=\"headerlink\" title=\"HashSet 中，equals 与 hashCode 之间的关系？\"></a>HashSet 中，equals 与 hashCode 之间的关系？</h3><p>equals 和 hashCode 这两个方法都是从 object 类中继承过来的，equals 主要用于判断对象的内存地址引用是否是同一个地址；hashCode 根据定义的哈希规则将对象的内存地址转换为一个哈希码。HashSet 中存储的元素是不能重复的，主要通过 hashCode 与 equals 两个方法来判断存储的对象是否相同：</p>\n<ul>\n<li> 如果两个对象的 hashCode 值不同，说明两个对象不相同。</li>\n<li> 如果两个对象的 hashCode 值相同，接着会调用对象的 equals 方法，如果 equlas 方法的返回结果为 true，那么说明两个对象相同，否则不相同。</li>\n</ul>\n<h3 id=\"fail-fast-和-fail-safe-迭代器的区别是什么？\"><a href=\"#fail-fast-和-fail-safe-迭代器的区别是什么？\" class=\"headerlink\" title=\"fail-fast 和 fail-safe 迭代器的区别是什么？\"></a>fail-fast 和 fail-safe 迭代器的区别是什么？</h3><ul>\n<li> fail-fast 直接在容器上进行，在遍历过程中，一旦发现容器中的数据被修改，就会立刻抛出 ConcurrentModificationException 异常从而导致遍历失败。常见的使用 fail-fast 方式的容器有 HashMap 和 ArrayList 等。</li>\n<li> fail-safe 这种遍历基于容器的一个克隆。因此对容器中的内容修改不影响遍历。常见的使用 fail-safe 方式遍历的容器有 ConcurrentHashMap 和 CopyOnWriteArrayList。</li>\n</ul>\n<h3 id=\"Collection-和-Collections-有什么区别？\"><a href=\"#Collection-和-Collections-有什么区别？\" class=\"headerlink\" title=\"Collection 和 Collections 有什么区别？\"></a>Collection 和 Collections 有什么区别？</h3><ul>\n<li> Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li>\n<li> Collections 是一个包装类，包含了很多静态方法、不能被实例化，而是作为工具类使用，比如提供的排序方法：Collections.sort(list);提供的反转方法：Collections.reverse(list)。</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<h3 id=\"Java-语言具有哪些特点？\"><a href=\"#Java-语言具有哪些特点？\" class=\"headerlink\" title=\"Java 语言具有哪些特点？\"></a>Java 语言具有哪些特点？</h3><ul>\n<li> Java 为纯面向对象的语言。它能够直接反应现实生活中的对象。</li>\n<li> 具有平台无关性。Java 利用 Java 虚拟机运行字节码，无论是在 Windows、Linux 还是 MacOS 等其它平台对 Java 程序进行编译，编译后的程序可在其它平台运行。</li>\n<li> Java 为解释型语言，编译器把 Java 代码编译成平台无关的中间代码，然后在 JVM 上解释运行，具有很好的可移植性。</li>\n<li> Java 提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收器。</li>\n<li> Java 具有较好的安全性和健壮性。Java 提供了异常处理和垃圾回收机制，去除了 C++中难以理解的指针特性。</li>\n</ul>\n<h3 id=\"JDK-与-JRE-有什么区别？\"><a href=\"#JDK-与-JRE-有什么区别？\" class=\"headerlink\" title=\"JDK 与 JRE 有什么区别？\"></a>JDK 与 JRE 有什么区别？</h3><ul>\n<li> JDK：Java 开发工具包（Java Development Kit），提供了 Java 的开发环境和运行环境。</li>\n<li> JRE：Java 运行环境(Java Runtime Environment)，提供了 Java 运行所需的环境。</li>\n<li> JDK 包含了 JRE。如果只运行 Java 程序，安装 JRE 即可。要编写 Java 程序需安装 JDK.</li>\n</ul>\n<h3 id=\"简述-Java-基本数据类型\"><a href=\"#简述-Java-基本数据类型\" class=\"headerlink\" title=\"简述 Java 基本数据类型\"></a>简述 Java 基本数据类型</h3><ul>\n<li> byte: 占用 1 个字节，取值范围-128 ~ 127</li>\n<li> short: 占用 2 个字节，取值范围-2^15^ ~ 2^15^-1</li>\n<li> int：占用 4 个字节，取值范围-2^31^ ~ 2^31^-1</li>\n<li> long：占用 8 个字节</li>\n<li> float：占用 4 个字节</li>\n<li> double：占用 8 个字节</li>\n<li> char: 占用 2 个字节</li>\n<li> boolean：占用大小根据实现虚拟机不同有所差异</li>\n</ul>\n<h3 id=\"简述自动装箱拆箱\"><a href=\"#简述自动装箱拆箱\" class=\"headerlink\" title=\"简述自动装箱拆箱\"></a>简述自动装箱拆箱</h3><p>对于 Java 基本数据类型，均对应一个包装类。</p>\n<p>装箱就是自动将基本数据类型转换为包装器类型，如 int-&gt;Integer</p>\n<p>拆箱就是自动将包装器类型转换为基本数据类型，如 Integer-&gt;int</p>\n<h3 id=\"简述-Java-访问修饰符\"><a href=\"#简述-Java-访问修饰符\" class=\"headerlink\" title=\"简述 Java 访问修饰符\"></a>简述 Java 访问修饰符</h3><ul>\n<li> default: 默认访问修饰符，在同一包内可见</li>\n<li> private: 在同一类内可见，不能修饰类</li>\n<li> protected : 对同一包内的类和所有子类可见，不能修饰类</li>\n<li> public: 对所有类可见</li>\n</ul>\n<h3 id=\"构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？\"><a href=\"#构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？\" class=\"headerlink\" title=\"构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？\"></a>构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？</h3><p>先后顺序：静态成员变量、成员变量、构造方法。</p>\n<p>详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。</p>\n<h3 id=\"Java-代码块执行顺序\"><a href=\"#Java-代码块执行顺序\" class=\"headerlink\" title=\"Java 代码块执行顺序\"></a>Java 代码块执行顺序</h3><ul>\n<li> 父类静态代码块（只执行一次）</li>\n<li> 子类静态代码块（只执行一次）</li>\n<li> 父类构造代码块</li>\n<li> 父类构造函数</li>\n<li> 子类构造代码块</li>\n<li> 子类构造函数</li>\n<li> 普通代码块</li>\n</ul>\n<h3 id=\"面向对象的三大特性？\"><a href=\"#面向对象的三大特性？\" class=\"headerlink\" title=\"面向对象的三大特性？\"></a>面向对象的三大特性？</h3><p>继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且派生类可以修改或新增新的方法使之更适合特殊的需求。</p>\n<p>封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。</p>\n<p>多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现行为是不一样的。</p>\n<h3 id=\"为什么-Java-语言不支持多重继承？\"><a href=\"#为什么-Java-语言不支持多重继承？\" class=\"headerlink\" title=\"为什么 Java 语言不支持多重继承？\"></a>为什么 Java 语言不支持多重继承？</h3><p>为了程序的结构能够更加清晰从而便于维护。假设 Java 语言支持多重继承，类 C 继承自类 A 和类 B，如果类 A 和 B 都有自定义的成员方法 <code>f()</code>，那么当代码中调用类 C 的 <code>f()</code> 会产生二义性。</p>\n<p>Java 语言通过实现多个接口间接支持多重继承，接口由于只包含方法定义，不能有方法的实现，类 C 继承接口 A 与接口 B 时即使它们都有方法<code>f()</code>，也不能直接调用方法，需实现具体的<code>f()</code>方法才能调用，不会产生二义性。</p>\n<p>多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。</p>\n<h3 id=\"简述-Java-的多态\"><a href=\"#简述-Java-的多态\" class=\"headerlink\" title=\"简述 Java 的多态\"></a>简述 Java 的多态</h3><p>Java 多态可以分为编译时多态和运行时多态。</p>\n<p>编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。</p>\n<p>运行时多态主要指继承父类和实现接口时，可使用父类引用指向子类对象。</p>\n<p>运行时多态的实现：主要依靠方法表，方法表中最先存放的是 Object 类的方法，接下来是该类的父类的方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个方法表项，都被认作是父类的方法。因此可以实现运行时多态。</p>\n<h3 id=\"Java-提供的多态机制？\"><a href=\"#Java-提供的多态机制？\" class=\"headerlink\" title=\"Java 提供的多态机制？\"></a>Java 提供的多态机制？</h3><p>Java 提供了两种用于多态的机制，分别是重载与覆盖。</p>\n<p>重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定调用哪个方法。</p>\n<p>覆盖：覆盖是指派生类重写基类的方法，使用基类指向其子类的实例对象，或接口的引用变量指向其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个对象的方法，即需要到运行期才能确定调用哪个方法。</p>\n<h3 id=\"重载与覆盖的区别？\"><a href=\"#重载与覆盖的区别？\" class=\"headerlink\" title=\"重载与覆盖的区别？\"></a>重载与覆盖的区别？</h3><ul>\n<li> 覆盖是父类与子类之间的关系，是垂直关系；重载是同一类中方法之间的关系，是水平关系。</li>\n<li> 覆盖只能由一个方法或一对方法产生关系；重载是多个方法之间的关系。</li>\n<li> 覆盖要求参数列表相同；重载要求参数列表不同。</li>\n<li> 覆盖中，调用方法体是根据对象的类型来决定的，而重载是根据调用时实参表与形参表来对应选择方法体。</li>\n<li> 重载方法可以改变返回值的类型，覆盖方法不能改变返回值的类型。</li>\n</ul>\n<h3 id=\"接口和抽象类的相同点和不同点？\"><a href=\"#接口和抽象类的相同点和不同点？\" class=\"headerlink\" title=\"接口和抽象类的相同点和不同点？\"></a>接口和抽象类的相同点和不同点？</h3><p>相同点:</p>\n<ul>\n<li> 都不能被实例化。</li>\n<li> 接口的实现类或抽象类的子类需实现接口或抽象类中相应的方法才能被实例化。</li>\n</ul>\n<p>不同点：</p>\n<ul>\n<li> 接口只能有方法定义，不能有方法的实现，而抽象类可以有方法的定义与实现。</li>\n<li> 实现接口的关键字为 implements，继承抽象类的关键字为 extends。一个类可以实现多个接口，只能继承一个抽象类。</li>\n<li> 当子类和父类之间存在逻辑上的层次结构，推荐使用抽象类，有利于功能的累积。当功能不需要，希望支持差别较大的两个或更多对象间的特定交互行为，推荐使用接口。使用接口能降低软件系统的耦合度，便于日后维护或添加删除方法。</li>\n</ul>\n<h3 id=\"简述抽象类与接口的区别\"><a href=\"#简述抽象类与接口的区别\" class=\"headerlink\" title=\"简述抽象类与接口的区别\"></a>简述抽象类与接口的区别</h3><p>抽象类：体现的是 is-a 的关系，如对于 man is a person，就可以将 person 定义为抽象类。</p>\n<p>接口：体现的是 can 的关系。是作为模板实现的。如设置接口 fly，plane 类和 bird 类均可实现该接口。</p>\n<p>一个类只能继承一个抽象类，但可以实现多个接口。</p>\n<h3 id=\"简述内部类及其作用\"><a href=\"#简述内部类及其作用\" class=\"headerlink\" title=\"简述内部类及其作用\"></a>简述内部类及其作用</h3><ul>\n<li> 成员内部类：作为成员对象的内部类。可以访问 private 及以上外部类的属性和方法。外部类想要访问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法。外部类也可访问 private 修饰的内部类属性。</li>\n<li> 局部内部类：存在于方法中的内部类。访问权限类似局部变量，只能访问外部类的 final 变量。</li>\n<li> 匿名内部类：只能使用一次，没有类名，只能访问外部类的 final 变量。</li>\n<li> 静态内部类：类似类的静态成员变量。</li>\n</ul>\n<h3 id=\"Java-语言中关键字-static-的作用是什么？\"><a href=\"#Java-语言中关键字-static-的作用是什么？\" class=\"headerlink\" title=\"Java 语言中关键字 static 的作用是什么？\"></a>Java 语言中关键字 static 的作用是什么？</h3><p>static 的主要作用有两个：</p>\n<ul>\n<li> 为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。</li>\n<li> 使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法或使用类的属性。</li>\n</ul>\n<p>具体而言 static 又可分为 4 种使用方式：</p>\n<ul>\n<li> 修饰成员变量。用 static 关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加载，这个静态变量就会被分配空间，可以使用“类.静态变量”和“对象.静态变量”的方法使用。</li>\n<li> 修饰成员方法。static 修饰的方法无需创建对象就可以被调用。static 方法中不能使用 this 和 super 关键字，不能调用非 static 方法，只能访问所属类的静态成员变量和静态成员方法。</li>\n<li> 修饰代码块。JVM 在加载类的时候会执行 static 代码块。static 代码块常用于初始化静态变量。static 代码块只会被执行一次。</li>\n<li> 修饰内部类。static 内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法。</li>\n</ul>\n<h3 id=\"为什么要把-String-设计为不可变？\"><a href=\"#为什么要把-String-设计为不可变？\" class=\"headerlink\" title=\"为什么要把 String 设计为不可变？\"></a>为什么要把 String 设计为不可变？</h3><ul>\n<li> 节省空间：字符串常量存储在 JVM 的字符串池中可以被用户共享。</li>\n<li> 提高效率：String 可以被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。</li>\n<li> 安全：String 常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修改。</li>\n</ul>\n<h3 id=\"简述-String-StringBuffer-与-StringBuilder\"><a href=\"#简述-String-StringBuffer-与-StringBuilder\" class=\"headerlink\" title=\"简述 String/StringBuffer 与 StringBuilder\"></a>简述 String/StringBuffer 与 StringBuilder</h3><p>String 类采用利用 final 修饰的字符数组进行字符串保存，因此不可变。如果对 String 类型对象修改，需要新建对象，将老字符和新增加的字符一并存进去。</p>\n<p>StringBuilder，采用无 final 修饰的字符数组进行保存，因此可变。但线程不安全。</p>\n<p>StringBuffer，采用无 final 修饰的字符数组进行保存，可理解为实现线程安全的 StringBuilder。</p>\n<h3 id=\"判等运算符-与-equals-的区别？\"><a href=\"#判等运算符-与-equals-的区别？\" class=\"headerlink\" title=\"判等运算符==与 equals 的区别？\"></a>判等运算符==与 equals 的区别？</h3><p>== 比较的是引用，equals 比较的是内容。</p>\n<p>如果变量是基础数据类型，== 用于比较其对应值是否相等。如果变量指向的是对象，== 用于比较两个对象是否指向同一块存储空间。</p>\n<p>equals 是 Object 类提供的方法之一，每个 Java 类都继承自 Object 类，所以每个对象都具有 equals 这个方法。Object 类中定义的 equals 方法内部是直接调用 == 比较对象的。但通过覆盖的方法可以让它不是比较引用而是比较数据内容。</p>\n<h3 id=\"简述-Object-类常用方法\"><a href=\"#简述-Object-类常用方法\" class=\"headerlink\" title=\"简述 Object 类常用方法\"></a>简述 Object 类常用方法</h3><ul>\n<li> hashCode：通过对象计算出的散列码。用于 map 型或 equals 方法。需要保证同一个对象多次调用该方法，总返回相同的整型值。</li>\n<li> equals：判断两个对象是否一致。需保证 equals 方法相同对应的对象 hashCode 也相同。</li>\n<li> toString: 用字符串表示该对象</li>\n<li> clone:深拷贝一个对象</li>\n</ul>\n<h3 id=\"Java-中一维数组和二维数组的声明方式？\"><a href=\"#Java-中一维数组和二维数组的声明方式？\" class=\"headerlink\" title=\"Java 中一维数组和二维数组的声明方式？\"></a>Java 中一维数组和二维数组的声明方式？</h3><p>一维数组的声明方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">type arrayName<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\ntype<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arrayName<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>二维数组的声明方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">type arrayName<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\ntype<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arrayName\ntype<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> arrayName<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>其中 type 为基本数据类型或类，arrayName 为数组名字</p>\n<h3 id=\"简述-Java-异常的分类\"><a href=\"#简述-Java-异常的分类\" class=\"headerlink\" title=\"简述 Java 异常的分类\"></a>简述 Java 异常的分类</h3><p>Java 异常分为 Error（程序无法处理的错误），和 Exception（程序本身可以处理的异常）。这两个类均继承 Throwable。</p>\n<p>Error 常见的有 StackOverFlowError、OutOfMemoryError 等等。</p>\n<p>Exception 可分为运行时异常和非运行时异常。对于运行时异常，可以利用 try catch 的方式进行处理，也可以不处理。对于非运行时异常，必须处理，不处理的话程序无法通过编译。</p>\n<h3 id=\"简述-throw-与-throws-的区别\"><a href=\"#简述-throw-与-throws-的区别\" class=\"headerlink\" title=\"简述 throw 与 throws 的区别\"></a>简述 throw 与 throws 的区别</h3><p>throw 一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常。</p>\n<p>throws 一般用于方法声明上，代表该方法可能会抛出的异常列表。</p>\n<h3 id=\"出现在-Java-程序中的-finally-代码块是否一定会执行？\"><a href=\"#出现在-Java-程序中的-finally-代码块是否一定会执行？\" class=\"headerlink\" title=\"出现在 Java 程序中的 finally 代码块是否一定会执行？\"></a>出现在 Java 程序中的 finally 代码块是否一定会执行？</h3><p>当遇到下面情况不会执行。</p>\n<ul>\n<li> 当程序在进入 try 语句块之前就出现异常时会直接结束。</li>\n<li> 当程序在 try 块中强制退出时，如使用 System.exit(0)，也不会执行 finally 块中的代码。</li>\n</ul>\n<p>其它情况下，在 try/catch/finally 语句执行的时候，try 块先执行，当有异常发生，catch 和 finally 进行处理后程序就结束了，当没有异常发生，在执行完 finally 中的代码后，后面代码会继续执行。值得注意的是，当 try/catch 语句块中有 return 时，finally 语句块中的代码会在 return 之前执行。如果 try/catch/finally 块中都有 return 语句，finally 块中的 return 语句会覆盖 try/catch 模块中的 return 语句。</p>\n<h3 id=\"final、finally-和-finalize-的区别是什么？\"><a href=\"#final、finally-和-finalize-的区别是什么？\" class=\"headerlink\" title=\"final、finally 和 finalize 的区别是什么？\"></a>final、finally 和 finalize 的区别是什么？</h3><ul>\n<li> final 用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。</li>\n<li> finally 作为异常处理的一部分，只能在 try/catch 语句中使用，finally 附带一个语句块用来表示这个语句最终一定被执行，经常被用在需要释放资源的情况下。</li>\n<li> finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的 finalize()方法。当垃圾回收器准备好释放对象占用空间时，首先会调用 finalize()方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存。</li>\n</ul>\n<h3 id=\"简述泛型\"><a href=\"#简述泛型\" class=\"headerlink\" title=\"简述泛型\"></a>简述泛型</h3><p>泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛型方法。</p>\n<h3 id=\"简述泛型擦除\"><a href=\"#简述泛型擦除\" class=\"headerlink\" title=\"简述泛型擦除\"></a>简述泛型擦除</h3><p>Java 编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程被称为泛型擦除。</p>\n<h3 id=\"简述注解\"><a href=\"#简述注解\" class=\"headerlink\" title=\"简述注解\"></a>简述注解</h3><p>Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。</p>\n<p>其可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代码，做对应操作。</p>\n<h3 id=\"简述元注解\"><a href=\"#简述元注解\" class=\"headerlink\" title=\"简述元注解\"></a>简述元注解</h3><p>元注解可以理解为注解的注解，即在注解中使用，实现想要的功能。其具体分为：</p>\n<ul>\n<li> @Retention: 表示注解存在阶段是保留在源码，还是在字节码（类加载）或者运行期（JVM 中运行）。</li>\n<li> @Target：表示注解作用的范围。</li>\n<li> @Documented：将注解中的元素包含到 Javadoc 中去。</li>\n<li> @Inherited：一个被@Inherited 注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。</li>\n<li> @Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。</li>\n</ul>\n<h3 id=\"简述-Java-中-Class-对象\"><a href=\"#简述-Java-中-Class-对象\" class=\"headerlink\" title=\"简述 Java 中 Class 对象\"></a>简述 Java 中 Class 对象</h3><p>java 中对象可以分为实例对象和 Class 对象，每一个类都有一个 Class 对象，其包含了与该类有关的信息。</p>\n<p>获取 Class 对象的方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Class</span><span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span>“类的全限定名”<span class=\"token punctuation\">)</span>\n实例对象<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n类名<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Java-反射机制是什么？\"><a href=\"#Java-反射机制是什么？\" class=\"headerlink\" title=\"Java 反射机制是什么？\"></a>Java 反射机制是什么？</h3><p>Java 反射机制是指在程序的运行过程中可以构造任意一个类的对象、获取任意一个类的成员变量和成员方法、获取任意一个对象所属的类信息、调用任意一个对象的属性和方法。反射机制使得 Java 具有动态获取程序信息和动态调用对象方法的能力。可以通过以下类调用反射 API。</p>\n<ul>\n<li> Class 类：可获得类属性方法</li>\n<li> Field 类：获得类的成员变量</li>\n<li> Method 类：获取类的方法信息</li>\n<li> Construct 类：获取类的构造方法等信息</li>\n</ul>\n<h3 id=\"序列化是什么？\"><a href=\"#序列化是什么？\" class=\"headerlink\" title=\"序列化是什么？\"></a>序列化是什么？</h3><p>序列化是一种将对象转换成字节序列的过程，用于解决在对对象流进行读写操作时所引发的问题。序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把该流读取出来重新构造成一个相同的对象。</p>\n<h3 id=\"简述-Java-序列化与反序列化的实现\"><a href=\"#简述-Java-序列化与反序列化的实现\" class=\"headerlink\" title=\"简述 Java 序列化与反序列化的实现\"></a>简述 Java 序列化与反序列化的实现</h3><p>序列化：将 java 对象转化为字节序列，由此可以通过网络对象进行传输。</p>\n<p>反序列化：将字节序列转化为 java 对象。</p>\n<p>具体实现：实现 Serializable 接口，或实现 Externalizable 接口中的 writeExternal()与 readExternal()方法。</p>\n<h3 id=\"简述-Java-的-List\"><a href=\"#简述-Java-的-List\" class=\"headerlink\" title=\"简述 Java 的 List\"></a>简述 Java 的 List</h3><p>List 是一个有序队列，在 Java 中有两种实现方式:</p>\n<p>ArrayList 使用数组实现，是容量可变的非线程安全列表，随机访问快，集合扩容时会创建更大的数组，把原有数组复制到新数组。</p>\n<p>LinkedList 本质是双向链表，与 ArrayList 相比插入和删除速度更快，但随机访问元素很慢。</p>\n<h3 id=\"Java-中线程安全的基本数据结构有哪些\"><a href=\"#Java-中线程安全的基本数据结构有哪些\" class=\"headerlink\" title=\"Java 中线程安全的基本数据结构有哪些\"></a>Java 中线程安全的基本数据结构有哪些</h3><ul>\n<li> HashTable: 哈希表的线程安全版，效率低</li>\n<li> ConcurrentHashMap：哈希表的线程安全版，效率高，用于替代 HashTable</li>\n<li> Vector：线程安全版 Arraylist</li>\n<li> Stack：线程安全版栈</li>\n<li> BlockingQueue 及其子类：线程安全版队列</li>\n</ul>\n<h3 id=\"简述-Java-的-Set\"><a href=\"#简述-Java-的-Set\" class=\"headerlink\" title=\"简述 Java 的 Set\"></a>简述 Java 的 Set</h3><p>Set 即集合，该数据结构不允许元素重复且无序。Java 对 Set 有三种实现方式：</p>\n<p>HashSet 通过 HashMap 实现，HashMap 的 Key 即 HashSet 存储的元素，Value 系统自定义一个名为 PRESENT 的 Object 类型常量。判断元素是否相同时，先比较 hashCode，相同后再利用 equals 比较，查询 O(1)</p>\n<p>LinkedHashSet 继承自 HashSet，通过 LinkedHashMap 实现，使用双向链表维护元素插入顺序。</p>\n<p>TreeSet 通过 TreeMap 实现的，底层数据结构是红黑树，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。查询 O(logn)</p>\n<h3 id=\"简述-Java-的-HashMap\"><a href=\"#简述-Java-的-HashMap\" class=\"headerlink\" title=\"简述 Java 的 HashMap\"></a>简述 Java 的 HashMap</h3><p>JDK8 之前底层实现是数组 + 链表，JDK8 改为数组 + 链表/红黑树。主要成员变量包括存储数据的 table 数组、元素数量 size、加载因子 loadFactor。HashMap 中数据以键值对的形式存在，键对应的 hash 值用来计算数组下标，如果两个元素 key 的 hash 值一样，就会发生哈希冲突，被放到同一个链表上。</p>\n<p>table 数组记录 HashMap 的数据，每个下标对应一条链表，所有哈希冲突的数据都会被存放到同一条链表，Node/Entry 节点包含四个成员变量：key、value、next 指针和 hash 值。在 JDK8 后链表超过 8 会转化为红黑树。</p>\n<p>若当前数据/总数据容量&gt;负载因子，Hashmap 将执行扩容操作。默认初始化容量为 16，扩容容量必须是 2 的幂次方、最大容量为 1&lt;&lt; 30 、默认加载因子为 0.75。</p>\n<h3 id=\"为何-HashMap-线程不安全\"><a href=\"#为何-HashMap-线程不安全\" class=\"headerlink\" title=\"为何 HashMap 线程不安全\"></a>为何 HashMap 线程不安全</h3><p>在 JDK1.7 中，HashMap 采用头插法插入元素，因此并发情况下会导致环形链表，产生死循环。</p>\n<p>虽然 JDK1.8 采用了尾插法解决了这个问题，但是并发下的 put 操作也会使前一个 key 被后一个 key 覆盖。</p>\n<p>由于 HashMap 有扩容机制存在，也存在 A 线程进行扩容后，B 线程执行 get 方法出现失误的情况。</p>\n<h3 id=\"简述-Java-的-TreeMap\"><a href=\"#简述-Java-的-TreeMap\" class=\"headerlink\" title=\"简述 Java 的 TreeMap\"></a>简述 Java 的 TreeMap</h3><p>TreeMap 是底层利用红黑树实现的 Map 结构，底层实现是一棵平衡的排序二叉树，由于红黑树的插入、删除、遍历时间复杂度都为 O(logN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树可以按照键的值的大小有序输出。</p>\n<h3 id=\"ArrayList、Vector-和-LinkedList-有什么共同点与区别？\"><a href=\"#ArrayList、Vector-和-LinkedList-有什么共同点与区别？\" class=\"headerlink\" title=\"ArrayList、Vector 和 LinkedList 有什么共同点与区别？\"></a>ArrayList、Vector 和 LinkedList 有什么共同点与区别？</h3><ul>\n<li> ArrayList、Vector 和 LinkedList 都是可伸缩的数组，即可以动态改变长度的数组。</li>\n<li> ArrayList 和 Vector 都是基于存储元素的 Object[] array 来实现的，它们会在内存中开辟一块连续的空间来存储，支持下标、索引访问。但在涉及插入元素时可能需要移动容器中的元素，插入效率较低。当存储元素超过容器的初始化容量大小，ArrayList 与 Vector 均会进行扩容。</li>\n<li> Vector 是线程安全的，其大部分方法是直接或间接同步的。ArrayList 不是线程安全的，其方法不具有同步性质。LinkedList 也不是线程安全的。</li>\n<li> LinkedList 采用双向列表实现，对数据索引需要从头开始遍历，因此随机访问效率较低，但在插入元素的时候不需要对数据进行移动，插入效率较高。</li>\n</ul>\n<h3 id=\"HashMap-和-Hashtable-有什么区别？\"><a href=\"#HashMap-和-Hashtable-有什么区别？\" class=\"headerlink\" title=\"HashMap 和 Hashtable 有什么区别？\"></a>HashMap 和 Hashtable 有什么区别？</h3><ul>\n<li> HashMap 是 Hashtable 的轻量级实现，HashMap 允许 key 和 value 为 null，但最多允许一条记录的 key 为 null.而 HashTable 不允许。</li>\n<li> HashTable 中的方法是线程安全的，而 HashMap 不是。在多线程访问 HashMap 需要提供额外的同步机制。</li>\n<li> Hashtable 使用 Enumeration 进行遍历，HashMap 使用 Iterator 进行遍历。</li>\n</ul>\n<h3 id=\"如何决定使用-HashMap-还是-TreeMap\"><a href=\"#如何决定使用-HashMap-还是-TreeMap\" class=\"headerlink\" title=\"如何决定使用 HashMap 还是 TreeMap?\"></a>如何决定使用 HashMap 还是 TreeMap?</h3><p>如果对 Map 进行插入、删除或定位一个元素的操作更频繁，HashMap 是更好的选择。如果需要对 key 集合进行有序的遍历，TreeMap 是更好的选择。</p>\n<h3 id=\"HashSet-中，equals-与-hashCode-之间的关系？\"><a href=\"#HashSet-中，equals-与-hashCode-之间的关系？\" class=\"headerlink\" title=\"HashSet 中，equals 与 hashCode 之间的关系？\"></a>HashSet 中，equals 与 hashCode 之间的关系？</h3><p>equals 和 hashCode 这两个方法都是从 object 类中继承过来的，equals 主要用于判断对象的内存地址引用是否是同一个地址；hashCode 根据定义的哈希规则将对象的内存地址转换为一个哈希码。HashSet 中存储的元素是不能重复的，主要通过 hashCode 与 equals 两个方法来判断存储的对象是否相同：</p>\n<ul>\n<li> 如果两个对象的 hashCode 值不同，说明两个对象不相同。</li>\n<li> 如果两个对象的 hashCode 值相同，接着会调用对象的 equals 方法，如果 equlas 方法的返回结果为 true，那么说明两个对象相同，否则不相同。</li>\n</ul>\n<h3 id=\"fail-fast-和-fail-safe-迭代器的区别是什么？\"><a href=\"#fail-fast-和-fail-safe-迭代器的区别是什么？\" class=\"headerlink\" title=\"fail-fast 和 fail-safe 迭代器的区别是什么？\"></a>fail-fast 和 fail-safe 迭代器的区别是什么？</h3><ul>\n<li> fail-fast 直接在容器上进行，在遍历过程中，一旦发现容器中的数据被修改，就会立刻抛出 ConcurrentModificationException 异常从而导致遍历失败。常见的使用 fail-fast 方式的容器有 HashMap 和 ArrayList 等。</li>\n<li> fail-safe 这种遍历基于容器的一个克隆。因此对容器中的内容修改不影响遍历。常见的使用 fail-safe 方式遍历的容器有 ConcurrentHashMap 和 CopyOnWriteArrayList。</li>\n</ul>\n<h3 id=\"Collection-和-Collections-有什么区别？\"><a href=\"#Collection-和-Collections-有什么区别？\" class=\"headerlink\" title=\"Collection 和 Collections 有什么区别？\"></a>Collection 和 Collections 有什么区别？</h3><ul>\n<li> Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li>\n<li> Collections 是一个包装类，包含了很多静态方法、不能被实例化，而是作为工具类使用，比如提供的排序方法：Collections.sort(list);提供的反转方法：Collections.reverse(list)。</li>\n</ul>\n"},{"title":"Java并发编程八股文","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-11-04T05:17:41.000Z","password":null,"summary":"保证单线程程序的执行结果不变","_content":"### 简述Java内存模型（JMM） \n\nJava内存模型定义了程序中各种变量的访问规则：\n\n *  所有变量都存储在主存，每个线程都有自己的工作内存。\n *  工作内存中保存了被该线程使用的变量的主存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。\n *  操作完成后，线程的工作内存通过缓存一致性协议将操作完的数据刷回主存。\n\n### 简述as-if-serial \n\n编译器会对原始的程序进行指令重排序和优化。但不管怎么重排序，其结果都必须和用户原始程序输出的预定结果保持一致。\n\n### 简述happens-before八大规则 \n\n *  程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；\n *  锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；\n *  volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；\n *  传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；\n *  线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；\n *  线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；\n *  线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；\n *  对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；\n\n### as-if-serial 和 happens-before 的区别 \n\nas-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。\n\n### 简述原子性操作 \n\n一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行，这就是原子性操作。\n\n### 简述线程的可见性 \n\n可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。volatile、synchronized、final 关键字都能保证可见性。\n\n### 简述有序性 \n\n虽然多线程存在并发和指令优化等操作，但在本线程内观察该线程的所有执行操作是有序的。\n\n### 简述Java中volatile关键字作用 \n\n *  保证变量对所有线程的可见性。当一个线程修改了变量值，新值对于其他线程来说是立即可以得知的。\n *  禁止指令重排。使用 volatile 变量进行写操作，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器进行重排序。\n\n### Java线程的实现方式 \n\n *  实现Runnable接口\n *  继承Thread类\n *  实现Callable接口\n\n### 简述Java线程的状态 \n\n线程状态有 NEW、RUNNABLE、BLOCK、WAITING、TIMED\\_WAITING、THERMINATED\n\n *  NEW：新建状态，线程被创建且未启动，此时还未调用 start 方法。\n *  RUNNABLE：运行状态。表示线程正在JVM中执行，但是这个执行，不一定真的在跑，也可能在排队等CPU。\n *  BLOCKED：阻塞状态。线程等待获取锁，锁还没获得。\n *  WAITING：等待状态。线程内run方法执行完Object.wait()/Thread.join()进入该状态。\n *  TIMED\\_WAITING：限期等待。在一定时间之后跳出状态。调用Thread.sleep(long) Object.wait(long) Thread.join(long)进入状态。其中这些参数代表等待的时间。\n *  TERMINATED：结束状态。线程调用完run方法进入该状态。\n\n### 简述线程通信的方式 \n\n *  volatile 关键词修饰变量，保证所有线程对变量访问的可见性。\n *  synchronized关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中。\n *  wait/notify方法\n *  IO通信\n\n### 简述线程池 \n\n没有线程池的情况下，多次创建，销毁线程开销比较大。如果在开辟的线程执行完当前任务后复用已创建的线程，可以降低开销、控制最大并发数。\n\n线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列中的任务来执行。\n\n将任务派发给线程池时，会出现以下几种情况\n\n *  核心线程池未满，创建一个新的线程执行任务。\n *  如果核心线程池已满，工作队列未满，将线程存储在工作队列。\n *  如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务。\n *  如果超过大小线程数，按照拒绝策略来处理任务。\n\n线程池参数：\n\n *  corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁。\n *  maximumPoolSize：线程池能够容纳同时执行的线程最大数。\n *  keepAliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存资源。\n *  workQueue：工作队列。\n *  threadFactory：线程工厂，用来生产一组相同任务的线程。\n *  handler：拒绝策略。\n\n拒绝策略有以下几种：\n\n *  AbortPolicy：丢弃任务并抛出异常\n *  CallerRunsPolicy：重新尝试提交该任务\n *  DiscardOldestPolicy 抛弃队列里等待最久的任务并把当前任务加入队列\n *  DiscardPolicy 表示直接抛弃当前任务但不抛出异常。\n\n### 简述Executor框架 \n\nExecutor框架目的是将任务提交和任务如何运行分离开来的机制。用户不再需要从代码层考虑设计任务的提交运行，只需要调用Executor框架实现类的Execute方法就可以提交任务。\n\n### 简述Executor的继承关系 \n\n *  Executor：一个接口，其定义了一个接收Runnable对象的方法executor，该方法接收一个Runable实例执行这个任务。\n *  ExecutorService：Executor的子类接口，其定义了一个接收Callable对象的方法，返回 Future 对象，同时提供execute方法。\n *  ScheduledExecutorService：ExecutorService的子类接口，支持定期执行任务。\n *  AbstractExecutorService：抽象类，提供 ExecutorService 执行方法的默认实现。\n *  Executors：实现ExecutorService接口的静态工厂类，提供了一系列工厂方法用于创建线程池。\n *  ThreadPoolExecutor：继承AbstractExecutorService，用于创建线程池。\n *  ForkJoinPool: 继承AbstractExecutorService，Fork 将大任务分叉为多个小任务，然后让小任务执行，Join 是获得小任务的结果，类似于map reduce。\n *  ThreadPoolExecutor：继承ThreadPoolExecutor，实现ScheduledExecutorService，用于创建带定时任务的线程池。\n\n### 简述线程池的状态 \n\n *  Running：能接受新提交的任务，也可以处理阻塞队列的任务。\n *  Shutdown：不再接受新提交的任务，但可以处理存量任务，线程池处于running时调用shutdown方法，会进入该状态。\n *  Stop：不接受新任务，不处理存量任务，调用shutdownnow进入该状态。\n *  Tidying：所有任务已经终止了，worker\\_count（有效线程数）为0。\n *  Terminated：线程池彻底终止。在tidying模式下调用terminated方法会进入该状态。\n\n### 简述线程池类型 \n\n *  newCachedThreadPool 可缓存线程池，可设置最小线程数和最大线程数，线程空闲1分钟后自动销毁。\n *  newFixedThreadPool 指定工作线程数量线程池。\n *  newSingleThreadExecutor 单线程Executor。\n *  newScheduleThreadPool 支持定时任务的指定工作线程数量线程池。\n *  newSingleThreadScheduledExecutor 支持定时任务的单线程Executor。\n\n### 简述阻塞队列 \n\n阻塞队列是生产者消费者的实现具体组件之一。当阻塞队列为空时，从队列中获取元素的操作将会被阻塞，当阻塞队列满了，往队列添加元素的操作将会被阻塞。具体实现有：\n\n *  ArrayBlockingQueue：底层是由数组组成的有界阻塞队列。\n *  LinkedBlockingQueue：底层是由链表组成的有界阻塞队列。\n *  PriorityBlockingQueue：阻塞优先队列。\n *  DelayQueue：创建元素时可以指定多久才能从队列中获取当前元素\n *  SynchronousQueue：不存储元素的阻塞队列，每一个存储必须等待一个取出操作\n *  LinkedTransferQueue：与LinkedBlockingQueue相比多一个transfer方法，即如果当前有消费者正等待接收元素，可以把生产者传入的元素立刻传输给消费者。\n *  LinkedBlockingDeque：双向阻塞队列。\n\n### 谈一谈ThreadLocal \n\nThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的。\n\n *  set 给ThreadLocalMap设置值。\n *  get 获取ThreadLocalMap。\n *  remove 删除ThreadLocalMap类型的对象。\n\n存在的问题：对于线程池，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用，造成一系列问题。\n\n比如说内存泄漏。由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放，产生内存泄漏。\n\n### 聊聊你对Java并发包下unsafe类的理解 \n\n对于 Java 语言，没有直接的指针组件，一般也不能使用偏移量对某块内存进行操作。这些操作相对来讲是安全（safe）的。\n\nJava 有个类叫 Unsafe 类，这个类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。这个类可以说是 Java 并发开发的基础。\n\n### Java中的乐观锁与CAS算法 \n\n乐观锁认为数据发送时发生并发冲突的概率不大，所以读操作前不上锁。\n\n到了写操作时才会进行判断，数据在此期间是否被其他线程修改。如果发生修改，那就返回写入失败；如果没有被修改，那就执行修改操作，返回修改成功。\n\n乐观锁一般都采用 Compare And Swap（CAS）算法进行实现。顾名思义，该算法涉及到了两个操作，比较（Compare）和交换（Swap）。\n\nCAS 算法的思路如下：\n\n *  该算法认为不同线程对变量的操作时产生竞争的情况比较少。\n *  该算法的核心是对当前读取变量值 E 和内存中的变量旧值 V 进行比较。\n *  如果相等，就代表其他线程没有对该变量进行修改，就将变量值更新为新值 N。\n *  如果不等，就认为在读取值 E 到比较阶段，有其他线程对变量进行过修改，不进行任何操作。\n\n### ABA问题及解决方法简述 \n\nCAS 算法是基于值来做比较的，如果当前有两个线程，一个线程将变量值从 A 改为 B ，再由 B 改回为 A ，当前线程开始执行 CAS 算法时，就很容易认为值没有变化，误认为读取数据到执行 CAS 算法的期间，没有线程修改过数据。\n\njuc 包提供了一个 AtomicStampedReference，即在原始的版本下加入版本号戳，解决 ABA 问题。\n\n### 简述常见的Atomic类 \n\n在很多时候，我们需要的仅仅是一个简单的、高效的、线程安全的++或者--方案，使用synchronized关键字和lock固然可以实现，但代价比较大，此时用原子类更加方便。基本数据类型的原子类有：\n\n *  AtomicInteger 原子更新整形\n *  AtomicLong 原子更新长整型\n *  AtomicBoolean 原子更新布尔类型\n\nAtomic数组类型有：\n\n *  AtomicIntegerArray 原子更新整形数组里的元素\n *  AtomicLongArray 原子更新长整型数组里的元素\n *  AtomicReferenceArray 原子更新引用类型数组里的元素。\n\nAtomic引用类型有：\n\n *  AtomicReference 原子更新引用类型\n *  AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 标记\n *  AtomicStampedReference 原子更新带有版本号的引用类型\n\nFieldUpdater类型：\n\n *  AtomicIntegerFieldUpdater 原子更新整形字段的更新器\n *  AtomicLongFieldUpdater 原子更新长整形字段的更新器\n *  AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器\n\n### 简述Atomic类基本实现原理 \n\n以AtomicIntger 为例。\n\n方法getAndIncrement，以原子方式将当前的值加1，具体实现为：\n\n *  在 for 死循环中取得 AtomicInteger 里存储的数值\n *  对 AtomicInteger 当前的值加 1\n *  调用 compareAndSet 方法进行原子更新\n *  先检查当前数值是否等于 expect\n *  如果等于则说明当前值没有被其他线程修改，则将值更新为 next，\n *  如果不是会更新失败返回 false，程序会进入 for 循环重新进行 compareAndSet 操作。\n\n### 简述CountDownLatch \n\nCountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，调用countDown方法，计数器的值就减1，当计数器的值为0时，表示所有线程都执行完毕，然后在等待的线程就可以恢复工作了。只能一次性使用，不能reset。\n\n### 简述CyclicBarrier \n\nCyclicBarrier 主要功能和CountDownLatch类似，也是通过一个计数器，使一个线程等待其他线程各自执行完毕后再执行。但是其可以重复使用（reset）。\n\n### 简述Semaphore \n\nSemaphore即信号量。Semaphore 的构造方法参数接收一个 int 值，设置一个计数器，表示可用的许可数量即最大并发数。使用 acquire 方法获得一个许可证，计数器减一，使用 release 方法归还许可，计数器加一。如果此时计数器值为0，线程进入休眠。\n\n### 简述Exchanger \n\nExchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。线程通过exchange 方法交换数据，第一个线程执行 exchange 方法后会阻塞等待第二个线程执行该方法。当两个线程都到达同步点时这两个线程就可以交换数据当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。\n\n### 简述ConcurrentHashMap \n\nJDK7采用锁分段技术。首先将数据分成 Segment 数据段，然后给每一个数据段配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。\n\nget 除读到空值不需要加锁。该方法先经过一次再散列，再用这个散列值通过散列运算定位到 Segment，最后通过散列算法定位到元素。put 须加锁，首先定位到 Segment，然后进行插入操作，第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放入数组。\n\nJDK8的改进\n\n *  取消分段锁机制，采用CAS算法进行值的设置，如果CAS失败再使用 synchronized 加锁添加元素\n *  引入红黑树结构，当某个槽内的元素个数超过8且 Node数组 容量大于 64 时，链表转为红黑树。\n *  使用了更加优化的方式统计集合内的元素数量。\n\n### synchronized底层实现原理 \n\nJava 对象底层都会关联一个 monitor，使用 synchronized 时 JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者，monitor 在被释放前不能再被其他线程获取。\n\nsynchronized在JVM编译后会产生monitorenter 和 monitorexit 这两个字节码指令，获取和释放 monitor。这两个字节码指令都需要一个引用类型的参数指明要锁定和解锁的对象，对于同步普通方法，锁是当前实例对象；对于静态同步方法，锁是当前类的 Class 对象；对于同步方法块，锁是 synchronized 括号里的对象。\n\n执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。\n\n### synchronized关键词使用方法 \n\n *  直接修饰某个实例方法\n *  直接修饰某个静态方法\n *  修饰代码块\n\n### 简述Java偏向锁 \n\nJDK 1.6 中提出了偏向锁的概念。该锁提出的原因是，开发者发现多数情况下锁并不存在竞争，一把锁往往是由同一个线程获得的。偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。\n\n其申请流程为：\n\n *  首先需要判断对象的 Mark Word 是否属于偏向模式，如果不属于，那就进入轻量级锁判断逻辑。否则继续下一步判断；\n *  判断目前请求锁的线程 ID 是否和偏向锁本身记录的线程 ID 一致。如果一致，继续下一步的判断，如果不一致，跳转到步骤4；\n *  判断是否需要重偏向。如果不用的话，直接获得偏向锁；\n *  利用 CAS 算法将对象的 Mark Word 进行更改，使线程 ID 部分换成本线程 ID。如果更换成功，则重偏向完成，获得偏向锁。如果失败，则说明有多线程竞争，升级为轻量级锁。\n\n### 简述轻量级锁 \n\n轻量级锁是为了在没有竞争的前提下减少重量级锁出现并导致的性能消耗。\n\n其申请流程为：\n\n *  如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝。\n *  虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针\n *  如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。\n *  如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧\n *  如果指向当前线程的栈帧，说明当前线程已经拥有了锁，直接进入同步块继续执行\n *  如果不是则说明锁对象已经被其他线程抢占。\n *  如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。\n\n### 简述锁优化策略 \n\n即自适应自旋、锁消除、锁粗化、锁升级等策略偏。\n\n### 简述Java的自旋锁 \n\n线程获取锁失败后，可以采用这样的策略，可以不放弃 CPU ，不停的重试内重试，这种操作也称为自旋锁。\n\n### 简述自适应自旋锁 \n\n自适应自旋锁自旋次数不再人为设定，通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。\n\n### 简述锁粗化 \n\n锁粗化的思想就是扩大加锁范围，避免反复的加锁和解锁。\n\n### 简述锁消除 \n\n锁消除是一种更为彻底的优化，在编译时，Java编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁。\n\n### 简述Lock与ReentrantLock \n\nLock接口是 Java并发包的顶层接口。\n\n可重入锁 ReentrantLock 是 Lock 最常见的实现，与 synchronized 一样可重入。ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会下降。\n\n### 简述AQS \n\nAQS（AbstractQuenedSynchronizer）抽象的队列式同步器。AQS是将每一条请求共享资源的线程封装成一个锁队列的一个结点（Node），来实现锁的分配。AQS是用来构建锁或其他同步组件的基础框架，它使用一个 volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。\n\n子类通过继承同步器并实现它的抽象方法getState、setState 和 compareAndSetState对同步状态进行更改。\n\nAQS获取独占锁/释放独占锁原理：\n\n获取：（acquire）\n\n *  调用 tryAcquire 方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过 addWaiter 方法加入到同步队列的尾部，在队列中自旋。\n *  调用 acquireQueued 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞。\n\n释放：（release）\n\n *  调用 tryRelease 方法释放同步状态\n *  调用 unparkSuccessor 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。\n\nAQS获取共享锁/释放共享锁原理\n\n获取锁（acquireShared）\n\n *  调用 tryAcquireShared 方法尝试获取同步状态，返回值不小于 0 表示能获取同步状态。\n *  释放（releaseShared），并唤醒后续处于等待状态的节点。","source":"_posts/Java并发编程八股文.md","raw":"---\ntitle: Java并发编程八股文\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-11-04 13:17:41\npassword:\nsummary: 保证单线程程序的执行结果不变\ntags:\n    - 并发编程\n    - 八股文\ncategories:\n    - java\n---\n### 简述Java内存模型（JMM） \n\nJava内存模型定义了程序中各种变量的访问规则：\n\n *  所有变量都存储在主存，每个线程都有自己的工作内存。\n *  工作内存中保存了被该线程使用的变量的主存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。\n *  操作完成后，线程的工作内存通过缓存一致性协议将操作完的数据刷回主存。\n\n### 简述as-if-serial \n\n编译器会对原始的程序进行指令重排序和优化。但不管怎么重排序，其结果都必须和用户原始程序输出的预定结果保持一致。\n\n### 简述happens-before八大规则 \n\n *  程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；\n *  锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；\n *  volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；\n *  传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；\n *  线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；\n *  线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；\n *  线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；\n *  对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；\n\n### as-if-serial 和 happens-before 的区别 \n\nas-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。\n\n### 简述原子性操作 \n\n一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行，这就是原子性操作。\n\n### 简述线程的可见性 \n\n可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。volatile、synchronized、final 关键字都能保证可见性。\n\n### 简述有序性 \n\n虽然多线程存在并发和指令优化等操作，但在本线程内观察该线程的所有执行操作是有序的。\n\n### 简述Java中volatile关键字作用 \n\n *  保证变量对所有线程的可见性。当一个线程修改了变量值，新值对于其他线程来说是立即可以得知的。\n *  禁止指令重排。使用 volatile 变量进行写操作，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器进行重排序。\n\n### Java线程的实现方式 \n\n *  实现Runnable接口\n *  继承Thread类\n *  实现Callable接口\n\n### 简述Java线程的状态 \n\n线程状态有 NEW、RUNNABLE、BLOCK、WAITING、TIMED\\_WAITING、THERMINATED\n\n *  NEW：新建状态，线程被创建且未启动，此时还未调用 start 方法。\n *  RUNNABLE：运行状态。表示线程正在JVM中执行，但是这个执行，不一定真的在跑，也可能在排队等CPU。\n *  BLOCKED：阻塞状态。线程等待获取锁，锁还没获得。\n *  WAITING：等待状态。线程内run方法执行完Object.wait()/Thread.join()进入该状态。\n *  TIMED\\_WAITING：限期等待。在一定时间之后跳出状态。调用Thread.sleep(long) Object.wait(long) Thread.join(long)进入状态。其中这些参数代表等待的时间。\n *  TERMINATED：结束状态。线程调用完run方法进入该状态。\n\n### 简述线程通信的方式 \n\n *  volatile 关键词修饰变量，保证所有线程对变量访问的可见性。\n *  synchronized关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中。\n *  wait/notify方法\n *  IO通信\n\n### 简述线程池 \n\n没有线程池的情况下，多次创建，销毁线程开销比较大。如果在开辟的线程执行完当前任务后复用已创建的线程，可以降低开销、控制最大并发数。\n\n线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列中的任务来执行。\n\n将任务派发给线程池时，会出现以下几种情况\n\n *  核心线程池未满，创建一个新的线程执行任务。\n *  如果核心线程池已满，工作队列未满，将线程存储在工作队列。\n *  如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务。\n *  如果超过大小线程数，按照拒绝策略来处理任务。\n\n线程池参数：\n\n *  corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁。\n *  maximumPoolSize：线程池能够容纳同时执行的线程最大数。\n *  keepAliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存资源。\n *  workQueue：工作队列。\n *  threadFactory：线程工厂，用来生产一组相同任务的线程。\n *  handler：拒绝策略。\n\n拒绝策略有以下几种：\n\n *  AbortPolicy：丢弃任务并抛出异常\n *  CallerRunsPolicy：重新尝试提交该任务\n *  DiscardOldestPolicy 抛弃队列里等待最久的任务并把当前任务加入队列\n *  DiscardPolicy 表示直接抛弃当前任务但不抛出异常。\n\n### 简述Executor框架 \n\nExecutor框架目的是将任务提交和任务如何运行分离开来的机制。用户不再需要从代码层考虑设计任务的提交运行，只需要调用Executor框架实现类的Execute方法就可以提交任务。\n\n### 简述Executor的继承关系 \n\n *  Executor：一个接口，其定义了一个接收Runnable对象的方法executor，该方法接收一个Runable实例执行这个任务。\n *  ExecutorService：Executor的子类接口，其定义了一个接收Callable对象的方法，返回 Future 对象，同时提供execute方法。\n *  ScheduledExecutorService：ExecutorService的子类接口，支持定期执行任务。\n *  AbstractExecutorService：抽象类，提供 ExecutorService 执行方法的默认实现。\n *  Executors：实现ExecutorService接口的静态工厂类，提供了一系列工厂方法用于创建线程池。\n *  ThreadPoolExecutor：继承AbstractExecutorService，用于创建线程池。\n *  ForkJoinPool: 继承AbstractExecutorService，Fork 将大任务分叉为多个小任务，然后让小任务执行，Join 是获得小任务的结果，类似于map reduce。\n *  ThreadPoolExecutor：继承ThreadPoolExecutor，实现ScheduledExecutorService，用于创建带定时任务的线程池。\n\n### 简述线程池的状态 \n\n *  Running：能接受新提交的任务，也可以处理阻塞队列的任务。\n *  Shutdown：不再接受新提交的任务，但可以处理存量任务，线程池处于running时调用shutdown方法，会进入该状态。\n *  Stop：不接受新任务，不处理存量任务，调用shutdownnow进入该状态。\n *  Tidying：所有任务已经终止了，worker\\_count（有效线程数）为0。\n *  Terminated：线程池彻底终止。在tidying模式下调用terminated方法会进入该状态。\n\n### 简述线程池类型 \n\n *  newCachedThreadPool 可缓存线程池，可设置最小线程数和最大线程数，线程空闲1分钟后自动销毁。\n *  newFixedThreadPool 指定工作线程数量线程池。\n *  newSingleThreadExecutor 单线程Executor。\n *  newScheduleThreadPool 支持定时任务的指定工作线程数量线程池。\n *  newSingleThreadScheduledExecutor 支持定时任务的单线程Executor。\n\n### 简述阻塞队列 \n\n阻塞队列是生产者消费者的实现具体组件之一。当阻塞队列为空时，从队列中获取元素的操作将会被阻塞，当阻塞队列满了，往队列添加元素的操作将会被阻塞。具体实现有：\n\n *  ArrayBlockingQueue：底层是由数组组成的有界阻塞队列。\n *  LinkedBlockingQueue：底层是由链表组成的有界阻塞队列。\n *  PriorityBlockingQueue：阻塞优先队列。\n *  DelayQueue：创建元素时可以指定多久才能从队列中获取当前元素\n *  SynchronousQueue：不存储元素的阻塞队列，每一个存储必须等待一个取出操作\n *  LinkedTransferQueue：与LinkedBlockingQueue相比多一个transfer方法，即如果当前有消费者正等待接收元素，可以把生产者传入的元素立刻传输给消费者。\n *  LinkedBlockingDeque：双向阻塞队列。\n\n### 谈一谈ThreadLocal \n\nThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的。\n\n *  set 给ThreadLocalMap设置值。\n *  get 获取ThreadLocalMap。\n *  remove 删除ThreadLocalMap类型的对象。\n\n存在的问题：对于线程池，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用，造成一系列问题。\n\n比如说内存泄漏。由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放，产生内存泄漏。\n\n### 聊聊你对Java并发包下unsafe类的理解 \n\n对于 Java 语言，没有直接的指针组件，一般也不能使用偏移量对某块内存进行操作。这些操作相对来讲是安全（safe）的。\n\nJava 有个类叫 Unsafe 类，这个类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。这个类可以说是 Java 并发开发的基础。\n\n### Java中的乐观锁与CAS算法 \n\n乐观锁认为数据发送时发生并发冲突的概率不大，所以读操作前不上锁。\n\n到了写操作时才会进行判断，数据在此期间是否被其他线程修改。如果发生修改，那就返回写入失败；如果没有被修改，那就执行修改操作，返回修改成功。\n\n乐观锁一般都采用 Compare And Swap（CAS）算法进行实现。顾名思义，该算法涉及到了两个操作，比较（Compare）和交换（Swap）。\n\nCAS 算法的思路如下：\n\n *  该算法认为不同线程对变量的操作时产生竞争的情况比较少。\n *  该算法的核心是对当前读取变量值 E 和内存中的变量旧值 V 进行比较。\n *  如果相等，就代表其他线程没有对该变量进行修改，就将变量值更新为新值 N。\n *  如果不等，就认为在读取值 E 到比较阶段，有其他线程对变量进行过修改，不进行任何操作。\n\n### ABA问题及解决方法简述 \n\nCAS 算法是基于值来做比较的，如果当前有两个线程，一个线程将变量值从 A 改为 B ，再由 B 改回为 A ，当前线程开始执行 CAS 算法时，就很容易认为值没有变化，误认为读取数据到执行 CAS 算法的期间，没有线程修改过数据。\n\njuc 包提供了一个 AtomicStampedReference，即在原始的版本下加入版本号戳，解决 ABA 问题。\n\n### 简述常见的Atomic类 \n\n在很多时候，我们需要的仅仅是一个简单的、高效的、线程安全的++或者--方案，使用synchronized关键字和lock固然可以实现，但代价比较大，此时用原子类更加方便。基本数据类型的原子类有：\n\n *  AtomicInteger 原子更新整形\n *  AtomicLong 原子更新长整型\n *  AtomicBoolean 原子更新布尔类型\n\nAtomic数组类型有：\n\n *  AtomicIntegerArray 原子更新整形数组里的元素\n *  AtomicLongArray 原子更新长整型数组里的元素\n *  AtomicReferenceArray 原子更新引用类型数组里的元素。\n\nAtomic引用类型有：\n\n *  AtomicReference 原子更新引用类型\n *  AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 标记\n *  AtomicStampedReference 原子更新带有版本号的引用类型\n\nFieldUpdater类型：\n\n *  AtomicIntegerFieldUpdater 原子更新整形字段的更新器\n *  AtomicLongFieldUpdater 原子更新长整形字段的更新器\n *  AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器\n\n### 简述Atomic类基本实现原理 \n\n以AtomicIntger 为例。\n\n方法getAndIncrement，以原子方式将当前的值加1，具体实现为：\n\n *  在 for 死循环中取得 AtomicInteger 里存储的数值\n *  对 AtomicInteger 当前的值加 1\n *  调用 compareAndSet 方法进行原子更新\n *  先检查当前数值是否等于 expect\n *  如果等于则说明当前值没有被其他线程修改，则将值更新为 next，\n *  如果不是会更新失败返回 false，程序会进入 for 循环重新进行 compareAndSet 操作。\n\n### 简述CountDownLatch \n\nCountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，调用countDown方法，计数器的值就减1，当计数器的值为0时，表示所有线程都执行完毕，然后在等待的线程就可以恢复工作了。只能一次性使用，不能reset。\n\n### 简述CyclicBarrier \n\nCyclicBarrier 主要功能和CountDownLatch类似，也是通过一个计数器，使一个线程等待其他线程各自执行完毕后再执行。但是其可以重复使用（reset）。\n\n### 简述Semaphore \n\nSemaphore即信号量。Semaphore 的构造方法参数接收一个 int 值，设置一个计数器，表示可用的许可数量即最大并发数。使用 acquire 方法获得一个许可证，计数器减一，使用 release 方法归还许可，计数器加一。如果此时计数器值为0，线程进入休眠。\n\n### 简述Exchanger \n\nExchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。线程通过exchange 方法交换数据，第一个线程执行 exchange 方法后会阻塞等待第二个线程执行该方法。当两个线程都到达同步点时这两个线程就可以交换数据当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。\n\n### 简述ConcurrentHashMap \n\nJDK7采用锁分段技术。首先将数据分成 Segment 数据段，然后给每一个数据段配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。\n\nget 除读到空值不需要加锁。该方法先经过一次再散列，再用这个散列值通过散列运算定位到 Segment，最后通过散列算法定位到元素。put 须加锁，首先定位到 Segment，然后进行插入操作，第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放入数组。\n\nJDK8的改进\n\n *  取消分段锁机制，采用CAS算法进行值的设置，如果CAS失败再使用 synchronized 加锁添加元素\n *  引入红黑树结构，当某个槽内的元素个数超过8且 Node数组 容量大于 64 时，链表转为红黑树。\n *  使用了更加优化的方式统计集合内的元素数量。\n\n### synchronized底层实现原理 \n\nJava 对象底层都会关联一个 monitor，使用 synchronized 时 JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者，monitor 在被释放前不能再被其他线程获取。\n\nsynchronized在JVM编译后会产生monitorenter 和 monitorexit 这两个字节码指令，获取和释放 monitor。这两个字节码指令都需要一个引用类型的参数指明要锁定和解锁的对象，对于同步普通方法，锁是当前实例对象；对于静态同步方法，锁是当前类的 Class 对象；对于同步方法块，锁是 synchronized 括号里的对象。\n\n执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。\n\n### synchronized关键词使用方法 \n\n *  直接修饰某个实例方法\n *  直接修饰某个静态方法\n *  修饰代码块\n\n### 简述Java偏向锁 \n\nJDK 1.6 中提出了偏向锁的概念。该锁提出的原因是，开发者发现多数情况下锁并不存在竞争，一把锁往往是由同一个线程获得的。偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。\n\n其申请流程为：\n\n *  首先需要判断对象的 Mark Word 是否属于偏向模式，如果不属于，那就进入轻量级锁判断逻辑。否则继续下一步判断；\n *  判断目前请求锁的线程 ID 是否和偏向锁本身记录的线程 ID 一致。如果一致，继续下一步的判断，如果不一致，跳转到步骤4；\n *  判断是否需要重偏向。如果不用的话，直接获得偏向锁；\n *  利用 CAS 算法将对象的 Mark Word 进行更改，使线程 ID 部分换成本线程 ID。如果更换成功，则重偏向完成，获得偏向锁。如果失败，则说明有多线程竞争，升级为轻量级锁。\n\n### 简述轻量级锁 \n\n轻量级锁是为了在没有竞争的前提下减少重量级锁出现并导致的性能消耗。\n\n其申请流程为：\n\n *  如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝。\n *  虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针\n *  如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。\n *  如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧\n *  如果指向当前线程的栈帧，说明当前线程已经拥有了锁，直接进入同步块继续执行\n *  如果不是则说明锁对象已经被其他线程抢占。\n *  如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。\n\n### 简述锁优化策略 \n\n即自适应自旋、锁消除、锁粗化、锁升级等策略偏。\n\n### 简述Java的自旋锁 \n\n线程获取锁失败后，可以采用这样的策略，可以不放弃 CPU ，不停的重试内重试，这种操作也称为自旋锁。\n\n### 简述自适应自旋锁 \n\n自适应自旋锁自旋次数不再人为设定，通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。\n\n### 简述锁粗化 \n\n锁粗化的思想就是扩大加锁范围，避免反复的加锁和解锁。\n\n### 简述锁消除 \n\n锁消除是一种更为彻底的优化，在编译时，Java编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁。\n\n### 简述Lock与ReentrantLock \n\nLock接口是 Java并发包的顶层接口。\n\n可重入锁 ReentrantLock 是 Lock 最常见的实现，与 synchronized 一样可重入。ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会下降。\n\n### 简述AQS \n\nAQS（AbstractQuenedSynchronizer）抽象的队列式同步器。AQS是将每一条请求共享资源的线程封装成一个锁队列的一个结点（Node），来实现锁的分配。AQS是用来构建锁或其他同步组件的基础框架，它使用一个 volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。\n\n子类通过继承同步器并实现它的抽象方法getState、setState 和 compareAndSetState对同步状态进行更改。\n\nAQS获取独占锁/释放独占锁原理：\n\n获取：（acquire）\n\n *  调用 tryAcquire 方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过 addWaiter 方法加入到同步队列的尾部，在队列中自旋。\n *  调用 acquireQueued 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞。\n\n释放：（release）\n\n *  调用 tryRelease 方法释放同步状态\n *  调用 unparkSuccessor 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。\n\nAQS获取共享锁/释放共享锁原理\n\n获取锁（acquireShared）\n\n *  调用 tryAcquireShared 方法尝试获取同步状态，返回值不小于 0 表示能获取同步状态。\n *  释放（releaseShared），并唤醒后续处于等待状态的节点。","slug":"Java并发编程八股文","published":1,"updated":"2022-11-04T05:46:45.544Z","_id":"cla21kmyw000101ld4jd8gijc","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"简述Java内存模型（JMM）\"><a href=\"#简述Java内存模型（JMM）\" class=\"headerlink\" title=\"简述Java内存模型（JMM）\"></a>简述Java内存模型（JMM）</h3><p>Java内存模型定义了程序中各种变量的访问规则：</p>\n<ul>\n<li> 所有变量都存储在主存，每个线程都有自己的工作内存。</li>\n<li> 工作内存中保存了被该线程使用的变量的主存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。</li>\n<li> 操作完成后，线程的工作内存通过缓存一致性协议将操作完的数据刷回主存。</li>\n</ul>\n<h3 id=\"简述as-if-serial\"><a href=\"#简述as-if-serial\" class=\"headerlink\" title=\"简述as-if-serial\"></a>简述as-if-serial</h3><p>编译器会对原始的程序进行指令重排序和优化。但不管怎么重排序，其结果都必须和用户原始程序输出的预定结果保持一致。</p>\n<h3 id=\"简述happens-before八大规则\"><a href=\"#简述happens-before八大规则\" class=\"headerlink\" title=\"简述happens-before八大规则\"></a>简述happens-before八大规则</h3><ul>\n<li> 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>\n<li> 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；</li>\n<li> volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>\n<li> 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>\n<li> 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li>\n<li> 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>\n<li> 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>\n<li> 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li>\n</ul>\n<h3 id=\"as-if-serial-和-happens-before-的区别\"><a href=\"#as-if-serial-和-happens-before-的区别\" class=\"headerlink\" title=\"as-if-serial 和 happens-before 的区别\"></a>as-if-serial 和 happens-before 的区别</h3><p>as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。</p>\n<h3 id=\"简述原子性操作\"><a href=\"#简述原子性操作\" class=\"headerlink\" title=\"简述原子性操作\"></a>简述原子性操作</h3><p>一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行，这就是原子性操作。</p>\n<h3 id=\"简述线程的可见性\"><a href=\"#简述线程的可见性\" class=\"headerlink\" title=\"简述线程的可见性\"></a>简述线程的可见性</h3><p>可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。volatile、synchronized、final 关键字都能保证可见性。</p>\n<h3 id=\"简述有序性\"><a href=\"#简述有序性\" class=\"headerlink\" title=\"简述有序性\"></a>简述有序性</h3><p>虽然多线程存在并发和指令优化等操作，但在本线程内观察该线程的所有执行操作是有序的。</p>\n<h3 id=\"简述Java中volatile关键字作用\"><a href=\"#简述Java中volatile关键字作用\" class=\"headerlink\" title=\"简述Java中volatile关键字作用\"></a>简述Java中volatile关键字作用</h3><ul>\n<li> 保证变量对所有线程的可见性。当一个线程修改了变量值，新值对于其他线程来说是立即可以得知的。</li>\n<li> 禁止指令重排。使用 volatile 变量进行写操作，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器进行重排序。</li>\n</ul>\n<h3 id=\"Java线程的实现方式\"><a href=\"#Java线程的实现方式\" class=\"headerlink\" title=\"Java线程的实现方式\"></a>Java线程的实现方式</h3><ul>\n<li> 实现Runnable接口</li>\n<li> 继承Thread类</li>\n<li> 实现Callable接口</li>\n</ul>\n<h3 id=\"简述Java线程的状态\"><a href=\"#简述Java线程的状态\" class=\"headerlink\" title=\"简述Java线程的状态\"></a>简述Java线程的状态</h3><p>线程状态有 NEW、RUNNABLE、BLOCK、WAITING、TIMED_WAITING、THERMINATED</p>\n<ul>\n<li> NEW：新建状态，线程被创建且未启动，此时还未调用 start 方法。</li>\n<li> RUNNABLE：运行状态。表示线程正在JVM中执行，但是这个执行，不一定真的在跑，也可能在排队等CPU。</li>\n<li> BLOCKED：阻塞状态。线程等待获取锁，锁还没获得。</li>\n<li> WAITING：等待状态。线程内run方法执行完Object.wait()/Thread.join()进入该状态。</li>\n<li> TIMED_WAITING：限期等待。在一定时间之后跳出状态。调用Thread.sleep(long) Object.wait(long) Thread.join(long)进入状态。其中这些参数代表等待的时间。</li>\n<li> TERMINATED：结束状态。线程调用完run方法进入该状态。</li>\n</ul>\n<h3 id=\"简述线程通信的方式\"><a href=\"#简述线程通信的方式\" class=\"headerlink\" title=\"简述线程通信的方式\"></a>简述线程通信的方式</h3><ul>\n<li> volatile 关键词修饰变量，保证所有线程对变量访问的可见性。</li>\n<li> synchronized关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中。</li>\n<li> wait/notify方法</li>\n<li> IO通信</li>\n</ul>\n<h3 id=\"简述线程池\"><a href=\"#简述线程池\" class=\"headerlink\" title=\"简述线程池\"></a>简述线程池</h3><p>没有线程池的情况下，多次创建，销毁线程开销比较大。如果在开辟的线程执行完当前任务后复用已创建的线程，可以降低开销、控制最大并发数。</p>\n<p>线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列中的任务来执行。</p>\n<p>将任务派发给线程池时，会出现以下几种情况</p>\n<ul>\n<li> 核心线程池未满，创建一个新的线程执行任务。</li>\n<li> 如果核心线程池已满，工作队列未满，将线程存储在工作队列。</li>\n<li> 如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务。</li>\n<li> 如果超过大小线程数，按照拒绝策略来处理任务。</li>\n</ul>\n<p>线程池参数：</p>\n<ul>\n<li> corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁。</li>\n<li> maximumPoolSize：线程池能够容纳同时执行的线程最大数。</li>\n<li> keepAliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存资源。</li>\n<li> workQueue：工作队列。</li>\n<li> threadFactory：线程工厂，用来生产一组相同任务的线程。</li>\n<li> handler：拒绝策略。</li>\n</ul>\n<p>拒绝策略有以下几种：</p>\n<ul>\n<li> AbortPolicy：丢弃任务并抛出异常</li>\n<li> CallerRunsPolicy：重新尝试提交该任务</li>\n<li> DiscardOldestPolicy 抛弃队列里等待最久的任务并把当前任务加入队列</li>\n<li> DiscardPolicy 表示直接抛弃当前任务但不抛出异常。</li>\n</ul>\n<h3 id=\"简述Executor框架\"><a href=\"#简述Executor框架\" class=\"headerlink\" title=\"简述Executor框架\"></a>简述Executor框架</h3><p>Executor框架目的是将任务提交和任务如何运行分离开来的机制。用户不再需要从代码层考虑设计任务的提交运行，只需要调用Executor框架实现类的Execute方法就可以提交任务。</p>\n<h3 id=\"简述Executor的继承关系\"><a href=\"#简述Executor的继承关系\" class=\"headerlink\" title=\"简述Executor的继承关系\"></a>简述Executor的继承关系</h3><ul>\n<li> Executor：一个接口，其定义了一个接收Runnable对象的方法executor，该方法接收一个Runable实例执行这个任务。</li>\n<li> ExecutorService：Executor的子类接口，其定义了一个接收Callable对象的方法，返回 Future 对象，同时提供execute方法。</li>\n<li> ScheduledExecutorService：ExecutorService的子类接口，支持定期执行任务。</li>\n<li> AbstractExecutorService：抽象类，提供 ExecutorService 执行方法的默认实现。</li>\n<li> Executors：实现ExecutorService接口的静态工厂类，提供了一系列工厂方法用于创建线程池。</li>\n<li> ThreadPoolExecutor：继承AbstractExecutorService，用于创建线程池。</li>\n<li> ForkJoinPool: 继承AbstractExecutorService，Fork 将大任务分叉为多个小任务，然后让小任务执行，Join 是获得小任务的结果，类似于map reduce。</li>\n<li> ThreadPoolExecutor：继承ThreadPoolExecutor，实现ScheduledExecutorService，用于创建带定时任务的线程池。</li>\n</ul>\n<h3 id=\"简述线程池的状态\"><a href=\"#简述线程池的状态\" class=\"headerlink\" title=\"简述线程池的状态\"></a>简述线程池的状态</h3><ul>\n<li> Running：能接受新提交的任务，也可以处理阻塞队列的任务。</li>\n<li> Shutdown：不再接受新提交的任务，但可以处理存量任务，线程池处于running时调用shutdown方法，会进入该状态。</li>\n<li> Stop：不接受新任务，不处理存量任务，调用shutdownnow进入该状态。</li>\n<li> Tidying：所有任务已经终止了，worker_count（有效线程数）为0。</li>\n<li> Terminated：线程池彻底终止。在tidying模式下调用terminated方法会进入该状态。</li>\n</ul>\n<h3 id=\"简述线程池类型\"><a href=\"#简述线程池类型\" class=\"headerlink\" title=\"简述线程池类型\"></a>简述线程池类型</h3><ul>\n<li> newCachedThreadPool 可缓存线程池，可设置最小线程数和最大线程数，线程空闲1分钟后自动销毁。</li>\n<li> newFixedThreadPool 指定工作线程数量线程池。</li>\n<li> newSingleThreadExecutor 单线程Executor。</li>\n<li> newScheduleThreadPool 支持定时任务的指定工作线程数量线程池。</li>\n<li> newSingleThreadScheduledExecutor 支持定时任务的单线程Executor。</li>\n</ul>\n<h3 id=\"简述阻塞队列\"><a href=\"#简述阻塞队列\" class=\"headerlink\" title=\"简述阻塞队列\"></a>简述阻塞队列</h3><p>阻塞队列是生产者消费者的实现具体组件之一。当阻塞队列为空时，从队列中获取元素的操作将会被阻塞，当阻塞队列满了，往队列添加元素的操作将会被阻塞。具体实现有：</p>\n<ul>\n<li> ArrayBlockingQueue：底层是由数组组成的有界阻塞队列。</li>\n<li> LinkedBlockingQueue：底层是由链表组成的有界阻塞队列。</li>\n<li> PriorityBlockingQueue：阻塞优先队列。</li>\n<li> DelayQueue：创建元素时可以指定多久才能从队列中获取当前元素</li>\n<li> SynchronousQueue：不存储元素的阻塞队列，每一个存储必须等待一个取出操作</li>\n<li> LinkedTransferQueue：与LinkedBlockingQueue相比多一个transfer方法，即如果当前有消费者正等待接收元素，可以把生产者传入的元素立刻传输给消费者。</li>\n<li> LinkedBlockingDeque：双向阻塞队列。</li>\n</ul>\n<h3 id=\"谈一谈ThreadLocal\"><a href=\"#谈一谈ThreadLocal\" class=\"headerlink\" title=\"谈一谈ThreadLocal\"></a>谈一谈ThreadLocal</h3><p>ThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的。</p>\n<ul>\n<li> set 给ThreadLocalMap设置值。</li>\n<li> get 获取ThreadLocalMap。</li>\n<li> remove 删除ThreadLocalMap类型的对象。</li>\n</ul>\n<p>存在的问题：对于线程池，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用，造成一系列问题。</p>\n<p>比如说内存泄漏。由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放，产生内存泄漏。</p>\n<h3 id=\"聊聊你对Java并发包下unsafe类的理解\"><a href=\"#聊聊你对Java并发包下unsafe类的理解\" class=\"headerlink\" title=\"聊聊你对Java并发包下unsafe类的理解\"></a>聊聊你对Java并发包下unsafe类的理解</h3><p>对于 Java 语言，没有直接的指针组件，一般也不能使用偏移量对某块内存进行操作。这些操作相对来讲是安全（safe）的。</p>\n<p>Java 有个类叫 Unsafe 类，这个类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。这个类可以说是 Java 并发开发的基础。</p>\n<h3 id=\"Java中的乐观锁与CAS算法\"><a href=\"#Java中的乐观锁与CAS算法\" class=\"headerlink\" title=\"Java中的乐观锁与CAS算法\"></a>Java中的乐观锁与CAS算法</h3><p>乐观锁认为数据发送时发生并发冲突的概率不大，所以读操作前不上锁。</p>\n<p>到了写操作时才会进行判断，数据在此期间是否被其他线程修改。如果发生修改，那就返回写入失败；如果没有被修改，那就执行修改操作，返回修改成功。</p>\n<p>乐观锁一般都采用 Compare And Swap（CAS）算法进行实现。顾名思义，该算法涉及到了两个操作，比较（Compare）和交换（Swap）。</p>\n<p>CAS 算法的思路如下：</p>\n<ul>\n<li> 该算法认为不同线程对变量的操作时产生竞争的情况比较少。</li>\n<li> 该算法的核心是对当前读取变量值 E 和内存中的变量旧值 V 进行比较。</li>\n<li> 如果相等，就代表其他线程没有对该变量进行修改，就将变量值更新为新值 N。</li>\n<li> 如果不等，就认为在读取值 E 到比较阶段，有其他线程对变量进行过修改，不进行任何操作。</li>\n</ul>\n<h3 id=\"ABA问题及解决方法简述\"><a href=\"#ABA问题及解决方法简述\" class=\"headerlink\" title=\"ABA问题及解决方法简述\"></a>ABA问题及解决方法简述</h3><p>CAS 算法是基于值来做比较的，如果当前有两个线程，一个线程将变量值从 A 改为 B ，再由 B 改回为 A ，当前线程开始执行 CAS 算法时，就很容易认为值没有变化，误认为读取数据到执行 CAS 算法的期间，没有线程修改过数据。</p>\n<p>juc 包提供了一个 AtomicStampedReference，即在原始的版本下加入版本号戳，解决 ABA 问题。</p>\n<h3 id=\"简述常见的Atomic类\"><a href=\"#简述常见的Atomic类\" class=\"headerlink\" title=\"简述常见的Atomic类\"></a>简述常见的Atomic类</h3><p>在很多时候，我们需要的仅仅是一个简单的、高效的、线程安全的++或者–方案，使用synchronized关键字和lock固然可以实现，但代价比较大，此时用原子类更加方便。基本数据类型的原子类有：</p>\n<ul>\n<li> AtomicInteger 原子更新整形</li>\n<li> AtomicLong 原子更新长整型</li>\n<li> AtomicBoolean 原子更新布尔类型</li>\n</ul>\n<p>Atomic数组类型有：</p>\n<ul>\n<li> AtomicIntegerArray 原子更新整形数组里的元素</li>\n<li> AtomicLongArray 原子更新长整型数组里的元素</li>\n<li> AtomicReferenceArray 原子更新引用类型数组里的元素。</li>\n</ul>\n<p>Atomic引用类型有：</p>\n<ul>\n<li> AtomicReference 原子更新引用类型</li>\n<li> AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 标记</li>\n<li> AtomicStampedReference 原子更新带有版本号的引用类型</li>\n</ul>\n<p>FieldUpdater类型：</p>\n<ul>\n<li> AtomicIntegerFieldUpdater 原子更新整形字段的更新器</li>\n<li> AtomicLongFieldUpdater 原子更新长整形字段的更新器</li>\n<li> AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器</li>\n</ul>\n<h3 id=\"简述Atomic类基本实现原理\"><a href=\"#简述Atomic类基本实现原理\" class=\"headerlink\" title=\"简述Atomic类基本实现原理\"></a>简述Atomic类基本实现原理</h3><p>以AtomicIntger 为例。</p>\n<p>方法getAndIncrement，以原子方式将当前的值加1，具体实现为：</p>\n<ul>\n<li> 在 for 死循环中取得 AtomicInteger 里存储的数值</li>\n<li> 对 AtomicInteger 当前的值加 1</li>\n<li> 调用 compareAndSet 方法进行原子更新</li>\n<li> 先检查当前数值是否等于 expect</li>\n<li> 如果等于则说明当前值没有被其他线程修改，则将值更新为 next，</li>\n<li> 如果不是会更新失败返回 false，程序会进入 for 循环重新进行 compareAndSet 操作。</li>\n</ul>\n<h3 id=\"简述CountDownLatch\"><a href=\"#简述CountDownLatch\" class=\"headerlink\" title=\"简述CountDownLatch\"></a>简述CountDownLatch</h3><p>CountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，调用countDown方法，计数器的值就减1，当计数器的值为0时，表示所有线程都执行完毕，然后在等待的线程就可以恢复工作了。只能一次性使用，不能reset。</p>\n<h3 id=\"简述CyclicBarrier\"><a href=\"#简述CyclicBarrier\" class=\"headerlink\" title=\"简述CyclicBarrier\"></a>简述CyclicBarrier</h3><p>CyclicBarrier 主要功能和CountDownLatch类似，也是通过一个计数器，使一个线程等待其他线程各自执行完毕后再执行。但是其可以重复使用（reset）。</p>\n<h3 id=\"简述Semaphore\"><a href=\"#简述Semaphore\" class=\"headerlink\" title=\"简述Semaphore\"></a>简述Semaphore</h3><p>Semaphore即信号量。Semaphore 的构造方法参数接收一个 int 值，设置一个计数器，表示可用的许可数量即最大并发数。使用 acquire 方法获得一个许可证，计数器减一，使用 release 方法归还许可，计数器加一。如果此时计数器值为0，线程进入休眠。</p>\n<h3 id=\"简述Exchanger\"><a href=\"#简述Exchanger\" class=\"headerlink\" title=\"简述Exchanger\"></a>简述Exchanger</h3><p>Exchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。线程通过exchange 方法交换数据，第一个线程执行 exchange 方法后会阻塞等待第二个线程执行该方法。当两个线程都到达同步点时这两个线程就可以交换数据当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。</p>\n<h3 id=\"简述ConcurrentHashMap\"><a href=\"#简述ConcurrentHashMap\" class=\"headerlink\" title=\"简述ConcurrentHashMap\"></a>简述ConcurrentHashMap</h3><p>JDK7采用锁分段技术。首先将数据分成 Segment 数据段，然后给每一个数据段配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。</p>\n<p>get 除读到空值不需要加锁。该方法先经过一次再散列，再用这个散列值通过散列运算定位到 Segment，最后通过散列算法定位到元素。put 须加锁，首先定位到 Segment，然后进行插入操作，第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放入数组。</p>\n<p>JDK8的改进</p>\n<ul>\n<li> 取消分段锁机制，采用CAS算法进行值的设置，如果CAS失败再使用 synchronized 加锁添加元素</li>\n<li> 引入红黑树结构，当某个槽内的元素个数超过8且 Node数组 容量大于 64 时，链表转为红黑树。</li>\n<li> 使用了更加优化的方式统计集合内的元素数量。</li>\n</ul>\n<h3 id=\"synchronized底层实现原理\"><a href=\"#synchronized底层实现原理\" class=\"headerlink\" title=\"synchronized底层实现原理\"></a>synchronized底层实现原理</h3><p>Java 对象底层都会关联一个 monitor，使用 synchronized 时 JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者，monitor 在被释放前不能再被其他线程获取。</p>\n<p>synchronized在JVM编译后会产生monitorenter 和 monitorexit 这两个字节码指令，获取和释放 monitor。这两个字节码指令都需要一个引用类型的参数指明要锁定和解锁的对象，对于同步普通方法，锁是当前实例对象；对于静态同步方法，锁是当前类的 Class 对象；对于同步方法块，锁是 synchronized 括号里的对象。</p>\n<p>执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。</p>\n<h3 id=\"synchronized关键词使用方法\"><a href=\"#synchronized关键词使用方法\" class=\"headerlink\" title=\"synchronized关键词使用方法\"></a>synchronized关键词使用方法</h3><ul>\n<li> 直接修饰某个实例方法</li>\n<li> 直接修饰某个静态方法</li>\n<li> 修饰代码块</li>\n</ul>\n<h3 id=\"简述Java偏向锁\"><a href=\"#简述Java偏向锁\" class=\"headerlink\" title=\"简述Java偏向锁\"></a>简述Java偏向锁</h3><p>JDK 1.6 中提出了偏向锁的概念。该锁提出的原因是，开发者发现多数情况下锁并不存在竞争，一把锁往往是由同一个线程获得的。偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。</p>\n<p>其申请流程为：</p>\n<ul>\n<li> 首先需要判断对象的 Mark Word 是否属于偏向模式，如果不属于，那就进入轻量级锁判断逻辑。否则继续下一步判断；</li>\n<li> 判断目前请求锁的线程 ID 是否和偏向锁本身记录的线程 ID 一致。如果一致，继续下一步的判断，如果不一致，跳转到步骤4；</li>\n<li> 判断是否需要重偏向。如果不用的话，直接获得偏向锁；</li>\n<li> 利用 CAS 算法将对象的 Mark Word 进行更改，使线程 ID 部分换成本线程 ID。如果更换成功，则重偏向完成，获得偏向锁。如果失败，则说明有多线程竞争，升级为轻量级锁。</li>\n</ul>\n<h3 id=\"简述轻量级锁\"><a href=\"#简述轻量级锁\" class=\"headerlink\" title=\"简述轻量级锁\"></a>简述轻量级锁</h3><p>轻量级锁是为了在没有竞争的前提下减少重量级锁出现并导致的性能消耗。</p>\n<p>其申请流程为：</p>\n<ul>\n<li> 如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝。</li>\n<li> 虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针</li>\n<li> 如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。</li>\n<li> 如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧</li>\n<li> 如果指向当前线程的栈帧，说明当前线程已经拥有了锁，直接进入同步块继续执行</li>\n<li> 如果不是则说明锁对象已经被其他线程抢占。</li>\n<li> 如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。</li>\n</ul>\n<h3 id=\"简述锁优化策略\"><a href=\"#简述锁优化策略\" class=\"headerlink\" title=\"简述锁优化策略\"></a>简述锁优化策略</h3><p>即自适应自旋、锁消除、锁粗化、锁升级等策略偏。</p>\n<h3 id=\"简述Java的自旋锁\"><a href=\"#简述Java的自旋锁\" class=\"headerlink\" title=\"简述Java的自旋锁\"></a>简述Java的自旋锁</h3><p>线程获取锁失败后，可以采用这样的策略，可以不放弃 CPU ，不停的重试内重试，这种操作也称为自旋锁。</p>\n<h3 id=\"简述自适应自旋锁\"><a href=\"#简述自适应自旋锁\" class=\"headerlink\" title=\"简述自适应自旋锁\"></a>简述自适应自旋锁</h3><p>自适应自旋锁自旋次数不再人为设定，通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。</p>\n<h3 id=\"简述锁粗化\"><a href=\"#简述锁粗化\" class=\"headerlink\" title=\"简述锁粗化\"></a>简述锁粗化</h3><p>锁粗化的思想就是扩大加锁范围，避免反复的加锁和解锁。</p>\n<h3 id=\"简述锁消除\"><a href=\"#简述锁消除\" class=\"headerlink\" title=\"简述锁消除\"></a>简述锁消除</h3><p>锁消除是一种更为彻底的优化，在编译时，Java编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁。</p>\n<h3 id=\"简述Lock与ReentrantLock\"><a href=\"#简述Lock与ReentrantLock\" class=\"headerlink\" title=\"简述Lock与ReentrantLock\"></a>简述Lock与ReentrantLock</h3><p>Lock接口是 Java并发包的顶层接口。</p>\n<p>可重入锁 ReentrantLock 是 Lock 最常见的实现，与 synchronized 一样可重入。ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会下降。</p>\n<h3 id=\"简述AQS\"><a href=\"#简述AQS\" class=\"headerlink\" title=\"简述AQS\"></a>简述AQS</h3><p>AQS（AbstractQuenedSynchronizer）抽象的队列式同步器。AQS是将每一条请求共享资源的线程封装成一个锁队列的一个结点（Node），来实现锁的分配。AQS是用来构建锁或其他同步组件的基础框架，它使用一个 volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。</p>\n<p>子类通过继承同步器并实现它的抽象方法getState、setState 和 compareAndSetState对同步状态进行更改。</p>\n<p>AQS获取独占锁/释放独占锁原理：</p>\n<p>获取：（acquire）</p>\n<ul>\n<li> 调用 tryAcquire 方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过 addWaiter 方法加入到同步队列的尾部，在队列中自旋。</li>\n<li> 调用 acquireQueued 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞。</li>\n</ul>\n<p>释放：（release）</p>\n<ul>\n<li> 调用 tryRelease 方法释放同步状态</li>\n<li> 调用 unparkSuccessor 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。</li>\n</ul>\n<p>AQS获取共享锁/释放共享锁原理</p>\n<p>获取锁（acquireShared）</p>\n<ul>\n<li> 调用 tryAcquireShared 方法尝试获取同步状态，返回值不小于 0 表示能获取同步状态。</li>\n<li> 释放（releaseShared），并唤醒后续处于等待状态的节点。</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<h3 id=\"简述Java内存模型（JMM）\"><a href=\"#简述Java内存模型（JMM）\" class=\"headerlink\" title=\"简述Java内存模型（JMM）\"></a>简述Java内存模型（JMM）</h3><p>Java内存模型定义了程序中各种变量的访问规则：</p>\n<ul>\n<li> 所有变量都存储在主存，每个线程都有自己的工作内存。</li>\n<li> 工作内存中保存了被该线程使用的变量的主存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。</li>\n<li> 操作完成后，线程的工作内存通过缓存一致性协议将操作完的数据刷回主存。</li>\n</ul>\n<h3 id=\"简述as-if-serial\"><a href=\"#简述as-if-serial\" class=\"headerlink\" title=\"简述as-if-serial\"></a>简述as-if-serial</h3><p>编译器会对原始的程序进行指令重排序和优化。但不管怎么重排序，其结果都必须和用户原始程序输出的预定结果保持一致。</p>\n<h3 id=\"简述happens-before八大规则\"><a href=\"#简述happens-before八大规则\" class=\"headerlink\" title=\"简述happens-before八大规则\"></a>简述happens-before八大规则</h3><ul>\n<li> 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>\n<li> 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；</li>\n<li> volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>\n<li> 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>\n<li> 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li>\n<li> 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>\n<li> 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>\n<li> 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li>\n</ul>\n<h3 id=\"as-if-serial-和-happens-before-的区别\"><a href=\"#as-if-serial-和-happens-before-的区别\" class=\"headerlink\" title=\"as-if-serial 和 happens-before 的区别\"></a>as-if-serial 和 happens-before 的区别</h3><p>as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。</p>\n<h3 id=\"简述原子性操作\"><a href=\"#简述原子性操作\" class=\"headerlink\" title=\"简述原子性操作\"></a>简述原子性操作</h3><p>一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行，这就是原子性操作。</p>\n<h3 id=\"简述线程的可见性\"><a href=\"#简述线程的可见性\" class=\"headerlink\" title=\"简述线程的可见性\"></a>简述线程的可见性</h3><p>可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。volatile、synchronized、final 关键字都能保证可见性。</p>\n<h3 id=\"简述有序性\"><a href=\"#简述有序性\" class=\"headerlink\" title=\"简述有序性\"></a>简述有序性</h3><p>虽然多线程存在并发和指令优化等操作，但在本线程内观察该线程的所有执行操作是有序的。</p>\n<h3 id=\"简述Java中volatile关键字作用\"><a href=\"#简述Java中volatile关键字作用\" class=\"headerlink\" title=\"简述Java中volatile关键字作用\"></a>简述Java中volatile关键字作用</h3><ul>\n<li> 保证变量对所有线程的可见性。当一个线程修改了变量值，新值对于其他线程来说是立即可以得知的。</li>\n<li> 禁止指令重排。使用 volatile 变量进行写操作，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器进行重排序。</li>\n</ul>\n<h3 id=\"Java线程的实现方式\"><a href=\"#Java线程的实现方式\" class=\"headerlink\" title=\"Java线程的实现方式\"></a>Java线程的实现方式</h3><ul>\n<li> 实现Runnable接口</li>\n<li> 继承Thread类</li>\n<li> 实现Callable接口</li>\n</ul>\n<h3 id=\"简述Java线程的状态\"><a href=\"#简述Java线程的状态\" class=\"headerlink\" title=\"简述Java线程的状态\"></a>简述Java线程的状态</h3><p>线程状态有 NEW、RUNNABLE、BLOCK、WAITING、TIMED_WAITING、THERMINATED</p>\n<ul>\n<li> NEW：新建状态，线程被创建且未启动，此时还未调用 start 方法。</li>\n<li> RUNNABLE：运行状态。表示线程正在JVM中执行，但是这个执行，不一定真的在跑，也可能在排队等CPU。</li>\n<li> BLOCKED：阻塞状态。线程等待获取锁，锁还没获得。</li>\n<li> WAITING：等待状态。线程内run方法执行完Object.wait()/Thread.join()进入该状态。</li>\n<li> TIMED_WAITING：限期等待。在一定时间之后跳出状态。调用Thread.sleep(long) Object.wait(long) Thread.join(long)进入状态。其中这些参数代表等待的时间。</li>\n<li> TERMINATED：结束状态。线程调用完run方法进入该状态。</li>\n</ul>\n<h3 id=\"简述线程通信的方式\"><a href=\"#简述线程通信的方式\" class=\"headerlink\" title=\"简述线程通信的方式\"></a>简述线程通信的方式</h3><ul>\n<li> volatile 关键词修饰变量，保证所有线程对变量访问的可见性。</li>\n<li> synchronized关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中。</li>\n<li> wait/notify方法</li>\n<li> IO通信</li>\n</ul>\n<h3 id=\"简述线程池\"><a href=\"#简述线程池\" class=\"headerlink\" title=\"简述线程池\"></a>简述线程池</h3><p>没有线程池的情况下，多次创建，销毁线程开销比较大。如果在开辟的线程执行完当前任务后复用已创建的线程，可以降低开销、控制最大并发数。</p>\n<p>线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列中的任务来执行。</p>\n<p>将任务派发给线程池时，会出现以下几种情况</p>\n<ul>\n<li> 核心线程池未满，创建一个新的线程执行任务。</li>\n<li> 如果核心线程池已满，工作队列未满，将线程存储在工作队列。</li>\n<li> 如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务。</li>\n<li> 如果超过大小线程数，按照拒绝策略来处理任务。</li>\n</ul>\n<p>线程池参数：</p>\n<ul>\n<li> corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁。</li>\n<li> maximumPoolSize：线程池能够容纳同时执行的线程最大数。</li>\n<li> keepAliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存资源。</li>\n<li> workQueue：工作队列。</li>\n<li> threadFactory：线程工厂，用来生产一组相同任务的线程。</li>\n<li> handler：拒绝策略。</li>\n</ul>\n<p>拒绝策略有以下几种：</p>\n<ul>\n<li> AbortPolicy：丢弃任务并抛出异常</li>\n<li> CallerRunsPolicy：重新尝试提交该任务</li>\n<li> DiscardOldestPolicy 抛弃队列里等待最久的任务并把当前任务加入队列</li>\n<li> DiscardPolicy 表示直接抛弃当前任务但不抛出异常。</li>\n</ul>\n<h3 id=\"简述Executor框架\"><a href=\"#简述Executor框架\" class=\"headerlink\" title=\"简述Executor框架\"></a>简述Executor框架</h3><p>Executor框架目的是将任务提交和任务如何运行分离开来的机制。用户不再需要从代码层考虑设计任务的提交运行，只需要调用Executor框架实现类的Execute方法就可以提交任务。</p>\n<h3 id=\"简述Executor的继承关系\"><a href=\"#简述Executor的继承关系\" class=\"headerlink\" title=\"简述Executor的继承关系\"></a>简述Executor的继承关系</h3><ul>\n<li> Executor：一个接口，其定义了一个接收Runnable对象的方法executor，该方法接收一个Runable实例执行这个任务。</li>\n<li> ExecutorService：Executor的子类接口，其定义了一个接收Callable对象的方法，返回 Future 对象，同时提供execute方法。</li>\n<li> ScheduledExecutorService：ExecutorService的子类接口，支持定期执行任务。</li>\n<li> AbstractExecutorService：抽象类，提供 ExecutorService 执行方法的默认实现。</li>\n<li> Executors：实现ExecutorService接口的静态工厂类，提供了一系列工厂方法用于创建线程池。</li>\n<li> ThreadPoolExecutor：继承AbstractExecutorService，用于创建线程池。</li>\n<li> ForkJoinPool: 继承AbstractExecutorService，Fork 将大任务分叉为多个小任务，然后让小任务执行，Join 是获得小任务的结果，类似于map reduce。</li>\n<li> ThreadPoolExecutor：继承ThreadPoolExecutor，实现ScheduledExecutorService，用于创建带定时任务的线程池。</li>\n</ul>\n<h3 id=\"简述线程池的状态\"><a href=\"#简述线程池的状态\" class=\"headerlink\" title=\"简述线程池的状态\"></a>简述线程池的状态</h3><ul>\n<li> Running：能接受新提交的任务，也可以处理阻塞队列的任务。</li>\n<li> Shutdown：不再接受新提交的任务，但可以处理存量任务，线程池处于running时调用shutdown方法，会进入该状态。</li>\n<li> Stop：不接受新任务，不处理存量任务，调用shutdownnow进入该状态。</li>\n<li> Tidying：所有任务已经终止了，worker_count（有效线程数）为0。</li>\n<li> Terminated：线程池彻底终止。在tidying模式下调用terminated方法会进入该状态。</li>\n</ul>\n<h3 id=\"简述线程池类型\"><a href=\"#简述线程池类型\" class=\"headerlink\" title=\"简述线程池类型\"></a>简述线程池类型</h3><ul>\n<li> newCachedThreadPool 可缓存线程池，可设置最小线程数和最大线程数，线程空闲1分钟后自动销毁。</li>\n<li> newFixedThreadPool 指定工作线程数量线程池。</li>\n<li> newSingleThreadExecutor 单线程Executor。</li>\n<li> newScheduleThreadPool 支持定时任务的指定工作线程数量线程池。</li>\n<li> newSingleThreadScheduledExecutor 支持定时任务的单线程Executor。</li>\n</ul>\n<h3 id=\"简述阻塞队列\"><a href=\"#简述阻塞队列\" class=\"headerlink\" title=\"简述阻塞队列\"></a>简述阻塞队列</h3><p>阻塞队列是生产者消费者的实现具体组件之一。当阻塞队列为空时，从队列中获取元素的操作将会被阻塞，当阻塞队列满了，往队列添加元素的操作将会被阻塞。具体实现有：</p>\n<ul>\n<li> ArrayBlockingQueue：底层是由数组组成的有界阻塞队列。</li>\n<li> LinkedBlockingQueue：底层是由链表组成的有界阻塞队列。</li>\n<li> PriorityBlockingQueue：阻塞优先队列。</li>\n<li> DelayQueue：创建元素时可以指定多久才能从队列中获取当前元素</li>\n<li> SynchronousQueue：不存储元素的阻塞队列，每一个存储必须等待一个取出操作</li>\n<li> LinkedTransferQueue：与LinkedBlockingQueue相比多一个transfer方法，即如果当前有消费者正等待接收元素，可以把生产者传入的元素立刻传输给消费者。</li>\n<li> LinkedBlockingDeque：双向阻塞队列。</li>\n</ul>\n<h3 id=\"谈一谈ThreadLocal\"><a href=\"#谈一谈ThreadLocal\" class=\"headerlink\" title=\"谈一谈ThreadLocal\"></a>谈一谈ThreadLocal</h3><p>ThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的。</p>\n<ul>\n<li> set 给ThreadLocalMap设置值。</li>\n<li> get 获取ThreadLocalMap。</li>\n<li> remove 删除ThreadLocalMap类型的对象。</li>\n</ul>\n<p>存在的问题：对于线程池，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用，造成一系列问题。</p>\n<p>比如说内存泄漏。由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放，产生内存泄漏。</p>\n<h3 id=\"聊聊你对Java并发包下unsafe类的理解\"><a href=\"#聊聊你对Java并发包下unsafe类的理解\" class=\"headerlink\" title=\"聊聊你对Java并发包下unsafe类的理解\"></a>聊聊你对Java并发包下unsafe类的理解</h3><p>对于 Java 语言，没有直接的指针组件，一般也不能使用偏移量对某块内存进行操作。这些操作相对来讲是安全（safe）的。</p>\n<p>Java 有个类叫 Unsafe 类，这个类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。这个类可以说是 Java 并发开发的基础。</p>\n<h3 id=\"Java中的乐观锁与CAS算法\"><a href=\"#Java中的乐观锁与CAS算法\" class=\"headerlink\" title=\"Java中的乐观锁与CAS算法\"></a>Java中的乐观锁与CAS算法</h3><p>乐观锁认为数据发送时发生并发冲突的概率不大，所以读操作前不上锁。</p>\n<p>到了写操作时才会进行判断，数据在此期间是否被其他线程修改。如果发生修改，那就返回写入失败；如果没有被修改，那就执行修改操作，返回修改成功。</p>\n<p>乐观锁一般都采用 Compare And Swap（CAS）算法进行实现。顾名思义，该算法涉及到了两个操作，比较（Compare）和交换（Swap）。</p>\n<p>CAS 算法的思路如下：</p>\n<ul>\n<li> 该算法认为不同线程对变量的操作时产生竞争的情况比较少。</li>\n<li> 该算法的核心是对当前读取变量值 E 和内存中的变量旧值 V 进行比较。</li>\n<li> 如果相等，就代表其他线程没有对该变量进行修改，就将变量值更新为新值 N。</li>\n<li> 如果不等，就认为在读取值 E 到比较阶段，有其他线程对变量进行过修改，不进行任何操作。</li>\n</ul>\n<h3 id=\"ABA问题及解决方法简述\"><a href=\"#ABA问题及解决方法简述\" class=\"headerlink\" title=\"ABA问题及解决方法简述\"></a>ABA问题及解决方法简述</h3><p>CAS 算法是基于值来做比较的，如果当前有两个线程，一个线程将变量值从 A 改为 B ，再由 B 改回为 A ，当前线程开始执行 CAS 算法时，就很容易认为值没有变化，误认为读取数据到执行 CAS 算法的期间，没有线程修改过数据。</p>\n<p>juc 包提供了一个 AtomicStampedReference，即在原始的版本下加入版本号戳，解决 ABA 问题。</p>\n<h3 id=\"简述常见的Atomic类\"><a href=\"#简述常见的Atomic类\" class=\"headerlink\" title=\"简述常见的Atomic类\"></a>简述常见的Atomic类</h3><p>在很多时候，我们需要的仅仅是一个简单的、高效的、线程安全的++或者–方案，使用synchronized关键字和lock固然可以实现，但代价比较大，此时用原子类更加方便。基本数据类型的原子类有：</p>\n<ul>\n<li> AtomicInteger 原子更新整形</li>\n<li> AtomicLong 原子更新长整型</li>\n<li> AtomicBoolean 原子更新布尔类型</li>\n</ul>\n<p>Atomic数组类型有：</p>\n<ul>\n<li> AtomicIntegerArray 原子更新整形数组里的元素</li>\n<li> AtomicLongArray 原子更新长整型数组里的元素</li>\n<li> AtomicReferenceArray 原子更新引用类型数组里的元素。</li>\n</ul>\n<p>Atomic引用类型有：</p>\n<ul>\n<li> AtomicReference 原子更新引用类型</li>\n<li> AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 标记</li>\n<li> AtomicStampedReference 原子更新带有版本号的引用类型</li>\n</ul>\n<p>FieldUpdater类型：</p>\n<ul>\n<li> AtomicIntegerFieldUpdater 原子更新整形字段的更新器</li>\n<li> AtomicLongFieldUpdater 原子更新长整形字段的更新器</li>\n<li> AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器</li>\n</ul>\n<h3 id=\"简述Atomic类基本实现原理\"><a href=\"#简述Atomic类基本实现原理\" class=\"headerlink\" title=\"简述Atomic类基本实现原理\"></a>简述Atomic类基本实现原理</h3><p>以AtomicIntger 为例。</p>\n<p>方法getAndIncrement，以原子方式将当前的值加1，具体实现为：</p>\n<ul>\n<li> 在 for 死循环中取得 AtomicInteger 里存储的数值</li>\n<li> 对 AtomicInteger 当前的值加 1</li>\n<li> 调用 compareAndSet 方法进行原子更新</li>\n<li> 先检查当前数值是否等于 expect</li>\n<li> 如果等于则说明当前值没有被其他线程修改，则将值更新为 next，</li>\n<li> 如果不是会更新失败返回 false，程序会进入 for 循环重新进行 compareAndSet 操作。</li>\n</ul>\n<h3 id=\"简述CountDownLatch\"><a href=\"#简述CountDownLatch\" class=\"headerlink\" title=\"简述CountDownLatch\"></a>简述CountDownLatch</h3><p>CountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，调用countDown方法，计数器的值就减1，当计数器的值为0时，表示所有线程都执行完毕，然后在等待的线程就可以恢复工作了。只能一次性使用，不能reset。</p>\n<h3 id=\"简述CyclicBarrier\"><a href=\"#简述CyclicBarrier\" class=\"headerlink\" title=\"简述CyclicBarrier\"></a>简述CyclicBarrier</h3><p>CyclicBarrier 主要功能和CountDownLatch类似，也是通过一个计数器，使一个线程等待其他线程各自执行完毕后再执行。但是其可以重复使用（reset）。</p>\n<h3 id=\"简述Semaphore\"><a href=\"#简述Semaphore\" class=\"headerlink\" title=\"简述Semaphore\"></a>简述Semaphore</h3><p>Semaphore即信号量。Semaphore 的构造方法参数接收一个 int 值，设置一个计数器，表示可用的许可数量即最大并发数。使用 acquire 方法获得一个许可证，计数器减一，使用 release 方法归还许可，计数器加一。如果此时计数器值为0，线程进入休眠。</p>\n<h3 id=\"简述Exchanger\"><a href=\"#简述Exchanger\" class=\"headerlink\" title=\"简述Exchanger\"></a>简述Exchanger</h3><p>Exchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。线程通过exchange 方法交换数据，第一个线程执行 exchange 方法后会阻塞等待第二个线程执行该方法。当两个线程都到达同步点时这两个线程就可以交换数据当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。</p>\n<h3 id=\"简述ConcurrentHashMap\"><a href=\"#简述ConcurrentHashMap\" class=\"headerlink\" title=\"简述ConcurrentHashMap\"></a>简述ConcurrentHashMap</h3><p>JDK7采用锁分段技术。首先将数据分成 Segment 数据段，然后给每一个数据段配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。</p>\n<p>get 除读到空值不需要加锁。该方法先经过一次再散列，再用这个散列值通过散列运算定位到 Segment，最后通过散列算法定位到元素。put 须加锁，首先定位到 Segment，然后进行插入操作，第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放入数组。</p>\n<p>JDK8的改进</p>\n<ul>\n<li> 取消分段锁机制，采用CAS算法进行值的设置，如果CAS失败再使用 synchronized 加锁添加元素</li>\n<li> 引入红黑树结构，当某个槽内的元素个数超过8且 Node数组 容量大于 64 时，链表转为红黑树。</li>\n<li> 使用了更加优化的方式统计集合内的元素数量。</li>\n</ul>\n<h3 id=\"synchronized底层实现原理\"><a href=\"#synchronized底层实现原理\" class=\"headerlink\" title=\"synchronized底层实现原理\"></a>synchronized底层实现原理</h3><p>Java 对象底层都会关联一个 monitor，使用 synchronized 时 JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者，monitor 在被释放前不能再被其他线程获取。</p>\n<p>synchronized在JVM编译后会产生monitorenter 和 monitorexit 这两个字节码指令，获取和释放 monitor。这两个字节码指令都需要一个引用类型的参数指明要锁定和解锁的对象，对于同步普通方法，锁是当前实例对象；对于静态同步方法，锁是当前类的 Class 对象；对于同步方法块，锁是 synchronized 括号里的对象。</p>\n<p>执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。</p>\n<h3 id=\"synchronized关键词使用方法\"><a href=\"#synchronized关键词使用方法\" class=\"headerlink\" title=\"synchronized关键词使用方法\"></a>synchronized关键词使用方法</h3><ul>\n<li> 直接修饰某个实例方法</li>\n<li> 直接修饰某个静态方法</li>\n<li> 修饰代码块</li>\n</ul>\n<h3 id=\"简述Java偏向锁\"><a href=\"#简述Java偏向锁\" class=\"headerlink\" title=\"简述Java偏向锁\"></a>简述Java偏向锁</h3><p>JDK 1.6 中提出了偏向锁的概念。该锁提出的原因是，开发者发现多数情况下锁并不存在竞争，一把锁往往是由同一个线程获得的。偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。</p>\n<p>其申请流程为：</p>\n<ul>\n<li> 首先需要判断对象的 Mark Word 是否属于偏向模式，如果不属于，那就进入轻量级锁判断逻辑。否则继续下一步判断；</li>\n<li> 判断目前请求锁的线程 ID 是否和偏向锁本身记录的线程 ID 一致。如果一致，继续下一步的判断，如果不一致，跳转到步骤4；</li>\n<li> 判断是否需要重偏向。如果不用的话，直接获得偏向锁；</li>\n<li> 利用 CAS 算法将对象的 Mark Word 进行更改，使线程 ID 部分换成本线程 ID。如果更换成功，则重偏向完成，获得偏向锁。如果失败，则说明有多线程竞争，升级为轻量级锁。</li>\n</ul>\n<h3 id=\"简述轻量级锁\"><a href=\"#简述轻量级锁\" class=\"headerlink\" title=\"简述轻量级锁\"></a>简述轻量级锁</h3><p>轻量级锁是为了在没有竞争的前提下减少重量级锁出现并导致的性能消耗。</p>\n<p>其申请流程为：</p>\n<ul>\n<li> 如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝。</li>\n<li> 虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针</li>\n<li> 如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。</li>\n<li> 如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧</li>\n<li> 如果指向当前线程的栈帧，说明当前线程已经拥有了锁，直接进入同步块继续执行</li>\n<li> 如果不是则说明锁对象已经被其他线程抢占。</li>\n<li> 如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。</li>\n</ul>\n<h3 id=\"简述锁优化策略\"><a href=\"#简述锁优化策略\" class=\"headerlink\" title=\"简述锁优化策略\"></a>简述锁优化策略</h3><p>即自适应自旋、锁消除、锁粗化、锁升级等策略偏。</p>\n<h3 id=\"简述Java的自旋锁\"><a href=\"#简述Java的自旋锁\" class=\"headerlink\" title=\"简述Java的自旋锁\"></a>简述Java的自旋锁</h3><p>线程获取锁失败后，可以采用这样的策略，可以不放弃 CPU ，不停的重试内重试，这种操作也称为自旋锁。</p>\n<h3 id=\"简述自适应自旋锁\"><a href=\"#简述自适应自旋锁\" class=\"headerlink\" title=\"简述自适应自旋锁\"></a>简述自适应自旋锁</h3><p>自适应自旋锁自旋次数不再人为设定，通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。</p>\n<h3 id=\"简述锁粗化\"><a href=\"#简述锁粗化\" class=\"headerlink\" title=\"简述锁粗化\"></a>简述锁粗化</h3><p>锁粗化的思想就是扩大加锁范围，避免反复的加锁和解锁。</p>\n<h3 id=\"简述锁消除\"><a href=\"#简述锁消除\" class=\"headerlink\" title=\"简述锁消除\"></a>简述锁消除</h3><p>锁消除是一种更为彻底的优化，在编译时，Java编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁。</p>\n<h3 id=\"简述Lock与ReentrantLock\"><a href=\"#简述Lock与ReentrantLock\" class=\"headerlink\" title=\"简述Lock与ReentrantLock\"></a>简述Lock与ReentrantLock</h3><p>Lock接口是 Java并发包的顶层接口。</p>\n<p>可重入锁 ReentrantLock 是 Lock 最常见的实现，与 synchronized 一样可重入。ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会下降。</p>\n<h3 id=\"简述AQS\"><a href=\"#简述AQS\" class=\"headerlink\" title=\"简述AQS\"></a>简述AQS</h3><p>AQS（AbstractQuenedSynchronizer）抽象的队列式同步器。AQS是将每一条请求共享资源的线程封装成一个锁队列的一个结点（Node），来实现锁的分配。AQS是用来构建锁或其他同步组件的基础框架，它使用一个 volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。</p>\n<p>子类通过继承同步器并实现它的抽象方法getState、setState 和 compareAndSetState对同步状态进行更改。</p>\n<p>AQS获取独占锁/释放独占锁原理：</p>\n<p>获取：（acquire）</p>\n<ul>\n<li> 调用 tryAcquire 方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过 addWaiter 方法加入到同步队列的尾部，在队列中自旋。</li>\n<li> 调用 acquireQueued 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞。</li>\n</ul>\n<p>释放：（release）</p>\n<ul>\n<li> 调用 tryRelease 方法释放同步状态</li>\n<li> 调用 unparkSuccessor 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。</li>\n</ul>\n<p>AQS获取共享锁/释放共享锁原理</p>\n<p>获取锁（acquireShared）</p>\n<ul>\n<li> 调用 tryAcquireShared 方法尝试获取同步状态，返回值不小于 0 表示能获取同步状态。</li>\n<li> 释放（releaseShared），并唤醒后续处于等待状态的节点。</li>\n</ul>\n"},{"title":"Java虚拟机八股文","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-11-04T05:16:53.000Z","password":null,"summary":"程序计数器、Java 虚拟机栈、本地方法栈。","_content":"### 简述JVM内存模型 \n\n线程私有的运行时数据区: 程序计数器、Java 虚拟机栈、本地方法栈。\n\n线程共享的运行时数据区：Java 堆、方法区。\n\n### 简述程序计数器 \n\n程序计数器表示当前线程所执行的字节码的行号指示器。\n\n程序计数器不会产生StackOverflowError和OutOfMemoryError。\n\n### 简述虚拟机栈 \n\nJava 虚拟机栈用来描述 Java 方法执行的内存模型。线程创建时就会分配一个栈空间，线程结束后栈空间被回收。\n\n栈中元素用于支持虚拟机进行方法调用，每个方法在执行时都会创建一个栈帧存储方法的局部变量表、操作栈、动态链接和返回地址等信息。\n\n虚拟机栈会产生两类异常：\n\n *  StackOverflowError：线程请求的栈深度大于虚拟机允许的深度抛出。\n *  OutOfMemoryError：如果 JVM 栈容量可以动态扩展，虚拟机栈占用内存超出抛出。\n\n### 简述本地方法栈 \n\n本地方法栈与虚拟机栈作用相似，不同的是虚拟机栈为虚拟机执行 Java 方法服务，本地方法栈为本地方法服务。可以将虚拟机栈看作普通的java函数对应的内存模型，本地方法栈看作由native关键词修饰的函数对应的内存模型。\n\n本地方法栈会产生两类异常：\n\n *  StackOverflowError：线程请求的栈深度大于虚拟机允许的深度抛出。\n *  OutOfMemoryError：如果 JVM 栈容量可以动态扩展，虚拟机栈占用内存超出抛出。\n\n### 简述JVM中的堆 \n\n堆主要作用是存放对象实例，Java 里几乎所有对象实例都在堆上分配内存，堆也是内存管理中最大的一块。Java的垃圾回收主要就是针对堆这一区域进行。可通过 -Xms 和 -Xmx 设置堆的最小和最大容量。\n\n堆会抛出 OutOfMemoryError异常。\n\n### 简述方法区 \n\n方法区用于存储被虚拟机加载的类信息、常量、静态变量等数据。\n\nJDK6之前使用永久代实现方法区，容易内存溢出。JDK7 把放在永久代的字符串常量池、静态变量等移出，JDK8 中抛弃永久代，改用在本地内存中实现的元空间来实现方法区，把 JDK 7 中永久代内容移到元空间。\n\n方法区会抛出 OutOfMemoryError异常。\n\n### 简述运行时常量池 \n\n运行时常量池存放常量池表，用于存放编译器生成的各种字面量与符号引用。一般除了保存 Class 文件中描述的符号引用外，还会把符号引用翻译的直接引用也存储在运行时常量池。除此之外，也会存放字符串基本类型。\n\nJDK8之前，放在方法区，大小受限于方法区。JDK8将运行时常量池存放堆中。\n\n### 简述直接内存 \n\n直接内存也称为堆外内存，就是把内存对象分配在JVM堆外的内存区域。这部分内存不是虚拟机管理，而是由操作系统来管理。Java通过DriectByteBuffer对其进行操作，避免了在 Java 堆和 Native堆来回复制数据。\n\n### 简述Java创建对象的过程 \n\n *  检查该指令的参数能否在常量池中定位到一个类的符号引用，并检查引用代表的类是否已被加载、解析和初始化，如果没有就先执行类加载。\n *  通过检查通过后虚拟机将为新生对象分配内存。\n *  完成内存分配后虚拟机将成员变量设为零值\n *  设置对象头，包括哈希码、GC 信息、锁信息、对象所属类的类元信息等。\n *  执行 init 方法，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。\n\n### 简述JVM给对象分配内存的策略 \n\n *  指针碰撞：这种方式在内存中放一个指针作为分界指示器将使用过的内存放在一边，空闲的放在另一边，通过指针挪动完成分配。\n *  空闲列表：对于 Java 堆内存不规整的情况，虚拟机必须维护一个列表记录哪些内存可用，在分配时从列表中找到一块足够大的空间划分给对象并更新列表记录。\n\n### Java对象内存分配是如何保证线程安全的 \n\n第一种方法，采用CAS机制，配合失败重试的方式保证更新操作的原子性。该方式效率低。\n\n第二种方法，每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块\"私有\"内存中分配。一般采用这种策略。\n\n### 简述对象的内存布局 \n\n对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。\n\n1）对象头主要包含两部分数据：MarkWord、类型指针。\n\nMarkWord 用于存储哈希码（HashCode）、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID等信息。\n\n类型指针即对象指向他的类元数据指针，如果对象是一个 Java 数组，会有一块用于记录数组长度的数据。\n\n2）实例数据存储代码中所定义的各种类型的字段信息。\n\n3）对齐填充起占位作用。HotSpot 虚拟机要求对象的起始地址必须是8的整数倍，因此需要对齐填充。\n\n### 如何判断对象是否是垃圾 \n\n1）引用计数法：\n\n设置引用计数器，对象被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。会存在对象间循环引用的问题，一般不使用这种方法。\n\n2）可达性分析：\n\n通过 GC Roots 的根对象作为起始节点，从这些节点开始，根据引用关系向下搜索，如果某个对象没有被搜到，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。\n\n### 简述java的引用类型 \n\n *  强引用：被强引用关联的对象不会被回收。一般采用 new 方法创建强引用。\n *  软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。一般采用 SoftReference 类来创建软引用。\n *  弱引用：垃圾收集器碰到即回收，也就是说它只能存活到下一次垃圾回收发生之前。一般采用 WeakReference 类来创建弱引用。\n *  虚引用：无法通过该引用获取对象。唯一目的就是为了能在对象被回收时收到一个系统通知。虚引用必须与引用队列联合使用。\n\n### 简述标记清除算法、标记整理算法和标记复制算法 \n\n *  标记清除算法：先标记需清除的对象，之后统一回收。这种方法效率不高，会产生大量不连续的碎片。\n *  标记整理算法：先标记存活对象，然后让所有存活对象向一端移动，之后清理端边界以外的内存\n *  标记复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。\n\n### 简述分代收集算法 \n\n根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。\n\n一般将堆分为新生代和老年代，对这两块采用不同的算法。\n\n新生代使用：标记复制算法\n\n老年代使用：标记清除或者标记整理算法\n\n### 简述Serial垃圾收集器 \n\nSerial垃圾收集器是单线程串行收集器。垃圾回收的时候，必须暂停其他所有线程。新生代使用标记复制算法，老年代使用标记整理算法。简单高效。\n\n### 简述ParNew垃圾收集器 \n\nParNew垃圾收集器可以看作Serial垃圾收集器的多线程版本，新生代使用标记复制算法，老年代使用标记整理算法。\n\n### 简述Parallel Scavenge垃圾收集器 \n\n注重吞吐量，即 CPU运行代码时间/CPU耗时总时间（CPU运行代码时间+ 垃圾回收时间）。新生代使用标记复制算法，老年代使用标记整理算法。\n\n### 简述CMS垃圾收集器 \n\nCMS垃圾收集器注重最短时间停顿。CMS垃圾收集器为最早提出的并发收集器，垃圾收集线程与用户线程同时工作。采用标记清除算法。该收集器分为初始标记、并发标记、并发预清理、并发清除、并发重置这么几个步骤。\n\n *  初始标记：暂停其他线程(stop the world)，标记与GC roots直接关联的对象。\n *  并发标记：可达性分析过程(程序不会停顿)。\n *  并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象，重新标记，暂停虚拟机（stop the world）扫描CMS堆中剩余对象。\n *  并发清除：清理垃圾对象，(程序不会停顿)。\n *  并发重置，重置CMS收集器的数据结构。\n\n### 简述G1垃圾收集器 \n\n和Serial、Parallel Scavenge、CMS不同，G1垃圾收集器把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。\n\n *  初始标记：标记与GC roots直接关联的对象。\n *  并发标记：可达性分析。\n *  最终标记：对并发标记过程中，用户线程修改的对象再次标记一下。\n *  筛选回收：对各个Region的回收价值和成本进行排序，然后根据用户所期望的GC停顿时间制定回收计划并回收。\n\n### 简述Minor GC \n\nMinor GC指发生在新生代的垃圾收集，因为 Java 对象大多存活时间短，所以 Minor GC 非常频繁，一般回收速度也比较快。\n\n### 简述Full GC \n\nFull GC 是清理整个堆空间—包括年轻代和永久代。调用System.gc(),老年代空间不足，空间分配担保失败，永生代空间不足会产生full gc。\n\n### 常见内存分配策略 \n\n大多数情况下对象在新生代 Eden 区分配，当 Eden 没有足够空间时将发起一次 Minor GC。\n\n大对象需要大量连续内存空间，直接进入老年代区分配。\n\n如果经历过第一次 Minor GC 仍然存活且能被 Survivor 容纳，该对象就会被移动到 Survivor 中并将年龄设置为 1，并且每熬过一次 Minor GC 年龄就加 1 ，当增加到一定程度（默认15）就会被晋升到老年代。\n\n如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 的一半，年龄不小于该年龄的对象就可以直接进入老年代。\n\nMinorGC 前，虚拟机必须检查老年代最大可用连续空间是否大于新生代对象总空间，如果满足则说明这次 Minor GC 确定安全。如果不，JVM会查看HandlePromotionFailure 参数是否允许担保失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果满足将Minor GC，否则改成一次 FullGC。\n\n### 简述JVM类加载过程 \n\n1）加载：\n\n *  通过全类名获取类的二进制字节流。\n *  将类的静态存储结构转化为方法区的运行时数据结构。\n *  在内存中生成类的Class对象，作为方法区数据的入口。\n\n2）验证：对文件格式，元数据，字节码，符号引用等验证正确性。\n\n3）准备：在方法区内为类变量分配内存并设置为0值。\n\n4）解析：将符号引用转化为直接引用。\n\n5）初始化：执行类构造器clinit方法，真正初始化。\n\n### 简述JVM中的类加载器 \n\n *  BootstrapClassLoader启动类加载器：加载/lib下的jar包和类。由C++编写。\n *  ExtensionClassLoader扩展类加载器：/lib/ext目录下的jar包和类。由Java编写。\n *  AppClassLoader应用类加载器，加载当前classPath下的jar包和类。由Java编写。\n\n### 简述双亲委派机制 \n\n一个类加载器收到类加载请求之后，首先判断当前类是否被加载过。已经被加载的类会直接返回，如果没有被加载，首先将类加载请求转发给父类加载器，一直转发到启动类加载器，只有当父类加载器无法完成时才尝试自己加载。\n\n加载类顺序：BootstrapClassLoader->ExtensionClassLoader->AppClassLoader->CustomClassLoader 检查类是否加载顺序：CustomClassLoader->AppClassLoader->ExtensionClassLoader->BootstrapClassLoader\n\n### 双亲委派机制的优点 \n\n *  避免类的重复加载。相同的类被不同的类加载器加载会产生不同的类，双亲委派保证了Java程序的稳定运行。\n *  保证核心API不被修改。\n *  如何破坏双亲委派机制\n *  重载loadClass()方法，即自定义类加载器。\n\n### 如何构建自定义类加载器 \n\n新建自定义类继承自java.lang.ClassLoader，重写findClass、loadClass、defineClass方法\n\n### JVM常见调优参数 \n\n *  \\-Xms 初始堆大小\n *  \\-Xmx 最大堆大小\n *  \\-XX:NewSize 年轻代大小\n *  \\-XX:MaxNewSize 年轻代最大值\n *  \\-XX:PermSize 永生代初始值\n *  \\-XX:MaxPermSize 永生代最大值\n *  \\-XX:NewRatio 新生代与老年代的比例","source":"_posts/Java虚拟机八股文.md","raw":"---\ntitle: Java虚拟机八股文\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-11-04 13:16:53\npassword:\nsummary: 程序计数器、Java 虚拟机栈、本地方法栈。\ntags:\n    - java虚拟机\n    - 八股文\ncategories:\n    - java\n---\n### 简述JVM内存模型 \n\n线程私有的运行时数据区: 程序计数器、Java 虚拟机栈、本地方法栈。\n\n线程共享的运行时数据区：Java 堆、方法区。\n\n### 简述程序计数器 \n\n程序计数器表示当前线程所执行的字节码的行号指示器。\n\n程序计数器不会产生StackOverflowError和OutOfMemoryError。\n\n### 简述虚拟机栈 \n\nJava 虚拟机栈用来描述 Java 方法执行的内存模型。线程创建时就会分配一个栈空间，线程结束后栈空间被回收。\n\n栈中元素用于支持虚拟机进行方法调用，每个方法在执行时都会创建一个栈帧存储方法的局部变量表、操作栈、动态链接和返回地址等信息。\n\n虚拟机栈会产生两类异常：\n\n *  StackOverflowError：线程请求的栈深度大于虚拟机允许的深度抛出。\n *  OutOfMemoryError：如果 JVM 栈容量可以动态扩展，虚拟机栈占用内存超出抛出。\n\n### 简述本地方法栈 \n\n本地方法栈与虚拟机栈作用相似，不同的是虚拟机栈为虚拟机执行 Java 方法服务，本地方法栈为本地方法服务。可以将虚拟机栈看作普通的java函数对应的内存模型，本地方法栈看作由native关键词修饰的函数对应的内存模型。\n\n本地方法栈会产生两类异常：\n\n *  StackOverflowError：线程请求的栈深度大于虚拟机允许的深度抛出。\n *  OutOfMemoryError：如果 JVM 栈容量可以动态扩展，虚拟机栈占用内存超出抛出。\n\n### 简述JVM中的堆 \n\n堆主要作用是存放对象实例，Java 里几乎所有对象实例都在堆上分配内存，堆也是内存管理中最大的一块。Java的垃圾回收主要就是针对堆这一区域进行。可通过 -Xms 和 -Xmx 设置堆的最小和最大容量。\n\n堆会抛出 OutOfMemoryError异常。\n\n### 简述方法区 \n\n方法区用于存储被虚拟机加载的类信息、常量、静态变量等数据。\n\nJDK6之前使用永久代实现方法区，容易内存溢出。JDK7 把放在永久代的字符串常量池、静态变量等移出，JDK8 中抛弃永久代，改用在本地内存中实现的元空间来实现方法区，把 JDK 7 中永久代内容移到元空间。\n\n方法区会抛出 OutOfMemoryError异常。\n\n### 简述运行时常量池 \n\n运行时常量池存放常量池表，用于存放编译器生成的各种字面量与符号引用。一般除了保存 Class 文件中描述的符号引用外，还会把符号引用翻译的直接引用也存储在运行时常量池。除此之外，也会存放字符串基本类型。\n\nJDK8之前，放在方法区，大小受限于方法区。JDK8将运行时常量池存放堆中。\n\n### 简述直接内存 \n\n直接内存也称为堆外内存，就是把内存对象分配在JVM堆外的内存区域。这部分内存不是虚拟机管理，而是由操作系统来管理。Java通过DriectByteBuffer对其进行操作，避免了在 Java 堆和 Native堆来回复制数据。\n\n### 简述Java创建对象的过程 \n\n *  检查该指令的参数能否在常量池中定位到一个类的符号引用，并检查引用代表的类是否已被加载、解析和初始化，如果没有就先执行类加载。\n *  通过检查通过后虚拟机将为新生对象分配内存。\n *  完成内存分配后虚拟机将成员变量设为零值\n *  设置对象头，包括哈希码、GC 信息、锁信息、对象所属类的类元信息等。\n *  执行 init 方法，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。\n\n### 简述JVM给对象分配内存的策略 \n\n *  指针碰撞：这种方式在内存中放一个指针作为分界指示器将使用过的内存放在一边，空闲的放在另一边，通过指针挪动完成分配。\n *  空闲列表：对于 Java 堆内存不规整的情况，虚拟机必须维护一个列表记录哪些内存可用，在分配时从列表中找到一块足够大的空间划分给对象并更新列表记录。\n\n### Java对象内存分配是如何保证线程安全的 \n\n第一种方法，采用CAS机制，配合失败重试的方式保证更新操作的原子性。该方式效率低。\n\n第二种方法，每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块\"私有\"内存中分配。一般采用这种策略。\n\n### 简述对象的内存布局 \n\n对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。\n\n1）对象头主要包含两部分数据：MarkWord、类型指针。\n\nMarkWord 用于存储哈希码（HashCode）、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID等信息。\n\n类型指针即对象指向他的类元数据指针，如果对象是一个 Java 数组，会有一块用于记录数组长度的数据。\n\n2）实例数据存储代码中所定义的各种类型的字段信息。\n\n3）对齐填充起占位作用。HotSpot 虚拟机要求对象的起始地址必须是8的整数倍，因此需要对齐填充。\n\n### 如何判断对象是否是垃圾 \n\n1）引用计数法：\n\n设置引用计数器，对象被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。会存在对象间循环引用的问题，一般不使用这种方法。\n\n2）可达性分析：\n\n通过 GC Roots 的根对象作为起始节点，从这些节点开始，根据引用关系向下搜索，如果某个对象没有被搜到，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。\n\n### 简述java的引用类型 \n\n *  强引用：被强引用关联的对象不会被回收。一般采用 new 方法创建强引用。\n *  软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。一般采用 SoftReference 类来创建软引用。\n *  弱引用：垃圾收集器碰到即回收，也就是说它只能存活到下一次垃圾回收发生之前。一般采用 WeakReference 类来创建弱引用。\n *  虚引用：无法通过该引用获取对象。唯一目的就是为了能在对象被回收时收到一个系统通知。虚引用必须与引用队列联合使用。\n\n### 简述标记清除算法、标记整理算法和标记复制算法 \n\n *  标记清除算法：先标记需清除的对象，之后统一回收。这种方法效率不高，会产生大量不连续的碎片。\n *  标记整理算法：先标记存活对象，然后让所有存活对象向一端移动，之后清理端边界以外的内存\n *  标记复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。\n\n### 简述分代收集算法 \n\n根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。\n\n一般将堆分为新生代和老年代，对这两块采用不同的算法。\n\n新生代使用：标记复制算法\n\n老年代使用：标记清除或者标记整理算法\n\n### 简述Serial垃圾收集器 \n\nSerial垃圾收集器是单线程串行收集器。垃圾回收的时候，必须暂停其他所有线程。新生代使用标记复制算法，老年代使用标记整理算法。简单高效。\n\n### 简述ParNew垃圾收集器 \n\nParNew垃圾收集器可以看作Serial垃圾收集器的多线程版本，新生代使用标记复制算法，老年代使用标记整理算法。\n\n### 简述Parallel Scavenge垃圾收集器 \n\n注重吞吐量，即 CPU运行代码时间/CPU耗时总时间（CPU运行代码时间+ 垃圾回收时间）。新生代使用标记复制算法，老年代使用标记整理算法。\n\n### 简述CMS垃圾收集器 \n\nCMS垃圾收集器注重最短时间停顿。CMS垃圾收集器为最早提出的并发收集器，垃圾收集线程与用户线程同时工作。采用标记清除算法。该收集器分为初始标记、并发标记、并发预清理、并发清除、并发重置这么几个步骤。\n\n *  初始标记：暂停其他线程(stop the world)，标记与GC roots直接关联的对象。\n *  并发标记：可达性分析过程(程序不会停顿)。\n *  并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象，重新标记，暂停虚拟机（stop the world）扫描CMS堆中剩余对象。\n *  并发清除：清理垃圾对象，(程序不会停顿)。\n *  并发重置，重置CMS收集器的数据结构。\n\n### 简述G1垃圾收集器 \n\n和Serial、Parallel Scavenge、CMS不同，G1垃圾收集器把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。\n\n *  初始标记：标记与GC roots直接关联的对象。\n *  并发标记：可达性分析。\n *  最终标记：对并发标记过程中，用户线程修改的对象再次标记一下。\n *  筛选回收：对各个Region的回收价值和成本进行排序，然后根据用户所期望的GC停顿时间制定回收计划并回收。\n\n### 简述Minor GC \n\nMinor GC指发生在新生代的垃圾收集，因为 Java 对象大多存活时间短，所以 Minor GC 非常频繁，一般回收速度也比较快。\n\n### 简述Full GC \n\nFull GC 是清理整个堆空间—包括年轻代和永久代。调用System.gc(),老年代空间不足，空间分配担保失败，永生代空间不足会产生full gc。\n\n### 常见内存分配策略 \n\n大多数情况下对象在新生代 Eden 区分配，当 Eden 没有足够空间时将发起一次 Minor GC。\n\n大对象需要大量连续内存空间，直接进入老年代区分配。\n\n如果经历过第一次 Minor GC 仍然存活且能被 Survivor 容纳，该对象就会被移动到 Survivor 中并将年龄设置为 1，并且每熬过一次 Minor GC 年龄就加 1 ，当增加到一定程度（默认15）就会被晋升到老年代。\n\n如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 的一半，年龄不小于该年龄的对象就可以直接进入老年代。\n\nMinorGC 前，虚拟机必须检查老年代最大可用连续空间是否大于新生代对象总空间，如果满足则说明这次 Minor GC 确定安全。如果不，JVM会查看HandlePromotionFailure 参数是否允许担保失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果满足将Minor GC，否则改成一次 FullGC。\n\n### 简述JVM类加载过程 \n\n1）加载：\n\n *  通过全类名获取类的二进制字节流。\n *  将类的静态存储结构转化为方法区的运行时数据结构。\n *  在内存中生成类的Class对象，作为方法区数据的入口。\n\n2）验证：对文件格式，元数据，字节码，符号引用等验证正确性。\n\n3）准备：在方法区内为类变量分配内存并设置为0值。\n\n4）解析：将符号引用转化为直接引用。\n\n5）初始化：执行类构造器clinit方法，真正初始化。\n\n### 简述JVM中的类加载器 \n\n *  BootstrapClassLoader启动类加载器：加载/lib下的jar包和类。由C++编写。\n *  ExtensionClassLoader扩展类加载器：/lib/ext目录下的jar包和类。由Java编写。\n *  AppClassLoader应用类加载器，加载当前classPath下的jar包和类。由Java编写。\n\n### 简述双亲委派机制 \n\n一个类加载器收到类加载请求之后，首先判断当前类是否被加载过。已经被加载的类会直接返回，如果没有被加载，首先将类加载请求转发给父类加载器，一直转发到启动类加载器，只有当父类加载器无法完成时才尝试自己加载。\n\n加载类顺序：BootstrapClassLoader->ExtensionClassLoader->AppClassLoader->CustomClassLoader 检查类是否加载顺序：CustomClassLoader->AppClassLoader->ExtensionClassLoader->BootstrapClassLoader\n\n### 双亲委派机制的优点 \n\n *  避免类的重复加载。相同的类被不同的类加载器加载会产生不同的类，双亲委派保证了Java程序的稳定运行。\n *  保证核心API不被修改。\n *  如何破坏双亲委派机制\n *  重载loadClass()方法，即自定义类加载器。\n\n### 如何构建自定义类加载器 \n\n新建自定义类继承自java.lang.ClassLoader，重写findClass、loadClass、defineClass方法\n\n### JVM常见调优参数 \n\n *  \\-Xms 初始堆大小\n *  \\-Xmx 最大堆大小\n *  \\-XX:NewSize 年轻代大小\n *  \\-XX:MaxNewSize 年轻代最大值\n *  \\-XX:PermSize 永生代初始值\n *  \\-XX:MaxPermSize 永生代最大值\n *  \\-XX:NewRatio 新生代与老年代的比例","slug":"Java虚拟机八股文","published":1,"updated":"2022-11-04T05:22:54.139Z","_id":"cla21kmz0000301ldgbif4r8y","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"简述JVM内存模型\"><a href=\"#简述JVM内存模型\" class=\"headerlink\" title=\"简述JVM内存模型\"></a>简述JVM内存模型</h3><p>线程私有的运行时数据区: 程序计数器、Java 虚拟机栈、本地方法栈。</p>\n<p>线程共享的运行时数据区：Java 堆、方法区。</p>\n<h3 id=\"简述程序计数器\"><a href=\"#简述程序计数器\" class=\"headerlink\" title=\"简述程序计数器\"></a>简述程序计数器</h3><p>程序计数器表示当前线程所执行的字节码的行号指示器。</p>\n<p>程序计数器不会产生StackOverflowError和OutOfMemoryError。</p>\n<h3 id=\"简述虚拟机栈\"><a href=\"#简述虚拟机栈\" class=\"headerlink\" title=\"简述虚拟机栈\"></a>简述虚拟机栈</h3><p>Java 虚拟机栈用来描述 Java 方法执行的内存模型。线程创建时就会分配一个栈空间，线程结束后栈空间被回收。</p>\n<p>栈中元素用于支持虚拟机进行方法调用，每个方法在执行时都会创建一个栈帧存储方法的局部变量表、操作栈、动态链接和返回地址等信息。</p>\n<p>虚拟机栈会产生两类异常：</p>\n<ul>\n<li> StackOverflowError：线程请求的栈深度大于虚拟机允许的深度抛出。</li>\n<li> OutOfMemoryError：如果 JVM 栈容量可以动态扩展，虚拟机栈占用内存超出抛出。</li>\n</ul>\n<h3 id=\"简述本地方法栈\"><a href=\"#简述本地方法栈\" class=\"headerlink\" title=\"简述本地方法栈\"></a>简述本地方法栈</h3><p>本地方法栈与虚拟机栈作用相似，不同的是虚拟机栈为虚拟机执行 Java 方法服务，本地方法栈为本地方法服务。可以将虚拟机栈看作普通的java函数对应的内存模型，本地方法栈看作由native关键词修饰的函数对应的内存模型。</p>\n<p>本地方法栈会产生两类异常：</p>\n<ul>\n<li> StackOverflowError：线程请求的栈深度大于虚拟机允许的深度抛出。</li>\n<li> OutOfMemoryError：如果 JVM 栈容量可以动态扩展，虚拟机栈占用内存超出抛出。</li>\n</ul>\n<h3 id=\"简述JVM中的堆\"><a href=\"#简述JVM中的堆\" class=\"headerlink\" title=\"简述JVM中的堆\"></a>简述JVM中的堆</h3><p>堆主要作用是存放对象实例，Java 里几乎所有对象实例都在堆上分配内存，堆也是内存管理中最大的一块。Java的垃圾回收主要就是针对堆这一区域进行。可通过 -Xms 和 -Xmx 设置堆的最小和最大容量。</p>\n<p>堆会抛出 OutOfMemoryError异常。</p>\n<h3 id=\"简述方法区\"><a href=\"#简述方法区\" class=\"headerlink\" title=\"简述方法区\"></a>简述方法区</h3><p>方法区用于存储被虚拟机加载的类信息、常量、静态变量等数据。</p>\n<p>JDK6之前使用永久代实现方法区，容易内存溢出。JDK7 把放在永久代的字符串常量池、静态变量等移出，JDK8 中抛弃永久代，改用在本地内存中实现的元空间来实现方法区，把 JDK 7 中永久代内容移到元空间。</p>\n<p>方法区会抛出 OutOfMemoryError异常。</p>\n<h3 id=\"简述运行时常量池\"><a href=\"#简述运行时常量池\" class=\"headerlink\" title=\"简述运行时常量池\"></a>简述运行时常量池</h3><p>运行时常量池存放常量池表，用于存放编译器生成的各种字面量与符号引用。一般除了保存 Class 文件中描述的符号引用外，还会把符号引用翻译的直接引用也存储在运行时常量池。除此之外，也会存放字符串基本类型。</p>\n<p>JDK8之前，放在方法区，大小受限于方法区。JDK8将运行时常量池存放堆中。</p>\n<h3 id=\"简述直接内存\"><a href=\"#简述直接内存\" class=\"headerlink\" title=\"简述直接内存\"></a>简述直接内存</h3><p>直接内存也称为堆外内存，就是把内存对象分配在JVM堆外的内存区域。这部分内存不是虚拟机管理，而是由操作系统来管理。Java通过DriectByteBuffer对其进行操作，避免了在 Java 堆和 Native堆来回复制数据。</p>\n<h3 id=\"简述Java创建对象的过程\"><a href=\"#简述Java创建对象的过程\" class=\"headerlink\" title=\"简述Java创建对象的过程\"></a>简述Java创建对象的过程</h3><ul>\n<li> 检查该指令的参数能否在常量池中定位到一个类的符号引用，并检查引用代表的类是否已被加载、解析和初始化，如果没有就先执行类加载。</li>\n<li> 通过检查通过后虚拟机将为新生对象分配内存。</li>\n<li> 完成内存分配后虚拟机将成员变量设为零值</li>\n<li> 设置对象头，包括哈希码、GC 信息、锁信息、对象所属类的类元信息等。</li>\n<li> 执行 init 方法，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</li>\n</ul>\n<h3 id=\"简述JVM给对象分配内存的策略\"><a href=\"#简述JVM给对象分配内存的策略\" class=\"headerlink\" title=\"简述JVM给对象分配内存的策略\"></a>简述JVM给对象分配内存的策略</h3><ul>\n<li> 指针碰撞：这种方式在内存中放一个指针作为分界指示器将使用过的内存放在一边，空闲的放在另一边，通过指针挪动完成分配。</li>\n<li> 空闲列表：对于 Java 堆内存不规整的情况，虚拟机必须维护一个列表记录哪些内存可用，在分配时从列表中找到一块足够大的空间划分给对象并更新列表记录。</li>\n</ul>\n<h3 id=\"Java对象内存分配是如何保证线程安全的\"><a href=\"#Java对象内存分配是如何保证线程安全的\" class=\"headerlink\" title=\"Java对象内存分配是如何保证线程安全的\"></a>Java对象内存分配是如何保证线程安全的</h3><p>第一种方法，采用CAS机制，配合失败重试的方式保证更新操作的原子性。该方式效率低。</p>\n<p>第二种方法，每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配。一般采用这种策略。</p>\n<h3 id=\"简述对象的内存布局\"><a href=\"#简述对象的内存布局\" class=\"headerlink\" title=\"简述对象的内存布局\"></a>简述对象的内存布局</h3><p>对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。</p>\n<p>1）对象头主要包含两部分数据：MarkWord、类型指针。</p>\n<p>MarkWord 用于存储哈希码（HashCode）、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID等信息。</p>\n<p>类型指针即对象指向他的类元数据指针，如果对象是一个 Java 数组，会有一块用于记录数组长度的数据。</p>\n<p>2）实例数据存储代码中所定义的各种类型的字段信息。</p>\n<p>3）对齐填充起占位作用。HotSpot 虚拟机要求对象的起始地址必须是8的整数倍，因此需要对齐填充。</p>\n<h3 id=\"如何判断对象是否是垃圾\"><a href=\"#如何判断对象是否是垃圾\" class=\"headerlink\" title=\"如何判断对象是否是垃圾\"></a>如何判断对象是否是垃圾</h3><p>1）引用计数法：</p>\n<p>设置引用计数器，对象被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。会存在对象间循环引用的问题，一般不使用这种方法。</p>\n<p>2）可达性分析：</p>\n<p>通过 GC Roots 的根对象作为起始节点，从这些节点开始，根据引用关系向下搜索，如果某个对象没有被搜到，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。</p>\n<h3 id=\"简述java的引用类型\"><a href=\"#简述java的引用类型\" class=\"headerlink\" title=\"简述java的引用类型\"></a>简述java的引用类型</h3><ul>\n<li> 强引用：被强引用关联的对象不会被回收。一般采用 new 方法创建强引用。</li>\n<li> 软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。一般采用 SoftReference 类来创建软引用。</li>\n<li> 弱引用：垃圾收集器碰到即回收，也就是说它只能存活到下一次垃圾回收发生之前。一般采用 WeakReference 类来创建弱引用。</li>\n<li> 虚引用：无法通过该引用获取对象。唯一目的就是为了能在对象被回收时收到一个系统通知。虚引用必须与引用队列联合使用。</li>\n</ul>\n<h3 id=\"简述标记清除算法、标记整理算法和标记复制算法\"><a href=\"#简述标记清除算法、标记整理算法和标记复制算法\" class=\"headerlink\" title=\"简述标记清除算法、标记整理算法和标记复制算法\"></a>简述标记清除算法、标记整理算法和标记复制算法</h3><ul>\n<li> 标记清除算法：先标记需清除的对象，之后统一回收。这种方法效率不高，会产生大量不连续的碎片。</li>\n<li> 标记整理算法：先标记存活对象，然后让所有存活对象向一端移动，之后清理端边界以外的内存</li>\n<li> 标记复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。</li>\n</ul>\n<h3 id=\"简述分代收集算法\"><a href=\"#简述分代收集算法\" class=\"headerlink\" title=\"简述分代收集算法\"></a>简述分代收集算法</h3><p>根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>\n<p>一般将堆分为新生代和老年代，对这两块采用不同的算法。</p>\n<p>新生代使用：标记复制算法</p>\n<p>老年代使用：标记清除或者标记整理算法</p>\n<h3 id=\"简述Serial垃圾收集器\"><a href=\"#简述Serial垃圾收集器\" class=\"headerlink\" title=\"简述Serial垃圾收集器\"></a>简述Serial垃圾收集器</h3><p>Serial垃圾收集器是单线程串行收集器。垃圾回收的时候，必须暂停其他所有线程。新生代使用标记复制算法，老年代使用标记整理算法。简单高效。</p>\n<h3 id=\"简述ParNew垃圾收集器\"><a href=\"#简述ParNew垃圾收集器\" class=\"headerlink\" title=\"简述ParNew垃圾收集器\"></a>简述ParNew垃圾收集器</h3><p>ParNew垃圾收集器可以看作Serial垃圾收集器的多线程版本，新生代使用标记复制算法，老年代使用标记整理算法。</p>\n<h3 id=\"简述Parallel-Scavenge垃圾收集器\"><a href=\"#简述Parallel-Scavenge垃圾收集器\" class=\"headerlink\" title=\"简述Parallel Scavenge垃圾收集器\"></a>简述Parallel Scavenge垃圾收集器</h3><p>注重吞吐量，即 CPU运行代码时间/CPU耗时总时间（CPU运行代码时间+ 垃圾回收时间）。新生代使用标记复制算法，老年代使用标记整理算法。</p>\n<h3 id=\"简述CMS垃圾收集器\"><a href=\"#简述CMS垃圾收集器\" class=\"headerlink\" title=\"简述CMS垃圾收集器\"></a>简述CMS垃圾收集器</h3><p>CMS垃圾收集器注重最短时间停顿。CMS垃圾收集器为最早提出的并发收集器，垃圾收集线程与用户线程同时工作。采用标记清除算法。该收集器分为初始标记、并发标记、并发预清理、并发清除、并发重置这么几个步骤。</p>\n<ul>\n<li> 初始标记：暂停其他线程(stop the world)，标记与GC roots直接关联的对象。</li>\n<li> 并发标记：可达性分析过程(程序不会停顿)。</li>\n<li> 并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象，重新标记，暂停虚拟机（stop the world）扫描CMS堆中剩余对象。</li>\n<li> 并发清除：清理垃圾对象，(程序不会停顿)。</li>\n<li> 并发重置，重置CMS收集器的数据结构。</li>\n</ul>\n<h3 id=\"简述G1垃圾收集器\"><a href=\"#简述G1垃圾收集器\" class=\"headerlink\" title=\"简述G1垃圾收集器\"></a>简述G1垃圾收集器</h3><p>和Serial、Parallel Scavenge、CMS不同，G1垃圾收集器把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。</p>\n<ul>\n<li> 初始标记：标记与GC roots直接关联的对象。</li>\n<li> 并发标记：可达性分析。</li>\n<li> 最终标记：对并发标记过程中，用户线程修改的对象再次标记一下。</li>\n<li> 筛选回收：对各个Region的回收价值和成本进行排序，然后根据用户所期望的GC停顿时间制定回收计划并回收。</li>\n</ul>\n<h3 id=\"简述Minor-GC\"><a href=\"#简述Minor-GC\" class=\"headerlink\" title=\"简述Minor GC\"></a>简述Minor GC</h3><p>Minor GC指发生在新生代的垃圾收集，因为 Java 对象大多存活时间短，所以 Minor GC 非常频繁，一般回收速度也比较快。</p>\n<h3 id=\"简述Full-GC\"><a href=\"#简述Full-GC\" class=\"headerlink\" title=\"简述Full GC\"></a>简述Full GC</h3><p>Full GC 是清理整个堆空间—包括年轻代和永久代。调用System.gc(),老年代空间不足，空间分配担保失败，永生代空间不足会产生full gc。</p>\n<h3 id=\"常见内存分配策略\"><a href=\"#常见内存分配策略\" class=\"headerlink\" title=\"常见内存分配策略\"></a>常见内存分配策略</h3><p>大多数情况下对象在新生代 Eden 区分配，当 Eden 没有足够空间时将发起一次 Minor GC。</p>\n<p>大对象需要大量连续内存空间，直接进入老年代区分配。</p>\n<p>如果经历过第一次 Minor GC 仍然存活且能被 Survivor 容纳，该对象就会被移动到 Survivor 中并将年龄设置为 1，并且每熬过一次 Minor GC 年龄就加 1 ，当增加到一定程度（默认15）就会被晋升到老年代。</p>\n<p>如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 的一半，年龄不小于该年龄的对象就可以直接进入老年代。</p>\n<p>MinorGC 前，虚拟机必须检查老年代最大可用连续空间是否大于新生代对象总空间，如果满足则说明这次 Minor GC 确定安全。如果不，JVM会查看HandlePromotionFailure 参数是否允许担保失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果满足将Minor GC，否则改成一次 FullGC。</p>\n<h3 id=\"简述JVM类加载过程\"><a href=\"#简述JVM类加载过程\" class=\"headerlink\" title=\"简述JVM类加载过程\"></a>简述JVM类加载过程</h3><p>1）加载：</p>\n<ul>\n<li> 通过全类名获取类的二进制字节流。</li>\n<li> 将类的静态存储结构转化为方法区的运行时数据结构。</li>\n<li> 在内存中生成类的Class对象，作为方法区数据的入口。</li>\n</ul>\n<p>2）验证：对文件格式，元数据，字节码，符号引用等验证正确性。</p>\n<p>3）准备：在方法区内为类变量分配内存并设置为0值。</p>\n<p>4）解析：将符号引用转化为直接引用。</p>\n<p>5）初始化：执行类构造器clinit方法，真正初始化。</p>\n<h3 id=\"简述JVM中的类加载器\"><a href=\"#简述JVM中的类加载器\" class=\"headerlink\" title=\"简述JVM中的类加载器\"></a>简述JVM中的类加载器</h3><ul>\n<li> BootstrapClassLoader启动类加载器：加载/lib下的jar包和类。由C++编写。</li>\n<li> ExtensionClassLoader扩展类加载器：/lib/ext目录下的jar包和类。由Java编写。</li>\n<li> AppClassLoader应用类加载器，加载当前classPath下的jar包和类。由Java编写。</li>\n</ul>\n<h3 id=\"简述双亲委派机制\"><a href=\"#简述双亲委派机制\" class=\"headerlink\" title=\"简述双亲委派机制\"></a>简述双亲委派机制</h3><p>一个类加载器收到类加载请求之后，首先判断当前类是否被加载过。已经被加载的类会直接返回，如果没有被加载，首先将类加载请求转发给父类加载器，一直转发到启动类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>\n<p>加载类顺序：BootstrapClassLoader-&gt;ExtensionClassLoader-&gt;AppClassLoader-&gt;CustomClassLoader 检查类是否加载顺序：CustomClassLoader-&gt;AppClassLoader-&gt;ExtensionClassLoader-&gt;BootstrapClassLoader</p>\n<h3 id=\"双亲委派机制的优点\"><a href=\"#双亲委派机制的优点\" class=\"headerlink\" title=\"双亲委派机制的优点\"></a>双亲委派机制的优点</h3><ul>\n<li> 避免类的重复加载。相同的类被不同的类加载器加载会产生不同的类，双亲委派保证了Java程序的稳定运行。</li>\n<li> 保证核心API不被修改。</li>\n<li> 如何破坏双亲委派机制</li>\n<li> 重载loadClass()方法，即自定义类加载器。</li>\n</ul>\n<h3 id=\"如何构建自定义类加载器\"><a href=\"#如何构建自定义类加载器\" class=\"headerlink\" title=\"如何构建自定义类加载器\"></a>如何构建自定义类加载器</h3><p>新建自定义类继承自java.lang.ClassLoader，重写findClass、loadClass、defineClass方法</p>\n<h3 id=\"JVM常见调优参数\"><a href=\"#JVM常见调优参数\" class=\"headerlink\" title=\"JVM常见调优参数\"></a>JVM常见调优参数</h3><ul>\n<li> -Xms 初始堆大小</li>\n<li> -Xmx 最大堆大小</li>\n<li> -XX:NewSize 年轻代大小</li>\n<li> -XX:MaxNewSize 年轻代最大值</li>\n<li> -XX:PermSize 永生代初始值</li>\n<li> -XX:MaxPermSize 永生代最大值</li>\n<li> -XX:NewRatio 新生代与老年代的比例</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<h3 id=\"简述JVM内存模型\"><a href=\"#简述JVM内存模型\" class=\"headerlink\" title=\"简述JVM内存模型\"></a>简述JVM内存模型</h3><p>线程私有的运行时数据区: 程序计数器、Java 虚拟机栈、本地方法栈。</p>\n<p>线程共享的运行时数据区：Java 堆、方法区。</p>\n<h3 id=\"简述程序计数器\"><a href=\"#简述程序计数器\" class=\"headerlink\" title=\"简述程序计数器\"></a>简述程序计数器</h3><p>程序计数器表示当前线程所执行的字节码的行号指示器。</p>\n<p>程序计数器不会产生StackOverflowError和OutOfMemoryError。</p>\n<h3 id=\"简述虚拟机栈\"><a href=\"#简述虚拟机栈\" class=\"headerlink\" title=\"简述虚拟机栈\"></a>简述虚拟机栈</h3><p>Java 虚拟机栈用来描述 Java 方法执行的内存模型。线程创建时就会分配一个栈空间，线程结束后栈空间被回收。</p>\n<p>栈中元素用于支持虚拟机进行方法调用，每个方法在执行时都会创建一个栈帧存储方法的局部变量表、操作栈、动态链接和返回地址等信息。</p>\n<p>虚拟机栈会产生两类异常：</p>\n<ul>\n<li> StackOverflowError：线程请求的栈深度大于虚拟机允许的深度抛出。</li>\n<li> OutOfMemoryError：如果 JVM 栈容量可以动态扩展，虚拟机栈占用内存超出抛出。</li>\n</ul>\n<h3 id=\"简述本地方法栈\"><a href=\"#简述本地方法栈\" class=\"headerlink\" title=\"简述本地方法栈\"></a>简述本地方法栈</h3><p>本地方法栈与虚拟机栈作用相似，不同的是虚拟机栈为虚拟机执行 Java 方法服务，本地方法栈为本地方法服务。可以将虚拟机栈看作普通的java函数对应的内存模型，本地方法栈看作由native关键词修饰的函数对应的内存模型。</p>\n<p>本地方法栈会产生两类异常：</p>\n<ul>\n<li> StackOverflowError：线程请求的栈深度大于虚拟机允许的深度抛出。</li>\n<li> OutOfMemoryError：如果 JVM 栈容量可以动态扩展，虚拟机栈占用内存超出抛出。</li>\n</ul>\n<h3 id=\"简述JVM中的堆\"><a href=\"#简述JVM中的堆\" class=\"headerlink\" title=\"简述JVM中的堆\"></a>简述JVM中的堆</h3><p>堆主要作用是存放对象实例，Java 里几乎所有对象实例都在堆上分配内存，堆也是内存管理中最大的一块。Java的垃圾回收主要就是针对堆这一区域进行。可通过 -Xms 和 -Xmx 设置堆的最小和最大容量。</p>\n<p>堆会抛出 OutOfMemoryError异常。</p>\n<h3 id=\"简述方法区\"><a href=\"#简述方法区\" class=\"headerlink\" title=\"简述方法区\"></a>简述方法区</h3><p>方法区用于存储被虚拟机加载的类信息、常量、静态变量等数据。</p>\n<p>JDK6之前使用永久代实现方法区，容易内存溢出。JDK7 把放在永久代的字符串常量池、静态变量等移出，JDK8 中抛弃永久代，改用在本地内存中实现的元空间来实现方法区，把 JDK 7 中永久代内容移到元空间。</p>\n<p>方法区会抛出 OutOfMemoryError异常。</p>\n<h3 id=\"简述运行时常量池\"><a href=\"#简述运行时常量池\" class=\"headerlink\" title=\"简述运行时常量池\"></a>简述运行时常量池</h3><p>运行时常量池存放常量池表，用于存放编译器生成的各种字面量与符号引用。一般除了保存 Class 文件中描述的符号引用外，还会把符号引用翻译的直接引用也存储在运行时常量池。除此之外，也会存放字符串基本类型。</p>\n<p>JDK8之前，放在方法区，大小受限于方法区。JDK8将运行时常量池存放堆中。</p>\n<h3 id=\"简述直接内存\"><a href=\"#简述直接内存\" class=\"headerlink\" title=\"简述直接内存\"></a>简述直接内存</h3><p>直接内存也称为堆外内存，就是把内存对象分配在JVM堆外的内存区域。这部分内存不是虚拟机管理，而是由操作系统来管理。Java通过DriectByteBuffer对其进行操作，避免了在 Java 堆和 Native堆来回复制数据。</p>\n<h3 id=\"简述Java创建对象的过程\"><a href=\"#简述Java创建对象的过程\" class=\"headerlink\" title=\"简述Java创建对象的过程\"></a>简述Java创建对象的过程</h3><ul>\n<li> 检查该指令的参数能否在常量池中定位到一个类的符号引用，并检查引用代表的类是否已被加载、解析和初始化，如果没有就先执行类加载。</li>\n<li> 通过检查通过后虚拟机将为新生对象分配内存。</li>\n<li> 完成内存分配后虚拟机将成员变量设为零值</li>\n<li> 设置对象头，包括哈希码、GC 信息、锁信息、对象所属类的类元信息等。</li>\n<li> 执行 init 方法，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</li>\n</ul>\n<h3 id=\"简述JVM给对象分配内存的策略\"><a href=\"#简述JVM给对象分配内存的策略\" class=\"headerlink\" title=\"简述JVM给对象分配内存的策略\"></a>简述JVM给对象分配内存的策略</h3><ul>\n<li> 指针碰撞：这种方式在内存中放一个指针作为分界指示器将使用过的内存放在一边，空闲的放在另一边，通过指针挪动完成分配。</li>\n<li> 空闲列表：对于 Java 堆内存不规整的情况，虚拟机必须维护一个列表记录哪些内存可用，在分配时从列表中找到一块足够大的空间划分给对象并更新列表记录。</li>\n</ul>\n<h3 id=\"Java对象内存分配是如何保证线程安全的\"><a href=\"#Java对象内存分配是如何保证线程安全的\" class=\"headerlink\" title=\"Java对象内存分配是如何保证线程安全的\"></a>Java对象内存分配是如何保证线程安全的</h3><p>第一种方法，采用CAS机制，配合失败重试的方式保证更新操作的原子性。该方式效率低。</p>\n<p>第二种方法，每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配。一般采用这种策略。</p>\n<h3 id=\"简述对象的内存布局\"><a href=\"#简述对象的内存布局\" class=\"headerlink\" title=\"简述对象的内存布局\"></a>简述对象的内存布局</h3><p>对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。</p>\n<p>1）对象头主要包含两部分数据：MarkWord、类型指针。</p>\n<p>MarkWord 用于存储哈希码（HashCode）、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID等信息。</p>\n<p>类型指针即对象指向他的类元数据指针，如果对象是一个 Java 数组，会有一块用于记录数组长度的数据。</p>\n<p>2）实例数据存储代码中所定义的各种类型的字段信息。</p>\n<p>3）对齐填充起占位作用。HotSpot 虚拟机要求对象的起始地址必须是8的整数倍，因此需要对齐填充。</p>\n<h3 id=\"如何判断对象是否是垃圾\"><a href=\"#如何判断对象是否是垃圾\" class=\"headerlink\" title=\"如何判断对象是否是垃圾\"></a>如何判断对象是否是垃圾</h3><p>1）引用计数法：</p>\n<p>设置引用计数器，对象被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。会存在对象间循环引用的问题，一般不使用这种方法。</p>\n<p>2）可达性分析：</p>\n<p>通过 GC Roots 的根对象作为起始节点，从这些节点开始，根据引用关系向下搜索，如果某个对象没有被搜到，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。</p>\n<h3 id=\"简述java的引用类型\"><a href=\"#简述java的引用类型\" class=\"headerlink\" title=\"简述java的引用类型\"></a>简述java的引用类型</h3><ul>\n<li> 强引用：被强引用关联的对象不会被回收。一般采用 new 方法创建强引用。</li>\n<li> 软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。一般采用 SoftReference 类来创建软引用。</li>\n<li> 弱引用：垃圾收集器碰到即回收，也就是说它只能存活到下一次垃圾回收发生之前。一般采用 WeakReference 类来创建弱引用。</li>\n<li> 虚引用：无法通过该引用获取对象。唯一目的就是为了能在对象被回收时收到一个系统通知。虚引用必须与引用队列联合使用。</li>\n</ul>\n<h3 id=\"简述标记清除算法、标记整理算法和标记复制算法\"><a href=\"#简述标记清除算法、标记整理算法和标记复制算法\" class=\"headerlink\" title=\"简述标记清除算法、标记整理算法和标记复制算法\"></a>简述标记清除算法、标记整理算法和标记复制算法</h3><ul>\n<li> 标记清除算法：先标记需清除的对象，之后统一回收。这种方法效率不高，会产生大量不连续的碎片。</li>\n<li> 标记整理算法：先标记存活对象，然后让所有存活对象向一端移动，之后清理端边界以外的内存</li>\n<li> 标记复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。</li>\n</ul>\n<h3 id=\"简述分代收集算法\"><a href=\"#简述分代收集算法\" class=\"headerlink\" title=\"简述分代收集算法\"></a>简述分代收集算法</h3><p>根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>\n<p>一般将堆分为新生代和老年代，对这两块采用不同的算法。</p>\n<p>新生代使用：标记复制算法</p>\n<p>老年代使用：标记清除或者标记整理算法</p>\n<h3 id=\"简述Serial垃圾收集器\"><a href=\"#简述Serial垃圾收集器\" class=\"headerlink\" title=\"简述Serial垃圾收集器\"></a>简述Serial垃圾收集器</h3><p>Serial垃圾收集器是单线程串行收集器。垃圾回收的时候，必须暂停其他所有线程。新生代使用标记复制算法，老年代使用标记整理算法。简单高效。</p>\n<h3 id=\"简述ParNew垃圾收集器\"><a href=\"#简述ParNew垃圾收集器\" class=\"headerlink\" title=\"简述ParNew垃圾收集器\"></a>简述ParNew垃圾收集器</h3><p>ParNew垃圾收集器可以看作Serial垃圾收集器的多线程版本，新生代使用标记复制算法，老年代使用标记整理算法。</p>\n<h3 id=\"简述Parallel-Scavenge垃圾收集器\"><a href=\"#简述Parallel-Scavenge垃圾收集器\" class=\"headerlink\" title=\"简述Parallel Scavenge垃圾收集器\"></a>简述Parallel Scavenge垃圾收集器</h3><p>注重吞吐量，即 CPU运行代码时间/CPU耗时总时间（CPU运行代码时间+ 垃圾回收时间）。新生代使用标记复制算法，老年代使用标记整理算法。</p>\n<h3 id=\"简述CMS垃圾收集器\"><a href=\"#简述CMS垃圾收集器\" class=\"headerlink\" title=\"简述CMS垃圾收集器\"></a>简述CMS垃圾收集器</h3><p>CMS垃圾收集器注重最短时间停顿。CMS垃圾收集器为最早提出的并发收集器，垃圾收集线程与用户线程同时工作。采用标记清除算法。该收集器分为初始标记、并发标记、并发预清理、并发清除、并发重置这么几个步骤。</p>\n<ul>\n<li> 初始标记：暂停其他线程(stop the world)，标记与GC roots直接关联的对象。</li>\n<li> 并发标记：可达性分析过程(程序不会停顿)。</li>\n<li> 并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象，重新标记，暂停虚拟机（stop the world）扫描CMS堆中剩余对象。</li>\n<li> 并发清除：清理垃圾对象，(程序不会停顿)。</li>\n<li> 并发重置，重置CMS收集器的数据结构。</li>\n</ul>\n<h3 id=\"简述G1垃圾收集器\"><a href=\"#简述G1垃圾收集器\" class=\"headerlink\" title=\"简述G1垃圾收集器\"></a>简述G1垃圾收集器</h3><p>和Serial、Parallel Scavenge、CMS不同，G1垃圾收集器把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。</p>\n<ul>\n<li> 初始标记：标记与GC roots直接关联的对象。</li>\n<li> 并发标记：可达性分析。</li>\n<li> 最终标记：对并发标记过程中，用户线程修改的对象再次标记一下。</li>\n<li> 筛选回收：对各个Region的回收价值和成本进行排序，然后根据用户所期望的GC停顿时间制定回收计划并回收。</li>\n</ul>\n<h3 id=\"简述Minor-GC\"><a href=\"#简述Minor-GC\" class=\"headerlink\" title=\"简述Minor GC\"></a>简述Minor GC</h3><p>Minor GC指发生在新生代的垃圾收集，因为 Java 对象大多存活时间短，所以 Minor GC 非常频繁，一般回收速度也比较快。</p>\n<h3 id=\"简述Full-GC\"><a href=\"#简述Full-GC\" class=\"headerlink\" title=\"简述Full GC\"></a>简述Full GC</h3><p>Full GC 是清理整个堆空间—包括年轻代和永久代。调用System.gc(),老年代空间不足，空间分配担保失败，永生代空间不足会产生full gc。</p>\n<h3 id=\"常见内存分配策略\"><a href=\"#常见内存分配策略\" class=\"headerlink\" title=\"常见内存分配策略\"></a>常见内存分配策略</h3><p>大多数情况下对象在新生代 Eden 区分配，当 Eden 没有足够空间时将发起一次 Minor GC。</p>\n<p>大对象需要大量连续内存空间，直接进入老年代区分配。</p>\n<p>如果经历过第一次 Minor GC 仍然存活且能被 Survivor 容纳，该对象就会被移动到 Survivor 中并将年龄设置为 1，并且每熬过一次 Minor GC 年龄就加 1 ，当增加到一定程度（默认15）就会被晋升到老年代。</p>\n<p>如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 的一半，年龄不小于该年龄的对象就可以直接进入老年代。</p>\n<p>MinorGC 前，虚拟机必须检查老年代最大可用连续空间是否大于新生代对象总空间，如果满足则说明这次 Minor GC 确定安全。如果不，JVM会查看HandlePromotionFailure 参数是否允许担保失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果满足将Minor GC，否则改成一次 FullGC。</p>\n<h3 id=\"简述JVM类加载过程\"><a href=\"#简述JVM类加载过程\" class=\"headerlink\" title=\"简述JVM类加载过程\"></a>简述JVM类加载过程</h3><p>1）加载：</p>\n<ul>\n<li> 通过全类名获取类的二进制字节流。</li>\n<li> 将类的静态存储结构转化为方法区的运行时数据结构。</li>\n<li> 在内存中生成类的Class对象，作为方法区数据的入口。</li>\n</ul>\n<p>2）验证：对文件格式，元数据，字节码，符号引用等验证正确性。</p>\n<p>3）准备：在方法区内为类变量分配内存并设置为0值。</p>\n<p>4）解析：将符号引用转化为直接引用。</p>\n<p>5）初始化：执行类构造器clinit方法，真正初始化。</p>\n<h3 id=\"简述JVM中的类加载器\"><a href=\"#简述JVM中的类加载器\" class=\"headerlink\" title=\"简述JVM中的类加载器\"></a>简述JVM中的类加载器</h3><ul>\n<li> BootstrapClassLoader启动类加载器：加载/lib下的jar包和类。由C++编写。</li>\n<li> ExtensionClassLoader扩展类加载器：/lib/ext目录下的jar包和类。由Java编写。</li>\n<li> AppClassLoader应用类加载器，加载当前classPath下的jar包和类。由Java编写。</li>\n</ul>\n<h3 id=\"简述双亲委派机制\"><a href=\"#简述双亲委派机制\" class=\"headerlink\" title=\"简述双亲委派机制\"></a>简述双亲委派机制</h3><p>一个类加载器收到类加载请求之后，首先判断当前类是否被加载过。已经被加载的类会直接返回，如果没有被加载，首先将类加载请求转发给父类加载器，一直转发到启动类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>\n<p>加载类顺序：BootstrapClassLoader-&gt;ExtensionClassLoader-&gt;AppClassLoader-&gt;CustomClassLoader 检查类是否加载顺序：CustomClassLoader-&gt;AppClassLoader-&gt;ExtensionClassLoader-&gt;BootstrapClassLoader</p>\n<h3 id=\"双亲委派机制的优点\"><a href=\"#双亲委派机制的优点\" class=\"headerlink\" title=\"双亲委派机制的优点\"></a>双亲委派机制的优点</h3><ul>\n<li> 避免类的重复加载。相同的类被不同的类加载器加载会产生不同的类，双亲委派保证了Java程序的稳定运行。</li>\n<li> 保证核心API不被修改。</li>\n<li> 如何破坏双亲委派机制</li>\n<li> 重载loadClass()方法，即自定义类加载器。</li>\n</ul>\n<h3 id=\"如何构建自定义类加载器\"><a href=\"#如何构建自定义类加载器\" class=\"headerlink\" title=\"如何构建自定义类加载器\"></a>如何构建自定义类加载器</h3><p>新建自定义类继承自java.lang.ClassLoader，重写findClass、loadClass、defineClass方法</p>\n<h3 id=\"JVM常见调优参数\"><a href=\"#JVM常见调优参数\" class=\"headerlink\" title=\"JVM常见调优参数\"></a>JVM常见调优参数</h3><ul>\n<li> -Xms 初始堆大小</li>\n<li> -Xmx 最大堆大小</li>\n<li> -XX:NewSize 年轻代大小</li>\n<li> -XX:MaxNewSize 年轻代最大值</li>\n<li> -XX:PermSize 永生代初始值</li>\n<li> -XX:MaxPermSize 永生代最大值</li>\n<li> -XX:NewRatio 新生代与老年代的比例</li>\n</ul>\n"},{"title":"SQL语句性能优化策略","top":false,"cover":false,"toc":false,"mathjax":true,"date":"2022-11-04T05:41:23.000Z","password":null,"summary":"全面揭秘SQL语句性能优化策略","_content":"\n- 前言 -\n\n  \n\n\n本文将全面揭秘 SQL 语句性能优化策略，直接上干货！\n\n  \n\n- 52 条 SQL 语句性能优化策略 \\-\n\n  \n\n\n1、对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。\n\n  \n\n\n2、应尽量避免在where子句中对字段进行null值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默认值。\n\n  \n\n\n3、应尽量避免在where子句中使用!=或<>操作符，MySQL只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE。\n\n  \n\n\n4、应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用UNION合并查询：select id from t where num=10 union all select id from t where num=20。\n\n  \n\n\n5、in和not in也要慎用，否则会导致全表扫描，对于连续的数值，能用between就不要用in了：Select id from t where num between 1 and 3。\n\n  \n\n\n6、下面的查询也将导致全表扫描：select id from t where name like‘%abc%’或者select id from t where name like‘%abc’若要提高效率，可以考虑全文检索。而select id from t where name like‘abc%’才用到索引。\n\n  \n\n\n7、如果在where子句中使用参数，也会导致全表扫描。\n\n  \n\n\n8、应尽量避免在where子句中对字段进行表达式操作，应尽量避免在where子句中对字段进行函数操作。\n\n  \n\n\n9、很多时候用exists代替in是一个好的选择：select num from a where num in(select num from b)。用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)。\n\n  \n\n\n10、索引固然可以提高相应的select的效率，但同时也降低了insert及update的效率，因为insert或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。\n\n  \n\n\n11、应尽可能的避免更新clustered索引数据列， 因为clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新clustered索引数据列，那么需要考虑是否应将该索引建为clustered索引。\n\n  \n\n\n12、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。\n\n  \n\n\n13、尽可能的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。\n\n  \n\n\n14、最好不要使用”“返回所有：select from t ，用具体的字段列表代替“\\*”，不要返回用不到的任何字段。\n\n  \n\n\n15、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。\n\n  \n\n\n16、使用表的别名(Alias)：当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个Column上。这样一来，就可以减少解析的时间并减少那些由Column歧义引起的语法错误。\n\n  \n\n\n17、使用“临时表”暂存中间结果 ：\n\n  \n\n\n简化SQL语句的重要方法就是采用临时表暂存中间结果，但是临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。\n\n  \n\n\n18、一些SQL查询语句应加上nolock，读、写是会相互阻塞的，为了提高并发性能，对于一些查询，可以加上nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。\n\n  \n\n\n使用nolock有3条原则：\n\n  \n\n\n *  查询的结果用于“插、删、改”的不能加nolock；\n *  查询的表属于频繁发生页分裂的，慎用nolock ；\n *  使用临时表一样可以保存“数据前影”，起到类似Oracle的undo表空间的功能，能采用临时表提高并发性能的，不要用nolock。\n\n  \n\n\n19、常见的简化规则如下：\n\n  \n\n\n不要有超过5个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。少用子查询，视图嵌套不要过深，一般视图嵌套不要超过2个为宜。\n\n  \n\n\n20、将需要查询的结果预先计算好放在表中，查询的时候再Select。这在SQL7.0以前是最重要的手段，例如医院的住院费计算。\n\n  \n\n\n21、用OR的字句可以分解成多个查询，并且通过UNION 连接多个查询。他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用UNION all执行的效率更高。多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。\n\n  \n\n\n22、在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。\n\n  \n\n\n23、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。\n\n  \n\n\n存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL，可以使用临时存储过程，该过程（临时表）被放在Tempdb中。\n\n  \n\n\n24、当服务器的内存够多时，配制线程数量 = 最大连接数+5，这样能发挥最大的效率；否则使用 配制线程数量<最大连接数启用SQL SERVER的线程池来解决，如果还是数量 = 最大连接数+5，严重的损害服务器的性能。\n\n  \n\n\n25、查询的关联同写的顺序 ：\n\n  \n\n\n  \n\n\nselect a.personMemberID, \\* from chineseresume a,personmember b where personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ （A = B ,B = ‘号码’） \n\n  \n\n\nselect a.personMemberID, \\* from chineseresume a,personmember b where a.personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ and b.referenceid = ‘JCNPRH39681’ （A = B ,B = ‘号码’， A = ‘号码’） \n\n  \n\n\nselect a.personMemberID, \\* from chineseresume a,personmember b where b.referenceid = ‘JCNPRH39681’ and a.personMemberID = ‘JCNPRH39681’ （B = ‘号码’， A = ‘号码’）\n\n  \n\n\n26、尽量使用exists代替select count(1)来判断是否存在记录，count函数只有在统计表中所有行数时使用，而且count(1)比count(\\*)更有效率。  \n\n\n  \n\n\n27、尽量使用“>=”，不要使用“>”。\n\n  \n\n\n28、索引的使用规范：\n\n  \n\n\n *  索引的创建要与应用结合考虑，建议大的OLTP表不要超过6个索引；\n *  尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index\\_name来强制指定索引；\n *  避免对大表查询时进行table scan，必要时考虑新建索引；\n *  在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用；\n *  要注意索引的维护，周期性重建索引，重新编译存储过程。　　\n\n  \n\n\n  \n\n\n29、下列SQL条件语句中的列都建有恰当的索引，但执行速度却非常慢： \n\n  \n\n\n  \n\n\nSELECT \\* FROM record WHERE substrINg(card\\_no,1,4)=’5378’ (13秒) \n\n  \n\n\nSELECT \\* FROM record WHERE amount/30< 1000 （11秒） \n\n  \n\n\nSELECT \\* FROM record WHERE convert(char(10),date,112)=’19991201’ （10秒） \n\n  \n\n\n分析： \n\nWHERE子句中对列的任何操作结果都是在SQL运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引。\n\n  \n\n\n  \n\n\n如果这些结果在查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免表搜索，因此将SQL重写成下面这样： \n\n  \n\n\n  \n\n\nSELECT \\* FROM record WHERE card\\_no like ‘5378%’ （< 1秒） \n\n  \n\n\nSELECT \\* FROM record WHERE amount< 1000\\*30 （< 1秒） \n\n  \n\n\nSELECT \\* FROM record WHERE date= ‘1999/12/01’ （< 1秒）\n\n  \n\n\n30、当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新。  \n\n\n  \n\n\n31、在所有的存储过程中，能够用SQL语句的，我绝不会用循环去实现。\n\n例如：列出上个月的每一天，我会用connect by去递归查询一下，绝不会去用循环从上个月第一天到最后一天。\n\n  \n\n\n32、选择最有效率的表名顺序（只在基于规则的优化器中有效）： \n\nOracle的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表（基础表 driving table）将被最先处理，在FROM子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。\n\n  \n\n\n如果有3个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表。\n\n  \n\n\n33、提高GROUP BY语句的效率，可以通过将不需要的记录在GROUP BY之前过滤掉。下面两个查询返回相同结果，但第二个明显就快了许多。 \n\n  \n\n\n低效：\n\n  \n\n\nSELECT JOB , AVG(SAL) \n\nFROM EMP \n\nGROUP BY JOB \n\nHAVING JOB =’PRESIDENT’ \n\nOR JOB =’MANAGER’ \n\n  \n\n\n高效: \n\n  \n\n\nSELECT JOB , AVG(SAL) \n\nFROM EMP \n\nWHERE JOB =’PRESIDENT’ \n\nOR JOB =’MANAGER’ \n\nGROUP BY JOB\n\n  \n\n\n34、SQL语句用大写，因为Oracle总是先解析SQL语句，把小写的字母转换成大写的再执行。  \n\n\n  \n\n\n35、别名的使用，别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询速度要比建连接表快1.5倍。\n\n  \n\n\n36、避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序；事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量；永远不要在事务中等待用户输入。\n\n  \n\n\n37、避免使用临时表，除非却有需要，否则应尽量避免使用临时表，相反，可以使用表变量代替；大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在TempDb数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。\n\n  \n\n\n38、最好不要使用触发器：\n\n  \n\n\n *  触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程；\n *  如果能够使用约束实现的，尽量不要使用触发器；\n *  不要为不同的触发事件(Insert，Update和Delete)使用相同的触发器；\n *  不要在触发器中使用事务型代码。\n\n  \n\n\n39、索引创建规则： \n\n  \n\n\n *  表的主键、外键必须有索引； \n *  数据量超过300的表应该有索引； \n *  经常与其他表进行连接的表，在连接字段上应该建立索引； \n *  经常出现在Where子句中的字段，特别是大表的字段，应该建立索引； \n *  索引应该建在选择性高的字段上； \n *  索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； \n *  复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替； \n *  正确选择复合索引中的主列字段，一般是选择性较好的字段； \n *  复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引； \n *  如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引； \n *  如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段； \n *  如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引； \n *  频繁进行数据操作的表，不要建立太多的索引； \n *  删除无用的索引，避免对执行计划造成负面影响； \n *  表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。 \n *  尽量不要对数据库中某个含有大量重复的值的字段建立索引。\n\n  \n\n\n40、MySQL查询优化总结：\n\n  \n\n\n使用慢查询日志去发现慢查询，使用执行计划去判断查询是否正常运行，总是去测试你的查询看看是否他们运行在最佳状态下。\n\n  \n\n\n久而久之性能总会变化，避免在整个表上使用count(\\*)，它可能锁住整张表，使查询保持一致以便后续相似的查询可以使用查询缓存，在适当的情形下使用GROUP BY而不是DISTINCT，在WHERE、GROUP BY和ORDER BY子句中使用有索引的列，保持索引简单，不在多个索引中包含同一个列。\n\n  \n\n\n有时候MySQL会使用错误的索引，对于这种情况使用USE INDEX，检查使用SQL\\_MODE=STRICT的问题，对于记录数小于5的索引字段，在UNION的时候使用LIMIT不是是用OR。 \n\n  \n\n\n为了避免在更新前SELECT，使用INSERT ON DUPLICATE KEY或者INSERT IGNORE，不要用UPDATE去实现，不要使用MAX，使用索引字段和ORDER BY子句，LIMIT M，N实际上可以减缓查询在某些情况下，有节制地使用，在WHERE子句中使用UNION代替子查询，在重新启动的MySQL，记得来温暖你的数据库，以确保数据在内存和查询速度快，考虑持久连接，而不是多个连接，以减少开销。\n\n  \n\n\n基准查询，包括使用服务器上的负载，有时一个简单的查询可以影响其他查询，当负载增加在服务器上，使用SHOW PROCESSLIST查看慢的和有问题的查询，在开发环境中产生的镜像数据中测试的所有可疑的查询。\n\n  \n\n\n41、MySQL备份过程：\n\n  \n\n\n *  从二级复制服务器上进行备份；\n *  在进行备份期间停止复制，以避免在数据依赖和外键约束上出现不一致；\n *  彻底停止MySQL，从数据库文件进行备份；\n *  如果使用MySQL dump进行备份，请同时备份二进制日志文件 – 确保复制没有中断；\n *  不要信任LVM快照，这很可能产生数据不一致，将来会给你带来麻烦；\n *  为了更容易进行单表恢复，以表为单位导出数据——如果数据是与其他表隔离的。 \n *  当使用mysqldump时请使用–opt；\n *  在备份之前检查和优化表；\n *  为了更快的进行导入，在导入时临时禁用外键约束。；\n *  为了更快的进行导入，在导入时临时禁用唯一性检测；\n *  在每一次备份后计算数据库，表以及索引的尺寸，以便更够监控数据尺寸的增长；\n *  通过自动调度脚本监控复制实例的错误和延迟；\n *  定期执行备份。\n\n  \n\n\n42、查询缓冲并不自动处理空格，因此，在写SQL语句时，应尽量减少空格的使用，尤其是在SQL首和尾的空格（因为查询缓冲并不自动截取首尾空格）。\n\n  \n\n\n43、member用mid做标准进行分表方便查询么？一般的业务需求中基本上都是以username为查询依据，正常应当是username做hash取模来分表。\n\n  \n\n\n而分表的话MySQL的partition功能就是干这个的，对代码是透明的；在代码层面去实现貌似是不合理的。\n\n  \n\n\n44、我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO\\_INCREMENT标志。\n\n  \n\n\n45、在所有的存储过程和触发器的开始处设置SET NOCOUNT ON，在结束时设置SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后向客户端发送DONE\\_IN\\_PROC消息。\n\n  \n\n\n46、MySQL查询可以启用高速查询缓存。这是提高数据库性能的有效MySQL优化方法之一。当同一个查询被执行多次时，从缓存中提取数据和直接从数据库中返回数据快很多。\n\n  \n\n\n47、EXPLAIN SELECT查询用来跟踪查看效果：\n\n  \n\n\n使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的。\n\n  \n\n\n48、当只要一行数据时使用LIMIT 1 ：\n\n  \n\n\n当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。\n\n  \n\n\n在这种情况下，加上LIMIT 1可以增加性能。这样一来，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。\n\n  \n\n\n49、选择表合适存储引擎： \n\n  \n\n\n *  myisam：应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。 \n *  InnoDB：事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（InnoDB有效地降低删除和更新导致的锁定）。\n    \n    对于支持事务的InnoDB类型的表来说，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行SQL前调用begin，多条SQL形成一个事物（即使autocommit打开也可以），将大大提高性能。\n\n  \n\n\n50、优化表的数据类型，选择合适的数据类型： \n\n  \n\n\n原则：更小通常更好，简单就好，所有字段都得有默认值，尽量避免null。 \n\n  \n\n\n例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型。(mediumint就比int更合适) \n\n  \n\n\n比如时间字段：datetime和timestamp，datetime占用8个字节，而timestamp占用4个字节，只用了一半，而timestamp表示的范围是1970—2037适合做更新时间 \n\n  \n\n\nMySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。 \n\n  \n\n\n因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。\n\n  \n\n\n例如：在定义邮政编码这个字段时，如果将其设置为CHAR(255)，显然给数据库增加了不必要的空间。甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。\n\n  \n\n\n同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段，应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。 \n\n  \n\n\n对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。\n\n  \n\n\n51、字符串数据类型：char，varchar，text选择区别。\n\n  \n\n\n52、任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。\n\n  \n","source":"_posts/SQL语句性能优化策略.md","raw":"---\ntitle: SQL语句性能优化策略\ntop: false\ncover: false\ntoc: false\nmathjax: true\ndate: 2022-11-04 13:41:23\npassword:\nsummary: 全面揭秘SQL语句性能优化策略\ntags:\n    - sql优化\ncategories:\n    - 技巧\n---\n\n- 前言 -\n\n  \n\n\n本文将全面揭秘 SQL 语句性能优化策略，直接上干货！\n\n  \n\n- 52 条 SQL 语句性能优化策略 \\-\n\n  \n\n\n1、对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。\n\n  \n\n\n2、应尽量避免在where子句中对字段进行null值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默认值。\n\n  \n\n\n3、应尽量避免在where子句中使用!=或<>操作符，MySQL只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE。\n\n  \n\n\n4、应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用UNION合并查询：select id from t where num=10 union all select id from t where num=20。\n\n  \n\n\n5、in和not in也要慎用，否则会导致全表扫描，对于连续的数值，能用between就不要用in了：Select id from t where num between 1 and 3。\n\n  \n\n\n6、下面的查询也将导致全表扫描：select id from t where name like‘%abc%’或者select id from t where name like‘%abc’若要提高效率，可以考虑全文检索。而select id from t where name like‘abc%’才用到索引。\n\n  \n\n\n7、如果在where子句中使用参数，也会导致全表扫描。\n\n  \n\n\n8、应尽量避免在where子句中对字段进行表达式操作，应尽量避免在where子句中对字段进行函数操作。\n\n  \n\n\n9、很多时候用exists代替in是一个好的选择：select num from a where num in(select num from b)。用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)。\n\n  \n\n\n10、索引固然可以提高相应的select的效率，但同时也降低了insert及update的效率，因为insert或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。\n\n  \n\n\n11、应尽可能的避免更新clustered索引数据列， 因为clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新clustered索引数据列，那么需要考虑是否应将该索引建为clustered索引。\n\n  \n\n\n12、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。\n\n  \n\n\n13、尽可能的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。\n\n  \n\n\n14、最好不要使用”“返回所有：select from t ，用具体的字段列表代替“\\*”，不要返回用不到的任何字段。\n\n  \n\n\n15、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。\n\n  \n\n\n16、使用表的别名(Alias)：当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个Column上。这样一来，就可以减少解析的时间并减少那些由Column歧义引起的语法错误。\n\n  \n\n\n17、使用“临时表”暂存中间结果 ：\n\n  \n\n\n简化SQL语句的重要方法就是采用临时表暂存中间结果，但是临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。\n\n  \n\n\n18、一些SQL查询语句应加上nolock，读、写是会相互阻塞的，为了提高并发性能，对于一些查询，可以加上nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。\n\n  \n\n\n使用nolock有3条原则：\n\n  \n\n\n *  查询的结果用于“插、删、改”的不能加nolock；\n *  查询的表属于频繁发生页分裂的，慎用nolock ；\n *  使用临时表一样可以保存“数据前影”，起到类似Oracle的undo表空间的功能，能采用临时表提高并发性能的，不要用nolock。\n\n  \n\n\n19、常见的简化规则如下：\n\n  \n\n\n不要有超过5个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。少用子查询，视图嵌套不要过深，一般视图嵌套不要超过2个为宜。\n\n  \n\n\n20、将需要查询的结果预先计算好放在表中，查询的时候再Select。这在SQL7.0以前是最重要的手段，例如医院的住院费计算。\n\n  \n\n\n21、用OR的字句可以分解成多个查询，并且通过UNION 连接多个查询。他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用UNION all执行的效率更高。多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。\n\n  \n\n\n22、在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。\n\n  \n\n\n23、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。\n\n  \n\n\n存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL，可以使用临时存储过程，该过程（临时表）被放在Tempdb中。\n\n  \n\n\n24、当服务器的内存够多时，配制线程数量 = 最大连接数+5，这样能发挥最大的效率；否则使用 配制线程数量<最大连接数启用SQL SERVER的线程池来解决，如果还是数量 = 最大连接数+5，严重的损害服务器的性能。\n\n  \n\n\n25、查询的关联同写的顺序 ：\n\n  \n\n\n  \n\n\nselect a.personMemberID, \\* from chineseresume a,personmember b where personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ （A = B ,B = ‘号码’） \n\n  \n\n\nselect a.personMemberID, \\* from chineseresume a,personmember b where a.personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ and b.referenceid = ‘JCNPRH39681’ （A = B ,B = ‘号码’， A = ‘号码’） \n\n  \n\n\nselect a.personMemberID, \\* from chineseresume a,personmember b where b.referenceid = ‘JCNPRH39681’ and a.personMemberID = ‘JCNPRH39681’ （B = ‘号码’， A = ‘号码’）\n\n  \n\n\n26、尽量使用exists代替select count(1)来判断是否存在记录，count函数只有在统计表中所有行数时使用，而且count(1)比count(\\*)更有效率。  \n\n\n  \n\n\n27、尽量使用“>=”，不要使用“>”。\n\n  \n\n\n28、索引的使用规范：\n\n  \n\n\n *  索引的创建要与应用结合考虑，建议大的OLTP表不要超过6个索引；\n *  尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index\\_name来强制指定索引；\n *  避免对大表查询时进行table scan，必要时考虑新建索引；\n *  在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用；\n *  要注意索引的维护，周期性重建索引，重新编译存储过程。　　\n\n  \n\n\n  \n\n\n29、下列SQL条件语句中的列都建有恰当的索引，但执行速度却非常慢： \n\n  \n\n\n  \n\n\nSELECT \\* FROM record WHERE substrINg(card\\_no,1,4)=’5378’ (13秒) \n\n  \n\n\nSELECT \\* FROM record WHERE amount/30< 1000 （11秒） \n\n  \n\n\nSELECT \\* FROM record WHERE convert(char(10),date,112)=’19991201’ （10秒） \n\n  \n\n\n分析： \n\nWHERE子句中对列的任何操作结果都是在SQL运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引。\n\n  \n\n\n  \n\n\n如果这些结果在查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免表搜索，因此将SQL重写成下面这样： \n\n  \n\n\n  \n\n\nSELECT \\* FROM record WHERE card\\_no like ‘5378%’ （< 1秒） \n\n  \n\n\nSELECT \\* FROM record WHERE amount< 1000\\*30 （< 1秒） \n\n  \n\n\nSELECT \\* FROM record WHERE date= ‘1999/12/01’ （< 1秒）\n\n  \n\n\n30、当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新。  \n\n\n  \n\n\n31、在所有的存储过程中，能够用SQL语句的，我绝不会用循环去实现。\n\n例如：列出上个月的每一天，我会用connect by去递归查询一下，绝不会去用循环从上个月第一天到最后一天。\n\n  \n\n\n32、选择最有效率的表名顺序（只在基于规则的优化器中有效）： \n\nOracle的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表（基础表 driving table）将被最先处理，在FROM子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。\n\n  \n\n\n如果有3个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表。\n\n  \n\n\n33、提高GROUP BY语句的效率，可以通过将不需要的记录在GROUP BY之前过滤掉。下面两个查询返回相同结果，但第二个明显就快了许多。 \n\n  \n\n\n低效：\n\n  \n\n\nSELECT JOB , AVG(SAL) \n\nFROM EMP \n\nGROUP BY JOB \n\nHAVING JOB =’PRESIDENT’ \n\nOR JOB =’MANAGER’ \n\n  \n\n\n高效: \n\n  \n\n\nSELECT JOB , AVG(SAL) \n\nFROM EMP \n\nWHERE JOB =’PRESIDENT’ \n\nOR JOB =’MANAGER’ \n\nGROUP BY JOB\n\n  \n\n\n34、SQL语句用大写，因为Oracle总是先解析SQL语句，把小写的字母转换成大写的再执行。  \n\n\n  \n\n\n35、别名的使用，别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询速度要比建连接表快1.5倍。\n\n  \n\n\n36、避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序；事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量；永远不要在事务中等待用户输入。\n\n  \n\n\n37、避免使用临时表，除非却有需要，否则应尽量避免使用临时表，相反，可以使用表变量代替；大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在TempDb数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。\n\n  \n\n\n38、最好不要使用触发器：\n\n  \n\n\n *  触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程；\n *  如果能够使用约束实现的，尽量不要使用触发器；\n *  不要为不同的触发事件(Insert，Update和Delete)使用相同的触发器；\n *  不要在触发器中使用事务型代码。\n\n  \n\n\n39、索引创建规则： \n\n  \n\n\n *  表的主键、外键必须有索引； \n *  数据量超过300的表应该有索引； \n *  经常与其他表进行连接的表，在连接字段上应该建立索引； \n *  经常出现在Where子句中的字段，特别是大表的字段，应该建立索引； \n *  索引应该建在选择性高的字段上； \n *  索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； \n *  复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替； \n *  正确选择复合索引中的主列字段，一般是选择性较好的字段； \n *  复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引； \n *  如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引； \n *  如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段； \n *  如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引； \n *  频繁进行数据操作的表，不要建立太多的索引； \n *  删除无用的索引，避免对执行计划造成负面影响； \n *  表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。 \n *  尽量不要对数据库中某个含有大量重复的值的字段建立索引。\n\n  \n\n\n40、MySQL查询优化总结：\n\n  \n\n\n使用慢查询日志去发现慢查询，使用执行计划去判断查询是否正常运行，总是去测试你的查询看看是否他们运行在最佳状态下。\n\n  \n\n\n久而久之性能总会变化，避免在整个表上使用count(\\*)，它可能锁住整张表，使查询保持一致以便后续相似的查询可以使用查询缓存，在适当的情形下使用GROUP BY而不是DISTINCT，在WHERE、GROUP BY和ORDER BY子句中使用有索引的列，保持索引简单，不在多个索引中包含同一个列。\n\n  \n\n\n有时候MySQL会使用错误的索引，对于这种情况使用USE INDEX，检查使用SQL\\_MODE=STRICT的问题，对于记录数小于5的索引字段，在UNION的时候使用LIMIT不是是用OR。 \n\n  \n\n\n为了避免在更新前SELECT，使用INSERT ON DUPLICATE KEY或者INSERT IGNORE，不要用UPDATE去实现，不要使用MAX，使用索引字段和ORDER BY子句，LIMIT M，N实际上可以减缓查询在某些情况下，有节制地使用，在WHERE子句中使用UNION代替子查询，在重新启动的MySQL，记得来温暖你的数据库，以确保数据在内存和查询速度快，考虑持久连接，而不是多个连接，以减少开销。\n\n  \n\n\n基准查询，包括使用服务器上的负载，有时一个简单的查询可以影响其他查询，当负载增加在服务器上，使用SHOW PROCESSLIST查看慢的和有问题的查询，在开发环境中产生的镜像数据中测试的所有可疑的查询。\n\n  \n\n\n41、MySQL备份过程：\n\n  \n\n\n *  从二级复制服务器上进行备份；\n *  在进行备份期间停止复制，以避免在数据依赖和外键约束上出现不一致；\n *  彻底停止MySQL，从数据库文件进行备份；\n *  如果使用MySQL dump进行备份，请同时备份二进制日志文件 – 确保复制没有中断；\n *  不要信任LVM快照，这很可能产生数据不一致，将来会给你带来麻烦；\n *  为了更容易进行单表恢复，以表为单位导出数据——如果数据是与其他表隔离的。 \n *  当使用mysqldump时请使用–opt；\n *  在备份之前检查和优化表；\n *  为了更快的进行导入，在导入时临时禁用外键约束。；\n *  为了更快的进行导入，在导入时临时禁用唯一性检测；\n *  在每一次备份后计算数据库，表以及索引的尺寸，以便更够监控数据尺寸的增长；\n *  通过自动调度脚本监控复制实例的错误和延迟；\n *  定期执行备份。\n\n  \n\n\n42、查询缓冲并不自动处理空格，因此，在写SQL语句时，应尽量减少空格的使用，尤其是在SQL首和尾的空格（因为查询缓冲并不自动截取首尾空格）。\n\n  \n\n\n43、member用mid做标准进行分表方便查询么？一般的业务需求中基本上都是以username为查询依据，正常应当是username做hash取模来分表。\n\n  \n\n\n而分表的话MySQL的partition功能就是干这个的，对代码是透明的；在代码层面去实现貌似是不合理的。\n\n  \n\n\n44、我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO\\_INCREMENT标志。\n\n  \n\n\n45、在所有的存储过程和触发器的开始处设置SET NOCOUNT ON，在结束时设置SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后向客户端发送DONE\\_IN\\_PROC消息。\n\n  \n\n\n46、MySQL查询可以启用高速查询缓存。这是提高数据库性能的有效MySQL优化方法之一。当同一个查询被执行多次时，从缓存中提取数据和直接从数据库中返回数据快很多。\n\n  \n\n\n47、EXPLAIN SELECT查询用来跟踪查看效果：\n\n  \n\n\n使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的。\n\n  \n\n\n48、当只要一行数据时使用LIMIT 1 ：\n\n  \n\n\n当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。\n\n  \n\n\n在这种情况下，加上LIMIT 1可以增加性能。这样一来，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。\n\n  \n\n\n49、选择表合适存储引擎： \n\n  \n\n\n *  myisam：应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。 \n *  InnoDB：事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（InnoDB有效地降低删除和更新导致的锁定）。\n    \n    对于支持事务的InnoDB类型的表来说，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行SQL前调用begin，多条SQL形成一个事物（即使autocommit打开也可以），将大大提高性能。\n\n  \n\n\n50、优化表的数据类型，选择合适的数据类型： \n\n  \n\n\n原则：更小通常更好，简单就好，所有字段都得有默认值，尽量避免null。 \n\n  \n\n\n例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型。(mediumint就比int更合适) \n\n  \n\n\n比如时间字段：datetime和timestamp，datetime占用8个字节，而timestamp占用4个字节，只用了一半，而timestamp表示的范围是1970—2037适合做更新时间 \n\n  \n\n\nMySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。 \n\n  \n\n\n因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。\n\n  \n\n\n例如：在定义邮政编码这个字段时，如果将其设置为CHAR(255)，显然给数据库增加了不必要的空间。甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。\n\n  \n\n\n同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段，应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。 \n\n  \n\n\n对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。\n\n  \n\n\n51、字符串数据类型：char，varchar，text选择区别。\n\n  \n\n\n52、任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。\n\n  \n","slug":"SQL语句性能优化策略","published":1,"updated":"2022-11-04T09:20:00.274Z","_id":"cla22kxoj0000cxld7rmz50bk","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>前言 -</li>\n</ul>\n<p>本文将全面揭秘 SQL 语句性能优化策略，直接上干货！</p>\n<ul>\n<li>52 条 SQL 语句性能优化策略 -</li>\n</ul>\n<p>1、对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。</p>\n<p>2、应尽量避免在where子句中对字段进行null值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默认值。</p>\n<p>3、应尽量避免在where子句中使用!=或&lt;&gt;操作符，MySQL只有对以下操作符才使用索引：&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE。</p>\n<p>4、应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用UNION合并查询：select id from t where num=10 union all select id from t where num=20。</p>\n<p>5、in和not in也要慎用，否则会导致全表扫描，对于连续的数值，能用between就不要用in了：Select id from t where num between 1 and 3。</p>\n<p>6、下面的查询也将导致全表扫描：select id from t where name like‘%abc%’或者select id from t where name like‘%abc’若要提高效率，可以考虑全文检索。而select id from t where name like‘abc%’才用到索引。</p>\n<p>7、如果在where子句中使用参数，也会导致全表扫描。</p>\n<p>8、应尽量避免在where子句中对字段进行表达式操作，应尽量避免在where子句中对字段进行函数操作。</p>\n<p>9、很多时候用exists代替in是一个好的选择：select num from a where num in(select num from b)。用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)。</p>\n<p>10、索引固然可以提高相应的select的效率，但同时也降低了insert及update的效率，因为insert或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>\n<p>11、应尽可能的避免更新clustered索引数据列， 因为clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新clustered索引数据列，那么需要考虑是否应将该索引建为clustered索引。</p>\n<p>12、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</p>\n<p>13、尽可能的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>\n<p>14、最好不要使用”“返回所有：select from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>\n<p>15、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>\n<p>16、使用表的别名(Alias)：当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个Column上。这样一来，就可以减少解析的时间并减少那些由Column歧义引起的语法错误。</p>\n<p>17、使用“临时表”暂存中间结果 ：</p>\n<p>简化SQL语句的重要方法就是采用临时表暂存中间结果，但是临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。</p>\n<p>18、一些SQL查询语句应加上nolock，读、写是会相互阻塞的，为了提高并发性能，对于一些查询，可以加上nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。</p>\n<p>使用nolock有3条原则：</p>\n<ul>\n<li> 查询的结果用于“插、删、改”的不能加nolock；</li>\n<li> 查询的表属于频繁发生页分裂的，慎用nolock ；</li>\n<li>使用临时表一样可以保存“数据前影”，起到类似Oracle的undo表空间的功能，能采用临时表提高并发性能的，不要用nolock。</li>\n</ul>\n<p>19、常见的简化规则如下：</p>\n<p>不要有超过5个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。少用子查询，视图嵌套不要过深，一般视图嵌套不要超过2个为宜。</p>\n<p>20、将需要查询的结果预先计算好放在表中，查询的时候再Select。这在SQL7.0以前是最重要的手段，例如医院的住院费计算。</p>\n<p>21、用OR的字句可以分解成多个查询，并且通过UNION 连接多个查询。他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用UNION all执行的效率更高。多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。</p>\n<p>22、在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。</p>\n<p>23、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。</p>\n<p>存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL，可以使用临时存储过程，该过程（临时表）被放在Tempdb中。</p>\n<p>24、当服务器的内存够多时，配制线程数量 = 最大连接数+5，这样能发挥最大的效率；否则使用 配制线程数量&lt;最大连接数启用SQL SERVER的线程池来解决，如果还是数量 = 最大连接数+5，严重的损害服务器的性能。</p>\n<p>25、查询的关联同写的顺序 ：</p>\n<p>select a.personMemberID, * from chineseresume a,personmember b where personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ （A = B ,B = ‘号码’） </p>\n<p>select a.personMemberID, * from chineseresume a,personmember b where a.personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ and b.referenceid = ‘JCNPRH39681’ （A = B ,B = ‘号码’， A = ‘号码’） </p>\n<p>select a.personMemberID, * from chineseresume a,personmember b where b.referenceid = ‘JCNPRH39681’ and a.personMemberID = ‘JCNPRH39681’ （B = ‘号码’， A = ‘号码’）</p>\n<p>26、尽量使用exists代替select count(1)来判断是否存在记录，count函数只有在统计表中所有行数时使用，而且count(1)比count(*)更有效率。  </p>\n<p>27、尽量使用“&gt;=”，不要使用“&gt;”。</p>\n<p>28、索引的使用规范：</p>\n<ul>\n<li> 索引的创建要与应用结合考虑，建议大的OLTP表不要超过6个索引；</li>\n<li> 尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index_name来强制指定索引；</li>\n<li> 避免对大表查询时进行table scan，必要时考虑新建索引；</li>\n<li> 在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用；</li>\n<li>要注意索引的维护，周期性重建索引，重新编译存储过程。　　</li>\n</ul>\n<p>29、下列SQL条件语句中的列都建有恰当的索引，但执行速度却非常慢： </p>\n<p>SELECT * FROM record WHERE substrINg(card_no,1,4)=’5378’ (13秒) </p>\n<p>SELECT * FROM record WHERE amount/30&lt; 1000 （11秒） </p>\n<p>SELECT * FROM record WHERE convert(char(10),date,112)=’19991201’ （10秒） </p>\n<p>分析： </p>\n<p>WHERE子句中对列的任何操作结果都是在SQL运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引。</p>\n<p>如果这些结果在查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免表搜索，因此将SQL重写成下面这样： </p>\n<p>SELECT * FROM record WHERE card_no like ‘5378%’ （&lt; 1秒） </p>\n<p>SELECT * FROM record WHERE amount&lt; 1000*30 （&lt; 1秒） </p>\n<p>SELECT * FROM record WHERE date= ‘1999/12/01’ （&lt; 1秒）</p>\n<p>30、当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新。  </p>\n<p>31、在所有的存储过程中，能够用SQL语句的，我绝不会用循环去实现。</p>\n<p>例如：列出上个月的每一天，我会用connect by去递归查询一下，绝不会去用循环从上个月第一天到最后一天。</p>\n<p>32、选择最有效率的表名顺序（只在基于规则的优化器中有效）： </p>\n<p>Oracle的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表（基础表 driving table）将被最先处理，在FROM子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。</p>\n<p>如果有3个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表。</p>\n<p>33、提高GROUP BY语句的效率，可以通过将不需要的记录在GROUP BY之前过滤掉。下面两个查询返回相同结果，但第二个明显就快了许多。 </p>\n<p>低效：</p>\n<p>SELECT JOB , AVG(SAL) </p>\n<p>FROM EMP </p>\n<p>GROUP BY JOB </p>\n<p>HAVING JOB =’PRESIDENT’ </p>\n<p>OR JOB =’MANAGER’ </p>\n<p>高效: </p>\n<p>SELECT JOB , AVG(SAL) </p>\n<p>FROM EMP </p>\n<p>WHERE JOB =’PRESIDENT’ </p>\n<p>OR JOB =’MANAGER’ </p>\n<p>GROUP BY JOB</p>\n<p>34、SQL语句用大写，因为Oracle总是先解析SQL语句，把小写的字母转换成大写的再执行。  </p>\n<p>35、别名的使用，别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询速度要比建连接表快1.5倍。</p>\n<p>36、避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序；事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量；永远不要在事务中等待用户输入。</p>\n<p>37、避免使用临时表，除非却有需要，否则应尽量避免使用临时表，相反，可以使用表变量代替；大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在TempDb数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。</p>\n<p>38、最好不要使用触发器：</p>\n<ul>\n<li> 触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程；</li>\n<li> 如果能够使用约束实现的，尽量不要使用触发器；</li>\n<li> 不要为不同的触发事件(Insert，Update和Delete)使用相同的触发器；</li>\n<li>不要在触发器中使用事务型代码。</li>\n</ul>\n<p>39、索引创建规则： </p>\n<ul>\n<li> 表的主键、外键必须有索引； </li>\n<li> 数据量超过300的表应该有索引； </li>\n<li> 经常与其他表进行连接的表，在连接字段上应该建立索引； </li>\n<li> 经常出现在Where子句中的字段，特别是大表的字段，应该建立索引； </li>\n<li> 索引应该建在选择性高的字段上； </li>\n<li> 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； </li>\n<li> 复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替； </li>\n<li> 正确选择复合索引中的主列字段，一般是选择性较好的字段； </li>\n<li> 复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引； </li>\n<li> 如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引； </li>\n<li> 如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段； </li>\n<li> 如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引； </li>\n<li> 频繁进行数据操作的表，不要建立太多的索引； </li>\n<li> 删除无用的索引，避免对执行计划造成负面影响； </li>\n<li> 表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。 </li>\n<li>尽量不要对数据库中某个含有大量重复的值的字段建立索引。</li>\n</ul>\n<p>40、MySQL查询优化总结：</p>\n<p>使用慢查询日志去发现慢查询，使用执行计划去判断查询是否正常运行，总是去测试你的查询看看是否他们运行在最佳状态下。</p>\n<p>久而久之性能总会变化，避免在整个表上使用count(*)，它可能锁住整张表，使查询保持一致以便后续相似的查询可以使用查询缓存，在适当的情形下使用GROUP BY而不是DISTINCT，在WHERE、GROUP BY和ORDER BY子句中使用有索引的列，保持索引简单，不在多个索引中包含同一个列。</p>\n<p>有时候MySQL会使用错误的索引，对于这种情况使用USE INDEX，检查使用SQL_MODE=STRICT的问题，对于记录数小于5的索引字段，在UNION的时候使用LIMIT不是是用OR。 </p>\n<p>为了避免在更新前SELECT，使用INSERT ON DUPLICATE KEY或者INSERT IGNORE，不要用UPDATE去实现，不要使用MAX，使用索引字段和ORDER BY子句，LIMIT M，N实际上可以减缓查询在某些情况下，有节制地使用，在WHERE子句中使用UNION代替子查询，在重新启动的MySQL，记得来温暖你的数据库，以确保数据在内存和查询速度快，考虑持久连接，而不是多个连接，以减少开销。</p>\n<p>基准查询，包括使用服务器上的负载，有时一个简单的查询可以影响其他查询，当负载增加在服务器上，使用SHOW PROCESSLIST查看慢的和有问题的查询，在开发环境中产生的镜像数据中测试的所有可疑的查询。</p>\n<p>41、MySQL备份过程：</p>\n<ul>\n<li> 从二级复制服务器上进行备份；</li>\n<li> 在进行备份期间停止复制，以避免在数据依赖和外键约束上出现不一致；</li>\n<li> 彻底停止MySQL，从数据库文件进行备份；</li>\n<li> 如果使用MySQL dump进行备份，请同时备份二进制日志文件 – 确保复制没有中断；</li>\n<li> 不要信任LVM快照，这很可能产生数据不一致，将来会给你带来麻烦；</li>\n<li> 为了更容易进行单表恢复，以表为单位导出数据——如果数据是与其他表隔离的。 </li>\n<li> 当使用mysqldump时请使用–opt；</li>\n<li> 在备份之前检查和优化表；</li>\n<li> 为了更快的进行导入，在导入时临时禁用外键约束。；</li>\n<li> 为了更快的进行导入，在导入时临时禁用唯一性检测；</li>\n<li> 在每一次备份后计算数据库，表以及索引的尺寸，以便更够监控数据尺寸的增长；</li>\n<li> 通过自动调度脚本监控复制实例的错误和延迟；</li>\n<li>定期执行备份。</li>\n</ul>\n<p>42、查询缓冲并不自动处理空格，因此，在写SQL语句时，应尽量减少空格的使用，尤其是在SQL首和尾的空格（因为查询缓冲并不自动截取首尾空格）。</p>\n<p>43、member用mid做标准进行分表方便查询么？一般的业务需求中基本上都是以username为查询依据，正常应当是username做hash取模来分表。</p>\n<p>而分表的话MySQL的partition功能就是干这个的，对代码是透明的；在代码层面去实现貌似是不合理的。</p>\n<p>44、我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。</p>\n<p>45、在所有的存储过程和触发器的开始处设置SET NOCOUNT ON，在结束时设置SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC消息。</p>\n<p>46、MySQL查询可以启用高速查询缓存。这是提高数据库性能的有效MySQL优化方法之一。当同一个查询被执行多次时，从缓存中提取数据和直接从数据库中返回数据快很多。</p>\n<p>47、EXPLAIN SELECT查询用来跟踪查看效果：</p>\n<p>使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的。</p>\n<p>48、当只要一行数据时使用LIMIT 1 ：</p>\n<p>当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。</p>\n<p>在这种情况下，加上LIMIT 1可以增加性能。这样一来，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。</p>\n<p>49、选择表合适存储引擎： </p>\n<ul>\n<li> myisam：应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。 </li>\n<li>InnoDB：事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（InnoDB有效地降低删除和更新导致的锁定）。 对于支持事务的InnoDB类型的表来说，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行SQL前调用begin，多条SQL形成一个事物（即使autocommit打开也可以），将大大提高性能。</li>\n</ul>\n<p>50、优化表的数据类型，选择合适的数据类型： </p>\n<p>原则：更小通常更好，简单就好，所有字段都得有默认值，尽量避免null。 </p>\n<p>例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型。(mediumint就比int更合适) </p>\n<p>比如时间字段：datetime和timestamp，datetime占用8个字节，而timestamp占用4个字节，只用了一半，而timestamp表示的范围是1970—2037适合做更新时间 </p>\n<p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。 </p>\n<p>因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p>\n<p>例如：在定义邮政编码这个字段时，如果将其设置为CHAR(255)，显然给数据库增加了不必要的空间。甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。</p>\n<p>同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段，应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。 </p>\n<p>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p>\n<p>51、字符串数据类型：char，varchar，text选择区别。</p>\n<p>52、任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<ul>\n<li>前言 -</li>\n</ul>\n<p>本文将全面揭秘 SQL 语句性能优化策略，直接上干货！</p>\n<ul>\n<li>52 条 SQL 语句性能优化策略 -</li>\n</ul>\n<p>1、对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。</p>\n<p>2、应尽量避免在where子句中对字段进行null值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默认值。</p>\n<p>3、应尽量避免在where子句中使用!=或&lt;&gt;操作符，MySQL只有对以下操作符才使用索引：&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE。</p>\n<p>4、应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用UNION合并查询：select id from t where num=10 union all select id from t where num=20。</p>\n<p>5、in和not in也要慎用，否则会导致全表扫描，对于连续的数值，能用between就不要用in了：Select id from t where num between 1 and 3。</p>\n<p>6、下面的查询也将导致全表扫描：select id from t where name like‘%abc%’或者select id from t where name like‘%abc’若要提高效率，可以考虑全文检索。而select id from t where name like‘abc%’才用到索引。</p>\n<p>7、如果在where子句中使用参数，也会导致全表扫描。</p>\n<p>8、应尽量避免在where子句中对字段进行表达式操作，应尽量避免在where子句中对字段进行函数操作。</p>\n<p>9、很多时候用exists代替in是一个好的选择：select num from a where num in(select num from b)。用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)。</p>\n<p>10、索引固然可以提高相应的select的效率，但同时也降低了insert及update的效率，因为insert或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>\n<p>11、应尽可能的避免更新clustered索引数据列， 因为clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新clustered索引数据列，那么需要考虑是否应将该索引建为clustered索引。</p>\n<p>12、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</p>\n<p>13、尽可能的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>\n<p>14、最好不要使用”“返回所有：select from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>\n<p>15、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>\n<p>16、使用表的别名(Alias)：当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个Column上。这样一来，就可以减少解析的时间并减少那些由Column歧义引起的语法错误。</p>\n<p>17、使用“临时表”暂存中间结果 ：</p>\n<p>简化SQL语句的重要方法就是采用临时表暂存中间结果，但是临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。</p>\n<p>18、一些SQL查询语句应加上nolock，读、写是会相互阻塞的，为了提高并发性能，对于一些查询，可以加上nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。</p>\n<p>使用nolock有3条原则：</p>\n<ul>\n<li> 查询的结果用于“插、删、改”的不能加nolock；</li>\n<li> 查询的表属于频繁发生页分裂的，慎用nolock ；</li>\n<li>使用临时表一样可以保存“数据前影”，起到类似Oracle的undo表空间的功能，能采用临时表提高并发性能的，不要用nolock。</li>\n</ul>\n<p>19、常见的简化规则如下：</p>\n<p>不要有超过5个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。少用子查询，视图嵌套不要过深，一般视图嵌套不要超过2个为宜。</p>\n<p>20、将需要查询的结果预先计算好放在表中，查询的时候再Select。这在SQL7.0以前是最重要的手段，例如医院的住院费计算。</p>\n<p>21、用OR的字句可以分解成多个查询，并且通过UNION 连接多个查询。他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用UNION all执行的效率更高。多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。</p>\n<p>22、在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。</p>\n<p>23、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。</p>\n<p>存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL，可以使用临时存储过程，该过程（临时表）被放在Tempdb中。</p>\n<p>24、当服务器的内存够多时，配制线程数量 = 最大连接数+5，这样能发挥最大的效率；否则使用 配制线程数量&lt;最大连接数启用SQL SERVER的线程池来解决，如果还是数量 = 最大连接数+5，严重的损害服务器的性能。</p>\n<p>25、查询的关联同写的顺序 ：</p>\n<p>select a.personMemberID, * from chineseresume a,personmember b where personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ （A = B ,B = ‘号码’） </p>\n<p>select a.personMemberID, * from chineseresume a,personmember b where a.personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ and b.referenceid = ‘JCNPRH39681’ （A = B ,B = ‘号码’， A = ‘号码’） </p>\n<p>select a.personMemberID, * from chineseresume a,personmember b where b.referenceid = ‘JCNPRH39681’ and a.personMemberID = ‘JCNPRH39681’ （B = ‘号码’， A = ‘号码’）</p>\n<p>26、尽量使用exists代替select count(1)来判断是否存在记录，count函数只有在统计表中所有行数时使用，而且count(1)比count(*)更有效率。  </p>\n<p>27、尽量使用“&gt;=”，不要使用“&gt;”。</p>\n<p>28、索引的使用规范：</p>\n<ul>\n<li> 索引的创建要与应用结合考虑，建议大的OLTP表不要超过6个索引；</li>\n<li> 尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index_name来强制指定索引；</li>\n<li> 避免对大表查询时进行table scan，必要时考虑新建索引；</li>\n<li> 在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用；</li>\n<li>要注意索引的维护，周期性重建索引，重新编译存储过程。　　</li>\n</ul>\n<p>29、下列SQL条件语句中的列都建有恰当的索引，但执行速度却非常慢： </p>\n<p>SELECT * FROM record WHERE substrINg(card_no,1,4)=’5378’ (13秒) </p>\n<p>SELECT * FROM record WHERE amount/30&lt; 1000 （11秒） </p>\n<p>SELECT * FROM record WHERE convert(char(10),date,112)=’19991201’ （10秒） </p>\n<p>分析： </p>\n<p>WHERE子句中对列的任何操作结果都是在SQL运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引。</p>\n<p>如果这些结果在查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免表搜索，因此将SQL重写成下面这样： </p>\n<p>SELECT * FROM record WHERE card_no like ‘5378%’ （&lt; 1秒） </p>\n<p>SELECT * FROM record WHERE amount&lt; 1000*30 （&lt; 1秒） </p>\n<p>SELECT * FROM record WHERE date= ‘1999/12/01’ （&lt; 1秒）</p>\n<p>30、当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新。  </p>\n<p>31、在所有的存储过程中，能够用SQL语句的，我绝不会用循环去实现。</p>\n<p>例如：列出上个月的每一天，我会用connect by去递归查询一下，绝不会去用循环从上个月第一天到最后一天。</p>\n<p>32、选择最有效率的表名顺序（只在基于规则的优化器中有效）： </p>\n<p>Oracle的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表（基础表 driving table）将被最先处理，在FROM子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。</p>\n<p>如果有3个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表。</p>\n<p>33、提高GROUP BY语句的效率，可以通过将不需要的记录在GROUP BY之前过滤掉。下面两个查询返回相同结果，但第二个明显就快了许多。 </p>\n<p>低效：</p>\n<p>SELECT JOB , AVG(SAL) </p>\n<p>FROM EMP </p>\n<p>GROUP BY JOB </p>\n<p>HAVING JOB =’PRESIDENT’ </p>\n<p>OR JOB =’MANAGER’ </p>\n<p>高效: </p>\n<p>SELECT JOB , AVG(SAL) </p>\n<p>FROM EMP </p>\n<p>WHERE JOB =’PRESIDENT’ </p>\n<p>OR JOB =’MANAGER’ </p>\n<p>GROUP BY JOB</p>\n<p>34、SQL语句用大写，因为Oracle总是先解析SQL语句，把小写的字母转换成大写的再执行。  </p>\n<p>35、别名的使用，别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询速度要比建连接表快1.5倍。</p>\n<p>36、避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序；事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量；永远不要在事务中等待用户输入。</p>\n<p>37、避免使用临时表，除非却有需要，否则应尽量避免使用临时表，相反，可以使用表变量代替；大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在TempDb数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。</p>\n<p>38、最好不要使用触发器：</p>\n<ul>\n<li> 触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程；</li>\n<li> 如果能够使用约束实现的，尽量不要使用触发器；</li>\n<li> 不要为不同的触发事件(Insert，Update和Delete)使用相同的触发器；</li>\n<li>不要在触发器中使用事务型代码。</li>\n</ul>\n<p>39、索引创建规则： </p>\n<ul>\n<li> 表的主键、外键必须有索引； </li>\n<li> 数据量超过300的表应该有索引； </li>\n<li> 经常与其他表进行连接的表，在连接字段上应该建立索引； </li>\n<li> 经常出现在Where子句中的字段，特别是大表的字段，应该建立索引； </li>\n<li> 索引应该建在选择性高的字段上； </li>\n<li> 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； </li>\n<li> 复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替； </li>\n<li> 正确选择复合索引中的主列字段，一般是选择性较好的字段； </li>\n<li> 复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引； </li>\n<li> 如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引； </li>\n<li> 如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段； </li>\n<li> 如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引； </li>\n<li> 频繁进行数据操作的表，不要建立太多的索引； </li>\n<li> 删除无用的索引，避免对执行计划造成负面影响； </li>\n<li> 表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。 </li>\n<li>尽量不要对数据库中某个含有大量重复的值的字段建立索引。</li>\n</ul>\n<p>40、MySQL查询优化总结：</p>\n<p>使用慢查询日志去发现慢查询，使用执行计划去判断查询是否正常运行，总是去测试你的查询看看是否他们运行在最佳状态下。</p>\n<p>久而久之性能总会变化，避免在整个表上使用count(*)，它可能锁住整张表，使查询保持一致以便后续相似的查询可以使用查询缓存，在适当的情形下使用GROUP BY而不是DISTINCT，在WHERE、GROUP BY和ORDER BY子句中使用有索引的列，保持索引简单，不在多个索引中包含同一个列。</p>\n<p>有时候MySQL会使用错误的索引，对于这种情况使用USE INDEX，检查使用SQL_MODE=STRICT的问题，对于记录数小于5的索引字段，在UNION的时候使用LIMIT不是是用OR。 </p>\n<p>为了避免在更新前SELECT，使用INSERT ON DUPLICATE KEY或者INSERT IGNORE，不要用UPDATE去实现，不要使用MAX，使用索引字段和ORDER BY子句，LIMIT M，N实际上可以减缓查询在某些情况下，有节制地使用，在WHERE子句中使用UNION代替子查询，在重新启动的MySQL，记得来温暖你的数据库，以确保数据在内存和查询速度快，考虑持久连接，而不是多个连接，以减少开销。</p>\n<p>基准查询，包括使用服务器上的负载，有时一个简单的查询可以影响其他查询，当负载增加在服务器上，使用SHOW PROCESSLIST查看慢的和有问题的查询，在开发环境中产生的镜像数据中测试的所有可疑的查询。</p>\n<p>41、MySQL备份过程：</p>\n<ul>\n<li> 从二级复制服务器上进行备份；</li>\n<li> 在进行备份期间停止复制，以避免在数据依赖和外键约束上出现不一致；</li>\n<li> 彻底停止MySQL，从数据库文件进行备份；</li>\n<li> 如果使用MySQL dump进行备份，请同时备份二进制日志文件 – 确保复制没有中断；</li>\n<li> 不要信任LVM快照，这很可能产生数据不一致，将来会给你带来麻烦；</li>\n<li> 为了更容易进行单表恢复，以表为单位导出数据——如果数据是与其他表隔离的。 </li>\n<li> 当使用mysqldump时请使用–opt；</li>\n<li> 在备份之前检查和优化表；</li>\n<li> 为了更快的进行导入，在导入时临时禁用外键约束。；</li>\n<li> 为了更快的进行导入，在导入时临时禁用唯一性检测；</li>\n<li> 在每一次备份后计算数据库，表以及索引的尺寸，以便更够监控数据尺寸的增长；</li>\n<li> 通过自动调度脚本监控复制实例的错误和延迟；</li>\n<li>定期执行备份。</li>\n</ul>\n<p>42、查询缓冲并不自动处理空格，因此，在写SQL语句时，应尽量减少空格的使用，尤其是在SQL首和尾的空格（因为查询缓冲并不自动截取首尾空格）。</p>\n<p>43、member用mid做标准进行分表方便查询么？一般的业务需求中基本上都是以username为查询依据，正常应当是username做hash取模来分表。</p>\n<p>而分表的话MySQL的partition功能就是干这个的，对代码是透明的；在代码层面去实现貌似是不合理的。</p>\n<p>44、我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。</p>\n<p>45、在所有的存储过程和触发器的开始处设置SET NOCOUNT ON，在结束时设置SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC消息。</p>\n<p>46、MySQL查询可以启用高速查询缓存。这是提高数据库性能的有效MySQL优化方法之一。当同一个查询被执行多次时，从缓存中提取数据和直接从数据库中返回数据快很多。</p>\n<p>47、EXPLAIN SELECT查询用来跟踪查看效果：</p>\n<p>使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的。</p>\n<p>48、当只要一行数据时使用LIMIT 1 ：</p>\n<p>当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。</p>\n<p>在这种情况下，加上LIMIT 1可以增加性能。这样一来，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。</p>\n<p>49、选择表合适存储引擎： </p>\n<ul>\n<li> myisam：应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。 </li>\n<li>InnoDB：事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（InnoDB有效地降低删除和更新导致的锁定）。 对于支持事务的InnoDB类型的表来说，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行SQL前调用begin，多条SQL形成一个事物（即使autocommit打开也可以），将大大提高性能。</li>\n</ul>\n<p>50、优化表的数据类型，选择合适的数据类型： </p>\n<p>原则：更小通常更好，简单就好，所有字段都得有默认值，尽量避免null。 </p>\n<p>例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型。(mediumint就比int更合适) </p>\n<p>比如时间字段：datetime和timestamp，datetime占用8个字节，而timestamp占用4个字节，只用了一半，而timestamp表示的范围是1970—2037适合做更新时间 </p>\n<p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。 </p>\n<p>因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p>\n<p>例如：在定义邮政编码这个字段时，如果将其设置为CHAR(255)，显然给数据库增加了不必要的空间。甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。</p>\n<p>同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段，应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。 </p>\n<p>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p>\n<p>51、字符串数据类型：char，varchar，text选择区别。</p>\n<p>52、任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。</p>\n"},{"title":"23种设计模式的通俗解释","top":false,"cover":false,"toc":false,"mathjax":true,"date":"2022-11-04T05:43:04.000Z","password":null,"summary":"工厂方法 建造者模式 抽象工厂","_content":"\n\n *  01 工厂方法\n *  02 建造者模式\n *  03 抽象工厂\n *  04 原型模式\n *  05 单态模式\n *  06 适配器模式\n *  07 桥梁模式\n *  08 合成模式\n *  09 装饰模式\n *  10 门面模式\n *  11 享元模式\n *  12 代理模式\n *  13 责任链模式\n *  14 命令模式\n *  15 解释器模式\n *  16 迭代模式\n *  17 调停者模式\n *  18 备忘录模式\n *  19 观察者模式\n *  20 状态模式\n *  21 策略模式\n *  22 模板方法模式\n *  23 访问者模式\n\n## 01 工厂方法 \n\n追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：客户类和工厂类分开。\n\n消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。\n\n## 02 建造者模式 \n\nMM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。\n\n建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。\n\n## 03 抽象工厂 \n\n请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。\n\n工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。\n\n## 04 原型模式 \n\n跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）\n\n原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。\n\n## 05 单态模式 \n\n俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)\n\n单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。\n\n## 06 适配器模式 \n\n在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)\n\n适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。\n\n## 07 桥梁模式 \n\n早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了\n\n桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。\n\n08 合成模式 Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？\n\n合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。\n\n## 09 装饰模式 \n\nMary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？\n\n装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。\n\n## 10 门面模式 \n\n我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。\n\n门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。\n\n## 11 享元模式 \n\n每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。\n\n享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。\n\n将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。\n\n## 12 代理模式 \n\n跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。\n\n代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。\n\n客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。\n\n## 13 责任链模式 \n\n晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！\n\n责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。\n\n## 14 命令模式 \n\n俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”\n\n命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。\n\n## 15 解释器模式 \n\n俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。\n\n解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。\n\n在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。\n\n## 16 迭代模式 \n\n我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”\n\n迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。\n\n迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。\n\n## 17 调停者模式 \n\n四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。\n\n当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。\n\n## 18 备忘录模式 \n\n同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。\n\n备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。\n\n## 19 观察者模式 \n\n想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。\n\n观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。\n\n## 20 状态模式 \n\n跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。\n\n状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。\n\n状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。\n\n## 21 策略模式 \n\n跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。\n\n策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。\n\n## 22 模板方法模式 \n\n看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；\n\n模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。\n\n## 23 访问者模式 \n\n情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；\n\n访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。\n\n访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。\n","source":"_posts/23种设计模式的通俗解释.md","raw":"---\ntitle: 23种设计模式的通俗解释\ntop: false\ncover: false\ntoc: false\nmathjax: true\ndate: 2022-11-04 13:43:04\npassword:\nsummary: 工厂方法 建造者模式 抽象工厂\ntags:\n    - 设计模式\n    - 程序设计\ncategories:\n    - java\n---\n\n\n *  01 工厂方法\n *  02 建造者模式\n *  03 抽象工厂\n *  04 原型模式\n *  05 单态模式\n *  06 适配器模式\n *  07 桥梁模式\n *  08 合成模式\n *  09 装饰模式\n *  10 门面模式\n *  11 享元模式\n *  12 代理模式\n *  13 责任链模式\n *  14 命令模式\n *  15 解释器模式\n *  16 迭代模式\n *  17 调停者模式\n *  18 备忘录模式\n *  19 观察者模式\n *  20 状态模式\n *  21 策略模式\n *  22 模板方法模式\n *  23 访问者模式\n\n## 01 工厂方法 \n\n追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：客户类和工厂类分开。\n\n消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。\n\n## 02 建造者模式 \n\nMM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。\n\n建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。\n\n## 03 抽象工厂 \n\n请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。\n\n工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。\n\n## 04 原型模式 \n\n跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）\n\n原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。\n\n## 05 单态模式 \n\n俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)\n\n单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。\n\n## 06 适配器模式 \n\n在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)\n\n适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。\n\n## 07 桥梁模式 \n\n早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了\n\n桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。\n\n08 合成模式 Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？\n\n合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。\n\n## 09 装饰模式 \n\nMary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？\n\n装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。\n\n## 10 门面模式 \n\n我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。\n\n门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。\n\n## 11 享元模式 \n\n每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。\n\n享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。\n\n将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。\n\n## 12 代理模式 \n\n跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。\n\n代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。\n\n客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。\n\n## 13 责任链模式 \n\n晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！\n\n责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。\n\n## 14 命令模式 \n\n俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”\n\n命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。\n\n## 15 解释器模式 \n\n俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。\n\n解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。\n\n在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。\n\n## 16 迭代模式 \n\n我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”\n\n迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。\n\n迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。\n\n## 17 调停者模式 \n\n四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。\n\n当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。\n\n## 18 备忘录模式 \n\n同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。\n\n备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。\n\n## 19 观察者模式 \n\n想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。\n\n观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。\n\n## 20 状态模式 \n\n跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。\n\n状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。\n\n状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。\n\n## 21 策略模式 \n\n跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。\n\n策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。\n\n## 22 模板方法模式 \n\n看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；\n\n模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。\n\n## 23 访问者模式 \n\n情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；\n\n访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。\n\n访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。\n","slug":"23种设计模式的通俗解释","published":1,"updated":"2022-11-04T09:19:34.320Z","_id":"cla22ncim0000hpldesb6gc1n","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li> 01 工厂方法</li>\n<li> 02 建造者模式</li>\n<li> 03 抽象工厂</li>\n<li> 04 原型模式</li>\n<li> 05 单态模式</li>\n<li> 06 适配器模式</li>\n<li> 07 桥梁模式</li>\n<li> 08 合成模式</li>\n<li> 09 装饰模式</li>\n<li> 10 门面模式</li>\n<li> 11 享元模式</li>\n<li> 12 代理模式</li>\n<li> 13 责任链模式</li>\n<li> 14 命令模式</li>\n<li> 15 解释器模式</li>\n<li> 16 迭代模式</li>\n<li> 17 调停者模式</li>\n<li> 18 备忘录模式</li>\n<li> 19 观察者模式</li>\n<li> 20 状态模式</li>\n<li> 21 策略模式</li>\n<li> 22 模板方法模式</li>\n<li> 23 访问者模式</li>\n</ul>\n<h2 id=\"01-工厂方法\"><a href=\"#01-工厂方法\" class=\"headerlink\" title=\"01 工厂方法\"></a>01 工厂方法</h2><p>追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：客户类和工厂类分开。</p>\n<p>消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>\n<h2 id=\"02-建造者模式\"><a href=\"#02-建造者模式\" class=\"headerlink\" title=\"02 建造者模式\"></a>02 建造者模式</h2><p>MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。</p>\n<p>建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>\n<h2 id=\"03-抽象工厂\"><a href=\"#03-抽象工厂\" class=\"headerlink\" title=\"03 抽象工厂\"></a>03 抽象工厂</h2><p>请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。</p>\n<p>工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>\n<h2 id=\"04-原型模式\"><a href=\"#04-原型模式\" class=\"headerlink\" title=\"04 原型模式\"></a>04 原型模式</h2><p>跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）</p>\n<p>原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>\n<h2 id=\"05-单态模式\"><a href=\"#05-单态模式\" class=\"headerlink\" title=\"05 单态模式\"></a>05 单态模式</h2><p>俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)</p>\n<p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。</p>\n<h2 id=\"06-适配器模式\"><a href=\"#06-适配器模式\" class=\"headerlink\" title=\"06 适配器模式\"></a>06 适配器模式</h2><p>在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)</p>\n<p>适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>\n<h2 id=\"07-桥梁模式\"><a href=\"#07-桥梁模式\" class=\"headerlink\" title=\"07 桥梁模式\"></a>07 桥梁模式</h2><p>早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了</p>\n<p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。</p>\n<p>08 合成模式 Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？</p>\n<p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>\n<h2 id=\"09-装饰模式\"><a href=\"#09-装饰模式\" class=\"headerlink\" title=\"09 装饰模式\"></a>09 装饰模式</h2><p>Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</p>\n<p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>\n<h2 id=\"10-门面模式\"><a href=\"#10-门面模式\" class=\"headerlink\" title=\"10 门面模式\"></a>10 门面模式</h2><p>我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。</p>\n<p>门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>\n<h2 id=\"11-享元模式\"><a href=\"#11-享元模式\" class=\"headerlink\" title=\"11 享元模式\"></a>11 享元模式</h2><p>每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。</p>\n<p>享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。</p>\n<p>将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>\n<h2 id=\"12-代理模式\"><a href=\"#12-代理模式\" class=\"headerlink\" title=\"12 代理模式\"></a>12 代理模式</h2><p>跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>\n<p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。</p>\n<p>客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>\n<h2 id=\"13-责任链模式\"><a href=\"#13-责任链模式\" class=\"headerlink\" title=\"13 责任链模式\"></a>13 责任链模式</h2><p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！</p>\n<p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>\n<h2 id=\"14-命令模式\"><a href=\"#14-命令模式\" class=\"headerlink\" title=\"14 命令模式\"></a>14 命令模式</h2><p>俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”</p>\n<p>命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>\n<h2 id=\"15-解释器模式\"><a href=\"#15-解释器模式\" class=\"headerlink\" title=\"15 解释器模式\"></a>15 解释器模式</h2><p>俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。</p>\n<p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。</p>\n<p>在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>\n<h2 id=\"16-迭代模式\"><a href=\"#16-迭代模式\" class=\"headerlink\" title=\"16 迭代模式\"></a>16 迭代模式</h2><p>我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”</p>\n<p>迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。</p>\n<p>迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>\n<h2 id=\"17-调停者模式\"><a href=\"#17-调停者模式\" class=\"headerlink\" title=\"17 调停者模式\"></a>17 调停者模式</h2><p>四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。</p>\n<p>当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>\n<h2 id=\"18-备忘录模式\"><a href=\"#18-备忘录模式\" class=\"headerlink\" title=\"18 备忘录模式\"></a>18 备忘录模式</h2><p>同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</p>\n<p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>\n<h2 id=\"19-观察者模式\"><a href=\"#19-观察者模式\" class=\"headerlink\" title=\"19 观察者模式\"></a>19 观察者模式</h2><p>想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。</p>\n<p>观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>\n<h2 id=\"20-状态模式\"><a href=\"#20-状态模式\" class=\"headerlink\" title=\"20 状态模式\"></a>20 状态模式</h2><p>跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。</p>\n<p>状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。</p>\n<p>状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>\n<h2 id=\"21-策略模式\"><a href=\"#21-策略模式\" class=\"headerlink\" title=\"21 策略模式\"></a>21 策略模式</h2><p>跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。</p>\n<p>策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>\n<h2 id=\"22-模板方法模式\"><a href=\"#22-模板方法模式\" class=\"headerlink\" title=\"22 模板方法模式\"></a>22 模板方法模式</h2><p>看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；</p>\n<p>模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>\n<h2 id=\"23-访问者模式\"><a href=\"#23-访问者模式\" class=\"headerlink\" title=\"23 访问者模式\"></a>23 访问者模式</h2><p>情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；</p>\n<p>访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。</p>\n<p>访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<ul>\n<li> 01 工厂方法</li>\n<li> 02 建造者模式</li>\n<li> 03 抽象工厂</li>\n<li> 04 原型模式</li>\n<li> 05 单态模式</li>\n<li> 06 适配器模式</li>\n<li> 07 桥梁模式</li>\n<li> 08 合成模式</li>\n<li> 09 装饰模式</li>\n<li> 10 门面模式</li>\n<li> 11 享元模式</li>\n<li> 12 代理模式</li>\n<li> 13 责任链模式</li>\n<li> 14 命令模式</li>\n<li> 15 解释器模式</li>\n<li> 16 迭代模式</li>\n<li> 17 调停者模式</li>\n<li> 18 备忘录模式</li>\n<li> 19 观察者模式</li>\n<li> 20 状态模式</li>\n<li> 21 策略模式</li>\n<li> 22 模板方法模式</li>\n<li> 23 访问者模式</li>\n</ul>\n<h2 id=\"01-工厂方法\"><a href=\"#01-工厂方法\" class=\"headerlink\" title=\"01 工厂方法\"></a>01 工厂方法</h2><p>追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：客户类和工厂类分开。</p>\n<p>消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>\n<h2 id=\"02-建造者模式\"><a href=\"#02-建造者模式\" class=\"headerlink\" title=\"02 建造者模式\"></a>02 建造者模式</h2><p>MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。</p>\n<p>建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>\n<h2 id=\"03-抽象工厂\"><a href=\"#03-抽象工厂\" class=\"headerlink\" title=\"03 抽象工厂\"></a>03 抽象工厂</h2><p>请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。</p>\n<p>工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>\n<h2 id=\"04-原型模式\"><a href=\"#04-原型模式\" class=\"headerlink\" title=\"04 原型模式\"></a>04 原型模式</h2><p>跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）</p>\n<p>原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>\n<h2 id=\"05-单态模式\"><a href=\"#05-单态模式\" class=\"headerlink\" title=\"05 单态模式\"></a>05 单态模式</h2><p>俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)</p>\n<p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。</p>\n<h2 id=\"06-适配器模式\"><a href=\"#06-适配器模式\" class=\"headerlink\" title=\"06 适配器模式\"></a>06 适配器模式</h2><p>在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)</p>\n<p>适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>\n<h2 id=\"07-桥梁模式\"><a href=\"#07-桥梁模式\" class=\"headerlink\" title=\"07 桥梁模式\"></a>07 桥梁模式</h2><p>早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了</p>\n<p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。</p>\n<p>08 合成模式 Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？</p>\n<p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>\n<h2 id=\"09-装饰模式\"><a href=\"#09-装饰模式\" class=\"headerlink\" title=\"09 装饰模式\"></a>09 装饰模式</h2><p>Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</p>\n<p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>\n<h2 id=\"10-门面模式\"><a href=\"#10-门面模式\" class=\"headerlink\" title=\"10 门面模式\"></a>10 门面模式</h2><p>我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。</p>\n<p>门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>\n<h2 id=\"11-享元模式\"><a href=\"#11-享元模式\" class=\"headerlink\" title=\"11 享元模式\"></a>11 享元模式</h2><p>每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。</p>\n<p>享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。</p>\n<p>将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>\n<h2 id=\"12-代理模式\"><a href=\"#12-代理模式\" class=\"headerlink\" title=\"12 代理模式\"></a>12 代理模式</h2><p>跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>\n<p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。</p>\n<p>客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>\n<h2 id=\"13-责任链模式\"><a href=\"#13-责任链模式\" class=\"headerlink\" title=\"13 责任链模式\"></a>13 责任链模式</h2><p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！</p>\n<p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>\n<h2 id=\"14-命令模式\"><a href=\"#14-命令模式\" class=\"headerlink\" title=\"14 命令模式\"></a>14 命令模式</h2><p>俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”</p>\n<p>命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>\n<h2 id=\"15-解释器模式\"><a href=\"#15-解释器模式\" class=\"headerlink\" title=\"15 解释器模式\"></a>15 解释器模式</h2><p>俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。</p>\n<p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。</p>\n<p>在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>\n<h2 id=\"16-迭代模式\"><a href=\"#16-迭代模式\" class=\"headerlink\" title=\"16 迭代模式\"></a>16 迭代模式</h2><p>我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”</p>\n<p>迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。</p>\n<p>迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>\n<h2 id=\"17-调停者模式\"><a href=\"#17-调停者模式\" class=\"headerlink\" title=\"17 调停者模式\"></a>17 调停者模式</h2><p>四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。</p>\n<p>当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>\n<h2 id=\"18-备忘录模式\"><a href=\"#18-备忘录模式\" class=\"headerlink\" title=\"18 备忘录模式\"></a>18 备忘录模式</h2><p>同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</p>\n<p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>\n<h2 id=\"19-观察者模式\"><a href=\"#19-观察者模式\" class=\"headerlink\" title=\"19 观察者模式\"></a>19 观察者模式</h2><p>想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。</p>\n<p>观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>\n<h2 id=\"20-状态模式\"><a href=\"#20-状态模式\" class=\"headerlink\" title=\"20 状态模式\"></a>20 状态模式</h2><p>跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。</p>\n<p>状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。</p>\n<p>状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>\n<h2 id=\"21-策略模式\"><a href=\"#21-策略模式\" class=\"headerlink\" title=\"21 策略模式\"></a>21 策略模式</h2><p>跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。</p>\n<p>策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>\n<h2 id=\"22-模板方法模式\"><a href=\"#22-模板方法模式\" class=\"headerlink\" title=\"22 模板方法模式\"></a>22 模板方法模式</h2><p>看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；</p>\n<p>模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>\n<h2 id=\"23-访问者模式\"><a href=\"#23-访问者模式\" class=\"headerlink\" title=\"23 访问者模式\"></a>23 访问者模式</h2><p>情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；</p>\n<p>访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。</p>\n<p>访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>\n"},{"title":"不推荐使用@Autowired注解","top":false,"cover":false,"toc":false,"mathjax":true,"date":"2022-11-04T09:13:35.000Z","password":null,"summary":"Spring和IDEA都不推荐使用@Autowired 注解","_content":"大家在使用IDEA开发的时候有没有注意到过一个提示，在字段上使用Spring的依赖注入注解`@Autowired`后会出现如下警告  \n\n\n> Field injection is not recommended (字段注入是不被推荐的)\n\n但是使用`@Resource`却不会出现此提示\n\n网上文章大部分都是介绍两者的区别，没有提到为什么，当时想了好久想出了可能的原因，今天来总结一下\n\n## Spring常见的DI方式 \n\n *  构造器注入：利用构造方法的参数注入依赖\n *  Setter注入：调用Setter的方法注入依赖\n *  字段注入：在字段上使用`@Autowired/Resource`注解\n\n### @Autowired VS @Resource \n\n事实上，他们的基本功能都是通过注解实现依赖注入，只不过`@Autowired`是`Spring`定义的，而`@Resource`是`JSR-250`定义的。大致功能基本相同，但是还有一些细节不同：\n\n *  依赖识别方式：`@Autowired`默认是byType可以使用`@Qualifier`指定Name，`@Resource`默认ByName如果找不到则ByType\n *  适用对象：`@Autowired`可以对构造器、方法、参数、字段使用，`@Resource`只能对方法、字段使用\n *  提供方：`@Autowired`是Spring提供的，`@Resource`是JSR-250提供的\n\n## 各种DI方式的优缺点 \n\n参考Spring官方文档，建议了如下的使用场景：\n\n *  构造器注入：强依赖性（即必须使用此依赖），不变性（各依赖不会经常变动）\n *  Setter注入：可选（没有此依赖也可以工作），可变（依赖会经常变动）\n *  Field注入：大多数情况下尽量少使用字段注入，一定要使用的话， @Resource相对@Autowired对IoC容器的耦合更低\n\n## Field注入的缺点 \n\n *  不能像构造器那样注入不可变的对象\n *  依赖对外部不可见，外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖\n *  会导致组件与IoC容器紧耦合（这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难）\n *  导致单元测试也必须使用IoC容器，原因同上\n *  依赖过多时不够明显，比如我需要10个依赖，用构造器注入就会显得庞大，这时候应该考虑一下此组件是不是违反了单一职责原则\n\n### 为什么IDEA只对@Autowired警告 \n\nField注入虽然有很多缺点，但它的好处也不可忽略：那就是太方便了。使用构造器或者setter注入需要写更多业务无关的代码，十分麻烦，而字段注入大幅简化了它们。并且绝大多数情况下业务代码和框架就是强绑定的，完全松耦合只是一件理想上的事，牺牲了敏捷度去过度追求松耦合反而得不偿失。\n\n> 那么问题来了，为什么IDEA只对@Autowired警告，却对@Resource视而不见呢？\n\n个人认为，就像我们前面提到过的：@Autowired是Spring提供的，它是特定IoC提供的特定注解，这就导致了应用与框架的强绑定，一旦换用了其他的IoC框架，是不能够支持注入的。\n\n而 @Resource是JSR-250提供的，它是Java标准，我们使用的IoC容器应当去兼容它，这样即使更换容器，也可以正常工作。","source":"_posts/不推荐使用-Autowired注解.md","raw":"---\ntitle: 不推荐使用@Autowired注解\ntop: false\ncover: false\ntoc: false\nmathjax: true\ndate: 2022-11-04 17:13:35\npassword:\nsummary: Spring和IDEA都不推荐使用@Autowired 注解\ntags:\n    - ioc\n    - java\ncategories:\n    - java\n---\n大家在使用IDEA开发的时候有没有注意到过一个提示，在字段上使用Spring的依赖注入注解`@Autowired`后会出现如下警告  \n\n\n> Field injection is not recommended (字段注入是不被推荐的)\n\n但是使用`@Resource`却不会出现此提示\n\n网上文章大部分都是介绍两者的区别，没有提到为什么，当时想了好久想出了可能的原因，今天来总结一下\n\n## Spring常见的DI方式 \n\n *  构造器注入：利用构造方法的参数注入依赖\n *  Setter注入：调用Setter的方法注入依赖\n *  字段注入：在字段上使用`@Autowired/Resource`注解\n\n### @Autowired VS @Resource \n\n事实上，他们的基本功能都是通过注解实现依赖注入，只不过`@Autowired`是`Spring`定义的，而`@Resource`是`JSR-250`定义的。大致功能基本相同，但是还有一些细节不同：\n\n *  依赖识别方式：`@Autowired`默认是byType可以使用`@Qualifier`指定Name，`@Resource`默认ByName如果找不到则ByType\n *  适用对象：`@Autowired`可以对构造器、方法、参数、字段使用，`@Resource`只能对方法、字段使用\n *  提供方：`@Autowired`是Spring提供的，`@Resource`是JSR-250提供的\n\n## 各种DI方式的优缺点 \n\n参考Spring官方文档，建议了如下的使用场景：\n\n *  构造器注入：强依赖性（即必须使用此依赖），不变性（各依赖不会经常变动）\n *  Setter注入：可选（没有此依赖也可以工作），可变（依赖会经常变动）\n *  Field注入：大多数情况下尽量少使用字段注入，一定要使用的话， @Resource相对@Autowired对IoC容器的耦合更低\n\n## Field注入的缺点 \n\n *  不能像构造器那样注入不可变的对象\n *  依赖对外部不可见，外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖\n *  会导致组件与IoC容器紧耦合（这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难）\n *  导致单元测试也必须使用IoC容器，原因同上\n *  依赖过多时不够明显，比如我需要10个依赖，用构造器注入就会显得庞大，这时候应该考虑一下此组件是不是违反了单一职责原则\n\n### 为什么IDEA只对@Autowired警告 \n\nField注入虽然有很多缺点，但它的好处也不可忽略：那就是太方便了。使用构造器或者setter注入需要写更多业务无关的代码，十分麻烦，而字段注入大幅简化了它们。并且绝大多数情况下业务代码和框架就是强绑定的，完全松耦合只是一件理想上的事，牺牲了敏捷度去过度追求松耦合反而得不偿失。\n\n> 那么问题来了，为什么IDEA只对@Autowired警告，却对@Resource视而不见呢？\n\n个人认为，就像我们前面提到过的：@Autowired是Spring提供的，它是特定IoC提供的特定注解，这就导致了应用与框架的强绑定，一旦换用了其他的IoC框架，是不能够支持注入的。\n\n而 @Resource是JSR-250提供的，它是Java标准，我们使用的IoC容器应当去兼容它，这样即使更换容器，也可以正常工作。","slug":"不推荐使用-Autowired注解","published":1,"updated":"2022-11-04T09:28:12.403Z","_id":"cla2a5uer0000rhld2brcd2ez","comments":1,"layout":"post","photos":[],"link":"","content":"<p>大家在使用IDEA开发的时候有没有注意到过一个提示，在字段上使用Spring的依赖注入注解<code>@Autowired</code>后会出现如下警告  </p>\n<blockquote>\n<p>Field injection is not recommended (字段注入是不被推荐的)</p>\n</blockquote>\n<p>但是使用<code>@Resource</code>却不会出现此提示</p>\n<p>网上文章大部分都是介绍两者的区别，没有提到为什么，当时想了好久想出了可能的原因，今天来总结一下</p>\n<h2 id=\"Spring常见的DI方式\"><a href=\"#Spring常见的DI方式\" class=\"headerlink\" title=\"Spring常见的DI方式\"></a>Spring常见的DI方式</h2><ul>\n<li> 构造器注入：利用构造方法的参数注入依赖</li>\n<li> Setter注入：调用Setter的方法注入依赖</li>\n<li> 字段注入：在字段上使用<code>@Autowired/Resource</code>注解</li>\n</ul>\n<h3 id=\"Autowired-VS-Resource\"><a href=\"#Autowired-VS-Resource\" class=\"headerlink\" title=\"@Autowired VS @Resource\"></a>@Autowired VS @Resource</h3><p>事实上，他们的基本功能都是通过注解实现依赖注入，只不过<code>@Autowired</code>是<code>Spring</code>定义的，而<code>@Resource</code>是<code>JSR-250</code>定义的。大致功能基本相同，但是还有一些细节不同：</p>\n<ul>\n<li> 依赖识别方式：<code>@Autowired</code>默认是byType可以使用<code>@Qualifier</code>指定Name，<code>@Resource</code>默认ByName如果找不到则ByType</li>\n<li> 适用对象：<code>@Autowired</code>可以对构造器、方法、参数、字段使用，<code>@Resource</code>只能对方法、字段使用</li>\n<li> 提供方：<code>@Autowired</code>是Spring提供的，<code>@Resource</code>是JSR-250提供的</li>\n</ul>\n<h2 id=\"各种DI方式的优缺点\"><a href=\"#各种DI方式的优缺点\" class=\"headerlink\" title=\"各种DI方式的优缺点\"></a>各种DI方式的优缺点</h2><p>参考Spring官方文档，建议了如下的使用场景：</p>\n<ul>\n<li> 构造器注入：强依赖性（即必须使用此依赖），不变性（各依赖不会经常变动）</li>\n<li> Setter注入：可选（没有此依赖也可以工作），可变（依赖会经常变动）</li>\n<li> Field注入：大多数情况下尽量少使用字段注入，一定要使用的话， @Resource相对@Autowired对IoC容器的耦合更低</li>\n</ul>\n<h2 id=\"Field注入的缺点\"><a href=\"#Field注入的缺点\" class=\"headerlink\" title=\"Field注入的缺点\"></a>Field注入的缺点</h2><ul>\n<li> 不能像构造器那样注入不可变的对象</li>\n<li> 依赖对外部不可见，外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖</li>\n<li> 会导致组件与IoC容器紧耦合（这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难）</li>\n<li> 导致单元测试也必须使用IoC容器，原因同上</li>\n<li> 依赖过多时不够明显，比如我需要10个依赖，用构造器注入就会显得庞大，这时候应该考虑一下此组件是不是违反了单一职责原则</li>\n</ul>\n<h3 id=\"为什么IDEA只对-Autowired警告\"><a href=\"#为什么IDEA只对-Autowired警告\" class=\"headerlink\" title=\"为什么IDEA只对@Autowired警告\"></a>为什么IDEA只对@Autowired警告</h3><p>Field注入虽然有很多缺点，但它的好处也不可忽略：那就是太方便了。使用构造器或者setter注入需要写更多业务无关的代码，十分麻烦，而字段注入大幅简化了它们。并且绝大多数情况下业务代码和框架就是强绑定的，完全松耦合只是一件理想上的事，牺牲了敏捷度去过度追求松耦合反而得不偿失。</p>\n<blockquote>\n<p>那么问题来了，为什么IDEA只对@Autowired警告，却对@Resource视而不见呢？</p>\n</blockquote>\n<p>个人认为，就像我们前面提到过的：@Autowired是Spring提供的，它是特定IoC提供的特定注解，这就导致了应用与框架的强绑定，一旦换用了其他的IoC框架，是不能够支持注入的。</p>\n<p>而 @Resource是JSR-250提供的，它是Java标准，我们使用的IoC容器应当去兼容它，这样即使更换容器，也可以正常工作。</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<p>大家在使用IDEA开发的时候有没有注意到过一个提示，在字段上使用Spring的依赖注入注解<code>@Autowired</code>后会出现如下警告  </p>\n<blockquote>\n<p>Field injection is not recommended (字段注入是不被推荐的)</p>\n</blockquote>\n<p>但是使用<code>@Resource</code>却不会出现此提示</p>\n<p>网上文章大部分都是介绍两者的区别，没有提到为什么，当时想了好久想出了可能的原因，今天来总结一下</p>\n<h2 id=\"Spring常见的DI方式\"><a href=\"#Spring常见的DI方式\" class=\"headerlink\" title=\"Spring常见的DI方式\"></a>Spring常见的DI方式</h2><ul>\n<li> 构造器注入：利用构造方法的参数注入依赖</li>\n<li> Setter注入：调用Setter的方法注入依赖</li>\n<li> 字段注入：在字段上使用<code>@Autowired/Resource</code>注解</li>\n</ul>\n<h3 id=\"Autowired-VS-Resource\"><a href=\"#Autowired-VS-Resource\" class=\"headerlink\" title=\"@Autowired VS @Resource\"></a>@Autowired VS @Resource</h3><p>事实上，他们的基本功能都是通过注解实现依赖注入，只不过<code>@Autowired</code>是<code>Spring</code>定义的，而<code>@Resource</code>是<code>JSR-250</code>定义的。大致功能基本相同，但是还有一些细节不同：</p>\n<ul>\n<li> 依赖识别方式：<code>@Autowired</code>默认是byType可以使用<code>@Qualifier</code>指定Name，<code>@Resource</code>默认ByName如果找不到则ByType</li>\n<li> 适用对象：<code>@Autowired</code>可以对构造器、方法、参数、字段使用，<code>@Resource</code>只能对方法、字段使用</li>\n<li> 提供方：<code>@Autowired</code>是Spring提供的，<code>@Resource</code>是JSR-250提供的</li>\n</ul>\n<h2 id=\"各种DI方式的优缺点\"><a href=\"#各种DI方式的优缺点\" class=\"headerlink\" title=\"各种DI方式的优缺点\"></a>各种DI方式的优缺点</h2><p>参考Spring官方文档，建议了如下的使用场景：</p>\n<ul>\n<li> 构造器注入：强依赖性（即必须使用此依赖），不变性（各依赖不会经常变动）</li>\n<li> Setter注入：可选（没有此依赖也可以工作），可变（依赖会经常变动）</li>\n<li> Field注入：大多数情况下尽量少使用字段注入，一定要使用的话， @Resource相对@Autowired对IoC容器的耦合更低</li>\n</ul>\n<h2 id=\"Field注入的缺点\"><a href=\"#Field注入的缺点\" class=\"headerlink\" title=\"Field注入的缺点\"></a>Field注入的缺点</h2><ul>\n<li> 不能像构造器那样注入不可变的对象</li>\n<li> 依赖对外部不可见，外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖</li>\n<li> 会导致组件与IoC容器紧耦合（这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难）</li>\n<li> 导致单元测试也必须使用IoC容器，原因同上</li>\n<li> 依赖过多时不够明显，比如我需要10个依赖，用构造器注入就会显得庞大，这时候应该考虑一下此组件是不是违反了单一职责原则</li>\n</ul>\n<h3 id=\"为什么IDEA只对-Autowired警告\"><a href=\"#为什么IDEA只对-Autowired警告\" class=\"headerlink\" title=\"为什么IDEA只对@Autowired警告\"></a>为什么IDEA只对@Autowired警告</h3><p>Field注入虽然有很多缺点，但它的好处也不可忽略：那就是太方便了。使用构造器或者setter注入需要写更多业务无关的代码，十分麻烦，而字段注入大幅简化了它们。并且绝大多数情况下业务代码和框架就是强绑定的，完全松耦合只是一件理想上的事，牺牲了敏捷度去过度追求松耦合反而得不偿失。</p>\n<blockquote>\n<p>那么问题来了，为什么IDEA只对@Autowired警告，却对@Resource视而不见呢？</p>\n</blockquote>\n<p>个人认为，就像我们前面提到过的：@Autowired是Spring提供的，它是特定IoC提供的特定注解，这就导致了应用与框架的强绑定，一旦换用了其他的IoC框架，是不能够支持注入的。</p>\n<p>而 @Resource是JSR-250提供的，它是Java标准，我们使用的IoC容器应当去兼容它，这样即使更换容器，也可以正常工作。</p>\n"},{"title":"ConcurrentHashMap是如何保证线程安全","top":true,"cover":false,"toc":false,"mathjax":true,"date":"2022-11-04T09:16:22.000Z","password":null,"summary":"ConcurrentHashmap并发集合框架是线程安全","_content":"\n我们知道，ConcurrentHashmap(1.8)这个并发集合框架是线程安全的，当你看到源码的get操作时，会发现get操作全程是没有加任何锁的，这也是这篇博文讨论的问题——为什么它不需要加锁呢？\n\n### ConcurrentHashMap的简介 \n\n> 我想有基础的同学知道在jdk1.7中是采用Segment + HashEntry + ReentrantLock的方式进行实现的，而1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。\n\n *  JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）\n *  JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了\n *  JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档\n\n### ![image_256782fc.png](ConcurrentHashMap是如何保证线程安全/image_256782fc-20221104171702786.png) \n\n### get操作源码 \n\n * 首先计算hash值，定位到该table索引位置，如果是首节点符合就返回\n\n * 如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回\n\n * 以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null\n\n     \n\n```java\n//会发现源码中没有一处加了锁\npublic V get(Object key) {\n    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n    int h = spread(key.hashCode()); //计算hash\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n      (e = tabAt(tab, (n - 1) & h)) != null) {//读取首节点的Node元素\n        if ((eh = e.hash) == h) { //如果该节点就是首节点就返回\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        //hash值为负值表示正在扩容，这个时候查的是ForwardingNode的find方法来定位到nextTable来\n        //eh=-1，说明该节点是一个ForwardingNode，正在迁移，此时调用ForwardingNode的find方法去nextTable里找。\n        //eh=-2，说明该节点是一个TreeBin，此时调用TreeBin的find方法遍历红黑树，由于红黑树有可能正在旋转变色，所以find里会有读写锁。\n        //eh>=0，说明该节点下挂的是一个链表，直接遍历该链表即可。\n        else if (eh < 0)\n            return (p = e.find(h, key)) != null ? p.val : null;\n        while ((e = e.next) != null) {//既不是首节点也不是ForwardingNode，那就往下遍历\n            if (e.hash == h &&\n             ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                 return e.val;\n        }\n    }\n    return null;\n}\n```\n\n> get没有加锁的话，ConcurrentHashMap是如何保证读到的数据不是脏数据的呢？\n\n### volatile登场 \n\n对于可见性，Java提供了volatile关键字来保证可见性、有序性。但不保证原子性。\n\n普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n\n *  volatile关键字对于基本类型的修改可以在随后对多个线程的读保持一致，但是对于引用类型如数组，实体bean，仅仅保证引用的可见性，但并不保证引用内容的可见性。。\n *  禁止进行指令重排序。\n\n背景：为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。\n\n *  如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。\n *  在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。\n\n  \n\n\n![image_4be279cf.png](ConcurrentHashMap是如何保证线程安全/image_4be279cf-20221104171705595.png)\n\n总结下来：  \n\n\n第一：使用volatile关键字会强制将修改的值立即写入主存；\n\n第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；\n\n第三：由于线程1的工作内存中缓存变量的缓存行无效，所以线程1再次读取变量的值时会去主存读取。\n\n### 是加在数组上的volatile吗? \n\n```java\n    /**\n     * The array of bins. Lazily initialized upon first insertion.\n     * Size is always a power of two. Accessed directly by iterators.\n     */\n    transient volatile Node<K,V>[] table;\n```\n\n我们知道volatile可以修饰数组的，只是意思和它表面上看起来的样子不同。举个栗子，volatile int array\\[10\\]是指array的地址是volatile的而不是数组元素的值是volatile的.\n\n### 用volatile修饰的Node \n\nget操作可以无锁是由于Node的元素val和指针next是用volatile修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    //可以看到这些都用了volatile修饰\n    volatile V val;\n    volatile Node<K,V> next;\n\n    Node(int hash, K key, V val, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.val = val;\n        this.next = next;\n    }\n\n    public final K getKey() { return key; }\n    public final V getValue() { return val; }\n    public final int hashCode() { return key.hashCode() ^ val.hashCode(); }\n    public final String toString(){ return key + \"=\" + val; }\n    public final V setValue(V value) {\n        throw new UnsupportedOperationException();\n    }\n\n    public final boolean equals(Object o) {\n        Object k, v, u; Map.Entry<?,?> e;\n        return ((o instanceof Map.Entry) &&\n          (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&\n          (v = e.getValue()) != null &&\n          (k == key || k.equals(key)) &&\n          (v == (u = val) || v.equals(u))); \n    }\n\n    /**\n    * Virtualized support for map.get(); overridden in subclasses.\n    */\n    Node<K,V> find(int h, Object k) {\n        Node<K,V> e = this;\n        if (k != null) {\n            do {\n                K ek;\n                if (e.hash == h &&\n                 ((ek = e.key) == k || (ek != null && k.equals(ek))))\n                   return e;\n            } while ((e = e.next) != null);\n        }\n        return null;\n    }\n}\n```\n\n> 既然volatile修饰数组对get操作没有效果那加在数组上的volatile的目的是什么呢？\n\n其实就是为了使得Node数组在扩容的时候对其他线程具有可见性而加的volatile\n\n### 总结 \n\n *  在1.8中ConcurrentHashMap的get操作全程不需要加锁，这也是它比其他并发集合比如hashtable、用Collections.synchronizedMap()包装的hashmap;安全效率高的原因之一。\n *  get操作全程不需要加锁是因为Node的成员val是用volatile修饰的和数组用volatile修饰没有关系。\n *  数组用volatile修饰主要是保证在数组扩容的时候保证可见性。\n\n\n\n\n\n  ","source":"_posts/ConcurrentHashMap是如何保证线程安全.md","raw":"---\ntitle: ConcurrentHashMap是如何保证线程安全\ntop: true\ncover: false\ntoc: false\nmathjax: true\ndate: 2022-11-04 17:16:22\npassword:\nsummary: ConcurrentHashmap并发集合框架是线程安全\ntags:\n    - java基础\n    - 源码\ncategories:\n    - java\n---\n\n我们知道，ConcurrentHashmap(1.8)这个并发集合框架是线程安全的，当你看到源码的get操作时，会发现get操作全程是没有加任何锁的，这也是这篇博文讨论的问题——为什么它不需要加锁呢？\n\n### ConcurrentHashMap的简介 \n\n> 我想有基础的同学知道在jdk1.7中是采用Segment + HashEntry + ReentrantLock的方式进行实现的，而1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。\n\n *  JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）\n *  JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了\n *  JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档\n\n### ![image_256782fc.png](ConcurrentHashMap是如何保证线程安全/image_256782fc-20221104171702786.png) \n\n### get操作源码 \n\n * 首先计算hash值，定位到该table索引位置，如果是首节点符合就返回\n\n * 如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回\n\n * 以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null\n\n     \n\n```java\n//会发现源码中没有一处加了锁\npublic V get(Object key) {\n    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n    int h = spread(key.hashCode()); //计算hash\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n      (e = tabAt(tab, (n - 1) & h)) != null) {//读取首节点的Node元素\n        if ((eh = e.hash) == h) { //如果该节点就是首节点就返回\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        //hash值为负值表示正在扩容，这个时候查的是ForwardingNode的find方法来定位到nextTable来\n        //eh=-1，说明该节点是一个ForwardingNode，正在迁移，此时调用ForwardingNode的find方法去nextTable里找。\n        //eh=-2，说明该节点是一个TreeBin，此时调用TreeBin的find方法遍历红黑树，由于红黑树有可能正在旋转变色，所以find里会有读写锁。\n        //eh>=0，说明该节点下挂的是一个链表，直接遍历该链表即可。\n        else if (eh < 0)\n            return (p = e.find(h, key)) != null ? p.val : null;\n        while ((e = e.next) != null) {//既不是首节点也不是ForwardingNode，那就往下遍历\n            if (e.hash == h &&\n             ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                 return e.val;\n        }\n    }\n    return null;\n}\n```\n\n> get没有加锁的话，ConcurrentHashMap是如何保证读到的数据不是脏数据的呢？\n\n### volatile登场 \n\n对于可见性，Java提供了volatile关键字来保证可见性、有序性。但不保证原子性。\n\n普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n\n *  volatile关键字对于基本类型的修改可以在随后对多个线程的读保持一致，但是对于引用类型如数组，实体bean，仅仅保证引用的可见性，但并不保证引用内容的可见性。。\n *  禁止进行指令重排序。\n\n背景：为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。\n\n *  如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。\n *  在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。\n\n  \n\n\n![image_4be279cf.png](ConcurrentHashMap是如何保证线程安全/image_4be279cf-20221104171705595.png)\n\n总结下来：  \n\n\n第一：使用volatile关键字会强制将修改的值立即写入主存；\n\n第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；\n\n第三：由于线程1的工作内存中缓存变量的缓存行无效，所以线程1再次读取变量的值时会去主存读取。\n\n### 是加在数组上的volatile吗? \n\n```java\n    /**\n     * The array of bins. Lazily initialized upon first insertion.\n     * Size is always a power of two. Accessed directly by iterators.\n     */\n    transient volatile Node<K,V>[] table;\n```\n\n我们知道volatile可以修饰数组的，只是意思和它表面上看起来的样子不同。举个栗子，volatile int array\\[10\\]是指array的地址是volatile的而不是数组元素的值是volatile的.\n\n### 用volatile修饰的Node \n\nget操作可以无锁是由于Node的元素val和指针next是用volatile修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    //可以看到这些都用了volatile修饰\n    volatile V val;\n    volatile Node<K,V> next;\n\n    Node(int hash, K key, V val, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.val = val;\n        this.next = next;\n    }\n\n    public final K getKey() { return key; }\n    public final V getValue() { return val; }\n    public final int hashCode() { return key.hashCode() ^ val.hashCode(); }\n    public final String toString(){ return key + \"=\" + val; }\n    public final V setValue(V value) {\n        throw new UnsupportedOperationException();\n    }\n\n    public final boolean equals(Object o) {\n        Object k, v, u; Map.Entry<?,?> e;\n        return ((o instanceof Map.Entry) &&\n          (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&\n          (v = e.getValue()) != null &&\n          (k == key || k.equals(key)) &&\n          (v == (u = val) || v.equals(u))); \n    }\n\n    /**\n    * Virtualized support for map.get(); overridden in subclasses.\n    */\n    Node<K,V> find(int h, Object k) {\n        Node<K,V> e = this;\n        if (k != null) {\n            do {\n                K ek;\n                if (e.hash == h &&\n                 ((ek = e.key) == k || (ek != null && k.equals(ek))))\n                   return e;\n            } while ((e = e.next) != null);\n        }\n        return null;\n    }\n}\n```\n\n> 既然volatile修饰数组对get操作没有效果那加在数组上的volatile的目的是什么呢？\n\n其实就是为了使得Node数组在扩容的时候对其他线程具有可见性而加的volatile\n\n### 总结 \n\n *  在1.8中ConcurrentHashMap的get操作全程不需要加锁，这也是它比其他并发集合比如hashtable、用Collections.synchronizedMap()包装的hashmap;安全效率高的原因之一。\n *  get操作全程不需要加锁是因为Node的成员val是用volatile修饰的和数组用volatile修饰没有关系。\n *  数组用volatile修饰主要是保证在数组扩容的时候保证可见性。\n\n\n\n\n\n  ","slug":"ConcurrentHashMap是如何保证线程安全","published":1,"updated":"2022-11-04T09:28:25.831Z","_id":"cla2aa3710000vbld679fgjml","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我们知道，ConcurrentHashmap(1.8)这个并发集合框架是线程安全的，当你看到源码的get操作时，会发现get操作全程是没有加任何锁的，这也是这篇博文讨论的问题——为什么它不需要加锁呢？</p>\n<h3 id=\"ConcurrentHashMap的简介\"><a href=\"#ConcurrentHashMap的简介\" class=\"headerlink\" title=\"ConcurrentHashMap的简介\"></a>ConcurrentHashMap的简介</h3><blockquote>\n<p>我想有基础的同学知道在jdk1.7中是采用Segment + HashEntry + ReentrantLock的方式进行实现的，而1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。</p>\n</blockquote>\n<ul>\n<li> JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）</li>\n<li> JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了</li>\n<li> JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档</li>\n</ul>\n<h3 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"/2022/11/04/concurrenthashmap-shi-ru-he-bao-zheng-xian-cheng-an-quan/image_256782fc-20221104171702786.png\" alt=\"image_256782fc.png\"></h3><h3 id=\"get操作源码\"><a href=\"#get操作源码\" class=\"headerlink\" title=\"get操作源码\"></a>get操作源码</h3><ul>\n<li><p>首先计算hash值，定位到该table索引位置，如果是首节点符合就返回</p>\n</li>\n<li><p>如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回</p>\n</li>\n<li><p>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//会发现源码中没有一处加了锁</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">V</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tab<span class=\"token punctuation\">;</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> e<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">;</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> eh<span class=\"token punctuation\">;</span> <span class=\"token class-name\">K</span> ek<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> h <span class=\"token operator\">=</span> <span class=\"token function\">spread</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//计算hash</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span>\n      <span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> <span class=\"token function\">tabAt</span><span class=\"token punctuation\">(</span>tab<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//读取首节点的Node元素</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>eh <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>hash<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> h<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//如果该节点就是首节点就返回</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ek <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>ek <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>ek<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//hash值为负值表示正在扩容，这个时候查的是ForwardingNode的find方法来定位到nextTable来</span>\n        <span class=\"token comment\">//eh=-1，说明该节点是一个ForwardingNode，正在迁移，此时调用ForwardingNode的find方法去nextTable里找。</span>\n        <span class=\"token comment\">//eh=-2，说明该节点是一个TreeBin，此时调用TreeBin的find方法遍历红黑树，由于红黑树有可能正在旋转变色，所以find里会有读写锁。</span>\n        <span class=\"token comment\">//eh>=0，说明该节点下挂的是一个链表，直接遍历该链表即可。</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>eh <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> p<span class=\"token punctuation\">.</span>val <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//既不是首节点也不是ForwardingNode，那就往下遍历</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> h <span class=\"token operator\">&amp;&amp;</span>\n             <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ek <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>ek <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>ek<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                 <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>get没有加锁的话，ConcurrentHashMap是如何保证读到的数据不是脏数据的呢？</p>\n</blockquote>\n<h3 id=\"volatile登场\"><a href=\"#volatile登场\" class=\"headerlink\" title=\"volatile登场\"></a>volatile登场</h3><p>对于可见性，Java提供了volatile关键字来保证可见性、有序性。但不保证原子性。</p>\n<p>普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>\n<ul>\n<li> volatile关键字对于基本类型的修改可以在随后对多个线程的读保持一致，但是对于引用类型如数组，实体bean，仅仅保证引用的可见性，但并不保证引用内容的可见性。。</li>\n<li> 禁止进行指令重排序。</li>\n</ul>\n<p>背景：为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。</p>\n<ul>\n<li> 如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。</li>\n<li>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。</li>\n</ul>\n<p><img src=\"/2022/11/04/concurrenthashmap-shi-ru-he-bao-zheng-xian-cheng-an-quan/image_4be279cf-20221104171705595.png\" alt=\"image_4be279cf.png\"></p>\n<p>总结下来：  </p>\n<p>第一：使用volatile关键字会强制将修改的值立即写入主存；</p>\n<p>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>\n<p>第三：由于线程1的工作内存中缓存变量的缓存行无效，所以线程1再次读取变量的值时会去主存读取。</p>\n<h3 id=\"是加在数组上的volatile吗\"><a href=\"#是加在数组上的volatile吗\" class=\"headerlink\" title=\"是加在数组上的volatile吗?\"></a>是加在数组上的volatile吗?</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * The array of bins. Lazily initialized upon first insertion.\n * Size is always a power of two. Accessed directly by iterators.\n */</span>\n<span class=\"token keyword\">transient</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> table<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们知道volatile可以修饰数组的，只是意思和它表面上看起来的样子不同。举个栗子，volatile int array[10]是指array的地址是volatile的而不是数组元素的值是volatile的.</p>\n<h3 id=\"用volatile修饰的Node\"><a href=\"#用volatile修饰的Node\" class=\"headerlink\" title=\"用volatile修饰的Node\"></a>用volatile修饰的Node</h3><p>get操作可以无锁是由于Node的元素val和指针next是用volatile修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">K</span> key<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//可以看到这些都用了volatile修饰</span>\n    <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">V</span> val<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> next<span class=\"token punctuation\">;</span>\n\n    <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">,</span> <span class=\"token class-name\">K</span> key<span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span> val<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>hash <span class=\"token operator\">=</span> hash<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>key <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>val <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">K</span> <span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> key<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">V</span> <span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> val<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> val<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> key <span class=\"token operator\">+</span> <span class=\"token string\">\"=\"</span> <span class=\"token operator\">+</span> val<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">V</span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UnsupportedOperationException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Object</span> k<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">;</span> <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> e<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>o <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n          <span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span>\n          <span class=\"token punctuation\">(</span>v <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span>\n          <span class=\"token punctuation\">(</span>k <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> k<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n          <span class=\"token punctuation\">(</span>v <span class=\"token operator\">==</span> <span class=\"token punctuation\">(</span>u <span class=\"token operator\">=</span> val<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> v<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n    * Virtualized support for map.get(); overridden in subclasses.\n    */</span>\n    <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> e <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">do</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token class-name\">K</span> ek<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> h <span class=\"token operator\">&amp;&amp;</span>\n                 <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ek <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> k <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>ek <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> k<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>ek<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                   <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>既然volatile修饰数组对get操作没有效果那加在数组上的volatile的目的是什么呢？</p>\n</blockquote>\n<p>其实就是为了使得Node数组在扩容的时候对其他线程具有可见性而加的volatile</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li> 在1.8中ConcurrentHashMap的get操作全程不需要加锁，这也是它比其他并发集合比如hashtable、用Collections.synchronizedMap()包装的hashmap;安全效率高的原因之一。</li>\n<li> get操作全程不需要加锁是因为Node的成员val是用volatile修饰的和数组用volatile修饰没有关系。</li>\n<li> 数组用volatile修饰主要是保证在数组扩容的时候保证可见性。</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<p>我们知道，ConcurrentHashmap(1.8)这个并发集合框架是线程安全的，当你看到源码的get操作时，会发现get操作全程是没有加任何锁的，这也是这篇博文讨论的问题——为什么它不需要加锁呢？</p>\n<h3 id=\"ConcurrentHashMap的简介\"><a href=\"#ConcurrentHashMap的简介\" class=\"headerlink\" title=\"ConcurrentHashMap的简介\"></a>ConcurrentHashMap的简介</h3><blockquote>\n<p>我想有基础的同学知道在jdk1.7中是采用Segment + HashEntry + ReentrantLock的方式进行实现的，而1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。</p>\n</blockquote>\n<ul>\n<li> JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）</li>\n<li> JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了</li>\n<li> JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档</li>\n</ul>\n<h3 id><a href=\"#\" class=\"headerlink\" title></a><img src=\"/2022/11/04/concurrenthashmap-shi-ru-he-bao-zheng-xian-cheng-an-quan/image_256782fc-20221104171702786.png\" alt=\"image_256782fc.png\"></h3><h3 id=\"get操作源码\"><a href=\"#get操作源码\" class=\"headerlink\" title=\"get操作源码\"></a>get操作源码</h3><ul>\n<li><p>首先计算hash值，定位到该table索引位置，如果是首节点符合就返回</p>\n</li>\n<li><p>如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回</p>\n</li>\n<li><p>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//会发现源码中没有一处加了锁</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">V</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tab<span class=\"token punctuation\">;</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> e<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">;</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> eh<span class=\"token punctuation\">;</span> <span class=\"token class-name\">K</span> ek<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> h <span class=\"token operator\">=</span> <span class=\"token function\">spread</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//计算hash</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span>\n      <span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> <span class=\"token function\">tabAt</span><span class=\"token punctuation\">(</span>tab<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//读取首节点的Node元素</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>eh <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>hash<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> h<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//如果该节点就是首节点就返回</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ek <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>ek <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>ek<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//hash值为负值表示正在扩容，这个时候查的是ForwardingNode的find方法来定位到nextTable来</span>\n        <span class=\"token comment\">//eh=-1，说明该节点是一个ForwardingNode，正在迁移，此时调用ForwardingNode的find方法去nextTable里找。</span>\n        <span class=\"token comment\">//eh=-2，说明该节点是一个TreeBin，此时调用TreeBin的find方法遍历红黑树，由于红黑树有可能正在旋转变色，所以find里会有读写锁。</span>\n        <span class=\"token comment\">//eh>=0，说明该节点下挂的是一个链表，直接遍历该链表即可。</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>eh <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> p<span class=\"token punctuation\">.</span>val <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//既不是首节点也不是ForwardingNode，那就往下遍历</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> h <span class=\"token operator\">&amp;&amp;</span>\n             <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ek <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>ek <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>ek<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                 <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>get没有加锁的话，ConcurrentHashMap是如何保证读到的数据不是脏数据的呢？</p>\n</blockquote>\n<h3 id=\"volatile登场\"><a href=\"#volatile登场\" class=\"headerlink\" title=\"volatile登场\"></a>volatile登场</h3><p>对于可见性，Java提供了volatile关键字来保证可见性、有序性。但不保证原子性。</p>\n<p>普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>\n<ul>\n<li> volatile关键字对于基本类型的修改可以在随后对多个线程的读保持一致，但是对于引用类型如数组，实体bean，仅仅保证引用的可见性，但并不保证引用内容的可见性。。</li>\n<li> 禁止进行指令重排序。</li>\n</ul>\n<p>背景：为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。</p>\n<ul>\n<li> 如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。</li>\n<li>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。</li>\n</ul>\n<p><img src=\"/2022/11/04/concurrenthashmap-shi-ru-he-bao-zheng-xian-cheng-an-quan/image_4be279cf-20221104171705595.png\" alt=\"image_4be279cf.png\"></p>\n<p>总结下来：  </p>\n<p>第一：使用volatile关键字会强制将修改的值立即写入主存；</p>\n<p>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>\n<p>第三：由于线程1的工作内存中缓存变量的缓存行无效，所以线程1再次读取变量的值时会去主存读取。</p>\n<h3 id=\"是加在数组上的volatile吗\"><a href=\"#是加在数组上的volatile吗\" class=\"headerlink\" title=\"是加在数组上的volatile吗?\"></a>是加在数组上的volatile吗?</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * The array of bins. Lazily initialized upon first insertion.\n * Size is always a power of two. Accessed directly by iterators.\n */</span>\n<span class=\"token keyword\">transient</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> table<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们知道volatile可以修饰数组的，只是意思和它表面上看起来的样子不同。举个栗子，volatile int array[10]是指array的地址是volatile的而不是数组元素的值是volatile的.</p>\n<h3 id=\"用volatile修饰的Node\"><a href=\"#用volatile修饰的Node\" class=\"headerlink\" title=\"用volatile修饰的Node\"></a>用volatile修饰的Node</h3><p>get操作可以无锁是由于Node的元素val和指针next是用volatile修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">K</span> key<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//可以看到这些都用了volatile修饰</span>\n    <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">V</span> val<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> next<span class=\"token punctuation\">;</span>\n\n    <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">,</span> <span class=\"token class-name\">K</span> key<span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span> val<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>hash <span class=\"token operator\">=</span> hash<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>key <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>val <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">K</span> <span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> key<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">V</span> <span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> val<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> val<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> key <span class=\"token operator\">+</span> <span class=\"token string\">\"=\"</span> <span class=\"token operator\">+</span> val<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">V</span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UnsupportedOperationException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Object</span> k<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">;</span> <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> e<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>o <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n          <span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span>\n          <span class=\"token punctuation\">(</span>v <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span>\n          <span class=\"token punctuation\">(</span>k <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> k<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n          <span class=\"token punctuation\">(</span>v <span class=\"token operator\">==</span> <span class=\"token punctuation\">(</span>u <span class=\"token operator\">=</span> val<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> v<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">/**\n    * Virtualized support for map.get(); overridden in subclasses.\n    */</span>\n    <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> h<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Node</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> e <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">do</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token class-name\">K</span> ek<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> h <span class=\"token operator\">&amp;&amp;</span>\n                 <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ek <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> k <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>ek <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> k<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>ek<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                   <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>既然volatile修饰数组对get操作没有效果那加在数组上的volatile的目的是什么呢？</p>\n</blockquote>\n<p>其实就是为了使得Node数组在扩容的时候对其他线程具有可见性而加的volatile</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li> 在1.8中ConcurrentHashMap的get操作全程不需要加锁，这也是它比其他并发集合比如hashtable、用Collections.synchronizedMap()包装的hashmap;安全效率高的原因之一。</li>\n<li> get操作全程不需要加锁是因为Node的成员val是用volatile修饰的和数组用volatile修饰没有关系。</li>\n<li> 数组用volatile修饰主要是保证在数组扩容的时候保证可见性。</li>\n</ul>\n"},{"title":"SpringBoot内置工具类","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-11-07T02:12:23.000Z","password":null,"summary":"SpringBoot内置工具类","_content":"\n\n\n最近发现同事写了不少重复的工具类，发现其中很多功能，Spring 自带的都有。于是整理了本文，希望能够帮助到大家！\n\n## 断言 \n\n1.  断言是一个逻辑判断，用于检查不应该发生的情况\n2.  Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数 `-enableassertions`开启\n3.  SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查\n\n```java\n// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行\n// 参数 message 参数用于定制异常信息。\nvoid notNull(Object object, String message)\n// 要求参数必须空（Null），否则抛出异常，不予『放行』。\n// 和 notNull() 方法断言规则相反\nvoid isNull(Object object, String message)\n// 要求参数必须为真（True），否则抛出异常，不予『放行』。\nvoid isTrue(boolean expression, String message)\n// 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行\nvoid notEmpty(Collection collection, String message)\n// 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行\nvoid hasLength(String text, String message)\n// 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行\nvoid hasText(String text, String message)\n// 要求参数是指定类型的实例，否则抛出异常，不予放行\nvoid isInstanceOf(Class type, Object obj, String message)\n// 要求参数 `subType` 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行\nvoid isAssignable(Class superType, Class subType, String message)\n```\n\n## 对象、数组、集合 \n\n### ObjectUtils \n\n1.  获取对象的基本信息\n\n```java\n// 获取对象的类名。参数为 null 时，返回字符串：\"null\" \nString nullSafeClassName(Object obj)\n// 参数为 null 时，返回 0\nint nullSafeHashCode(Object object)\n// 参数为 null 时，返回字符串：\"null\"\nString nullSafeToString(boolean[] array)\n// 获取对象 HashCode（十六进制形式字符串）。参数为 null 时，返回 0 \nString getIdentityHexString(Object obj)\n// 获取对象的类名和 HashCode。 参数为 null 时，返回字符串：\"\" \nString identityToString(Object obj)\n// 相当于 toString()方法，但参数为 null 时，返回字符串：\"\"\nString getDisplayString(Object obj)\n```\n\n2. 判断工具\n\n```java\n// 判断数组是否为空\nboolean isEmpty(Object[] array)\n// 判断参数对象是否是数组\nboolean isArray(Object obj)\n// 判断数组中是否包含指定元素\nboolean containsElement(Object[] array, Object element)\n// 相等，或同为 null时，返回 true\nboolean nullSafeEquals(Object o1, Object o2)\n/*\n判断参数对象是否为空，判断标准为：\n    Optional: Optional.empty()\n       Array: length == 0\nCharSequence: length == 0\n  Collection: Collection.isEmpty()\n         Map: Map.isEmpty()\n */\nboolean isEmpty(Object obj)\n```\n\n3.其他工具方法\n\n```java\n// 向参数数组的末尾追加新元素，并返回一个新数组\n<A, O extends A> A[] addObjectToArray(A[] array, O obj)\n// 原生基础类型数组 --> 包装类数组\nObject[] toObjectArray(Object source)\n```\n\n### StringUtils \n\n1.  字符串判断工具\n\n```java\n// 判断字符串是否为 null，或 \"\"。注意，包含空白符的字符串为非空\nboolean isEmpty(Object str)\n// 判断字符串是否是以指定内容结束。忽略大小写\nboolean endsWithIgnoreCase(String str, String suffix)\n// 判断字符串是否已指定内容开头。忽略大小写\nboolean startsWithIgnoreCase(String str, String prefix) \n// 是否包含空白符\nboolean containsWhitespace(String str)\n// 判断字符串非空且长度不为 0，即，Not Empty\nboolean hasLength(CharSequence str)\n// 判断字符串是否包含实际内容，即非仅包含空白符，也就是 Not Blank\nboolean hasText(CharSequence str)\n// 判断字符串指定索引处是否包含一个子串。\nboolean substringMatch(CharSequence str, int index, CharSequence substring)\n// 计算一个字符串中指定子串的出现次数\nint countOccurrencesOf(String str, String sub)\n```\n\n2.字符串操作工具\n\n```java\n// 查找并替换指定子串\nString replace(String inString, String oldPattern, String newPattern)\n// 去除尾部的特定字符\nString trimTrailingCharacter(String str, char trailingCharacter) \n// 去除头部的特定字符\nString trimLeadingCharacter(String str, char leadingCharacter)\n// 去除头部的空白符\nString trimLeadingWhitespace(String str)\n// 去除头部的空白符\nString trimTrailingWhitespace(String str)\n// 去除头部和尾部的空白符\nString trimWhitespace(String str)\n// 删除开头、结尾和中间的空白符\nString trimAllWhitespace(String str)\n// 删除指定子串\nString delete(String inString, String pattern)\n// 删除指定字符（可以是多个）\nString deleteAny(String inString, String charsToDelete)\n// 对数组的每一项执行 trim() 方法\nString[] trimArrayElements(String[] array)\n// 将 URL 字符串进行解码\nString uriDecode(String source, Charset charset)\n```\n\n3.路径相关工具方法\n\n```java\n// 解析路径字符串，优化其中的 “..” \nString cleanPath(String path)\n// 解析路径字符串，解析出文件名部分\nString getFilename(String path)\n// 解析路径字符串，解析出文件后缀名\nString getFilenameExtension(String path)\n// 比较两个两个字符串，判断是否是同一个路径。会自动处理路径中的 “..” \nboolean pathEquals(String path1, String path2)\n// 删除文件路径名中的后缀部分\nString stripFilenameExtension(String path) \n// 以 “. 作为分隔符，获取其最后一部分\nString unqualify(String qualifiedName)\n// 以指定字符作为分隔符，获取其最后一部分\nString unqualify(String qualifiedName, char separator)\n```\n\n### CollectionUtils \n\n1.  集合判断工具\n\n```java\n// 判断 List/Set 是否为空\nboolean isEmpty(Collection<?> collection)\n// 判断 Map 是否为空\nboolean isEmpty(Map<?,?> map)\n// 判断 List/Set 中是否包含某个对象\nboolean containsInstance(Collection<?> collection, Object element)\n// 以迭代器的方式，判断 List/Set 中是否包含某个对象\nboolean contains(Iterator<?> iterator, Object element)\n// 判断 List/Set 是否包含某些对象中的任意一个\nboolean containsAny(Collection<?> source, Collection<?> candidates)\n// 判断 List/Set 中的每个元素是否唯一。即 List/Set 中不存在重复元素\nboolean hasUniqueObject(Collection<?> collection)\n```\n\n2.集合操作工具\n\n```java\n// 将 Array 中的元素都添加到 List/Set 中\n<E> void mergeArrayIntoCollection(Object array, Collection<E> collection)  \n// 将 Properties 中的键值对都添加到 Map 中\n<K,V> void mergePropertiesIntoMap(Properties props, Map<K,V> map)\n// 返回 List 中最后一个元素\n<T> T lastElement(List<T> list)  \n// 返回 Set 中最后一个元素\n<T> T lastElement(Set<T> set) \n// 返回参数 candidates 中第一个存在于参数 source 中的元素\n<E> E findFirstMatch(Collection<?> source, Collection<E> candidates)\n// 返回 List/Set 中指定类型的元素。\n<T> T findValueOfType(Collection<?> collection, Class<T> type)\n// 返回 List/Set 中指定类型的元素。如果第一种类型未找到，则查找第二种类型，以此类推\nObject findValueOfType(Collection<?> collection, Class<?>[] types)\n// 返回 List/Set 中元素的类型\nClass<?> findCommonElementType(Collectio<?> collection)\n```\n\n## 文件、资源、IO 流 \n\n### FileCopyUtils \n\n1.  输入\n\n```java\n// 从文件中读入到字节数组中\nbyte[] copyToByteArray(File in)\n// 从输入流中读入到字节数组中\nbyte[] copyToByteArray(InputStream in)\n// 从输入流中读入到字符串中\nString copyToString(Reader in)\n```\n\n2.输出\n\n```java\n// 从字节数组到文件\nvoid copy(byte[] in, File out)\n// 从文件到文件\nint copy(File in, File out)\n// 从字节数组到输出流\nvoid copy(byte[] in, OutputStream out) \n// 从输入流到输出流\nint copy(InputStream in, OutputStream out) \n// 从输入流到输出流\nint copy(Reader in, Writer out)\n// 从字符串到输出流\nvoid copy(String in, Writer out)\n```\n\n### ResourceUtils \n\n1.  从资源路径获取文件\n\n```java\n// 判断字符串是否是一个合法的 URL 字符串。\nstatic boolean isUrl(String resourceLocation)\n// 获取 URL\nstatic URL getURL(String resourceLocation) \n// 获取文件（在 JAR 包内无法正常使用，需要是一个独立的文件）\nstatic File getFile(String resourceLocation)\n```\n\n2.Resource\n\n```java\n// 文件系统资源 D:\\...\nFileSystemResource\n// URL 资源，如 file://... http://...\nUrlResource\n// 类路径下的资源，classpth:...\nClassPathResource\n// Web 容器上下文中的资源（jar 包、war 包）\nServletContextResource\n// 判断资源是否存在\nboolean exists()\n// 从资源中获得 File 对象\nFile getFile()\n// 从资源中获得 URI 对象\nURI getURI()\n// 从资源中获得 URI 对象\nURL getURL()\n// 获得资源的 InputStream\nInputStream getInputStream()\n// 获得资源的描述信息\nString getDescription()\n```\n\n### StreamUtils \n\n1.  输入\n\n```java\nvoid copy(byte[] in, OutputStream out)\nint copy(InputStream in, OutputStream out)\nvoid copy(String in, Charset charset, OutputStream out)\nlong copyRange(InputStream in, OutputStream out, long start, long end)\n```\n\n2.输出\n\n```java\nbyte[] copyToByteArray(InputStream in)\nString copyToString(InputStream in, Charset charset)\n// 舍弃输入流中的内容\nint drain(InputStream in) \n```\n\n## 反射、AOP \n\n### ReflectionUtils \n\n1.  获取方法\n\n```java\n// 在类中查找指定方法\nMethod findMethod(Class<?> clazz, String name) \n// 同上，额外提供方法参数类型作查找条件\nMethod findMethod(Class<?> clazz, String name, Class<?>... paramTypes) \n// 获得类中所有方法，包括继承而来的\nMethod[] getAllDeclaredMethods(Class<?> leafClass) \n// 在类中查找指定构造方法\nConstructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes) \n// 是否是 equals() 方法\nboolean isEqualsMethod(Method method) \n// 是否是 hashCode() 方法 \nboolean isHashCodeMethod(Method method) \n// 是否是 toString() 方法\nboolean isToStringMethod(Method method) \n// 是否是从 Object 类继承而来的方法\nboolean isObjectMethod(Method method) \n// 检查一个方法是否声明抛出指定异常\nboolean declaresException(Method method, Class<?> exceptionType) \n```\n\n2.执行方法\n\n```java\n// 执行方法\nObject invokeMethod(Method method, Object target)  \n// 同上，提供方法参数\nObject invokeMethod(Method method, Object target, Object... args) \n// 取消 Java 权限检查。以便后续执行该私有方法\nvoid makeAccessible(Method method) \n// 取消 Java 权限检查。以便后续执行私有构造方法\nvoid makeAccessible(Constructor<?> ctor) \n```\n\n3.获取字段\n\n```java\n// 在类中查找指定属性\nField findField(Class<?> clazz, String name) \n// 同上，多提供了属性的类型\nField findField(Class<?> clazz, String name, Class<?> type) \n// 是否为一个 \"public static final\" 属性\nboolean isPublicStaticFinal(Field field) \n```\n\n4.设置字段\n\n```java\n// 获取 target 对象的 field 属性值\nObject getField(Field field, Object target) \n// 设置 target 对象的 field 属性值，值为 value\nvoid setField(Field field, Object target, Object value) \n// 同类对象属性对等赋值\nvoid shallowCopyFieldState(Object src, Object dest)\n// 取消 Java 的权限控制检查。以便后续读写该私有属性\nvoid makeAccessible(Field field) \n// 对类的每个属性执行 callback\nvoid doWithFields(Class<?> clazz, ReflectionUtils.FieldCallback fc) \n// 同上，多了个属性过滤功能。\nvoid doWithFields(Class<?> clazz, ReflectionUtils.FieldCallback fc, \n                  ReflectionUtils.FieldFilter ff) \n// 同上，但不包括继承而来的属性\nvoid doWithLocalFields(Class<?> clazz, ReflectionUtils.FieldCallback fc) \n```\n\n### AopUtils \n\n1.  判断代理类型\n\n```java\n// 判断是不是 Spring 代理对象\nboolean isAopProxy()\n// 判断是不是 jdk 动态代理对象\nisJdkDynamicProxy()\n// 判断是不是 CGLIB 代理对象\nboolean isCglibProxy()\n```\n\n2.获取被代理对象的 class\n\n```java\n// 获取被代理的目标 class\nClass<?> getTargetClass()\n```\n\n### AopContext \n\n1.  获取当前对象的代理对象\n\n```java\nObject currentProxy()\n```","source":"_posts/SpringBoot内置工具类.md","raw":"---\ntitle: SpringBoot内置工具类\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-11-07 10:12:23\npassword:\nsummary: SpringBoot内置工具类\ntags:\n    - 工具轮子\ncategories:\n    - java\n    - spring\n---\n\n\n\n最近发现同事写了不少重复的工具类，发现其中很多功能，Spring 自带的都有。于是整理了本文，希望能够帮助到大家！\n\n## 断言 \n\n1.  断言是一个逻辑判断，用于检查不应该发生的情况\n2.  Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数 `-enableassertions`开启\n3.  SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查\n\n```java\n// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行\n// 参数 message 参数用于定制异常信息。\nvoid notNull(Object object, String message)\n// 要求参数必须空（Null），否则抛出异常，不予『放行』。\n// 和 notNull() 方法断言规则相反\nvoid isNull(Object object, String message)\n// 要求参数必须为真（True），否则抛出异常，不予『放行』。\nvoid isTrue(boolean expression, String message)\n// 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行\nvoid notEmpty(Collection collection, String message)\n// 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行\nvoid hasLength(String text, String message)\n// 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行\nvoid hasText(String text, String message)\n// 要求参数是指定类型的实例，否则抛出异常，不予放行\nvoid isInstanceOf(Class type, Object obj, String message)\n// 要求参数 `subType` 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行\nvoid isAssignable(Class superType, Class subType, String message)\n```\n\n## 对象、数组、集合 \n\n### ObjectUtils \n\n1.  获取对象的基本信息\n\n```java\n// 获取对象的类名。参数为 null 时，返回字符串：\"null\" \nString nullSafeClassName(Object obj)\n// 参数为 null 时，返回 0\nint nullSafeHashCode(Object object)\n// 参数为 null 时，返回字符串：\"null\"\nString nullSafeToString(boolean[] array)\n// 获取对象 HashCode（十六进制形式字符串）。参数为 null 时，返回 0 \nString getIdentityHexString(Object obj)\n// 获取对象的类名和 HashCode。 参数为 null 时，返回字符串：\"\" \nString identityToString(Object obj)\n// 相当于 toString()方法，但参数为 null 时，返回字符串：\"\"\nString getDisplayString(Object obj)\n```\n\n2. 判断工具\n\n```java\n// 判断数组是否为空\nboolean isEmpty(Object[] array)\n// 判断参数对象是否是数组\nboolean isArray(Object obj)\n// 判断数组中是否包含指定元素\nboolean containsElement(Object[] array, Object element)\n// 相等，或同为 null时，返回 true\nboolean nullSafeEquals(Object o1, Object o2)\n/*\n判断参数对象是否为空，判断标准为：\n    Optional: Optional.empty()\n       Array: length == 0\nCharSequence: length == 0\n  Collection: Collection.isEmpty()\n         Map: Map.isEmpty()\n */\nboolean isEmpty(Object obj)\n```\n\n3.其他工具方法\n\n```java\n// 向参数数组的末尾追加新元素，并返回一个新数组\n<A, O extends A> A[] addObjectToArray(A[] array, O obj)\n// 原生基础类型数组 --> 包装类数组\nObject[] toObjectArray(Object source)\n```\n\n### StringUtils \n\n1.  字符串判断工具\n\n```java\n// 判断字符串是否为 null，或 \"\"。注意，包含空白符的字符串为非空\nboolean isEmpty(Object str)\n// 判断字符串是否是以指定内容结束。忽略大小写\nboolean endsWithIgnoreCase(String str, String suffix)\n// 判断字符串是否已指定内容开头。忽略大小写\nboolean startsWithIgnoreCase(String str, String prefix) \n// 是否包含空白符\nboolean containsWhitespace(String str)\n// 判断字符串非空且长度不为 0，即，Not Empty\nboolean hasLength(CharSequence str)\n// 判断字符串是否包含实际内容，即非仅包含空白符，也就是 Not Blank\nboolean hasText(CharSequence str)\n// 判断字符串指定索引处是否包含一个子串。\nboolean substringMatch(CharSequence str, int index, CharSequence substring)\n// 计算一个字符串中指定子串的出现次数\nint countOccurrencesOf(String str, String sub)\n```\n\n2.字符串操作工具\n\n```java\n// 查找并替换指定子串\nString replace(String inString, String oldPattern, String newPattern)\n// 去除尾部的特定字符\nString trimTrailingCharacter(String str, char trailingCharacter) \n// 去除头部的特定字符\nString trimLeadingCharacter(String str, char leadingCharacter)\n// 去除头部的空白符\nString trimLeadingWhitespace(String str)\n// 去除头部的空白符\nString trimTrailingWhitespace(String str)\n// 去除头部和尾部的空白符\nString trimWhitespace(String str)\n// 删除开头、结尾和中间的空白符\nString trimAllWhitespace(String str)\n// 删除指定子串\nString delete(String inString, String pattern)\n// 删除指定字符（可以是多个）\nString deleteAny(String inString, String charsToDelete)\n// 对数组的每一项执行 trim() 方法\nString[] trimArrayElements(String[] array)\n// 将 URL 字符串进行解码\nString uriDecode(String source, Charset charset)\n```\n\n3.路径相关工具方法\n\n```java\n// 解析路径字符串，优化其中的 “..” \nString cleanPath(String path)\n// 解析路径字符串，解析出文件名部分\nString getFilename(String path)\n// 解析路径字符串，解析出文件后缀名\nString getFilenameExtension(String path)\n// 比较两个两个字符串，判断是否是同一个路径。会自动处理路径中的 “..” \nboolean pathEquals(String path1, String path2)\n// 删除文件路径名中的后缀部分\nString stripFilenameExtension(String path) \n// 以 “. 作为分隔符，获取其最后一部分\nString unqualify(String qualifiedName)\n// 以指定字符作为分隔符，获取其最后一部分\nString unqualify(String qualifiedName, char separator)\n```\n\n### CollectionUtils \n\n1.  集合判断工具\n\n```java\n// 判断 List/Set 是否为空\nboolean isEmpty(Collection<?> collection)\n// 判断 Map 是否为空\nboolean isEmpty(Map<?,?> map)\n// 判断 List/Set 中是否包含某个对象\nboolean containsInstance(Collection<?> collection, Object element)\n// 以迭代器的方式，判断 List/Set 中是否包含某个对象\nboolean contains(Iterator<?> iterator, Object element)\n// 判断 List/Set 是否包含某些对象中的任意一个\nboolean containsAny(Collection<?> source, Collection<?> candidates)\n// 判断 List/Set 中的每个元素是否唯一。即 List/Set 中不存在重复元素\nboolean hasUniqueObject(Collection<?> collection)\n```\n\n2.集合操作工具\n\n```java\n// 将 Array 中的元素都添加到 List/Set 中\n<E> void mergeArrayIntoCollection(Object array, Collection<E> collection)  \n// 将 Properties 中的键值对都添加到 Map 中\n<K,V> void mergePropertiesIntoMap(Properties props, Map<K,V> map)\n// 返回 List 中最后一个元素\n<T> T lastElement(List<T> list)  \n// 返回 Set 中最后一个元素\n<T> T lastElement(Set<T> set) \n// 返回参数 candidates 中第一个存在于参数 source 中的元素\n<E> E findFirstMatch(Collection<?> source, Collection<E> candidates)\n// 返回 List/Set 中指定类型的元素。\n<T> T findValueOfType(Collection<?> collection, Class<T> type)\n// 返回 List/Set 中指定类型的元素。如果第一种类型未找到，则查找第二种类型，以此类推\nObject findValueOfType(Collection<?> collection, Class<?>[] types)\n// 返回 List/Set 中元素的类型\nClass<?> findCommonElementType(Collectio<?> collection)\n```\n\n## 文件、资源、IO 流 \n\n### FileCopyUtils \n\n1.  输入\n\n```java\n// 从文件中读入到字节数组中\nbyte[] copyToByteArray(File in)\n// 从输入流中读入到字节数组中\nbyte[] copyToByteArray(InputStream in)\n// 从输入流中读入到字符串中\nString copyToString(Reader in)\n```\n\n2.输出\n\n```java\n// 从字节数组到文件\nvoid copy(byte[] in, File out)\n// 从文件到文件\nint copy(File in, File out)\n// 从字节数组到输出流\nvoid copy(byte[] in, OutputStream out) \n// 从输入流到输出流\nint copy(InputStream in, OutputStream out) \n// 从输入流到输出流\nint copy(Reader in, Writer out)\n// 从字符串到输出流\nvoid copy(String in, Writer out)\n```\n\n### ResourceUtils \n\n1.  从资源路径获取文件\n\n```java\n// 判断字符串是否是一个合法的 URL 字符串。\nstatic boolean isUrl(String resourceLocation)\n// 获取 URL\nstatic URL getURL(String resourceLocation) \n// 获取文件（在 JAR 包内无法正常使用，需要是一个独立的文件）\nstatic File getFile(String resourceLocation)\n```\n\n2.Resource\n\n```java\n// 文件系统资源 D:\\...\nFileSystemResource\n// URL 资源，如 file://... http://...\nUrlResource\n// 类路径下的资源，classpth:...\nClassPathResource\n// Web 容器上下文中的资源（jar 包、war 包）\nServletContextResource\n// 判断资源是否存在\nboolean exists()\n// 从资源中获得 File 对象\nFile getFile()\n// 从资源中获得 URI 对象\nURI getURI()\n// 从资源中获得 URI 对象\nURL getURL()\n// 获得资源的 InputStream\nInputStream getInputStream()\n// 获得资源的描述信息\nString getDescription()\n```\n\n### StreamUtils \n\n1.  输入\n\n```java\nvoid copy(byte[] in, OutputStream out)\nint copy(InputStream in, OutputStream out)\nvoid copy(String in, Charset charset, OutputStream out)\nlong copyRange(InputStream in, OutputStream out, long start, long end)\n```\n\n2.输出\n\n```java\nbyte[] copyToByteArray(InputStream in)\nString copyToString(InputStream in, Charset charset)\n// 舍弃输入流中的内容\nint drain(InputStream in) \n```\n\n## 反射、AOP \n\n### ReflectionUtils \n\n1.  获取方法\n\n```java\n// 在类中查找指定方法\nMethod findMethod(Class<?> clazz, String name) \n// 同上，额外提供方法参数类型作查找条件\nMethod findMethod(Class<?> clazz, String name, Class<?>... paramTypes) \n// 获得类中所有方法，包括继承而来的\nMethod[] getAllDeclaredMethods(Class<?> leafClass) \n// 在类中查找指定构造方法\nConstructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes) \n// 是否是 equals() 方法\nboolean isEqualsMethod(Method method) \n// 是否是 hashCode() 方法 \nboolean isHashCodeMethod(Method method) \n// 是否是 toString() 方法\nboolean isToStringMethod(Method method) \n// 是否是从 Object 类继承而来的方法\nboolean isObjectMethod(Method method) \n// 检查一个方法是否声明抛出指定异常\nboolean declaresException(Method method, Class<?> exceptionType) \n```\n\n2.执行方法\n\n```java\n// 执行方法\nObject invokeMethod(Method method, Object target)  \n// 同上，提供方法参数\nObject invokeMethod(Method method, Object target, Object... args) \n// 取消 Java 权限检查。以便后续执行该私有方法\nvoid makeAccessible(Method method) \n// 取消 Java 权限检查。以便后续执行私有构造方法\nvoid makeAccessible(Constructor<?> ctor) \n```\n\n3.获取字段\n\n```java\n// 在类中查找指定属性\nField findField(Class<?> clazz, String name) \n// 同上，多提供了属性的类型\nField findField(Class<?> clazz, String name, Class<?> type) \n// 是否为一个 \"public static final\" 属性\nboolean isPublicStaticFinal(Field field) \n```\n\n4.设置字段\n\n```java\n// 获取 target 对象的 field 属性值\nObject getField(Field field, Object target) \n// 设置 target 对象的 field 属性值，值为 value\nvoid setField(Field field, Object target, Object value) \n// 同类对象属性对等赋值\nvoid shallowCopyFieldState(Object src, Object dest)\n// 取消 Java 的权限控制检查。以便后续读写该私有属性\nvoid makeAccessible(Field field) \n// 对类的每个属性执行 callback\nvoid doWithFields(Class<?> clazz, ReflectionUtils.FieldCallback fc) \n// 同上，多了个属性过滤功能。\nvoid doWithFields(Class<?> clazz, ReflectionUtils.FieldCallback fc, \n                  ReflectionUtils.FieldFilter ff) \n// 同上，但不包括继承而来的属性\nvoid doWithLocalFields(Class<?> clazz, ReflectionUtils.FieldCallback fc) \n```\n\n### AopUtils \n\n1.  判断代理类型\n\n```java\n// 判断是不是 Spring 代理对象\nboolean isAopProxy()\n// 判断是不是 jdk 动态代理对象\nisJdkDynamicProxy()\n// 判断是不是 CGLIB 代理对象\nboolean isCglibProxy()\n```\n\n2.获取被代理对象的 class\n\n```java\n// 获取被代理的目标 class\nClass<?> getTargetClass()\n```\n\n### AopContext \n\n1.  获取当前对象的代理对象\n\n```java\nObject currentProxy()\n```","slug":"SpringBoot内置工具类","published":1,"updated":"2022-11-07T02:14:08.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cla65gxi60000msld6qyr7te5","content":"<p>最近发现同事写了不少重复的工具类，发现其中很多功能，Spring 自带的都有。于是整理了本文，希望能够帮助到大家！</p>\n<h2 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h2><ol>\n<li> 断言是一个逻辑判断，用于检查不应该发生的情况</li>\n<li> Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数 <code>-enableassertions</code>开启</li>\n<li> SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行</span>\n<span class=\"token comment\">// 参数 message 参数用于定制异常信息。</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">notNull</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> object<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 要求参数必须空（Null），否则抛出异常，不予『放行』。</span>\n<span class=\"token comment\">// 和 notNull() 方法断言规则相反</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">isNull</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> object<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 要求参数必须为真（True），否则抛出异常，不予『放行』。</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> expression<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">notEmpty</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span> collection<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">hasLength</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> text<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">hasText</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> text<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 要求参数是指定类型的实例，否则抛出异常，不予放行</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">isInstanceOf</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span> type<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 要求参数 `subType` 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">isAssignable</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span> superType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span> subType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"对象、数组、集合\"><a href=\"#对象、数组、集合\" class=\"headerlink\" title=\"对象、数组、集合\"></a>对象、数组、集合</h2><h3 id=\"ObjectUtils\"><a href=\"#ObjectUtils\" class=\"headerlink\" title=\"ObjectUtils\"></a>ObjectUtils</h3><ol>\n<li> 获取对象的基本信息</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 获取对象的类名。参数为 null 时，返回字符串：\"null\" </span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">nullSafeClassName</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 参数为 null 时，返回 0</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">nullSafeHashCode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> object<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 参数为 null 时，返回字符串：\"null\"</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">nullSafeToString</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 获取对象 HashCode（十六进制形式字符串）。参数为 null 时，返回 0 </span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">getIdentityHexString</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 获取对象的类名和 HashCode。 参数为 null 时，返回字符串：\"\" </span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">identityToString</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 相当于 toString()方法，但参数为 null 时，返回字符串：\"\"</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">getDisplayString</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol start=\"2\">\n<li>判断工具</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 判断数组是否为空</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断参数对象是否是数组</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断数组中是否包含指定元素</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">containsElement</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> element<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 相等，或同为 null时，返回 true</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">nullSafeEquals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> o2<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">/*\n判断参数对象是否为空，判断标准为：\n    Optional: Optional.empty()\n       Array: length == 0\nCharSequence: length == 0\n  Collection: Collection.isEmpty()\n         Map: Map.isEmpty()\n */</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>3.其他工具方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 向参数数组的末尾追加新元素，并返回一个新数组</span>\n<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">O</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">addObjectToArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">A</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">,</span> <span class=\"token class-name\">O</span> obj<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 原生基础类型数组 --> 包装类数组</span>\n<span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">toObjectArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> source<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"StringUtils\"><a href=\"#StringUtils\" class=\"headerlink\" title=\"StringUtils\"></a>StringUtils</h3><ol>\n<li> 字符串判断工具</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 判断字符串是否为 null，或 \"\"。注意，包含空白符的字符串为非空</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断字符串是否是以指定内容结束。忽略大小写</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">endsWithIgnoreCase</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> suffix<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断字符串是否已指定内容开头。忽略大小写</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">startsWithIgnoreCase</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> prefix<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 是否包含空白符</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">containsWhitespace</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断字符串非空且长度不为 0，即，Not Empty</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">hasLength</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CharSequence</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断字符串是否包含实际内容，即非仅包含空白符，也就是 Not Blank</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">hasText</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CharSequence</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断字符串指定索引处是否包含一个子串。</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">substringMatch</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CharSequence</span> str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">,</span> <span class=\"token class-name\">CharSequence</span> substring<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 计算一个字符串中指定子串的出现次数</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">countOccurrencesOf</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> sub<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.字符串操作工具</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 查找并替换指定子串</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> inString<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> oldPattern<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> newPattern<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 去除尾部的特定字符</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">trimTrailingCharacter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> trailingCharacter<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 去除头部的特定字符</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">trimLeadingCharacter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> leadingCharacter<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 去除头部的空白符</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">trimLeadingWhitespace</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 去除头部的空白符</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">trimTrailingWhitespace</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 去除头部和尾部的空白符</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">trimWhitespace</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 删除开头、结尾和中间的空白符</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">trimAllWhitespace</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 删除指定子串</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> inString<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> pattern<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 删除指定字符（可以是多个）</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">deleteAny</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> inString<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> charsToDelete<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 对数组的每一项执行 trim() 方法</span>\n<span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">trimArrayElements</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 将 URL 字符串进行解码</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">uriDecode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> source<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Charset</span> charset<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>3.路径相关工具方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 解析路径字符串，优化其中的 “..” </span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">cleanPath</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> path<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 解析路径字符串，解析出文件名部分</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">getFilename</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> path<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 解析路径字符串，解析出文件后缀名</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">getFilenameExtension</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> path<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 比较两个两个字符串，判断是否是同一个路径。会自动处理路径中的 “..” </span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">pathEquals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> path1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> path2<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 删除文件路径名中的后缀部分</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">stripFilenameExtension</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> path<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 以 “. 作为分隔符，获取其最后一部分</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">unqualify</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> qualifiedName<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 以指定字符作为分隔符，获取其最后一部分</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">unqualify</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> qualifiedName<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> separator<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"CollectionUtils\"><a href=\"#CollectionUtils\" class=\"headerlink\" title=\"CollectionUtils\"></a>CollectionUtils</h3><ol>\n<li> 集合判断工具</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 判断 List/Set 是否为空</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> collection<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断 Map 是否为空</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> map<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断 List/Set 中是否包含某个对象</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">containsInstance</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> collection<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> element<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 以迭代器的方式，判断 List/Set 中是否包含某个对象</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Iterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> iterator<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> element<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断 List/Set 是否包含某些对象中的任意一个</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">containsAny</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> source<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> candidates<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断 List/Set 中的每个元素是否唯一。即 List/Set 中不存在重复元素</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">hasUniqueObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> collection<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.集合操作工具</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 将 Array 中的元素都添加到 List/Set 中</span>\n<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">void</span> <span class=\"token function\">mergeArrayIntoCollection</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> array<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> collection<span class=\"token punctuation\">)</span>  \n<span class=\"token comment\">// 将 Properties 中的键值对都添加到 Map 中</span>\n<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">void</span> <span class=\"token function\">mergePropertiesIntoMap</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Properties</span> props<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> map<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 返回 List 中最后一个元素</span>\n<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">lastElement</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> list<span class=\"token punctuation\">)</span>  \n<span class=\"token comment\">// 返回 Set 中最后一个元素</span>\n<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">lastElement</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> set<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 返回参数 candidates 中第一个存在于参数 source 中的元素</span>\n<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">E</span> <span class=\"token function\">findFirstMatch</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> source<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> candidates<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 返回 List/Set 中指定类型的元素。</span>\n<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">findValueOfType</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> collection<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> type<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 返回 List/Set 中指定类型的元素。如果第一种类型未找到，则查找第二种类型，以此类推</span>\n<span class=\"token class-name\">Object</span> <span class=\"token function\">findValueOfType</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> collection<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> types<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 返回 List/Set 中元素的类型</span>\n<span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findCommonElementType</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectio</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> collection<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"文件、资源、IO-流\"><a href=\"#文件、资源、IO-流\" class=\"headerlink\" title=\"文件、资源、IO 流\"></a>文件、资源、IO 流</h2><h3 id=\"FileCopyUtils\"><a href=\"#FileCopyUtils\" class=\"headerlink\" title=\"FileCopyUtils\"></a>FileCopyUtils</h3><ol>\n<li> 输入</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 从文件中读入到字节数组中</span>\n<span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">copyToByteArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">File</span> in<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从输入流中读入到字节数组中</span>\n<span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">copyToByteArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从输入流中读入到字符串中</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">copyToString</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Reader</span> in<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.输出</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 从字节数组到文件</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">File</span> out<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从文件到文件</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">File</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">File</span> out<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从字节数组到输出流</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">OutputStream</span> out<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 从输入流到输出流</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">OutputStream</span> out<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 从输入流到输出流</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Reader</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Writer</span> out<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从字符串到输出流</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Writer</span> out<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"ResourceUtils\"><a href=\"#ResourceUtils\" class=\"headerlink\" title=\"ResourceUtils\"></a>ResourceUtils</h3><ol>\n<li> 从资源路径获取文件</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 判断字符串是否是一个合法的 URL 字符串。</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isUrl</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> resourceLocation<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 获取 URL</span>\n<span class=\"token keyword\">static</span> <span class=\"token class-name\">URL</span> <span class=\"token function\">getURL</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> resourceLocation<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 获取文件（在 JAR 包内无法正常使用，需要是一个独立的文件）</span>\n<span class=\"token keyword\">static</span> <span class=\"token class-name\">File</span> <span class=\"token function\">getFile</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> resourceLocation<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.Resource</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 文件系统资源 D:\\...</span>\n<span class=\"token class-name\">FileSystemResource</span>\n<span class=\"token comment\">// URL 资源，如 file://... http://...</span>\n<span class=\"token class-name\">UrlResource</span>\n<span class=\"token comment\">// 类路径下的资源，classpth:...</span>\n<span class=\"token class-name\">ClassPathResource</span>\n<span class=\"token comment\">// Web 容器上下文中的资源（jar 包、war 包）</span>\n<span class=\"token class-name\">ServletContextResource</span>\n<span class=\"token comment\">// 判断资源是否存在</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">exists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从资源中获得 File 对象</span>\n<span class=\"token class-name\">File</span> <span class=\"token function\">getFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从资源中获得 URI 对象</span>\n<span class=\"token class-name\">URI</span> <span class=\"token function\">getURI</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从资源中获得 URI 对象</span>\n<span class=\"token class-name\">URL</span> <span class=\"token function\">getURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 获得资源的 InputStream</span>\n<span class=\"token class-name\">InputStream</span> <span class=\"token function\">getInputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 获得资源的描述信息</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">getDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"StreamUtils\"><a href=\"#StreamUtils\" class=\"headerlink\" title=\"StreamUtils\"></a>StreamUtils</h3><ol>\n<li> 输入</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">OutputStream</span> out<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">OutputStream</span> out<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Charset</span> charset<span class=\"token punctuation\">,</span> <span class=\"token class-name\">OutputStream</span> out<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">long</span> <span class=\"token function\">copyRange</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">OutputStream</span> out<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> end<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.输出</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">copyToByteArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in<span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">copyToString</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Charset</span> charset<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 舍弃输入流中的内容</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">drain</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in<span class=\"token punctuation\">)</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"反射、AOP\"><a href=\"#反射、AOP\" class=\"headerlink\" title=\"反射、AOP\"></a>反射、AOP</h2><h3 id=\"ReflectionUtils\"><a href=\"#ReflectionUtils\" class=\"headerlink\" title=\"ReflectionUtils\"></a>ReflectionUtils</h3><ol>\n<li> 获取方法</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 在类中查找指定方法</span>\n<span class=\"token class-name\">Method</span> <span class=\"token function\">findMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 同上，额外提供方法参数类型作查找条件</span>\n<span class=\"token class-name\">Method</span> <span class=\"token function\">findMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> paramTypes<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 获得类中所有方法，包括继承而来的</span>\n<span class=\"token class-name\">Method</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">getAllDeclaredMethods</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> leafClass<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 在类中查找指定构造方法</span>\n<span class=\"token class-name\">Constructor</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">accessibleConstructor</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> parameterTypes<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 是否是 equals() 方法</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isEqualsMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 是否是 hashCode() 方法 </span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isHashCodeMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 是否是 toString() 方法</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isToStringMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 是否是从 Object 类继承而来的方法</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isObjectMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 检查一个方法是否声明抛出指定异常</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">declaresException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> exceptionType<span class=\"token punctuation\">)</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.执行方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 执行方法</span>\n<span class=\"token class-name\">Object</span> <span class=\"token function\">invokeMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> target<span class=\"token punctuation\">)</span>  \n<span class=\"token comment\">// 同上，提供方法参数</span>\n<span class=\"token class-name\">Object</span> <span class=\"token function\">invokeMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> target<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> args<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 取消 Java 权限检查。以便后续执行该私有方法</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">makeAccessible</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 取消 Java 权限检查。以便后续执行私有构造方法</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">makeAccessible</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Constructor</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> ctor<span class=\"token punctuation\">)</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>3.获取字段</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 在类中查找指定属性</span>\n<span class=\"token class-name\">Field</span> <span class=\"token function\">findField</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 同上，多提供了属性的类型</span>\n<span class=\"token class-name\">Field</span> <span class=\"token function\">findField</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> type<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 是否为一个 \"public static final\" 属性</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isPublicStaticFinal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Field</span> field<span class=\"token punctuation\">)</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>4.设置字段</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 获取 target 对象的 field 属性值</span>\n<span class=\"token class-name\">Object</span> <span class=\"token function\">getField</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Field</span> field<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> target<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 设置 target 对象的 field 属性值，值为 value</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">setField</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Field</span> field<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> target<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> value<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 同类对象属性对等赋值</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">shallowCopyFieldState</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> src<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> dest<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 取消 Java 的权限控制检查。以便后续读写该私有属性</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">makeAccessible</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Field</span> field<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 对类的每个属性执行 callback</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">doWithFields</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ReflectionUtils<span class=\"token punctuation\">.</span>FieldCallback</span> fc<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 同上，多了个属性过滤功能。</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">doWithFields</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ReflectionUtils<span class=\"token punctuation\">.</span>FieldCallback</span> fc<span class=\"token punctuation\">,</span> \n                  <span class=\"token class-name\">ReflectionUtils<span class=\"token punctuation\">.</span>FieldFilter</span> ff<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 同上，但不包括继承而来的属性</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">doWithLocalFields</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ReflectionUtils<span class=\"token punctuation\">.</span>FieldCallback</span> fc<span class=\"token punctuation\">)</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"AopUtils\"><a href=\"#AopUtils\" class=\"headerlink\" title=\"AopUtils\"></a>AopUtils</h3><ol>\n<li> 判断代理类型</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 判断是不是 Spring 代理对象</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isAopProxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断是不是 jdk 动态代理对象</span>\n<span class=\"token function\">isJdkDynamicProxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断是不是 CGLIB 代理对象</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isCglibProxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.获取被代理对象的 class</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 获取被代理的目标 class</span>\n<span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">getTargetClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"AopContext\"><a href=\"#AopContext\" class=\"headerlink\" title=\"AopContext\"></a>AopContext</h3><ol>\n<li> 获取当前对象的代理对象</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Object</span> <span class=\"token function\">currentProxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<p>最近发现同事写了不少重复的工具类，发现其中很多功能，Spring 自带的都有。于是整理了本文，希望能够帮助到大家！</p>\n<h2 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h2><ol>\n<li> 断言是一个逻辑判断，用于检查不应该发生的情况</li>\n<li> Assert 关键字在 JDK1.4 中引入，可通过 JVM 参数 <code>-enableassertions</code>开启</li>\n<li> SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行</span>\n<span class=\"token comment\">// 参数 message 参数用于定制异常信息。</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">notNull</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> object<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 要求参数必须空（Null），否则抛出异常，不予『放行』。</span>\n<span class=\"token comment\">// 和 notNull() 方法断言规则相反</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">isNull</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> object<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 要求参数必须为真（True），否则抛出异常，不予『放行』。</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> expression<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">notEmpty</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span> collection<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">hasLength</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> text<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">hasText</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> text<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 要求参数是指定类型的实例，否则抛出异常，不予放行</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">isInstanceOf</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span> type<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 要求参数 `subType` 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">isAssignable</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span> superType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span> subType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> message<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"对象、数组、集合\"><a href=\"#对象、数组、集合\" class=\"headerlink\" title=\"对象、数组、集合\"></a>对象、数组、集合</h2><h3 id=\"ObjectUtils\"><a href=\"#ObjectUtils\" class=\"headerlink\" title=\"ObjectUtils\"></a>ObjectUtils</h3><ol>\n<li> 获取对象的基本信息</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 获取对象的类名。参数为 null 时，返回字符串：\"null\" </span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">nullSafeClassName</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 参数为 null 时，返回 0</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">nullSafeHashCode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> object<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 参数为 null 时，返回字符串：\"null\"</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">nullSafeToString</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 获取对象 HashCode（十六进制形式字符串）。参数为 null 时，返回 0 </span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">getIdentityHexString</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 获取对象的类名和 HashCode。 参数为 null 时，返回字符串：\"\" </span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">identityToString</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 相当于 toString()方法，但参数为 null 时，返回字符串：\"\"</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">getDisplayString</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol start=\"2\">\n<li>判断工具</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 判断数组是否为空</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断参数对象是否是数组</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断数组中是否包含指定元素</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">containsElement</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> element<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 相等，或同为 null时，返回 true</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">nullSafeEquals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> o2<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">/*\n判断参数对象是否为空，判断标准为：\n    Optional: Optional.empty()\n       Array: length == 0\nCharSequence: length == 0\n  Collection: Collection.isEmpty()\n         Map: Map.isEmpty()\n */</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> obj<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>3.其他工具方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 向参数数组的末尾追加新元素，并返回一个新数组</span>\n<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">O</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">addObjectToArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">A</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">,</span> <span class=\"token class-name\">O</span> obj<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 原生基础类型数组 --> 包装类数组</span>\n<span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">toObjectArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> source<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"StringUtils\"><a href=\"#StringUtils\" class=\"headerlink\" title=\"StringUtils\"></a>StringUtils</h3><ol>\n<li> 字符串判断工具</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 判断字符串是否为 null，或 \"\"。注意，包含空白符的字符串为非空</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断字符串是否是以指定内容结束。忽略大小写</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">endsWithIgnoreCase</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> suffix<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断字符串是否已指定内容开头。忽略大小写</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">startsWithIgnoreCase</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> prefix<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 是否包含空白符</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">containsWhitespace</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断字符串非空且长度不为 0，即，Not Empty</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">hasLength</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CharSequence</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断字符串是否包含实际内容，即非仅包含空白符，也就是 Not Blank</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">hasText</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CharSequence</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断字符串指定索引处是否包含一个子串。</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">substringMatch</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CharSequence</span> str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">,</span> <span class=\"token class-name\">CharSequence</span> substring<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 计算一个字符串中指定子串的出现次数</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">countOccurrencesOf</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> sub<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.字符串操作工具</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 查找并替换指定子串</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> inString<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> oldPattern<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> newPattern<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 去除尾部的特定字符</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">trimTrailingCharacter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> trailingCharacter<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 去除头部的特定字符</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">trimLeadingCharacter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> leadingCharacter<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 去除头部的空白符</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">trimLeadingWhitespace</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 去除头部的空白符</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">trimTrailingWhitespace</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 去除头部和尾部的空白符</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">trimWhitespace</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 删除开头、结尾和中间的空白符</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">trimAllWhitespace</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> str<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 删除指定子串</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> inString<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> pattern<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 删除指定字符（可以是多个）</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">deleteAny</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> inString<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> charsToDelete<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 对数组的每一项执行 trim() 方法</span>\n<span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">trimArrayElements</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 将 URL 字符串进行解码</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">uriDecode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> source<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Charset</span> charset<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>3.路径相关工具方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 解析路径字符串，优化其中的 “..” </span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">cleanPath</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> path<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 解析路径字符串，解析出文件名部分</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">getFilename</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> path<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 解析路径字符串，解析出文件后缀名</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">getFilenameExtension</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> path<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 比较两个两个字符串，判断是否是同一个路径。会自动处理路径中的 “..” </span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">pathEquals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> path1<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> path2<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 删除文件路径名中的后缀部分</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">stripFilenameExtension</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> path<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 以 “. 作为分隔符，获取其最后一部分</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">unqualify</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> qualifiedName<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 以指定字符作为分隔符，获取其最后一部分</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">unqualify</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> qualifiedName<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> separator<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"CollectionUtils\"><a href=\"#CollectionUtils\" class=\"headerlink\" title=\"CollectionUtils\"></a>CollectionUtils</h3><ol>\n<li> 集合判断工具</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 判断 List/Set 是否为空</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> collection<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断 Map 是否为空</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> map<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断 List/Set 中是否包含某个对象</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">containsInstance</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> collection<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> element<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 以迭代器的方式，判断 List/Set 中是否包含某个对象</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Iterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> iterator<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> element<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断 List/Set 是否包含某些对象中的任意一个</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">containsAny</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> source<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> candidates<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断 List/Set 中的每个元素是否唯一。即 List/Set 中不存在重复元素</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">hasUniqueObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> collection<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.集合操作工具</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 将 Array 中的元素都添加到 List/Set 中</span>\n<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">void</span> <span class=\"token function\">mergeArrayIntoCollection</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> array<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> collection<span class=\"token punctuation\">)</span>  \n<span class=\"token comment\">// 将 Properties 中的键值对都添加到 Map 中</span>\n<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">void</span> <span class=\"token function\">mergePropertiesIntoMap</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Properties</span> props<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> map<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 返回 List 中最后一个元素</span>\n<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">lastElement</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> list<span class=\"token punctuation\">)</span>  \n<span class=\"token comment\">// 返回 Set 中最后一个元素</span>\n<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">lastElement</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> set<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 返回参数 candidates 中第一个存在于参数 source 中的元素</span>\n<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">E</span> <span class=\"token function\">findFirstMatch</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> source<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> candidates<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 返回 List/Set 中指定类型的元素。</span>\n<span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">findValueOfType</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> collection<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> type<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 返回 List/Set 中指定类型的元素。如果第一种类型未找到，则查找第二种类型，以此类推</span>\n<span class=\"token class-name\">Object</span> <span class=\"token function\">findValueOfType</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> collection<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> types<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 返回 List/Set 中元素的类型</span>\n<span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findCommonElementType</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collectio</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> collection<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"文件、资源、IO-流\"><a href=\"#文件、资源、IO-流\" class=\"headerlink\" title=\"文件、资源、IO 流\"></a>文件、资源、IO 流</h2><h3 id=\"FileCopyUtils\"><a href=\"#FileCopyUtils\" class=\"headerlink\" title=\"FileCopyUtils\"></a>FileCopyUtils</h3><ol>\n<li> 输入</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 从文件中读入到字节数组中</span>\n<span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">copyToByteArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">File</span> in<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从输入流中读入到字节数组中</span>\n<span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">copyToByteArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从输入流中读入到字符串中</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">copyToString</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Reader</span> in<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.输出</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 从字节数组到文件</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">File</span> out<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从文件到文件</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">File</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">File</span> out<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从字节数组到输出流</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">OutputStream</span> out<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 从输入流到输出流</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">OutputStream</span> out<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 从输入流到输出流</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Reader</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Writer</span> out<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从字符串到输出流</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Writer</span> out<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"ResourceUtils\"><a href=\"#ResourceUtils\" class=\"headerlink\" title=\"ResourceUtils\"></a>ResourceUtils</h3><ol>\n<li> 从资源路径获取文件</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 判断字符串是否是一个合法的 URL 字符串。</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isUrl</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> resourceLocation<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 获取 URL</span>\n<span class=\"token keyword\">static</span> <span class=\"token class-name\">URL</span> <span class=\"token function\">getURL</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> resourceLocation<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 获取文件（在 JAR 包内无法正常使用，需要是一个独立的文件）</span>\n<span class=\"token keyword\">static</span> <span class=\"token class-name\">File</span> <span class=\"token function\">getFile</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> resourceLocation<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.Resource</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 文件系统资源 D:\\...</span>\n<span class=\"token class-name\">FileSystemResource</span>\n<span class=\"token comment\">// URL 资源，如 file://... http://...</span>\n<span class=\"token class-name\">UrlResource</span>\n<span class=\"token comment\">// 类路径下的资源，classpth:...</span>\n<span class=\"token class-name\">ClassPathResource</span>\n<span class=\"token comment\">// Web 容器上下文中的资源（jar 包、war 包）</span>\n<span class=\"token class-name\">ServletContextResource</span>\n<span class=\"token comment\">// 判断资源是否存在</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">exists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从资源中获得 File 对象</span>\n<span class=\"token class-name\">File</span> <span class=\"token function\">getFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从资源中获得 URI 对象</span>\n<span class=\"token class-name\">URI</span> <span class=\"token function\">getURI</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 从资源中获得 URI 对象</span>\n<span class=\"token class-name\">URL</span> <span class=\"token function\">getURL</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 获得资源的 InputStream</span>\n<span class=\"token class-name\">InputStream</span> <span class=\"token function\">getInputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 获得资源的描述信息</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">getDescription</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"StreamUtils\"><a href=\"#StreamUtils\" class=\"headerlink\" title=\"StreamUtils\"></a>StreamUtils</h3><ol>\n<li> 输入</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">OutputStream</span> out<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">OutputStream</span> out<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Charset</span> charset<span class=\"token punctuation\">,</span> <span class=\"token class-name\">OutputStream</span> out<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">long</span> <span class=\"token function\">copyRange</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">OutputStream</span> out<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> end<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.输出</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">copyToByteArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in<span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">String</span> <span class=\"token function\">copyToString</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Charset</span> charset<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 舍弃输入流中的内容</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">drain</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">InputStream</span> in<span class=\"token punctuation\">)</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"反射、AOP\"><a href=\"#反射、AOP\" class=\"headerlink\" title=\"反射、AOP\"></a>反射、AOP</h2><h3 id=\"ReflectionUtils\"><a href=\"#ReflectionUtils\" class=\"headerlink\" title=\"ReflectionUtils\"></a>ReflectionUtils</h3><ol>\n<li> 获取方法</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 在类中查找指定方法</span>\n<span class=\"token class-name\">Method</span> <span class=\"token function\">findMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 同上，额外提供方法参数类型作查找条件</span>\n<span class=\"token class-name\">Method</span> <span class=\"token function\">findMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> paramTypes<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 获得类中所有方法，包括继承而来的</span>\n<span class=\"token class-name\">Method</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">getAllDeclaredMethods</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> leafClass<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 在类中查找指定构造方法</span>\n<span class=\"token class-name\">Constructor</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">accessibleConstructor</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> parameterTypes<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 是否是 equals() 方法</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isEqualsMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 是否是 hashCode() 方法 </span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isHashCodeMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 是否是 toString() 方法</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isToStringMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 是否是从 Object 类继承而来的方法</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isObjectMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 检查一个方法是否声明抛出指定异常</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">declaresException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> exceptionType<span class=\"token punctuation\">)</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.执行方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 执行方法</span>\n<span class=\"token class-name\">Object</span> <span class=\"token function\">invokeMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> target<span class=\"token punctuation\">)</span>  \n<span class=\"token comment\">// 同上，提供方法参数</span>\n<span class=\"token class-name\">Object</span> <span class=\"token function\">invokeMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> target<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> args<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 取消 Java 权限检查。以便后续执行该私有方法</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">makeAccessible</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Method</span> method<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 取消 Java 权限检查。以便后续执行私有构造方法</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">makeAccessible</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Constructor</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> ctor<span class=\"token punctuation\">)</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>3.获取字段</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 在类中查找指定属性</span>\n<span class=\"token class-name\">Field</span> <span class=\"token function\">findField</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 同上，多提供了属性的类型</span>\n<span class=\"token class-name\">Field</span> <span class=\"token function\">findField</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> type<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 是否为一个 \"public static final\" 属性</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isPublicStaticFinal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Field</span> field<span class=\"token punctuation\">)</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>4.设置字段</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 获取 target 对象的 field 属性值</span>\n<span class=\"token class-name\">Object</span> <span class=\"token function\">getField</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Field</span> field<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> target<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 设置 target 对象的 field 属性值，值为 value</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">setField</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Field</span> field<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> target<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> value<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 同类对象属性对等赋值</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">shallowCopyFieldState</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> src<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> dest<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 取消 Java 的权限控制检查。以便后续读写该私有属性</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">makeAccessible</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Field</span> field<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 对类的每个属性执行 callback</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">doWithFields</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ReflectionUtils<span class=\"token punctuation\">.</span>FieldCallback</span> fc<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 同上，多了个属性过滤功能。</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">doWithFields</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ReflectionUtils<span class=\"token punctuation\">.</span>FieldCallback</span> fc<span class=\"token punctuation\">,</span> \n                  <span class=\"token class-name\">ReflectionUtils<span class=\"token punctuation\">.</span>FieldFilter</span> ff<span class=\"token punctuation\">)</span> \n<span class=\"token comment\">// 同上，但不包括继承而来的属性</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">doWithLocalFields</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> clazz<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ReflectionUtils<span class=\"token punctuation\">.</span>FieldCallback</span> fc<span class=\"token punctuation\">)</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"AopUtils\"><a href=\"#AopUtils\" class=\"headerlink\" title=\"AopUtils\"></a>AopUtils</h3><ol>\n<li> 判断代理类型</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 判断是不是 Spring 代理对象</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isAopProxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断是不是 jdk 动态代理对象</span>\n<span class=\"token function\">isJdkDynamicProxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 判断是不是 CGLIB 代理对象</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">isCglibProxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.获取被代理对象的 class</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 获取被代理的目标 class</span>\n<span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">getTargetClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"AopContext\"><a href=\"#AopContext\" class=\"headerlink\" title=\"AopContext\"></a>AopContext</h3><ol>\n<li> 获取当前对象的代理对象</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Object</span> <span class=\"token function\">currentProxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>"},{"title":"java中高级面试题总结","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-11-07T01:52:39.000Z","password":null,"summary":"java中高级面试题总结","_content":"\n\n目录\n\n[前言][Link 1]\n\n[Part 1 java基础][Part 1 java]\n\n[1.1. JDK的基本的类库][1.1. JDK]\n\n[1.2. java虚拟机相关知识点][1.2. java]\n\n[1.4. Unsafe类][1.4. Unsafe]\n\n[1.5. Session、cookie区别][1.5. Session_cookie]\n\n[1.6. 权限问题][1.6.]\n\n[1.7. 安全问题][1.7.]\n\n[1.8 HashMap实现原理][1.8 HashMap]\n\n[1.9. HashMap和HashTable的区别][1.9. HashMap_HashTable]\n\n[1.9. ArrayList和LinkedList的区别][1.9. ArrayList_LinkedList]\n\n[1.10 设计模式 ][1.10 _]\n\n[1.12 NIO][]\n\n[Part 2 多线程问题][Part 2]\n\n[多线程问题（必问）][Link 2]\n\n[Concurrenthashmap原理分析有用][Concurrenthashmap]\n\n[Volitile关键字的作用][Volitile]\n\n[Part 3 Spring与ORM映射框架][Part 3 Spring_ORM]\n\n[面试题集锦：][Link 3]\n\n[3.1. Spring作用域][3.1. Spring]\n\n[3.2. SpringMVC面试题][3.2. SpringMVC]\n\n[SpringMVC的流程][SpringMVC]\n\n[SpringMVC与Struts2的区别][SpringMVC_Struts2]\n\n[过滤器与拦截器区别][Link 4]\n\n[4.4. Mybatis面试题][4.4. Mybatis]\n\n[\\#\\{\\}和$\\{\\}的区别是什么？][Link 5]\n\n[Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？][Xml_select_insert_updae_delete]\n\n[Mybatis批量插入数据][Mybatis]\n\n[Part 4 SpringBoot相关][Part 4 SpringBoot]\n\n[Springboot面试题集锦：][Springboot]\n\n[Springboot优点][Springboot 1]\n\n[springboot核心注解][springboot]\n\n[Spring Boot 支持哪些日志框架][Spring Boot]\n\n[Part 5 数据库相关][Part 5]\n\n[面试题集锦：][Link 3]\n\n[什么是数据库约束,常见的约束有哪几种?][Link 6]\n\n[乐观锁和悲观锁][Link 7]\n\n[什么是事务][Link 8]\n\n[事务四大特性][Link 9]\n\n[事务的并发问题][Link 10]\n\n[事务的隔离级别][Link 11]\n\n[事务的传播行为][Link 12]\n\n[sql编写以及优化（必问）][sql]\n\n[Part 5 其它问题][Part 5 1]\n\n[怎么设计一个高并发系统（比如100万人同时抢票）][100]\n\n[Spring cloud（有些公司的项目用不到这个）][Spring cloud]\n\n[java性能优化][java]\n\n[java8的新特性][java8]\n\n[redis相关问题][redis]\n\n[linux常用命令][linux]\n\n# 前言 \n\n这篇文章是我近期面试遇到的一些问题（技术类），做的一个总结。\n\n注意：\n\n1.有些问题没有标准答案，需要读者朋友在网上查找。\n\n2.有些问题答案太长，三言两语道不尽，直接给了链接，可以复制链接去搜索。\n\n3.有些技术涉及到很多问题，我给了总结的链接之后，又给大家列出了我面试遇到的题目\n\n# Part 1 java基础 \n\n## 1.1. JDK的基本的类库 \n\n存放位置：jre/lib/rt.jar（这个问题很简单，但是很多人答不上来！）\n\n常用的 Java 核心包 (Java Core Package)\n\njava.lang Java 编程语言的基本类库（Object、String、StringBuffer、StringBuilder、System、Runtime、Throwable、Exception、Error、Thread、Math等）\n\njava.io 通过数据流、对象序列以及文件系统实现的系统输入、输出\n\njava.util 集合类、时间处理模式、日期时间工具等各类常用工具包\n\n其它还有\n\njava.sql 访问和处理来自于 Java 标准数据源数据的类\n\njava.test 以一种独立于自然语言的方式处理文本、日期、数字和消息的类和接口\n\njava.math简明的整数算术以及十进制算术的基本函数\n\n## 1.2. java虚拟机相关知识点 \n\n[https://shuhao.blog.csdn.net/article/details/113524369][https_shuhao.blog.csdn.net_article_details_113524369]\n\n## 1.4. Unsafe类 \n\n参考：[https://www.cnblogs.com/thomas12112406/p/6510787.html][https_www.cnblogs.com_thomas12112406_p_6510787.html]\n\nUnsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题\n\n## 1.5. Session、cookie区别 \n\n1、cookie数据存放在客户端，session数据放在服务器上。\n\n2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。\n\n3、session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑性能应当使用cookie。\n\n4、不同浏览器对cookie的数据大小限制不同，个数限制也不相同。\n\n5、可以考虑将登陆信息等重要信息存放为session，不重要的信息可以放在cookie中。\n\n## 1.6. 权限问题 \n\n参考：[https://blog.csdn.net/Y0Q2T57s/article/details/82921270][https_blog.csdn.net_Y0Q2T57s_article_details_82921270]\n\n## 1.7. 安全问题 \n\n参考：[https://blog.csdn.net/wojiushiwo945you/article/details/77920165][https_blog.csdn.net_wojiushiwo945you_article_details_77920165]\n\nshiro：[https://www.cnblogs.com/WUXIAOCHANG/p/10886534.html][https_www.cnblogs.com_WUXIAOCHANG_p_10886534.html]\n\n[https://blog.csdn.net/qq\\_37254736/article/details/99350029][https_blog.csdn.net_qq_37254736_article_details_99350029]\n\n## 1.8 HashMap实现原理 \n\n参考：[https://shuhao.blog.csdn.net/article/details/108733952][https_shuhao.blog.csdn.net_article_details_108733952]\n\n## 1.9. HashMap和HashTable的区别 \n\n1.HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现Map接口\n\n2.HashMap和Hashtable的底层实现都是数组+链表结构实现、\n\n3.Hashtable是线程安全，HashMap是非线程安全\n\nHashMap的性能会高于Hashtable，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步\n\n4.两者计算hash的方法不同：\n\nHashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模\n\nHashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸\n\n5.HashMap可以使用null作为key，不过建议还是尽量避免这样使用。HashMap以null作为key时，总是存储在table数组的第一个节点上。而Hashtable则不允许null作为key\n\n6.HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75\n\n7.HashMap扩容时是当前容量翻倍即:capacity2，Hashtable扩容时是容量翻倍+1即:capacity2+1\n\n## 1.9. ArrayList和LinkedList的区别 \n\n1、ArrayList和LinkedList可想从名字分析，它们一个是Array(动态数组)的数据结构，一个是Link(链表)的数据结构，此外，它们两个都是对List接口的实现。\n\n前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列\n\n2、当随机访问List时（get和set操作），ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。\n\n3、当对数据进行增加和删除的操作时(add和remove操作)，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。\n\n4、从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。\n\n5、ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。\n\n## 1.10 设计模式  \n\n参考：[http://c.biancheng.net/design\\_pattern/][http_c.biancheng.net_design_pattern]\n\n## 1.12 NIO \n\n[Java中的IO与NIO面试题][Java_IO_NIO]\n\n# Part 2 多线程问题 \n\n## 多线程问题（必问） \n\n多线程的面试题太多了，下面的三个链接总结的很全面很详细：\n\n[https://www.cnblogs.com/Jansens520/p/8624708.html][https_www.cnblogs.com_Jansens520_p_8624708.html]\n\n[https://www.cnblogs.com/wangjintao-0623/p/9727234.html][https_www.cnblogs.com_wangjintao-0623_p_9727234.html]\n\n[https://blog.csdn.net/zl1zl2zl3/article/details/81868173][https_blog.csdn.net_zl1zl2zl3_article_details_81868173]\n\n## Concurrenthashmap原理分析有用 \n\nHashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。\n\n## Volitile关键字的作用 \n\n参考：[https://www.cnblogs.com/xd502djj/p/9873067.html][https_www.cnblogs.com_xd502djj_p_9873067.html]\n\n# Part 3 Spring与ORM映射框架 \n\n## 面试题集锦： \n\n[https://blog.csdn.net/qq\\_34337272/article/details/90955736][https_blog.csdn.net_qq_34337272_article_details_90955736]\n\n## 3.1. Spring作用域 \n\nsingleton：单例模式，当spring创建applicationContext容器的时候，spring会欲初始化所有的该作用域实例，加上lazy-init就可以避免预处理；\n\nprototype：原型模式，每次通过getBean获取该bean就会新产生一个实例，创建后spring将不再对其管理；\n\n====下面是在web项目下才用到的===\n\nrequest：搞web的大家都应该明白request的域了吧，就是每次请求都新产生一个实例，和prototype不同就是创建后，接下来的管理，spring依然在监听；\n\nsession：每次会话，同上；\n\nglobal session：全局的web域，类似于servlet中的application。\n\n## 3.2. SpringMVC面试题 \n\n面试题集锦：\n\n[https://blog.csdn.net/a745233700/article/details/80963758][https_blog.csdn.net_a745233700_article_details_80963758]\n\n## SpringMVC的流程 \n\n![image_0aae936f.png](http://markdown.liangtengyu.com:9999/images//image_0aae936f.png)![image_b8bfb6ea.png](http://markdown.liangtengyu.com:9999/images//image_b8bfb6ea.png)\n\n## SpringMVC与Struts2的区别 \n\n（1）springmvc的入口是一个servlet即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。\n\n（2）springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。\n\n（3）Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl\n\n## 过滤器与拦截器区别 \n\n①过滤器只能在容器初始化时被调用一次，在action的生命周期中，而拦截器可以多次被调用\n\n②过滤器可以对几乎所有的请求起作用，拦截器只能对action请求起作用。\n\n③过滤器不能访问action上下文、值栈里的对象，而拦截器可以访问。\n\n④过滤器依赖于servlet容器，而拦截器不依赖于servlet容器。\n\n⑤过滤器是基于函数回调，而拦截器是基于java的反射机制的。\n\n⑥过滤器不能获取IOC容器中的各个bean，而拦截器可以，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。\n\n## 4.4. Mybatis面试题 \n\n面试题集锦：\n\n[https://blog.csdn.net/a745233700/article/details/80977133][https_blog.csdn.net_a745233700_article_details_80977133]\n\n## \\#\\{\\}和$\\{\\}的区别是什么？ \n\n\\#\\{\\}是预编译处理，$\\{\\}是字符串替换。\n\nMybatis在处理\\#\\{\\}时，会将sql中的\\#\\{\\}替换为?号，调用PreparedStatement的set方法来赋值；\n\nMybatis在处理$\\{\\}时，就是把$\\{\\}替换成变量的值。\n\n使用\\#\\{\\}可以有效的防止SQL注入，提高系统安全性。\n\n## Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？ \n\ntrim | where | set | foreach | if | choose | when | otherwise | bind\n\n## Mybatis批量插入数据 \n\n可以使用foreach标签\n\n# Part 4 SpringBoot相关 \n\n## Springboot面试题集锦： \n\n[https://blog.csdn.net/ThinkWon/article/details/104397299][https_blog.csdn.net_ThinkWon_article_details_104397299]\n\n[https://www.jianshu.com/p/14ef39ed8ad3][https_www.jianshu.com_p_14ef39ed8ad3]\n\n[https://segmentfault.com/a/1190000016686735][https_segmentfault.com_a_1190000016686735]\n\n## Springboot优点 \n\n内置Tomcat、jetty，简化配置配置，restful风格\n\n## springboot核心注解 \n\nSpringbootApplication，包含3个配置springbootConfiguration、enableAutoConfiguration、componentScan\n\n## Spring Boot 支持哪些日志框架 \n\nSpring Boot支持Java Util Logging,Log4j2,Lockback作为日志框架，如果你使用starters启动器，Spring Boot将使用Logback作为默认日志框架。无论使用哪种日志框架，Spring Boot都支持配置将日志输出到控制台或者文件中\n\n# Part 5 数据库相关 \n\n## 面试题集锦： \n\n[https://www.cnblogs.com/wenxiaofei/p/9853682.html][https_www.cnblogs.com_wenxiaofei_p_9853682.html]\n\n## 什么是数据库约束,常见的约束有哪几种? \n\n数据库约束用于保证数据库表数据的完整性（正确性和一致性）。可以通过定义约束\\\\索引\\\\触发器来保证数据的完整性。\n\n总体来讲,约束可以分为:\n\n主键约束：primary key；\n\n外键约束：foreign key；\n\n唯一约束：unique；\n\n检查约束：check；\n\n空值约束：not null；\n\n默认值约束：default；\n\n## 乐观锁和悲观锁 \n\n参考：[https://blog.csdn.net/qq\\_34337272/article/details/81072874][https_blog.csdn.net_qq_34337272_article_details_81072874]\n\n## 什么是事务 \n\n事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。\n\n## 事务四大特性 \n\n原子性（Atomicity）: 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。\n\n一致性（Consistency）: 事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。\n\n隔离性（Isolation）: 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。\n\n持久性（Durability）: 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n\n## 事务的并发问题 \n\n1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据\n\n2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。\n\n3、幻读：幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。\n\n例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。\n\n## 事务的隔离级别 \n\n1. 读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读\n\n2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。\n\n3. 可重复读：在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象\n\n4. 串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样\n\n## 事务的传播行为 \n\n1.PROPAGATION\\_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。\n\n2.PROPAGATION\\_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。\n\n3.PROPAGATION\\_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。\n\n4.PROPAGATION\\_REQUIRES\\_NEW：创建新事务，无论当前存不存在事务，都创建新事务。\n\n5.PROPAGATION\\_NOT\\_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n\n6.PROPAGATION\\_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。\n\n7.PROPAGATION\\_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION\\_REQUIRED类似的操作。\n\n## sql编写以及优化（必问） \n\n参考：\n\n[https://blog.csdn.net/qq\\_38789941/article/details/83744271][https_blog.csdn.net_qq_38789941_article_details_83744271]\n\n# Part 5 其它问题 \n\n## 怎么设计一个高并发系统（比如100万人同时抢票） \n\n[https://blog.csdn.net/java\\_leejin/article/details/98096274][https_blog.csdn.net_java_leejin_article_details_98096274]\n\n## Spring cloud（有些公司的项目用不到这个） \n\n面试题集锦：\n\n[https://blog.csdn.net/hjq\\_ku/article/details/89504229][https_blog.csdn.net_hjq_ku_article_details_89504229]\n\n[https://blog.csdn.net/oldshaui/article/details/90675149][https_blog.csdn.net_oldshaui_article_details_90675149]\n\n![image_63a70387.png](http://markdown.liangtengyu.com:9999/images//image_63a70387.png)![image_4b7e356a.png](http://markdown.liangtengyu.com:9999/images//image_4b7e356a.png)\n\n## java性能优化 \n\n[http://www.wityx.com/post/424\\_1\\_1.html][http_www.wityx.com_post_424_1_1.html]\n\n## java8的新特性 \n\n[https://www.cnblogs.com/onetwo/p/8526374.html][https_www.cnblogs.com_onetwo_p_8526374.html]\n\n## redis相关问题 \n\n[https://www.cnblogs.com/jasontec/p/9699242.html][https_www.cnblogs.com_jasontec_p_9699242.html]\n\n## linux常用命令 \n\n[https://blog.csdn.net/qq\\_26230421/article/details/98359696][https_blog.csdn.net_qq_26230421_article_details_98359696]\n\n这些技术都会的话就可以上战场了\n","source":"_posts/java中高级面试题总结.md","raw":"---\ntitle: java中高级面试题总结\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-11-07 09:52:39\npassword:\nsummary: java中高级面试题总结\ntags: \n    - java面试\ncategories:\n    - java\n---\n\n\n目录\n\n[前言][Link 1]\n\n[Part 1 java基础][Part 1 java]\n\n[1.1. JDK的基本的类库][1.1. JDK]\n\n[1.2. java虚拟机相关知识点][1.2. java]\n\n[1.4. Unsafe类][1.4. Unsafe]\n\n[1.5. Session、cookie区别][1.5. Session_cookie]\n\n[1.6. 权限问题][1.6.]\n\n[1.7. 安全问题][1.7.]\n\n[1.8 HashMap实现原理][1.8 HashMap]\n\n[1.9. HashMap和HashTable的区别][1.9. HashMap_HashTable]\n\n[1.9. ArrayList和LinkedList的区别][1.9. ArrayList_LinkedList]\n\n[1.10 设计模式 ][1.10 _]\n\n[1.12 NIO][]\n\n[Part 2 多线程问题][Part 2]\n\n[多线程问题（必问）][Link 2]\n\n[Concurrenthashmap原理分析有用][Concurrenthashmap]\n\n[Volitile关键字的作用][Volitile]\n\n[Part 3 Spring与ORM映射框架][Part 3 Spring_ORM]\n\n[面试题集锦：][Link 3]\n\n[3.1. Spring作用域][3.1. Spring]\n\n[3.2. SpringMVC面试题][3.2. SpringMVC]\n\n[SpringMVC的流程][SpringMVC]\n\n[SpringMVC与Struts2的区别][SpringMVC_Struts2]\n\n[过滤器与拦截器区别][Link 4]\n\n[4.4. Mybatis面试题][4.4. Mybatis]\n\n[\\#\\{\\}和$\\{\\}的区别是什么？][Link 5]\n\n[Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？][Xml_select_insert_updae_delete]\n\n[Mybatis批量插入数据][Mybatis]\n\n[Part 4 SpringBoot相关][Part 4 SpringBoot]\n\n[Springboot面试题集锦：][Springboot]\n\n[Springboot优点][Springboot 1]\n\n[springboot核心注解][springboot]\n\n[Spring Boot 支持哪些日志框架][Spring Boot]\n\n[Part 5 数据库相关][Part 5]\n\n[面试题集锦：][Link 3]\n\n[什么是数据库约束,常见的约束有哪几种?][Link 6]\n\n[乐观锁和悲观锁][Link 7]\n\n[什么是事务][Link 8]\n\n[事务四大特性][Link 9]\n\n[事务的并发问题][Link 10]\n\n[事务的隔离级别][Link 11]\n\n[事务的传播行为][Link 12]\n\n[sql编写以及优化（必问）][sql]\n\n[Part 5 其它问题][Part 5 1]\n\n[怎么设计一个高并发系统（比如100万人同时抢票）][100]\n\n[Spring cloud（有些公司的项目用不到这个）][Spring cloud]\n\n[java性能优化][java]\n\n[java8的新特性][java8]\n\n[redis相关问题][redis]\n\n[linux常用命令][linux]\n\n# 前言 \n\n这篇文章是我近期面试遇到的一些问题（技术类），做的一个总结。\n\n注意：\n\n1.有些问题没有标准答案，需要读者朋友在网上查找。\n\n2.有些问题答案太长，三言两语道不尽，直接给了链接，可以复制链接去搜索。\n\n3.有些技术涉及到很多问题，我给了总结的链接之后，又给大家列出了我面试遇到的题目\n\n# Part 1 java基础 \n\n## 1.1. JDK的基本的类库 \n\n存放位置：jre/lib/rt.jar（这个问题很简单，但是很多人答不上来！）\n\n常用的 Java 核心包 (Java Core Package)\n\njava.lang Java 编程语言的基本类库（Object、String、StringBuffer、StringBuilder、System、Runtime、Throwable、Exception、Error、Thread、Math等）\n\njava.io 通过数据流、对象序列以及文件系统实现的系统输入、输出\n\njava.util 集合类、时间处理模式、日期时间工具等各类常用工具包\n\n其它还有\n\njava.sql 访问和处理来自于 Java 标准数据源数据的类\n\njava.test 以一种独立于自然语言的方式处理文本、日期、数字和消息的类和接口\n\njava.math简明的整数算术以及十进制算术的基本函数\n\n## 1.2. java虚拟机相关知识点 \n\n[https://shuhao.blog.csdn.net/article/details/113524369][https_shuhao.blog.csdn.net_article_details_113524369]\n\n## 1.4. Unsafe类 \n\n参考：[https://www.cnblogs.com/thomas12112406/p/6510787.html][https_www.cnblogs.com_thomas12112406_p_6510787.html]\n\nUnsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题\n\n## 1.5. Session、cookie区别 \n\n1、cookie数据存放在客户端，session数据放在服务器上。\n\n2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。\n\n3、session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑性能应当使用cookie。\n\n4、不同浏览器对cookie的数据大小限制不同，个数限制也不相同。\n\n5、可以考虑将登陆信息等重要信息存放为session，不重要的信息可以放在cookie中。\n\n## 1.6. 权限问题 \n\n参考：[https://blog.csdn.net/Y0Q2T57s/article/details/82921270][https_blog.csdn.net_Y0Q2T57s_article_details_82921270]\n\n## 1.7. 安全问题 \n\n参考：[https://blog.csdn.net/wojiushiwo945you/article/details/77920165][https_blog.csdn.net_wojiushiwo945you_article_details_77920165]\n\nshiro：[https://www.cnblogs.com/WUXIAOCHANG/p/10886534.html][https_www.cnblogs.com_WUXIAOCHANG_p_10886534.html]\n\n[https://blog.csdn.net/qq\\_37254736/article/details/99350029][https_blog.csdn.net_qq_37254736_article_details_99350029]\n\n## 1.8 HashMap实现原理 \n\n参考：[https://shuhao.blog.csdn.net/article/details/108733952][https_shuhao.blog.csdn.net_article_details_108733952]\n\n## 1.9. HashMap和HashTable的区别 \n\n1.HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现Map接口\n\n2.HashMap和Hashtable的底层实现都是数组+链表结构实现、\n\n3.Hashtable是线程安全，HashMap是非线程安全\n\nHashMap的性能会高于Hashtable，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步\n\n4.两者计算hash的方法不同：\n\nHashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模\n\nHashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸\n\n5.HashMap可以使用null作为key，不过建议还是尽量避免这样使用。HashMap以null作为key时，总是存储在table数组的第一个节点上。而Hashtable则不允许null作为key\n\n6.HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75\n\n7.HashMap扩容时是当前容量翻倍即:capacity2，Hashtable扩容时是容量翻倍+1即:capacity2+1\n\n## 1.9. ArrayList和LinkedList的区别 \n\n1、ArrayList和LinkedList可想从名字分析，它们一个是Array(动态数组)的数据结构，一个是Link(链表)的数据结构，此外，它们两个都是对List接口的实现。\n\n前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列\n\n2、当随机访问List时（get和set操作），ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。\n\n3、当对数据进行增加和删除的操作时(add和remove操作)，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。\n\n4、从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。\n\n5、ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。\n\n## 1.10 设计模式  \n\n参考：[http://c.biancheng.net/design\\_pattern/][http_c.biancheng.net_design_pattern]\n\n## 1.12 NIO \n\n[Java中的IO与NIO面试题][Java_IO_NIO]\n\n# Part 2 多线程问题 \n\n## 多线程问题（必问） \n\n多线程的面试题太多了，下面的三个链接总结的很全面很详细：\n\n[https://www.cnblogs.com/Jansens520/p/8624708.html][https_www.cnblogs.com_Jansens520_p_8624708.html]\n\n[https://www.cnblogs.com/wangjintao-0623/p/9727234.html][https_www.cnblogs.com_wangjintao-0623_p_9727234.html]\n\n[https://blog.csdn.net/zl1zl2zl3/article/details/81868173][https_blog.csdn.net_zl1zl2zl3_article_details_81868173]\n\n## Concurrenthashmap原理分析有用 \n\nHashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。\n\n## Volitile关键字的作用 \n\n参考：[https://www.cnblogs.com/xd502djj/p/9873067.html][https_www.cnblogs.com_xd502djj_p_9873067.html]\n\n# Part 3 Spring与ORM映射框架 \n\n## 面试题集锦： \n\n[https://blog.csdn.net/qq\\_34337272/article/details/90955736][https_blog.csdn.net_qq_34337272_article_details_90955736]\n\n## 3.1. Spring作用域 \n\nsingleton：单例模式，当spring创建applicationContext容器的时候，spring会欲初始化所有的该作用域实例，加上lazy-init就可以避免预处理；\n\nprototype：原型模式，每次通过getBean获取该bean就会新产生一个实例，创建后spring将不再对其管理；\n\n====下面是在web项目下才用到的===\n\nrequest：搞web的大家都应该明白request的域了吧，就是每次请求都新产生一个实例，和prototype不同就是创建后，接下来的管理，spring依然在监听；\n\nsession：每次会话，同上；\n\nglobal session：全局的web域，类似于servlet中的application。\n\n## 3.2. SpringMVC面试题 \n\n面试题集锦：\n\n[https://blog.csdn.net/a745233700/article/details/80963758][https_blog.csdn.net_a745233700_article_details_80963758]\n\n## SpringMVC的流程 \n\n![image_0aae936f.png](http://markdown.liangtengyu.com:9999/images//image_0aae936f.png)![image_b8bfb6ea.png](http://markdown.liangtengyu.com:9999/images//image_b8bfb6ea.png)\n\n## SpringMVC与Struts2的区别 \n\n（1）springmvc的入口是一个servlet即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。\n\n（2）springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。\n\n（3）Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl\n\n## 过滤器与拦截器区别 \n\n①过滤器只能在容器初始化时被调用一次，在action的生命周期中，而拦截器可以多次被调用\n\n②过滤器可以对几乎所有的请求起作用，拦截器只能对action请求起作用。\n\n③过滤器不能访问action上下文、值栈里的对象，而拦截器可以访问。\n\n④过滤器依赖于servlet容器，而拦截器不依赖于servlet容器。\n\n⑤过滤器是基于函数回调，而拦截器是基于java的反射机制的。\n\n⑥过滤器不能获取IOC容器中的各个bean，而拦截器可以，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。\n\n## 4.4. Mybatis面试题 \n\n面试题集锦：\n\n[https://blog.csdn.net/a745233700/article/details/80977133][https_blog.csdn.net_a745233700_article_details_80977133]\n\n## \\#\\{\\}和$\\{\\}的区别是什么？ \n\n\\#\\{\\}是预编译处理，$\\{\\}是字符串替换。\n\nMybatis在处理\\#\\{\\}时，会将sql中的\\#\\{\\}替换为?号，调用PreparedStatement的set方法来赋值；\n\nMybatis在处理$\\{\\}时，就是把$\\{\\}替换成变量的值。\n\n使用\\#\\{\\}可以有效的防止SQL注入，提高系统安全性。\n\n## Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？ \n\ntrim | where | set | foreach | if | choose | when | otherwise | bind\n\n## Mybatis批量插入数据 \n\n可以使用foreach标签\n\n# Part 4 SpringBoot相关 \n\n## Springboot面试题集锦： \n\n[https://blog.csdn.net/ThinkWon/article/details/104397299][https_blog.csdn.net_ThinkWon_article_details_104397299]\n\n[https://www.jianshu.com/p/14ef39ed8ad3][https_www.jianshu.com_p_14ef39ed8ad3]\n\n[https://segmentfault.com/a/1190000016686735][https_segmentfault.com_a_1190000016686735]\n\n## Springboot优点 \n\n内置Tomcat、jetty，简化配置配置，restful风格\n\n## springboot核心注解 \n\nSpringbootApplication，包含3个配置springbootConfiguration、enableAutoConfiguration、componentScan\n\n## Spring Boot 支持哪些日志框架 \n\nSpring Boot支持Java Util Logging,Log4j2,Lockback作为日志框架，如果你使用starters启动器，Spring Boot将使用Logback作为默认日志框架。无论使用哪种日志框架，Spring Boot都支持配置将日志输出到控制台或者文件中\n\n# Part 5 数据库相关 \n\n## 面试题集锦： \n\n[https://www.cnblogs.com/wenxiaofei/p/9853682.html][https_www.cnblogs.com_wenxiaofei_p_9853682.html]\n\n## 什么是数据库约束,常见的约束有哪几种? \n\n数据库约束用于保证数据库表数据的完整性（正确性和一致性）。可以通过定义约束\\\\索引\\\\触发器来保证数据的完整性。\n\n总体来讲,约束可以分为:\n\n主键约束：primary key；\n\n外键约束：foreign key；\n\n唯一约束：unique；\n\n检查约束：check；\n\n空值约束：not null；\n\n默认值约束：default；\n\n## 乐观锁和悲观锁 \n\n参考：[https://blog.csdn.net/qq\\_34337272/article/details/81072874][https_blog.csdn.net_qq_34337272_article_details_81072874]\n\n## 什么是事务 \n\n事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。\n\n## 事务四大特性 \n\n原子性（Atomicity）: 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。\n\n一致性（Consistency）: 事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。\n\n隔离性（Isolation）: 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。\n\n持久性（Durability）: 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n\n## 事务的并发问题 \n\n1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据\n\n2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。\n\n3、幻读：幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。\n\n例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。\n\n## 事务的隔离级别 \n\n1. 读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读\n\n2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。\n\n3. 可重复读：在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象\n\n4. 串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样\n\n## 事务的传播行为 \n\n1.PROPAGATION\\_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。\n\n2.PROPAGATION\\_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。\n\n3.PROPAGATION\\_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。\n\n4.PROPAGATION\\_REQUIRES\\_NEW：创建新事务，无论当前存不存在事务，都创建新事务。\n\n5.PROPAGATION\\_NOT\\_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n\n6.PROPAGATION\\_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。\n\n7.PROPAGATION\\_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION\\_REQUIRED类似的操作。\n\n## sql编写以及优化（必问） \n\n参考：\n\n[https://blog.csdn.net/qq\\_38789941/article/details/83744271][https_blog.csdn.net_qq_38789941_article_details_83744271]\n\n# Part 5 其它问题 \n\n## 怎么设计一个高并发系统（比如100万人同时抢票） \n\n[https://blog.csdn.net/java\\_leejin/article/details/98096274][https_blog.csdn.net_java_leejin_article_details_98096274]\n\n## Spring cloud（有些公司的项目用不到这个） \n\n面试题集锦：\n\n[https://blog.csdn.net/hjq\\_ku/article/details/89504229][https_blog.csdn.net_hjq_ku_article_details_89504229]\n\n[https://blog.csdn.net/oldshaui/article/details/90675149][https_blog.csdn.net_oldshaui_article_details_90675149]\n\n![image_63a70387.png](http://markdown.liangtengyu.com:9999/images//image_63a70387.png)![image_4b7e356a.png](http://markdown.liangtengyu.com:9999/images//image_4b7e356a.png)\n\n## java性能优化 \n\n[http://www.wityx.com/post/424\\_1\\_1.html][http_www.wityx.com_post_424_1_1.html]\n\n## java8的新特性 \n\n[https://www.cnblogs.com/onetwo/p/8526374.html][https_www.cnblogs.com_onetwo_p_8526374.html]\n\n## redis相关问题 \n\n[https://www.cnblogs.com/jasontec/p/9699242.html][https_www.cnblogs.com_jasontec_p_9699242.html]\n\n## linux常用命令 \n\n[https://blog.csdn.net/qq\\_26230421/article/details/98359696][https_blog.csdn.net_qq_26230421_article_details_98359696]\n\n这些技术都会的话就可以上战场了\n","slug":"java中高级面试题总结","published":1,"updated":"2022-11-07T01:54:06.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cla65gxig0006msldcoyi6ja1","content":"<p>目录</p>\n<p>[前言][Link 1]</p>\n<p>[Part 1 java基础][Part 1 java]</p>\n<p>[1.1. JDK的基本的类库][1.1. JDK]</p>\n<p>[1.2. java虚拟机相关知识点][1.2. java]</p>\n<p>[1.4. Unsafe类][1.4. Unsafe]</p>\n<p>[1.5. Session、cookie区别][1.5. Session_cookie]</p>\n<p>[1.6. 权限问题][1.6.]</p>\n<p>[1.7. 安全问题][1.7.]</p>\n<p>[1.8 HashMap实现原理][1.8 HashMap]</p>\n<p>[1.9. HashMap和HashTable的区别][1.9. HashMap_HashTable]</p>\n<p>[1.9. ArrayList和LinkedList的区别][1.9. ArrayList_LinkedList]</p>\n<p>[1.10 设计模式 ][1.10 _]</p>\n<p>[1.12 NIO][]</p>\n<p>[Part 2 多线程问题][Part 2]</p>\n<p>[多线程问题（必问）][Link 2]</p>\n<p>[Concurrenthashmap原理分析有用][Concurrenthashmap]</p>\n<p>[Volitile关键字的作用][Volitile]</p>\n<p>[Part 3 Spring与ORM映射框架][Part 3 Spring_ORM]</p>\n<p>[面试题集锦：][Link 3]</p>\n<p>[3.1. Spring作用域][3.1. Spring]</p>\n<p>[3.2. SpringMVC面试题][3.2. SpringMVC]</p>\n<p>[SpringMVC的流程][SpringMVC]</p>\n<p>[SpringMVC与Struts2的区别][SpringMVC_Struts2]</p>\n<p>[过滤器与拦截器区别][Link 4]</p>\n<p>[4.4. Mybatis面试题][4.4. Mybatis]</p>\n<p>[#{}和${}的区别是什么？][Link 5]</p>\n<p>[Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？][Xml_select_insert_updae_delete]</p>\n<p>[Mybatis批量插入数据][Mybatis]</p>\n<p>[Part 4 SpringBoot相关][Part 4 SpringBoot]</p>\n<p>[Springboot面试题集锦：][Springboot]</p>\n<p>[Springboot优点][Springboot 1]</p>\n<p>[springboot核心注解][springboot]</p>\n<p>[Spring Boot 支持哪些日志框架][Spring Boot]</p>\n<p>[Part 5 数据库相关][Part 5]</p>\n<p>[面试题集锦：][Link 3]</p>\n<p>[什么是数据库约束,常见的约束有哪几种?][Link 6]</p>\n<p>[乐观锁和悲观锁][Link 7]</p>\n<p>[什么是事务][Link 8]</p>\n<p>[事务四大特性][Link 9]</p>\n<p>[事务的并发问题][Link 10]</p>\n<p>[事务的隔离级别][Link 11]</p>\n<p>[事务的传播行为][Link 12]</p>\n<p>[sql编写以及优化（必问）][sql]</p>\n<p>[Part 5 其它问题][Part 5 1]</p>\n<p>[怎么设计一个高并发系统（比如100万人同时抢票）][100]</p>\n<p>[Spring cloud（有些公司的项目用不到这个）][Spring cloud]</p>\n<p>[java性能优化][java]</p>\n<p>[java8的新特性][java8]</p>\n<p>[redis相关问题][redis]</p>\n<p>[linux常用命令][linux]</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>这篇文章是我近期面试遇到的一些问题（技术类），做的一个总结。</p>\n<p>注意：</p>\n<p>1.有些问题没有标准答案，需要读者朋友在网上查找。</p>\n<p>2.有些问题答案太长，三言两语道不尽，直接给了链接，可以复制链接去搜索。</p>\n<p>3.有些技术涉及到很多问题，我给了总结的链接之后，又给大家列出了我面试遇到的题目</p>\n<h1 id=\"Part-1-java基础\"><a href=\"#Part-1-java基础\" class=\"headerlink\" title=\"Part 1 java基础\"></a>Part 1 java基础</h1><h2 id=\"1-1-JDK的基本的类库\"><a href=\"#1-1-JDK的基本的类库\" class=\"headerlink\" title=\"1.1. JDK的基本的类库\"></a>1.1. JDK的基本的类库</h2><p>存放位置：jre/lib/rt.jar（这个问题很简单，但是很多人答不上来！）</p>\n<p>常用的 Java 核心包 (Java Core Package)</p>\n<p>java.lang Java 编程语言的基本类库（Object、String、StringBuffer、StringBuilder、System、Runtime、Throwable、Exception、Error、Thread、Math等）</p>\n<p>java.io 通过数据流、对象序列以及文件系统实现的系统输入、输出</p>\n<p>java.util 集合类、时间处理模式、日期时间工具等各类常用工具包</p>\n<p>其它还有</p>\n<p>java.sql 访问和处理来自于 Java 标准数据源数据的类</p>\n<p>java.test 以一种独立于自然语言的方式处理文本、日期、数字和消息的类和接口</p>\n<p>java.math简明的整数算术以及十进制算术的基本函数</p>\n<h2 id=\"1-2-java虚拟机相关知识点\"><a href=\"#1-2-java虚拟机相关知识点\" class=\"headerlink\" title=\"1.2. java虚拟机相关知识点\"></a>1.2. java虚拟机相关知识点</h2><p>[<a href=\"https://shuhao.blog.csdn.net/article/details/113524369][https_shuhao.blog.csdn.net_article_details_113524369]\">https://shuhao.blog.csdn.net/article/details/113524369][https_shuhao.blog.csdn.net_article_details_113524369]</a></p>\n<h2 id=\"1-4-Unsafe类\"><a href=\"#1-4-Unsafe类\" class=\"headerlink\" title=\"1.4. Unsafe类\"></a>1.4. Unsafe类</h2><p>参考：[<a href=\"https://www.cnblogs.com/thomas12112406/p/6510787.html][https_www.cnblogs.com_thomas12112406_p_6510787.html]\">https://www.cnblogs.com/thomas12112406/p/6510787.html][https_www.cnblogs.com_thomas12112406_p_6510787.html]</a></p>\n<p>Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题</p>\n<h2 id=\"1-5-Session、cookie区别\"><a href=\"#1-5-Session、cookie区别\" class=\"headerlink\" title=\"1.5. Session、cookie区别\"></a>1.5. Session、cookie区别</h2><p>1、cookie数据存放在客户端，session数据放在服务器上。</p>\n<p>2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</p>\n<p>3、session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑性能应当使用cookie。</p>\n<p>4、不同浏览器对cookie的数据大小限制不同，个数限制也不相同。</p>\n<p>5、可以考虑将登陆信息等重要信息存放为session，不重要的信息可以放在cookie中。</p>\n<h2 id=\"1-6-权限问题\"><a href=\"#1-6-权限问题\" class=\"headerlink\" title=\"1.6. 权限问题\"></a>1.6. 权限问题</h2><p>参考：[<a href=\"https://blog.csdn.net/Y0Q2T57s/article/details/82921270][https_blog.csdn.net_Y0Q2T57s_article_details_82921270]\">https://blog.csdn.net/Y0Q2T57s/article/details/82921270][https_blog.csdn.net_Y0Q2T57s_article_details_82921270]</a></p>\n<h2 id=\"1-7-安全问题\"><a href=\"#1-7-安全问题\" class=\"headerlink\" title=\"1.7. 安全问题\"></a>1.7. 安全问题</h2><p>参考：[<a href=\"https://blog.csdn.net/wojiushiwo945you/article/details/77920165][https_blog.csdn.net_wojiushiwo945you_article_details_77920165]\">https://blog.csdn.net/wojiushiwo945you/article/details/77920165][https_blog.csdn.net_wojiushiwo945you_article_details_77920165]</a></p>\n<p>shiro：[<a href=\"https://www.cnblogs.com/WUXIAOCHANG/p/10886534.html][https_www.cnblogs.com_WUXIAOCHANG_p_10886534.html]\">https://www.cnblogs.com/WUXIAOCHANG/p/10886534.html][https_www.cnblogs.com_WUXIAOCHANG_p_10886534.html]</a></p>\n<p>[<a href=\"https://blog.csdn.net/qq/_37254736/article/details/99350029][https_blog.csdn.net_qq_37254736_article_details_99350029]\">https://blog.csdn.net/qq\\_37254736/article/details/99350029][https_blog.csdn.net_qq_37254736_article_details_99350029]</a></p>\n<h2 id=\"1-8-HashMap实现原理\"><a href=\"#1-8-HashMap实现原理\" class=\"headerlink\" title=\"1.8 HashMap实现原理\"></a>1.8 HashMap实现原理</h2><p>参考：[<a href=\"https://shuhao.blog.csdn.net/article/details/108733952][https_shuhao.blog.csdn.net_article_details_108733952]\">https://shuhao.blog.csdn.net/article/details/108733952][https_shuhao.blog.csdn.net_article_details_108733952]</a></p>\n<h2 id=\"1-9-HashMap和HashTable的区别\"><a href=\"#1-9-HashMap和HashTable的区别\" class=\"headerlink\" title=\"1.9. HashMap和HashTable的区别\"></a>1.9. HashMap和HashTable的区别</h2><p>1.HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现Map接口</p>\n<p>2.HashMap和Hashtable的底层实现都是数组+链表结构实现、</p>\n<p>3.Hashtable是线程安全，HashMap是非线程安全</p>\n<p>HashMap的性能会高于Hashtable，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步</p>\n<p>4.两者计算hash的方法不同：</p>\n<p>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模</p>\n<p>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸</p>\n<p>5.HashMap可以使用null作为key，不过建议还是尽量避免这样使用。HashMap以null作为key时，总是存储在table数组的第一个节点上。而Hashtable则不允许null作为key</p>\n<p>6.HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75</p>\n<p>7.HashMap扩容时是当前容量翻倍即:capacity2，Hashtable扩容时是容量翻倍+1即:capacity2+1</p>\n<h2 id=\"1-9-ArrayList和LinkedList的区别\"><a href=\"#1-9-ArrayList和LinkedList的区别\" class=\"headerlink\" title=\"1.9. ArrayList和LinkedList的区别\"></a>1.9. ArrayList和LinkedList的区别</h2><p>1、ArrayList和LinkedList可想从名字分析，它们一个是Array(动态数组)的数据结构，一个是Link(链表)的数据结构，此外，它们两个都是对List接口的实现。</p>\n<p>前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列</p>\n<p>2、当随机访问List时（get和set操作），ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p>\n<p>3、当对数据进行增加和删除的操作时(add和remove操作)，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。</p>\n<p>4、从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。</p>\n<p>5、ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。</p>\n<h2 id=\"1-10-设计模式\"><a href=\"#1-10-设计模式\" class=\"headerlink\" title=\"1.10 设计模式\"></a>1.10 设计模式</h2><p>参考：[<a href=\"http://c.biancheng.net/design/_pattern/][http_c.biancheng.net_design_pattern]\">http://c.biancheng.net/design\\_pattern/][http_c.biancheng.net_design_pattern]</a></p>\n<h2 id=\"1-12-NIO\"><a href=\"#1-12-NIO\" class=\"headerlink\" title=\"1.12 NIO\"></a>1.12 NIO</h2><p>[Java中的IO与NIO面试题][Java_IO_NIO]</p>\n<h1 id=\"Part-2-多线程问题\"><a href=\"#Part-2-多线程问题\" class=\"headerlink\" title=\"Part 2 多线程问题\"></a>Part 2 多线程问题</h1><h2 id=\"多线程问题（必问）\"><a href=\"#多线程问题（必问）\" class=\"headerlink\" title=\"多线程问题（必问）\"></a>多线程问题（必问）</h2><p>多线程的面试题太多了，下面的三个链接总结的很全面很详细：</p>\n<p>[<a href=\"https://www.cnblogs.com/Jansens520/p/8624708.html][https_www.cnblogs.com_Jansens520_p_8624708.html]\">https://www.cnblogs.com/Jansens520/p/8624708.html][https_www.cnblogs.com_Jansens520_p_8624708.html]</a></p>\n<p>[<a href=\"https://www.cnblogs.com/wangjintao-0623/p/9727234.html][https_www.cnblogs.com_wangjintao-0623_p_9727234.html]\">https://www.cnblogs.com/wangjintao-0623/p/9727234.html][https_www.cnblogs.com_wangjintao-0623_p_9727234.html]</a></p>\n<p>[<a href=\"https://blog.csdn.net/zl1zl2zl3/article/details/81868173][https_blog.csdn.net_zl1zl2zl3_article_details_81868173]\">https://blog.csdn.net/zl1zl2zl3/article/details/81868173][https_blog.csdn.net_zl1zl2zl3_article_details_81868173]</a></p>\n<h2 id=\"Concurrenthashmap原理分析有用\"><a href=\"#Concurrenthashmap原理分析有用\" class=\"headerlink\" title=\"Concurrenthashmap原理分析有用\"></a>Concurrenthashmap原理分析有用</h2><p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>\n<h2 id=\"Volitile关键字的作用\"><a href=\"#Volitile关键字的作用\" class=\"headerlink\" title=\"Volitile关键字的作用\"></a>Volitile关键字的作用</h2><p>参考：[<a href=\"https://www.cnblogs.com/xd502djj/p/9873067.html][https_www.cnblogs.com_xd502djj_p_9873067.html]\">https://www.cnblogs.com/xd502djj/p/9873067.html][https_www.cnblogs.com_xd502djj_p_9873067.html]</a></p>\n<h1 id=\"Part-3-Spring与ORM映射框架\"><a href=\"#Part-3-Spring与ORM映射框架\" class=\"headerlink\" title=\"Part 3 Spring与ORM映射框架\"></a>Part 3 Spring与ORM映射框架</h1><h2 id=\"面试题集锦：\"><a href=\"#面试题集锦：\" class=\"headerlink\" title=\"面试题集锦：\"></a>面试题集锦：</h2><p>[<a href=\"https://blog.csdn.net/qq/_34337272/article/details/90955736][https_blog.csdn.net_qq_34337272_article_details_90955736]\">https://blog.csdn.net/qq\\_34337272/article/details/90955736][https_blog.csdn.net_qq_34337272_article_details_90955736]</a></p>\n<h2 id=\"3-1-Spring作用域\"><a href=\"#3-1-Spring作用域\" class=\"headerlink\" title=\"3.1. Spring作用域\"></a>3.1. Spring作用域</h2><p>singleton：单例模式，当spring创建applicationContext容器的时候，spring会欲初始化所有的该作用域实例，加上lazy-init就可以避免预处理；</p>\n<p>prototype：原型模式，每次通过getBean获取该bean就会新产生一个实例，创建后spring将不再对其管理；</p>\n<p>====下面是在web项目下才用到的===</p>\n<p>request：搞web的大家都应该明白request的域了吧，就是每次请求都新产生一个实例，和prototype不同就是创建后，接下来的管理，spring依然在监听；</p>\n<p>session：每次会话，同上；</p>\n<p>global session：全局的web域，类似于servlet中的application。</p>\n<h2 id=\"3-2-SpringMVC面试题\"><a href=\"#3-2-SpringMVC面试题\" class=\"headerlink\" title=\"3.2. SpringMVC面试题\"></a>3.2. SpringMVC面试题</h2><p>面试题集锦：</p>\n<p>[<a href=\"https://blog.csdn.net/a745233700/article/details/80963758][https_blog.csdn.net_a745233700_article_details_80963758]\">https://blog.csdn.net/a745233700/article/details/80963758][https_blog.csdn.net_a745233700_article_details_80963758]</a></p>\n<h2 id=\"SpringMVC的流程\"><a href=\"#SpringMVC的流程\" class=\"headerlink\" title=\"SpringMVC的流程\"></a>SpringMVC的流程</h2><p><img src=\"http://markdown.liangtengyu.com:9999/images//image_0aae936f.png\" alt=\"image_0aae936f.png\"><img src=\"http://markdown.liangtengyu.com:9999/images//image_b8bfb6ea.png\" alt=\"image_b8bfb6ea.png\"></p>\n<h2 id=\"SpringMVC与Struts2的区别\"><a href=\"#SpringMVC与Struts2的区别\" class=\"headerlink\" title=\"SpringMVC与Struts2的区别\"></a>SpringMVC与Struts2的区别</h2><p>（1）springmvc的入口是一个servlet即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。</p>\n<p>（2）springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</p>\n<p>（3）Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl</p>\n<h2 id=\"过滤器与拦截器区别\"><a href=\"#过滤器与拦截器区别\" class=\"headerlink\" title=\"过滤器与拦截器区别\"></a>过滤器与拦截器区别</h2><p>①过滤器只能在容器初始化时被调用一次，在action的生命周期中，而拦截器可以多次被调用</p>\n<p>②过滤器可以对几乎所有的请求起作用，拦截器只能对action请求起作用。</p>\n<p>③过滤器不能访问action上下文、值栈里的对象，而拦截器可以访问。</p>\n<p>④过滤器依赖于servlet容器，而拦截器不依赖于servlet容器。</p>\n<p>⑤过滤器是基于函数回调，而拦截器是基于java的反射机制的。</p>\n<p>⑥过滤器不能获取IOC容器中的各个bean，而拦截器可以，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</p>\n<h2 id=\"4-4-Mybatis面试题\"><a href=\"#4-4-Mybatis面试题\" class=\"headerlink\" title=\"4.4. Mybatis面试题\"></a>4.4. Mybatis面试题</h2><p>面试题集锦：</p>\n<p>[<a href=\"https://blog.csdn.net/a745233700/article/details/80977133][https_blog.csdn.net_a745233700_article_details_80977133]\">https://blog.csdn.net/a745233700/article/details/80977133][https_blog.csdn.net_a745233700_article_details_80977133]</a></p>\n<h2 id=\"和-的区别是什么？\"><a href=\"#和-的区别是什么？\" class=\"headerlink\" title=\"#{}和${}的区别是什么？\"></a>#{}和${}的区别是什么？</h2><p>#{}是预编译处理，${}是字符串替换。</p>\n<p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p>\n<p>Mybatis在处理${}时，就是把${}替换成变量的值。</p>\n<p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p>\n<h2 id=\"Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？\"><a href=\"#Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？\" class=\"headerlink\" title=\"Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？\"></a>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h2><p>trim | where | set | foreach | if | choose | when | otherwise | bind</p>\n<h2 id=\"Mybatis批量插入数据\"><a href=\"#Mybatis批量插入数据\" class=\"headerlink\" title=\"Mybatis批量插入数据\"></a>Mybatis批量插入数据</h2><p>可以使用foreach标签</p>\n<h1 id=\"Part-4-SpringBoot相关\"><a href=\"#Part-4-SpringBoot相关\" class=\"headerlink\" title=\"Part 4 SpringBoot相关\"></a>Part 4 SpringBoot相关</h1><h2 id=\"Springboot面试题集锦：\"><a href=\"#Springboot面试题集锦：\" class=\"headerlink\" title=\"Springboot面试题集锦：\"></a>Springboot面试题集锦：</h2><p>[<a href=\"https://blog.csdn.net/ThinkWon/article/details/104397299][https_blog.csdn.net_ThinkWon_article_details_104397299]\">https://blog.csdn.net/ThinkWon/article/details/104397299][https_blog.csdn.net_ThinkWon_article_details_104397299]</a></p>\n<p>[<a href=\"https://www.jianshu.com/p/14ef39ed8ad3][https_www.jianshu.com_p_14ef39ed8ad3]\">https://www.jianshu.com/p/14ef39ed8ad3][https_www.jianshu.com_p_14ef39ed8ad3]</a></p>\n<p>[<a href=\"https://segmentfault.com/a/1190000016686735][https_segmentfault.com_a_1190000016686735]\">https://segmentfault.com/a/1190000016686735][https_segmentfault.com_a_1190000016686735]</a></p>\n<h2 id=\"Springboot优点\"><a href=\"#Springboot优点\" class=\"headerlink\" title=\"Springboot优点\"></a>Springboot优点</h2><p>内置Tomcat、jetty，简化配置配置，restful风格</p>\n<h2 id=\"springboot核心注解\"><a href=\"#springboot核心注解\" class=\"headerlink\" title=\"springboot核心注解\"></a>springboot核心注解</h2><p>SpringbootApplication，包含3个配置springbootConfiguration、enableAutoConfiguration、componentScan</p>\n<h2 id=\"Spring-Boot-支持哪些日志框架\"><a href=\"#Spring-Boot-支持哪些日志框架\" class=\"headerlink\" title=\"Spring Boot 支持哪些日志框架\"></a>Spring Boot 支持哪些日志框架</h2><p>Spring Boot支持Java Util Logging,Log4j2,Lockback作为日志框架，如果你使用starters启动器，Spring Boot将使用Logback作为默认日志框架。无论使用哪种日志框架，Spring Boot都支持配置将日志输出到控制台或者文件中</p>\n<h1 id=\"Part-5-数据库相关\"><a href=\"#Part-5-数据库相关\" class=\"headerlink\" title=\"Part 5 数据库相关\"></a>Part 5 数据库相关</h1><h2 id=\"面试题集锦：-1\"><a href=\"#面试题集锦：-1\" class=\"headerlink\" title=\"面试题集锦：\"></a>面试题集锦：</h2><p>[<a href=\"https://www.cnblogs.com/wenxiaofei/p/9853682.html][https_www.cnblogs.com_wenxiaofei_p_9853682.html]\">https://www.cnblogs.com/wenxiaofei/p/9853682.html][https_www.cnblogs.com_wenxiaofei_p_9853682.html]</a></p>\n<h2 id=\"什么是数据库约束-常见的约束有哪几种\"><a href=\"#什么是数据库约束-常见的约束有哪几种\" class=\"headerlink\" title=\"什么是数据库约束,常见的约束有哪几种?\"></a>什么是数据库约束,常见的约束有哪几种?</h2><p>数据库约束用于保证数据库表数据的完整性（正确性和一致性）。可以通过定义约束\\索引\\触发器来保证数据的完整性。</p>\n<p>总体来讲,约束可以分为:</p>\n<p>主键约束：primary key；</p>\n<p>外键约束：foreign key；</p>\n<p>唯一约束：unique；</p>\n<p>检查约束：check；</p>\n<p>空值约束：not null；</p>\n<p>默认值约束：default；</p>\n<h2 id=\"乐观锁和悲观锁\"><a href=\"#乐观锁和悲观锁\" class=\"headerlink\" title=\"乐观锁和悲观锁\"></a>乐观锁和悲观锁</h2><p>参考：[<a href=\"https://blog.csdn.net/qq/_34337272/article/details/81072874][https_blog.csdn.net_qq_34337272_article_details_81072874]\">https://blog.csdn.net/qq\\_34337272/article/details/81072874][https_blog.csdn.net_qq_34337272_article_details_81072874]</a></p>\n<h2 id=\"什么是事务\"><a href=\"#什么是事务\" class=\"headerlink\" title=\"什么是事务\"></a>什么是事务</h2><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p>\n<h2 id=\"事务四大特性\"><a href=\"#事务四大特性\" class=\"headerlink\" title=\"事务四大特性\"></a>事务四大特性</h2><p>原子性（Atomicity）: 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>\n<p>一致性（Consistency）: 事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p>\n<p>隔离性（Isolation）: 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>\n<p>持久性（Durability）: 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>\n<h2 id=\"事务的并发问题\"><a href=\"#事务的并发问题\" class=\"headerlink\" title=\"事务的并发问题\"></a>事务的并发问题</h2><p>1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p>\n<p>2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p>\n<p>3、幻读：幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。</p>\n<p>例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>\n<h2 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h2><ol>\n<li><p>读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读</p>\n</li>\n<li><p>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p>\n</li>\n<li><p>可重复读：在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象</p>\n</li>\n<li><p>串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样</p>\n</li>\n</ol>\n<h2 id=\"事务的传播行为\"><a href=\"#事务的传播行为\" class=\"headerlink\" title=\"事务的传播行为\"></a>事务的传播行为</h2><p>1.PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p>\n<p>2.PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p>\n<p>3.PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>\n<p>4.PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p>\n<p>5.PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>\n<p>6.PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p>\n<p>7.PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p>\n<h2 id=\"sql编写以及优化（必问）\"><a href=\"#sql编写以及优化（必问）\" class=\"headerlink\" title=\"sql编写以及优化（必问）\"></a>sql编写以及优化（必问）</h2><p>参考：</p>\n<p>[<a href=\"https://blog.csdn.net/qq/_38789941/article/details/83744271][https_blog.csdn.net_qq_38789941_article_details_83744271]\">https://blog.csdn.net/qq\\_38789941/article/details/83744271][https_blog.csdn.net_qq_38789941_article_details_83744271]</a></p>\n<h1 id=\"Part-5-其它问题\"><a href=\"#Part-5-其它问题\" class=\"headerlink\" title=\"Part 5 其它问题\"></a>Part 5 其它问题</h1><h2 id=\"怎么设计一个高并发系统（比如100万人同时抢票）\"><a href=\"#怎么设计一个高并发系统（比如100万人同时抢票）\" class=\"headerlink\" title=\"怎么设计一个高并发系统（比如100万人同时抢票）\"></a>怎么设计一个高并发系统（比如100万人同时抢票）</h2><p>[<a href=\"https://blog.csdn.net/java/_leejin/article/details/98096274][https_blog.csdn.net_java_leejin_article_details_98096274]\">https://blog.csdn.net/java\\_leejin/article/details/98096274][https_blog.csdn.net_java_leejin_article_details_98096274]</a></p>\n<h2 id=\"Spring-cloud（有些公司的项目用不到这个）\"><a href=\"#Spring-cloud（有些公司的项目用不到这个）\" class=\"headerlink\" title=\"Spring cloud（有些公司的项目用不到这个）\"></a>Spring cloud（有些公司的项目用不到这个）</h2><p>面试题集锦：</p>\n<p>[<a href=\"https://blog.csdn.net/hjq/_ku/article/details/89504229][https_blog.csdn.net_hjq_ku_article_details_89504229]\">https://blog.csdn.net/hjq\\_ku/article/details/89504229][https_blog.csdn.net_hjq_ku_article_details_89504229]</a></p>\n<p>[<a href=\"https://blog.csdn.net/oldshaui/article/details/90675149][https_blog.csdn.net_oldshaui_article_details_90675149]\">https://blog.csdn.net/oldshaui/article/details/90675149][https_blog.csdn.net_oldshaui_article_details_90675149]</a></p>\n<p><img src=\"http://markdown.liangtengyu.com:9999/images//image_63a70387.png\" alt=\"image_63a70387.png\"><img src=\"http://markdown.liangtengyu.com:9999/images//image_4b7e356a.png\" alt=\"image_4b7e356a.png\"></p>\n<h2 id=\"java性能优化\"><a href=\"#java性能优化\" class=\"headerlink\" title=\"java性能优化\"></a>java性能优化</h2><p>[<a href=\"http://www.wityx.com/post/424/_1/_1.html][http_www.wityx.com_post_424_1_1.html]\">http://www.wityx.com/post/424\\_1\\_1.html][http_www.wityx.com_post_424_1_1.html]</a></p>\n<h2 id=\"java8的新特性\"><a href=\"#java8的新特性\" class=\"headerlink\" title=\"java8的新特性\"></a>java8的新特性</h2><p>[<a href=\"https://www.cnblogs.com/onetwo/p/8526374.html][https_www.cnblogs.com_onetwo_p_8526374.html]\">https://www.cnblogs.com/onetwo/p/8526374.html][https_www.cnblogs.com_onetwo_p_8526374.html]</a></p>\n<h2 id=\"redis相关问题\"><a href=\"#redis相关问题\" class=\"headerlink\" title=\"redis相关问题\"></a>redis相关问题</h2><p>[<a href=\"https://www.cnblogs.com/jasontec/p/9699242.html][https_www.cnblogs.com_jasontec_p_9699242.html]\">https://www.cnblogs.com/jasontec/p/9699242.html][https_www.cnblogs.com_jasontec_p_9699242.html]</a></p>\n<h2 id=\"linux常用命令\"><a href=\"#linux常用命令\" class=\"headerlink\" title=\"linux常用命令\"></a>linux常用命令</h2><p>[<a href=\"https://blog.csdn.net/qq/_26230421/article/details/98359696][https_blog.csdn.net_qq_26230421_article_details_98359696]\">https://blog.csdn.net/qq\\_26230421/article/details/98359696][https_blog.csdn.net_qq_26230421_article_details_98359696]</a></p>\n<p>这些技术都会的话就可以上战场了</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<p>目录</p>\n<p>[前言][Link 1]</p>\n<p>[Part 1 java基础][Part 1 java]</p>\n<p>[1.1. JDK的基本的类库][1.1. JDK]</p>\n<p>[1.2. java虚拟机相关知识点][1.2. java]</p>\n<p>[1.4. Unsafe类][1.4. Unsafe]</p>\n<p>[1.5. Session、cookie区别][1.5. Session_cookie]</p>\n<p>[1.6. 权限问题][1.6.]</p>\n<p>[1.7. 安全问题][1.7.]</p>\n<p>[1.8 HashMap实现原理][1.8 HashMap]</p>\n<p>[1.9. HashMap和HashTable的区别][1.9. HashMap_HashTable]</p>\n<p>[1.9. ArrayList和LinkedList的区别][1.9. ArrayList_LinkedList]</p>\n<p>[1.10 设计模式 ][1.10 _]</p>\n<p>[1.12 NIO][]</p>\n<p>[Part 2 多线程问题][Part 2]</p>\n<p>[多线程问题（必问）][Link 2]</p>\n<p>[Concurrenthashmap原理分析有用][Concurrenthashmap]</p>\n<p>[Volitile关键字的作用][Volitile]</p>\n<p>[Part 3 Spring与ORM映射框架][Part 3 Spring_ORM]</p>\n<p>[面试题集锦：][Link 3]</p>\n<p>[3.1. Spring作用域][3.1. Spring]</p>\n<p>[3.2. SpringMVC面试题][3.2. SpringMVC]</p>\n<p>[SpringMVC的流程][SpringMVC]</p>\n<p>[SpringMVC与Struts2的区别][SpringMVC_Struts2]</p>\n<p>[过滤器与拦截器区别][Link 4]</p>\n<p>[4.4. Mybatis面试题][4.4. Mybatis]</p>\n<p>[#{}和${}的区别是什么？][Link 5]</p>\n<p>[Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？][Xml_select_insert_updae_delete]</p>\n<p>[Mybatis批量插入数据][Mybatis]</p>\n<p>[Part 4 SpringBoot相关][Part 4 SpringBoot]</p>\n<p>[Springboot面试题集锦：][Springboot]</p>\n<p>[Springboot优点][Springboot 1]</p>\n<p>[springboot核心注解][springboot]</p>\n<p>[Spring Boot 支持哪些日志框架][Spring Boot]</p>\n<p>[Part 5 数据库相关][Part 5]</p>\n<p>[面试题集锦：][Link 3]</p>\n<p>[什么是数据库约束,常见的约束有哪几种?][Link 6]</p>\n<p>[乐观锁和悲观锁][Link 7]</p>\n<p>[什么是事务][Link 8]</p>\n<p>[事务四大特性][Link 9]</p>\n<p>[事务的并发问题][Link 10]</p>\n<p>[事务的隔离级别][Link 11]</p>\n<p>[事务的传播行为][Link 12]</p>\n<p>[sql编写以及优化（必问）][sql]</p>\n<p>[Part 5 其它问题][Part 5 1]</p>\n<p>[怎么设计一个高并发系统（比如100万人同时抢票）][100]</p>\n<p>[Spring cloud（有些公司的项目用不到这个）][Spring cloud]</p>\n<p>[java性能优化][java]</p>\n<p>[java8的新特性][java8]</p>\n<p>[redis相关问题][redis]</p>\n<p>[linux常用命令][linux]</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>这篇文章是我近期面试遇到的一些问题（技术类），做的一个总结。</p>\n<p>注意：</p>\n<p>1.有些问题没有标准答案，需要读者朋友在网上查找。</p>\n<p>2.有些问题答案太长，三言两语道不尽，直接给了链接，可以复制链接去搜索。</p>\n<p>3.有些技术涉及到很多问题，我给了总结的链接之后，又给大家列出了我面试遇到的题目</p>\n<h1 id=\"Part-1-java基础\"><a href=\"#Part-1-java基础\" class=\"headerlink\" title=\"Part 1 java基础\"></a>Part 1 java基础</h1><h2 id=\"1-1-JDK的基本的类库\"><a href=\"#1-1-JDK的基本的类库\" class=\"headerlink\" title=\"1.1. JDK的基本的类库\"></a>1.1. JDK的基本的类库</h2><p>存放位置：jre/lib/rt.jar（这个问题很简单，但是很多人答不上来！）</p>\n<p>常用的 Java 核心包 (Java Core Package)</p>\n<p>java.lang Java 编程语言的基本类库（Object、String、StringBuffer、StringBuilder、System、Runtime、Throwable、Exception、Error、Thread、Math等）</p>\n<p>java.io 通过数据流、对象序列以及文件系统实现的系统输入、输出</p>\n<p>java.util 集合类、时间处理模式、日期时间工具等各类常用工具包</p>\n<p>其它还有</p>\n<p>java.sql 访问和处理来自于 Java 标准数据源数据的类</p>\n<p>java.test 以一种独立于自然语言的方式处理文本、日期、数字和消息的类和接口</p>\n<p>java.math简明的整数算术以及十进制算术的基本函数</p>\n<h2 id=\"1-2-java虚拟机相关知识点\"><a href=\"#1-2-java虚拟机相关知识点\" class=\"headerlink\" title=\"1.2. java虚拟机相关知识点\"></a>1.2. java虚拟机相关知识点</h2><p>[<a href=\"https://shuhao.blog.csdn.net/article/details/113524369][https_shuhao.blog.csdn.net_article_details_113524369]\">https://shuhao.blog.csdn.net/article/details/113524369][https_shuhao.blog.csdn.net_article_details_113524369]</a></p>\n<h2 id=\"1-4-Unsafe类\"><a href=\"#1-4-Unsafe类\" class=\"headerlink\" title=\"1.4. Unsafe类\"></a>1.4. Unsafe类</h2><p>参考：[<a href=\"https://www.cnblogs.com/thomas12112406/p/6510787.html][https_www.cnblogs.com_thomas12112406_p_6510787.html]\">https://www.cnblogs.com/thomas12112406/p/6510787.html][https_www.cnblogs.com_thomas12112406_p_6510787.html]</a></p>\n<p>Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题</p>\n<h2 id=\"1-5-Session、cookie区别\"><a href=\"#1-5-Session、cookie区别\" class=\"headerlink\" title=\"1.5. Session、cookie区别\"></a>1.5. Session、cookie区别</h2><p>1、cookie数据存放在客户端，session数据放在服务器上。</p>\n<p>2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</p>\n<p>3、session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑性能应当使用cookie。</p>\n<p>4、不同浏览器对cookie的数据大小限制不同，个数限制也不相同。</p>\n<p>5、可以考虑将登陆信息等重要信息存放为session，不重要的信息可以放在cookie中。</p>\n<h2 id=\"1-6-权限问题\"><a href=\"#1-6-权限问题\" class=\"headerlink\" title=\"1.6. 权限问题\"></a>1.6. 权限问题</h2><p>参考：[<a href=\"https://blog.csdn.net/Y0Q2T57s/article/details/82921270][https_blog.csdn.net_Y0Q2T57s_article_details_82921270]\">https://blog.csdn.net/Y0Q2T57s/article/details/82921270][https_blog.csdn.net_Y0Q2T57s_article_details_82921270]</a></p>\n<h2 id=\"1-7-安全问题\"><a href=\"#1-7-安全问题\" class=\"headerlink\" title=\"1.7. 安全问题\"></a>1.7. 安全问题</h2><p>参考：[<a href=\"https://blog.csdn.net/wojiushiwo945you/article/details/77920165][https_blog.csdn.net_wojiushiwo945you_article_details_77920165]\">https://blog.csdn.net/wojiushiwo945you/article/details/77920165][https_blog.csdn.net_wojiushiwo945you_article_details_77920165]</a></p>\n<p>shiro：[<a href=\"https://www.cnblogs.com/WUXIAOCHANG/p/10886534.html][https_www.cnblogs.com_WUXIAOCHANG_p_10886534.html]\">https://www.cnblogs.com/WUXIAOCHANG/p/10886534.html][https_www.cnblogs.com_WUXIAOCHANG_p_10886534.html]</a></p>\n<p>[<a href=\"https://blog.csdn.net/qq/_37254736/article/details/99350029][https_blog.csdn.net_qq_37254736_article_details_99350029]\">https://blog.csdn.net/qq\\_37254736/article/details/99350029][https_blog.csdn.net_qq_37254736_article_details_99350029]</a></p>\n<h2 id=\"1-8-HashMap实现原理\"><a href=\"#1-8-HashMap实现原理\" class=\"headerlink\" title=\"1.8 HashMap实现原理\"></a>1.8 HashMap实现原理</h2><p>参考：[<a href=\"https://shuhao.blog.csdn.net/article/details/108733952][https_shuhao.blog.csdn.net_article_details_108733952]\">https://shuhao.blog.csdn.net/article/details/108733952][https_shuhao.blog.csdn.net_article_details_108733952]</a></p>\n<h2 id=\"1-9-HashMap和HashTable的区别\"><a href=\"#1-9-HashMap和HashTable的区别\" class=\"headerlink\" title=\"1.9. HashMap和HashTable的区别\"></a>1.9. HashMap和HashTable的区别</h2><p>1.HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现Map接口</p>\n<p>2.HashMap和Hashtable的底层实现都是数组+链表结构实现、</p>\n<p>3.Hashtable是线程安全，HashMap是非线程安全</p>\n<p>HashMap的性能会高于Hashtable，我们平时使用时若无特殊需求建议使用HashMap，在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合（Collections.synchronizedMap()实现原理是Collections定义了一个SynchronizedMap的内部类，这个类实现了Map接口，在调用方法时使用synchronized来保证线程同步</p>\n<p>4.两者计算hash的方法不同：</p>\n<p>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模</p>\n<p>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸</p>\n<p>5.HashMap可以使用null作为key，不过建议还是尽量避免这样使用。HashMap以null作为key时，总是存储在table数组的第一个节点上。而Hashtable则不允许null作为key</p>\n<p>6.HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75</p>\n<p>7.HashMap扩容时是当前容量翻倍即:capacity2，Hashtable扩容时是容量翻倍+1即:capacity2+1</p>\n<h2 id=\"1-9-ArrayList和LinkedList的区别\"><a href=\"#1-9-ArrayList和LinkedList的区别\" class=\"headerlink\" title=\"1.9. ArrayList和LinkedList的区别\"></a>1.9. ArrayList和LinkedList的区别</h2><p>1、ArrayList和LinkedList可想从名字分析，它们一个是Array(动态数组)的数据结构，一个是Link(链表)的数据结构，此外，它们两个都是对List接口的实现。</p>\n<p>前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列</p>\n<p>2、当随机访问List时（get和set操作），ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p>\n<p>3、当对数据进行增加和删除的操作时(add和remove操作)，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。</p>\n<p>4、从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。</p>\n<p>5、ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。</p>\n<h2 id=\"1-10-设计模式\"><a href=\"#1-10-设计模式\" class=\"headerlink\" title=\"1.10 设计模式\"></a>1.10 设计模式</h2><p>参考：[<a href=\"http://c.biancheng.net/design/_pattern/][http_c.biancheng.net_design_pattern]\">http://c.biancheng.net/design\\_pattern/][http_c.biancheng.net_design_pattern]</a></p>\n<h2 id=\"1-12-NIO\"><a href=\"#1-12-NIO\" class=\"headerlink\" title=\"1.12 NIO\"></a>1.12 NIO</h2><p>[Java中的IO与NIO面试题][Java_IO_NIO]</p>\n<h1 id=\"Part-2-多线程问题\"><a href=\"#Part-2-多线程问题\" class=\"headerlink\" title=\"Part 2 多线程问题\"></a>Part 2 多线程问题</h1><h2 id=\"多线程问题（必问）\"><a href=\"#多线程问题（必问）\" class=\"headerlink\" title=\"多线程问题（必问）\"></a>多线程问题（必问）</h2><p>多线程的面试题太多了，下面的三个链接总结的很全面很详细：</p>\n<p>[<a href=\"https://www.cnblogs.com/Jansens520/p/8624708.html][https_www.cnblogs.com_Jansens520_p_8624708.html]\">https://www.cnblogs.com/Jansens520/p/8624708.html][https_www.cnblogs.com_Jansens520_p_8624708.html]</a></p>\n<p>[<a href=\"https://www.cnblogs.com/wangjintao-0623/p/9727234.html][https_www.cnblogs.com_wangjintao-0623_p_9727234.html]\">https://www.cnblogs.com/wangjintao-0623/p/9727234.html][https_www.cnblogs.com_wangjintao-0623_p_9727234.html]</a></p>\n<p>[<a href=\"https://blog.csdn.net/zl1zl2zl3/article/details/81868173][https_blog.csdn.net_zl1zl2zl3_article_details_81868173]\">https://blog.csdn.net/zl1zl2zl3/article/details/81868173][https_blog.csdn.net_zl1zl2zl3_article_details_81868173]</a></p>\n<h2 id=\"Concurrenthashmap原理分析有用\"><a href=\"#Concurrenthashmap原理分析有用\" class=\"headerlink\" title=\"Concurrenthashmap原理分析有用\"></a>Concurrenthashmap原理分析有用</h2><p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>\n<h2 id=\"Volitile关键字的作用\"><a href=\"#Volitile关键字的作用\" class=\"headerlink\" title=\"Volitile关键字的作用\"></a>Volitile关键字的作用</h2><p>参考：[<a href=\"https://www.cnblogs.com/xd502djj/p/9873067.html][https_www.cnblogs.com_xd502djj_p_9873067.html]\">https://www.cnblogs.com/xd502djj/p/9873067.html][https_www.cnblogs.com_xd502djj_p_9873067.html]</a></p>\n<h1 id=\"Part-3-Spring与ORM映射框架\"><a href=\"#Part-3-Spring与ORM映射框架\" class=\"headerlink\" title=\"Part 3 Spring与ORM映射框架\"></a>Part 3 Spring与ORM映射框架</h1><h2 id=\"面试题集锦：\"><a href=\"#面试题集锦：\" class=\"headerlink\" title=\"面试题集锦：\"></a>面试题集锦：</h2><p>[<a href=\"https://blog.csdn.net/qq/_34337272/article/details/90955736][https_blog.csdn.net_qq_34337272_article_details_90955736]\">https://blog.csdn.net/qq\\_34337272/article/details/90955736][https_blog.csdn.net_qq_34337272_article_details_90955736]</a></p>\n<h2 id=\"3-1-Spring作用域\"><a href=\"#3-1-Spring作用域\" class=\"headerlink\" title=\"3.1. Spring作用域\"></a>3.1. Spring作用域</h2><p>singleton：单例模式，当spring创建applicationContext容器的时候，spring会欲初始化所有的该作用域实例，加上lazy-init就可以避免预处理；</p>\n<p>prototype：原型模式，每次通过getBean获取该bean就会新产生一个实例，创建后spring将不再对其管理；</p>\n<p>====下面是在web项目下才用到的===</p>\n<p>request：搞web的大家都应该明白request的域了吧，就是每次请求都新产生一个实例，和prototype不同就是创建后，接下来的管理，spring依然在监听；</p>\n<p>session：每次会话，同上；</p>\n<p>global session：全局的web域，类似于servlet中的application。</p>\n<h2 id=\"3-2-SpringMVC面试题\"><a href=\"#3-2-SpringMVC面试题\" class=\"headerlink\" title=\"3.2. SpringMVC面试题\"></a>3.2. SpringMVC面试题</h2><p>面试题集锦：</p>\n<p>[<a href=\"https://blog.csdn.net/a745233700/article/details/80963758][https_blog.csdn.net_a745233700_article_details_80963758]\">https://blog.csdn.net/a745233700/article/details/80963758][https_blog.csdn.net_a745233700_article_details_80963758]</a></p>\n<h2 id=\"SpringMVC的流程\"><a href=\"#SpringMVC的流程\" class=\"headerlink\" title=\"SpringMVC的流程\"></a>SpringMVC的流程</h2><p><img src=\"http://markdown.liangtengyu.com:9999/images//image_0aae936f.png\" alt=\"image_0aae936f.png\"><img src=\"http://markdown.liangtengyu.com:9999/images//image_b8bfb6ea.png\" alt=\"image_b8bfb6ea.png\"></p>\n<h2 id=\"SpringMVC与Struts2的区别\"><a href=\"#SpringMVC与Struts2的区别\" class=\"headerlink\" title=\"SpringMVC与Struts2的区别\"></a>SpringMVC与Struts2的区别</h2><p>（1）springmvc的入口是一个servlet即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。</p>\n<p>（2）springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</p>\n<p>（3）Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl</p>\n<h2 id=\"过滤器与拦截器区别\"><a href=\"#过滤器与拦截器区别\" class=\"headerlink\" title=\"过滤器与拦截器区别\"></a>过滤器与拦截器区别</h2><p>①过滤器只能在容器初始化时被调用一次，在action的生命周期中，而拦截器可以多次被调用</p>\n<p>②过滤器可以对几乎所有的请求起作用，拦截器只能对action请求起作用。</p>\n<p>③过滤器不能访问action上下文、值栈里的对象，而拦截器可以访问。</p>\n<p>④过滤器依赖于servlet容器，而拦截器不依赖于servlet容器。</p>\n<p>⑤过滤器是基于函数回调，而拦截器是基于java的反射机制的。</p>\n<p>⑥过滤器不能获取IOC容器中的各个bean，而拦截器可以，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</p>\n<h2 id=\"4-4-Mybatis面试题\"><a href=\"#4-4-Mybatis面试题\" class=\"headerlink\" title=\"4.4. Mybatis面试题\"></a>4.4. Mybatis面试题</h2><p>面试题集锦：</p>\n<p>[<a href=\"https://blog.csdn.net/a745233700/article/details/80977133][https_blog.csdn.net_a745233700_article_details_80977133]\">https://blog.csdn.net/a745233700/article/details/80977133][https_blog.csdn.net_a745233700_article_details_80977133]</a></p>\n<h2 id=\"和-的区别是什么？\"><a href=\"#和-的区别是什么？\" class=\"headerlink\" title=\"#{}和${}的区别是什么？\"></a>#{}和${}的区别是什么？</h2><p>#{}是预编译处理，${}是字符串替换。</p>\n<p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p>\n<p>Mybatis在处理${}时，就是把${}替换成变量的值。</p>\n<p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p>\n<h2 id=\"Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？\"><a href=\"#Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？\" class=\"headerlink\" title=\"Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？\"></a>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h2><p>trim | where | set | foreach | if | choose | when | otherwise | bind</p>\n<h2 id=\"Mybatis批量插入数据\"><a href=\"#Mybatis批量插入数据\" class=\"headerlink\" title=\"Mybatis批量插入数据\"></a>Mybatis批量插入数据</h2><p>可以使用foreach标签</p>\n<h1 id=\"Part-4-SpringBoot相关\"><a href=\"#Part-4-SpringBoot相关\" class=\"headerlink\" title=\"Part 4 SpringBoot相关\"></a>Part 4 SpringBoot相关</h1><h2 id=\"Springboot面试题集锦：\"><a href=\"#Springboot面试题集锦：\" class=\"headerlink\" title=\"Springboot面试题集锦：\"></a>Springboot面试题集锦：</h2><p>[<a href=\"https://blog.csdn.net/ThinkWon/article/details/104397299][https_blog.csdn.net_ThinkWon_article_details_104397299]\">https://blog.csdn.net/ThinkWon/article/details/104397299][https_blog.csdn.net_ThinkWon_article_details_104397299]</a></p>\n<p>[<a href=\"https://www.jianshu.com/p/14ef39ed8ad3][https_www.jianshu.com_p_14ef39ed8ad3]\">https://www.jianshu.com/p/14ef39ed8ad3][https_www.jianshu.com_p_14ef39ed8ad3]</a></p>\n<p>[<a href=\"https://segmentfault.com/a/1190000016686735][https_segmentfault.com_a_1190000016686735]\">https://segmentfault.com/a/1190000016686735][https_segmentfault.com_a_1190000016686735]</a></p>\n<h2 id=\"Springboot优点\"><a href=\"#Springboot优点\" class=\"headerlink\" title=\"Springboot优点\"></a>Springboot优点</h2><p>内置Tomcat、jetty，简化配置配置，restful风格</p>\n<h2 id=\"springboot核心注解\"><a href=\"#springboot核心注解\" class=\"headerlink\" title=\"springboot核心注解\"></a>springboot核心注解</h2><p>SpringbootApplication，包含3个配置springbootConfiguration、enableAutoConfiguration、componentScan</p>\n<h2 id=\"Spring-Boot-支持哪些日志框架\"><a href=\"#Spring-Boot-支持哪些日志框架\" class=\"headerlink\" title=\"Spring Boot 支持哪些日志框架\"></a>Spring Boot 支持哪些日志框架</h2><p>Spring Boot支持Java Util Logging,Log4j2,Lockback作为日志框架，如果你使用starters启动器，Spring Boot将使用Logback作为默认日志框架。无论使用哪种日志框架，Spring Boot都支持配置将日志输出到控制台或者文件中</p>\n<h1 id=\"Part-5-数据库相关\"><a href=\"#Part-5-数据库相关\" class=\"headerlink\" title=\"Part 5 数据库相关\"></a>Part 5 数据库相关</h1><h2 id=\"面试题集锦：-1\"><a href=\"#面试题集锦：-1\" class=\"headerlink\" title=\"面试题集锦：\"></a>面试题集锦：</h2><p>[<a href=\"https://www.cnblogs.com/wenxiaofei/p/9853682.html][https_www.cnblogs.com_wenxiaofei_p_9853682.html]\">https://www.cnblogs.com/wenxiaofei/p/9853682.html][https_www.cnblogs.com_wenxiaofei_p_9853682.html]</a></p>\n<h2 id=\"什么是数据库约束-常见的约束有哪几种\"><a href=\"#什么是数据库约束-常见的约束有哪几种\" class=\"headerlink\" title=\"什么是数据库约束,常见的约束有哪几种?\"></a>什么是数据库约束,常见的约束有哪几种?</h2><p>数据库约束用于保证数据库表数据的完整性（正确性和一致性）。可以通过定义约束\\索引\\触发器来保证数据的完整性。</p>\n<p>总体来讲,约束可以分为:</p>\n<p>主键约束：primary key；</p>\n<p>外键约束：foreign key；</p>\n<p>唯一约束：unique；</p>\n<p>检查约束：check；</p>\n<p>空值约束：not null；</p>\n<p>默认值约束：default；</p>\n<h2 id=\"乐观锁和悲观锁\"><a href=\"#乐观锁和悲观锁\" class=\"headerlink\" title=\"乐观锁和悲观锁\"></a>乐观锁和悲观锁</h2><p>参考：[<a href=\"https://blog.csdn.net/qq/_34337272/article/details/81072874][https_blog.csdn.net_qq_34337272_article_details_81072874]\">https://blog.csdn.net/qq\\_34337272/article/details/81072874][https_blog.csdn.net_qq_34337272_article_details_81072874]</a></p>\n<h2 id=\"什么是事务\"><a href=\"#什么是事务\" class=\"headerlink\" title=\"什么是事务\"></a>什么是事务</h2><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p>\n<h2 id=\"事务四大特性\"><a href=\"#事务四大特性\" class=\"headerlink\" title=\"事务四大特性\"></a>事务四大特性</h2><p>原子性（Atomicity）: 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>\n<p>一致性（Consistency）: 事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p>\n<p>隔离性（Isolation）: 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>\n<p>持久性（Durability）: 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>\n<h2 id=\"事务的并发问题\"><a href=\"#事务的并发问题\" class=\"headerlink\" title=\"事务的并发问题\"></a>事务的并发问题</h2><p>1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p>\n<p>2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p>\n<p>3、幻读：幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。</p>\n<p>例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>\n<h2 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h2><ol>\n<li><p>读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读</p>\n</li>\n<li><p>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p>\n</li>\n<li><p>可重复读：在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象</p>\n</li>\n<li><p>串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样</p>\n</li>\n</ol>\n<h2 id=\"事务的传播行为\"><a href=\"#事务的传播行为\" class=\"headerlink\" title=\"事务的传播行为\"></a>事务的传播行为</h2><p>1.PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p>\n<p>2.PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p>\n<p>3.PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p>\n<p>4.PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p>\n<p>5.PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>\n<p>6.PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p>\n<p>7.PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p>\n<h2 id=\"sql编写以及优化（必问）\"><a href=\"#sql编写以及优化（必问）\" class=\"headerlink\" title=\"sql编写以及优化（必问）\"></a>sql编写以及优化（必问）</h2><p>参考：</p>\n<p>[<a href=\"https://blog.csdn.net/qq/_38789941/article/details/83744271][https_blog.csdn.net_qq_38789941_article_details_83744271]\">https://blog.csdn.net/qq\\_38789941/article/details/83744271][https_blog.csdn.net_qq_38789941_article_details_83744271]</a></p>\n<h1 id=\"Part-5-其它问题\"><a href=\"#Part-5-其它问题\" class=\"headerlink\" title=\"Part 5 其它问题\"></a>Part 5 其它问题</h1><h2 id=\"怎么设计一个高并发系统（比如100万人同时抢票）\"><a href=\"#怎么设计一个高并发系统（比如100万人同时抢票）\" class=\"headerlink\" title=\"怎么设计一个高并发系统（比如100万人同时抢票）\"></a>怎么设计一个高并发系统（比如100万人同时抢票）</h2><p>[<a href=\"https://blog.csdn.net/java/_leejin/article/details/98096274][https_blog.csdn.net_java_leejin_article_details_98096274]\">https://blog.csdn.net/java\\_leejin/article/details/98096274][https_blog.csdn.net_java_leejin_article_details_98096274]</a></p>\n<h2 id=\"Spring-cloud（有些公司的项目用不到这个）\"><a href=\"#Spring-cloud（有些公司的项目用不到这个）\" class=\"headerlink\" title=\"Spring cloud（有些公司的项目用不到这个）\"></a>Spring cloud（有些公司的项目用不到这个）</h2><p>面试题集锦：</p>\n<p>[<a href=\"https://blog.csdn.net/hjq/_ku/article/details/89504229][https_blog.csdn.net_hjq_ku_article_details_89504229]\">https://blog.csdn.net/hjq\\_ku/article/details/89504229][https_blog.csdn.net_hjq_ku_article_details_89504229]</a></p>\n<p>[<a href=\"https://blog.csdn.net/oldshaui/article/details/90675149][https_blog.csdn.net_oldshaui_article_details_90675149]\">https://blog.csdn.net/oldshaui/article/details/90675149][https_blog.csdn.net_oldshaui_article_details_90675149]</a></p>\n<p><img src=\"http://markdown.liangtengyu.com:9999/images//image_63a70387.png\" alt=\"image_63a70387.png\"><img src=\"http://markdown.liangtengyu.com:9999/images//image_4b7e356a.png\" alt=\"image_4b7e356a.png\"></p>\n<h2 id=\"java性能优化\"><a href=\"#java性能优化\" class=\"headerlink\" title=\"java性能优化\"></a>java性能优化</h2><p>[<a href=\"http://www.wityx.com/post/424/_1/_1.html][http_www.wityx.com_post_424_1_1.html]\">http://www.wityx.com/post/424\\_1\\_1.html][http_www.wityx.com_post_424_1_1.html]</a></p>\n<h2 id=\"java8的新特性\"><a href=\"#java8的新特性\" class=\"headerlink\" title=\"java8的新特性\"></a>java8的新特性</h2><p>[<a href=\"https://www.cnblogs.com/onetwo/p/8526374.html][https_www.cnblogs.com_onetwo_p_8526374.html]\">https://www.cnblogs.com/onetwo/p/8526374.html][https_www.cnblogs.com_onetwo_p_8526374.html]</a></p>\n<h2 id=\"redis相关问题\"><a href=\"#redis相关问题\" class=\"headerlink\" title=\"redis相关问题\"></a>redis相关问题</h2><p>[<a href=\"https://www.cnblogs.com/jasontec/p/9699242.html][https_www.cnblogs.com_jasontec_p_9699242.html]\">https://www.cnblogs.com/jasontec/p/9699242.html][https_www.cnblogs.com_jasontec_p_9699242.html]</a></p>\n<h2 id=\"linux常用命令\"><a href=\"#linux常用命令\" class=\"headerlink\" title=\"linux常用命令\"></a>linux常用命令</h2><p>[<a href=\"https://blog.csdn.net/qq/_26230421/article/details/98359696][https_blog.csdn.net_qq_26230421_article_details_98359696]\">https://blog.csdn.net/qq\\_26230421/article/details/98359696][https_blog.csdn.net_qq_26230421_article_details_98359696]</a></p>\n<p>这些技术都会的话就可以上战场了</p>\n"},{"title":"JDK源码中NB的设计模式","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2022-11-07T02:25:02.000Z","password":null,"summary":"JDK源码中NB的设计模式","_content":"## 一、结构性模式：    \n\n### 1、适配器模式： \n\n> 常用于将一个新接口适配旧接口\n\n![image_0db7343e.png](JDK源码中NB的设计模式/image_0db7343e.png)\n\n在我们业务代码中经常有新旧接口适配需求，可以采用该模式。\n\n### 2、桥接模式： \n\n> 将抽象和抽象的具体实现进行解耦，这样可以使得抽象和抽象的具体实现可以独立进行变化。\n\n![image_80280cd4.png](JDK源码中NB的设计模式/image_80280cd4.png)\n\n：这个模式，其实我们每天都在用到，但是你可能却浑然不知。只要你用到面向接口编程，其实都是在用桥接模式。\n\n### 3、组合模式 \n\n> 让客户端看起来在处理单个对象和对象的组合是平等的，换句话说，某个类型的方法同时也接受自身类型作为参数。（So in other words methods on a type accepting the same type）\n\n![image_da86596b.png](JDK源码中NB的设计模式/image_da86596b.png)\n\n从上面那句英文我们就可以得知，组合模式常用于递归操作的优化上，比如每个公司都有个boss系统，都会有什么菜单的功能。比如一级菜单下有二级菜单，二级菜单又有三级菜单。删除一级菜单的时候需要不断删除子菜单，那么这个设计模式你可以试试。总之，凡是有级联操作的，你都可以尝试这个设计模式。\n\n### 4、装饰者模式 \n\n> 动态的给一个对象附加额外的功能，因此它也是子类化的一种替代方法。该设计模式在JDK中广泛运用，以下只是列举一小部分\n\n![image_a62166f6.png](JDK源码中NB的设计模式/image_a62166f6.png)\n\n这个模式使用就太广了，我们常用的AOP，既有动态代理，也有装饰者的味道。\n\n### 5、门面模式 \n\n> 为一组组件，接口，抽象或子系统提供简化的接口。\n\n![image_cabc5bfb.png](JDK源码中NB的设计模式/image_cabc5bfb.png)\n\n我们每天使用的SLFJ日志就是门面日志，比如我们使用Dubbo，向外提供的服务就尽量采用门面模式，然后服务在调用各种service做聚合。\n\n### 6、享元模式 \n\n> 使用缓存来减少对小对象的访问时间\n\n![image_db731042.png](JDK源码中NB的设计模式/image_db731042.png)\n\n只要用到了缓存，基本都是在使用享元模式。很多同学都说自己的项目太low了，都没有用到什么设计模式，这不是开玩笑吗，你用个map缓存几个对象，基本上都运用了享元的思想。\n\n### 7、代理模式 \n\n> 代理模式用于向较简单的对象代替创建复杂或耗时的对象。\n\n![image_e9562544.png](JDK源码中NB的设计模式/image_e9562544.png)\n\n代理模式用得很广泛，基本所有大家知道的开源框架，都用到了动态代理。\n\n## 二、创建模式 \n\n### 1、抽象工厂模式 \n\n> 抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型。它使得应用程序能够和使用的框架的具体实现进行解耦。在JDK和许多开源框架，比如Spring中随处可见，它们很容易被发现。任何用于创建对象但返回接口或抽象类的，就是抽象工厂模式了。（any method that is used to create an object but still returns a interface or abstract class）\n\n![image_fbd05a32.png](JDK源码中NB的设计模式/image_fbd05a32.png)\n\n从英文就可以得出，该模式可以与策略模式结合使用。\n\n### 2、建造者模式 \n\n> 用于通过定义一个类来简化复杂对象的创建，该类的目的是构建另一个类的实例。构建器模式还允许实现Fluent接口。\n\n![image_a7e0d82b.png](JDK源码中NB的设计模式/image_a7e0d82b.png)\n\n这个在我们业务代码中使用的场景太广泛了。比如订单系统大部分项目都有，订单对象就是一个复杂对象，我们就可以采用建造者模式来做。\n\n### 3、工厂方法 \n\n> 只是一个返回实际类型的方法。\n\n![image_b2dcd320.png](JDK源码中NB的设计模式/image_b2dcd320.png)\n\n这个属于大家都会的设计模式，不多过介绍。\n\n### 4、原型模式 \n\n> 使得类的实例能够生成自身的拷贝。如果创建一个对象的实例非常复杂且耗时时，就可以使用这种模式，而不重新创建一个新的实例，你可以拷贝一个对象并直接修改它。\n\n![image_3135fcc2.png](JDK源码中NB的设计模式/image_3135fcc2.png)\n\n这个你以为是冷门的设计模式，其实错了，这个是大热门的设计模式。比如我们业务代码，经常要各种DTO、BO、DO、VO转换，其实就可以参考原型设计模式的思想来做。\n\n### 5、单例模式 \n\n> 用来确保类只有一个实例。Joshua Bloch在Effetive Java中建议到，还有一种方法就是使用枚举。\n\n![image_f4c365cb.png](JDK源码中NB的设计模式/image_f4c365cb.png)\n\n在平时开发中，单例是我们用得最多的了，因为Spring的bean，默认就是单例级别的。单例属于大家基本都会的设计模式。\n\n## 三、行为模式 \n\n### 1、责任链 \n\n> 通过把请求从一个对象传递到链条中下一个对象的方式来解除对象之间的耦合，直到请求被处理完毕。链中的对象是同一接口或抽象类的不同实现。\n\n![image_26b58e72.png](JDK源码中NB的设计模式/image_26b58e72.png)\n\n凡是带有`Filter`关键词的，基本都在用这个设计模式。在业务代码使用的场景实在是太多了，用到拦截器的地方基本都在用这个设计模式。\n\n### 2、命令模式 \n\n> 将命令包装在对象中，以便可以将其存储，传递到方法中，并像任何其他对象一样返回。\n\n![image_12478821.png](JDK源码中NB的设计模式/image_12478821.png)\n\n命令模式使用频率较高，和策略模式比较像，具体区别可以搜索一下。如果用过`Activiti`工作流引擎的朋友可以看一下里面的源码，很多地方都用到了命令模式。\n\n### 3、解释器模式 \n\n> 此模式通常描述为该语言定义语法并使用该语法来解释该格式的语句。（This pattern generally describes defining a grammar for that language and using that grammar to interpret statements in that format.）\n\n![image_a76314fe.png](JDK源码中NB的设计模式/image_a76314fe.png)\n\n这个比较冷门，肥朝没怎么用过，你用过的话可以留言告诉肥朝。\n\n### 4、迭代器模式 \n\n> 提供一个统一的方式来访问集合中的对象。\n\n![image_56c75850.png](JDK源码中NB的设计模式/image_56c75850.png)\n\n这个中间件和基础框架组的同学可能用得比较多，业务代码的话用得不多，不过JDK中的这种使用很经典，可以看看。\n\n### 5、中介者模式 \n\n> 通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。\n\n![image_4cc8d46f.png](JDK源码中NB的设计模式/image_4cc8d46f.png)\n\n看到这个描述不用我多说什么，业务代码使用的场景太多了。比如你们用MQ，其实就是在用中介者模式。所以肥朝一再强调，即使是每天CRUD，关注肥朝一起学习，也能给你的CRUD项目，加上美颜+滤镜（设计模式）的加强效果。\n\n### 6、备忘录模式 \n\n> 生成对象状态的一个快照，以便对象可以恢复原始状态而不用暴露自身的内容。比如Date对象通过自身内部的一个long值来实现备忘录模式。\n\n![image_6794e25f.png](JDK源码中NB的设计模式/image_6794e25f.png)\n\n这个在业务中使用得不多，据肥朝了解其中一种场景是，你要把数据丢到MQ，但是MQ暂时不可用，那么你把数据暂存到DB，后面再轮询丢到MQ。如果你有更好的场景，留言告诉肥朝。\n\n### 7、空对象模式 \n\n> 它允许您抽象空对象的处理。\n\n![image_7f6ad923.png](JDK源码中NB的设计模式/image_7f6ad923.png)\n\n这个业务代码用得不多，但是JDK中的这几个方法我们倒是挺常用的。\n\n### 8、观察者模式 \n\n> 用于为组件提供一种灵活地向感兴趣的接收者广播消息的方式。\n\n![image_7cbd31c6.png](JDK源码中NB的设计模式/image_7cbd31c6.png)\n\n我们业务代码一般是基于Zookeeper来做观察者的。基本上用到ZK的地方，都是在用观察者模式，比如分布式锁，比如服务发现等。\n\n### 9、状态模式 \n\n> 允许您在运行时根据内部状态轻松更改对象的行为。\n\n![image_8826e899.png](JDK源码中NB的设计模式/image_8826e899.png)\n\n这个在业务代码用得就太广泛了，我就不信你们系统还没有“状态”了。比如我们常见的订单状态或者各种XX状态，都可以用得上。\n\n### 10、策略模式 \n\n> 使用这个模式来将一组算法封装成一系列对象。通过调用这些对象可以灵活的改变程序的功能。\n\n![image_056a7a91.png](JDK源码中NB的设计模式/image_056a7a91.png)\n\n这个太高频了，常用于优化大量的`if-else`,如果这个设计模式都不会，出去不要说关注过肥朝的公众号！\n\n### 11、模板方法模式 \n\n> 让子类可以重写方法的一部分，而不是整个重写，你可以控制子类需要重写那些操作。\n\n![image_0f3aa81b.png](JDK源码中NB的设计模式/image_0f3aa81b.png)\n\n这个模式也是非常高频的模式。业务代码中经常遇到有很多相同的部分，我们可以做一个抽象类，子类来实现差异化，如果还不知道的，赶紧搜索一下，再次强调，非常高频。\n\n### 12、访问者模式 \n\n> 提供一个方便的可维护的方式来操作一组对象。它使得你在不改变操作的对象前提下，可以修改或者扩展对象的行为。\n\n![image_09845ad7.png](JDK源码中NB的设计模式/image_09845ad7.png)","source":"_posts/JDK源码中NB的设计模式.md","raw":"---\ntitle: JDK源码中NB的设计模式\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2022-11-07 10:25:02\npassword:\nsummary: JDK源码中NB的设计模式\ntags:\n    - jdk源码\n    - 设计模式\ncategories:\n    - java\n---\n## 一、结构性模式：    \n\n### 1、适配器模式： \n\n> 常用于将一个新接口适配旧接口\n\n![image_0db7343e.png](JDK源码中NB的设计模式/image_0db7343e.png)\n\n在我们业务代码中经常有新旧接口适配需求，可以采用该模式。\n\n### 2、桥接模式： \n\n> 将抽象和抽象的具体实现进行解耦，这样可以使得抽象和抽象的具体实现可以独立进行变化。\n\n![image_80280cd4.png](JDK源码中NB的设计模式/image_80280cd4.png)\n\n：这个模式，其实我们每天都在用到，但是你可能却浑然不知。只要你用到面向接口编程，其实都是在用桥接模式。\n\n### 3、组合模式 \n\n> 让客户端看起来在处理单个对象和对象的组合是平等的，换句话说，某个类型的方法同时也接受自身类型作为参数。（So in other words methods on a type accepting the same type）\n\n![image_da86596b.png](JDK源码中NB的设计模式/image_da86596b.png)\n\n从上面那句英文我们就可以得知，组合模式常用于递归操作的优化上，比如每个公司都有个boss系统，都会有什么菜单的功能。比如一级菜单下有二级菜单，二级菜单又有三级菜单。删除一级菜单的时候需要不断删除子菜单，那么这个设计模式你可以试试。总之，凡是有级联操作的，你都可以尝试这个设计模式。\n\n### 4、装饰者模式 \n\n> 动态的给一个对象附加额外的功能，因此它也是子类化的一种替代方法。该设计模式在JDK中广泛运用，以下只是列举一小部分\n\n![image_a62166f6.png](JDK源码中NB的设计模式/image_a62166f6.png)\n\n这个模式使用就太广了，我们常用的AOP，既有动态代理，也有装饰者的味道。\n\n### 5、门面模式 \n\n> 为一组组件，接口，抽象或子系统提供简化的接口。\n\n![image_cabc5bfb.png](JDK源码中NB的设计模式/image_cabc5bfb.png)\n\n我们每天使用的SLFJ日志就是门面日志，比如我们使用Dubbo，向外提供的服务就尽量采用门面模式，然后服务在调用各种service做聚合。\n\n### 6、享元模式 \n\n> 使用缓存来减少对小对象的访问时间\n\n![image_db731042.png](JDK源码中NB的设计模式/image_db731042.png)\n\n只要用到了缓存，基本都是在使用享元模式。很多同学都说自己的项目太low了，都没有用到什么设计模式，这不是开玩笑吗，你用个map缓存几个对象，基本上都运用了享元的思想。\n\n### 7、代理模式 \n\n> 代理模式用于向较简单的对象代替创建复杂或耗时的对象。\n\n![image_e9562544.png](JDK源码中NB的设计模式/image_e9562544.png)\n\n代理模式用得很广泛，基本所有大家知道的开源框架，都用到了动态代理。\n\n## 二、创建模式 \n\n### 1、抽象工厂模式 \n\n> 抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型。它使得应用程序能够和使用的框架的具体实现进行解耦。在JDK和许多开源框架，比如Spring中随处可见，它们很容易被发现。任何用于创建对象但返回接口或抽象类的，就是抽象工厂模式了。（any method that is used to create an object but still returns a interface or abstract class）\n\n![image_fbd05a32.png](JDK源码中NB的设计模式/image_fbd05a32.png)\n\n从英文就可以得出，该模式可以与策略模式结合使用。\n\n### 2、建造者模式 \n\n> 用于通过定义一个类来简化复杂对象的创建，该类的目的是构建另一个类的实例。构建器模式还允许实现Fluent接口。\n\n![image_a7e0d82b.png](JDK源码中NB的设计模式/image_a7e0d82b.png)\n\n这个在我们业务代码中使用的场景太广泛了。比如订单系统大部分项目都有，订单对象就是一个复杂对象，我们就可以采用建造者模式来做。\n\n### 3、工厂方法 \n\n> 只是一个返回实际类型的方法。\n\n![image_b2dcd320.png](JDK源码中NB的设计模式/image_b2dcd320.png)\n\n这个属于大家都会的设计模式，不多过介绍。\n\n### 4、原型模式 \n\n> 使得类的实例能够生成自身的拷贝。如果创建一个对象的实例非常复杂且耗时时，就可以使用这种模式，而不重新创建一个新的实例，你可以拷贝一个对象并直接修改它。\n\n![image_3135fcc2.png](JDK源码中NB的设计模式/image_3135fcc2.png)\n\n这个你以为是冷门的设计模式，其实错了，这个是大热门的设计模式。比如我们业务代码，经常要各种DTO、BO、DO、VO转换，其实就可以参考原型设计模式的思想来做。\n\n### 5、单例模式 \n\n> 用来确保类只有一个实例。Joshua Bloch在Effetive Java中建议到，还有一种方法就是使用枚举。\n\n![image_f4c365cb.png](JDK源码中NB的设计模式/image_f4c365cb.png)\n\n在平时开发中，单例是我们用得最多的了，因为Spring的bean，默认就是单例级别的。单例属于大家基本都会的设计模式。\n\n## 三、行为模式 \n\n### 1、责任链 \n\n> 通过把请求从一个对象传递到链条中下一个对象的方式来解除对象之间的耦合，直到请求被处理完毕。链中的对象是同一接口或抽象类的不同实现。\n\n![image_26b58e72.png](JDK源码中NB的设计模式/image_26b58e72.png)\n\n凡是带有`Filter`关键词的，基本都在用这个设计模式。在业务代码使用的场景实在是太多了，用到拦截器的地方基本都在用这个设计模式。\n\n### 2、命令模式 \n\n> 将命令包装在对象中，以便可以将其存储，传递到方法中，并像任何其他对象一样返回。\n\n![image_12478821.png](JDK源码中NB的设计模式/image_12478821.png)\n\n命令模式使用频率较高，和策略模式比较像，具体区别可以搜索一下。如果用过`Activiti`工作流引擎的朋友可以看一下里面的源码，很多地方都用到了命令模式。\n\n### 3、解释器模式 \n\n> 此模式通常描述为该语言定义语法并使用该语法来解释该格式的语句。（This pattern generally describes defining a grammar for that language and using that grammar to interpret statements in that format.）\n\n![image_a76314fe.png](JDK源码中NB的设计模式/image_a76314fe.png)\n\n这个比较冷门，肥朝没怎么用过，你用过的话可以留言告诉肥朝。\n\n### 4、迭代器模式 \n\n> 提供一个统一的方式来访问集合中的对象。\n\n![image_56c75850.png](JDK源码中NB的设计模式/image_56c75850.png)\n\n这个中间件和基础框架组的同学可能用得比较多，业务代码的话用得不多，不过JDK中的这种使用很经典，可以看看。\n\n### 5、中介者模式 \n\n> 通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。\n\n![image_4cc8d46f.png](JDK源码中NB的设计模式/image_4cc8d46f.png)\n\n看到这个描述不用我多说什么，业务代码使用的场景太多了。比如你们用MQ，其实就是在用中介者模式。所以肥朝一再强调，即使是每天CRUD，关注肥朝一起学习，也能给你的CRUD项目，加上美颜+滤镜（设计模式）的加强效果。\n\n### 6、备忘录模式 \n\n> 生成对象状态的一个快照，以便对象可以恢复原始状态而不用暴露自身的内容。比如Date对象通过自身内部的一个long值来实现备忘录模式。\n\n![image_6794e25f.png](JDK源码中NB的设计模式/image_6794e25f.png)\n\n这个在业务中使用得不多，据肥朝了解其中一种场景是，你要把数据丢到MQ，但是MQ暂时不可用，那么你把数据暂存到DB，后面再轮询丢到MQ。如果你有更好的场景，留言告诉肥朝。\n\n### 7、空对象模式 \n\n> 它允许您抽象空对象的处理。\n\n![image_7f6ad923.png](JDK源码中NB的设计模式/image_7f6ad923.png)\n\n这个业务代码用得不多，但是JDK中的这几个方法我们倒是挺常用的。\n\n### 8、观察者模式 \n\n> 用于为组件提供一种灵活地向感兴趣的接收者广播消息的方式。\n\n![image_7cbd31c6.png](JDK源码中NB的设计模式/image_7cbd31c6.png)\n\n我们业务代码一般是基于Zookeeper来做观察者的。基本上用到ZK的地方，都是在用观察者模式，比如分布式锁，比如服务发现等。\n\n### 9、状态模式 \n\n> 允许您在运行时根据内部状态轻松更改对象的行为。\n\n![image_8826e899.png](JDK源码中NB的设计模式/image_8826e899.png)\n\n这个在业务代码用得就太广泛了，我就不信你们系统还没有“状态”了。比如我们常见的订单状态或者各种XX状态，都可以用得上。\n\n### 10、策略模式 \n\n> 使用这个模式来将一组算法封装成一系列对象。通过调用这些对象可以灵活的改变程序的功能。\n\n![image_056a7a91.png](JDK源码中NB的设计模式/image_056a7a91.png)\n\n这个太高频了，常用于优化大量的`if-else`,如果这个设计模式都不会，出去不要说关注过肥朝的公众号！\n\n### 11、模板方法模式 \n\n> 让子类可以重写方法的一部分，而不是整个重写，你可以控制子类需要重写那些操作。\n\n![image_0f3aa81b.png](JDK源码中NB的设计模式/image_0f3aa81b.png)\n\n这个模式也是非常高频的模式。业务代码中经常遇到有很多相同的部分，我们可以做一个抽象类，子类来实现差异化，如果还不知道的，赶紧搜索一下，再次强调，非常高频。\n\n### 12、访问者模式 \n\n> 提供一个方便的可维护的方式来操作一组对象。它使得你在不改变操作的对象前提下，可以修改或者扩展对象的行为。\n\n![image_09845ad7.png](JDK源码中NB的设计模式/image_09845ad7.png)","slug":"JDK源码中NB的设计模式","published":1,"updated":"2022-11-07T02:25:49.685Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cla65vzs60000uylddl2n5sz7","content":"<h2 id=\"一、结构性模式：\"><a href=\"#一、结构性模式：\" class=\"headerlink\" title=\"一、结构性模式：\"></a>一、结构性模式：</h2><h3 id=\"1、适配器模式：\"><a href=\"#1、适配器模式：\" class=\"headerlink\" title=\"1、适配器模式：\"></a>1、适配器模式：</h3><blockquote>\n<p>常用于将一个新接口适配旧接口</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_0db7343e.png\" alt=\"image_0db7343e.png\"></p>\n<p>在我们业务代码中经常有新旧接口适配需求，可以采用该模式。</p>\n<h3 id=\"2、桥接模式：\"><a href=\"#2、桥接模式：\" class=\"headerlink\" title=\"2、桥接模式：\"></a>2、桥接模式：</h3><blockquote>\n<p>将抽象和抽象的具体实现进行解耦，这样可以使得抽象和抽象的具体实现可以独立进行变化。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_80280cd4.png\" alt=\"image_80280cd4.png\"></p>\n<p>：这个模式，其实我们每天都在用到，但是你可能却浑然不知。只要你用到面向接口编程，其实都是在用桥接模式。</p>\n<h3 id=\"3、组合模式\"><a href=\"#3、组合模式\" class=\"headerlink\" title=\"3、组合模式\"></a>3、组合模式</h3><blockquote>\n<p>让客户端看起来在处理单个对象和对象的组合是平等的，换句话说，某个类型的方法同时也接受自身类型作为参数。（So in other words methods on a type accepting the same type）</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_da86596b.png\" alt=\"image_da86596b.png\"></p>\n<p>从上面那句英文我们就可以得知，组合模式常用于递归操作的优化上，比如每个公司都有个boss系统，都会有什么菜单的功能。比如一级菜单下有二级菜单，二级菜单又有三级菜单。删除一级菜单的时候需要不断删除子菜单，那么这个设计模式你可以试试。总之，凡是有级联操作的，你都可以尝试这个设计模式。</p>\n<h3 id=\"4、装饰者模式\"><a href=\"#4、装饰者模式\" class=\"headerlink\" title=\"4、装饰者模式\"></a>4、装饰者模式</h3><blockquote>\n<p>动态的给一个对象附加额外的功能，因此它也是子类化的一种替代方法。该设计模式在JDK中广泛运用，以下只是列举一小部分</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_a62166f6.png\" alt=\"image_a62166f6.png\"></p>\n<p>这个模式使用就太广了，我们常用的AOP，既有动态代理，也有装饰者的味道。</p>\n<h3 id=\"5、门面模式\"><a href=\"#5、门面模式\" class=\"headerlink\" title=\"5、门面模式\"></a>5、门面模式</h3><blockquote>\n<p>为一组组件，接口，抽象或子系统提供简化的接口。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_cabc5bfb.png\" alt=\"image_cabc5bfb.png\"></p>\n<p>我们每天使用的SLFJ日志就是门面日志，比如我们使用Dubbo，向外提供的服务就尽量采用门面模式，然后服务在调用各种service做聚合。</p>\n<h3 id=\"6、享元模式\"><a href=\"#6、享元模式\" class=\"headerlink\" title=\"6、享元模式\"></a>6、享元模式</h3><blockquote>\n<p>使用缓存来减少对小对象的访问时间</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_db731042.png\" alt=\"image_db731042.png\"></p>\n<p>只要用到了缓存，基本都是在使用享元模式。很多同学都说自己的项目太low了，都没有用到什么设计模式，这不是开玩笑吗，你用个map缓存几个对象，基本上都运用了享元的思想。</p>\n<h3 id=\"7、代理模式\"><a href=\"#7、代理模式\" class=\"headerlink\" title=\"7、代理模式\"></a>7、代理模式</h3><blockquote>\n<p>代理模式用于向较简单的对象代替创建复杂或耗时的对象。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_e9562544.png\" alt=\"image_e9562544.png\"></p>\n<p>代理模式用得很广泛，基本所有大家知道的开源框架，都用到了动态代理。</p>\n<h2 id=\"二、创建模式\"><a href=\"#二、创建模式\" class=\"headerlink\" title=\"二、创建模式\"></a>二、创建模式</h2><h3 id=\"1、抽象工厂模式\"><a href=\"#1、抽象工厂模式\" class=\"headerlink\" title=\"1、抽象工厂模式\"></a>1、抽象工厂模式</h3><blockquote>\n<p>抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型。它使得应用程序能够和使用的框架的具体实现进行解耦。在JDK和许多开源框架，比如Spring中随处可见，它们很容易被发现。任何用于创建对象但返回接口或抽象类的，就是抽象工厂模式了。（any method that is used to create an object but still returns a interface or abstract class）</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_fbd05a32.png\" alt=\"image_fbd05a32.png\"></p>\n<p>从英文就可以得出，该模式可以与策略模式结合使用。</p>\n<h3 id=\"2、建造者模式\"><a href=\"#2、建造者模式\" class=\"headerlink\" title=\"2、建造者模式\"></a>2、建造者模式</h3><blockquote>\n<p>用于通过定义一个类来简化复杂对象的创建，该类的目的是构建另一个类的实例。构建器模式还允许实现Fluent接口。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_a7e0d82b.png\" alt=\"image_a7e0d82b.png\"></p>\n<p>这个在我们业务代码中使用的场景太广泛了。比如订单系统大部分项目都有，订单对象就是一个复杂对象，我们就可以采用建造者模式来做。</p>\n<h3 id=\"3、工厂方法\"><a href=\"#3、工厂方法\" class=\"headerlink\" title=\"3、工厂方法\"></a>3、工厂方法</h3><blockquote>\n<p>只是一个返回实际类型的方法。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_b2dcd320.png\" alt=\"image_b2dcd320.png\"></p>\n<p>这个属于大家都会的设计模式，不多过介绍。</p>\n<h3 id=\"4、原型模式\"><a href=\"#4、原型模式\" class=\"headerlink\" title=\"4、原型模式\"></a>4、原型模式</h3><blockquote>\n<p>使得类的实例能够生成自身的拷贝。如果创建一个对象的实例非常复杂且耗时时，就可以使用这种模式，而不重新创建一个新的实例，你可以拷贝一个对象并直接修改它。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_3135fcc2.png\" alt=\"image_3135fcc2.png\"></p>\n<p>这个你以为是冷门的设计模式，其实错了，这个是大热门的设计模式。比如我们业务代码，经常要各种DTO、BO、DO、VO转换，其实就可以参考原型设计模式的思想来做。</p>\n<h3 id=\"5、单例模式\"><a href=\"#5、单例模式\" class=\"headerlink\" title=\"5、单例模式\"></a>5、单例模式</h3><blockquote>\n<p>用来确保类只有一个实例。Joshua Bloch在Effetive Java中建议到，还有一种方法就是使用枚举。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_f4c365cb.png\" alt=\"image_f4c365cb.png\"></p>\n<p>在平时开发中，单例是我们用得最多的了，因为Spring的bean，默认就是单例级别的。单例属于大家基本都会的设计模式。</p>\n<h2 id=\"三、行为模式\"><a href=\"#三、行为模式\" class=\"headerlink\" title=\"三、行为模式\"></a>三、行为模式</h2><h3 id=\"1、责任链\"><a href=\"#1、责任链\" class=\"headerlink\" title=\"1、责任链\"></a>1、责任链</h3><blockquote>\n<p>通过把请求从一个对象传递到链条中下一个对象的方式来解除对象之间的耦合，直到请求被处理完毕。链中的对象是同一接口或抽象类的不同实现。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_26b58e72.png\" alt=\"image_26b58e72.png\"></p>\n<p>凡是带有<code>Filter</code>关键词的，基本都在用这个设计模式。在业务代码使用的场景实在是太多了，用到拦截器的地方基本都在用这个设计模式。</p>\n<h3 id=\"2、命令模式\"><a href=\"#2、命令模式\" class=\"headerlink\" title=\"2、命令模式\"></a>2、命令模式</h3><blockquote>\n<p>将命令包装在对象中，以便可以将其存储，传递到方法中，并像任何其他对象一样返回。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_12478821.png\" alt=\"image_12478821.png\"></p>\n<p>命令模式使用频率较高，和策略模式比较像，具体区别可以搜索一下。如果用过<code>Activiti</code>工作流引擎的朋友可以看一下里面的源码，很多地方都用到了命令模式。</p>\n<h3 id=\"3、解释器模式\"><a href=\"#3、解释器模式\" class=\"headerlink\" title=\"3、解释器模式\"></a>3、解释器模式</h3><blockquote>\n<p>此模式通常描述为该语言定义语法并使用该语法来解释该格式的语句。（This pattern generally describes defining a grammar for that language and using that grammar to interpret statements in that format.）</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_a76314fe.png\" alt=\"image_a76314fe.png\"></p>\n<p>这个比较冷门，肥朝没怎么用过，你用过的话可以留言告诉肥朝。</p>\n<h3 id=\"4、迭代器模式\"><a href=\"#4、迭代器模式\" class=\"headerlink\" title=\"4、迭代器模式\"></a>4、迭代器模式</h3><blockquote>\n<p>提供一个统一的方式来访问集合中的对象。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_56c75850.png\" alt=\"image_56c75850.png\"></p>\n<p>这个中间件和基础框架组的同学可能用得比较多，业务代码的话用得不多，不过JDK中的这种使用很经典，可以看看。</p>\n<h3 id=\"5、中介者模式\"><a href=\"#5、中介者模式\" class=\"headerlink\" title=\"5、中介者模式\"></a>5、中介者模式</h3><blockquote>\n<p>通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_4cc8d46f.png\" alt=\"image_4cc8d46f.png\"></p>\n<p>看到这个描述不用我多说什么，业务代码使用的场景太多了。比如你们用MQ，其实就是在用中介者模式。所以肥朝一再强调，即使是每天CRUD，关注肥朝一起学习，也能给你的CRUD项目，加上美颜+滤镜（设计模式）的加强效果。</p>\n<h3 id=\"6、备忘录模式\"><a href=\"#6、备忘录模式\" class=\"headerlink\" title=\"6、备忘录模式\"></a>6、备忘录模式</h3><blockquote>\n<p>生成对象状态的一个快照，以便对象可以恢复原始状态而不用暴露自身的内容。比如Date对象通过自身内部的一个long值来实现备忘录模式。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_6794e25f.png\" alt=\"image_6794e25f.png\"></p>\n<p>这个在业务中使用得不多，据肥朝了解其中一种场景是，你要把数据丢到MQ，但是MQ暂时不可用，那么你把数据暂存到DB，后面再轮询丢到MQ。如果你有更好的场景，留言告诉肥朝。</p>\n<h3 id=\"7、空对象模式\"><a href=\"#7、空对象模式\" class=\"headerlink\" title=\"7、空对象模式\"></a>7、空对象模式</h3><blockquote>\n<p>它允许您抽象空对象的处理。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_7f6ad923.png\" alt=\"image_7f6ad923.png\"></p>\n<p>这个业务代码用得不多，但是JDK中的这几个方法我们倒是挺常用的。</p>\n<h3 id=\"8、观察者模式\"><a href=\"#8、观察者模式\" class=\"headerlink\" title=\"8、观察者模式\"></a>8、观察者模式</h3><blockquote>\n<p>用于为组件提供一种灵活地向感兴趣的接收者广播消息的方式。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_7cbd31c6.png\" alt=\"image_7cbd31c6.png\"></p>\n<p>我们业务代码一般是基于Zookeeper来做观察者的。基本上用到ZK的地方，都是在用观察者模式，比如分布式锁，比如服务发现等。</p>\n<h3 id=\"9、状态模式\"><a href=\"#9、状态模式\" class=\"headerlink\" title=\"9、状态模式\"></a>9、状态模式</h3><blockquote>\n<p>允许您在运行时根据内部状态轻松更改对象的行为。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_8826e899.png\" alt=\"image_8826e899.png\"></p>\n<p>这个在业务代码用得就太广泛了，我就不信你们系统还没有“状态”了。比如我们常见的订单状态或者各种XX状态，都可以用得上。</p>\n<h3 id=\"10、策略模式\"><a href=\"#10、策略模式\" class=\"headerlink\" title=\"10、策略模式\"></a>10、策略模式</h3><blockquote>\n<p>使用这个模式来将一组算法封装成一系列对象。通过调用这些对象可以灵活的改变程序的功能。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_056a7a91.png\" alt=\"image_056a7a91.png\"></p>\n<p>这个太高频了，常用于优化大量的<code>if-else</code>,如果这个设计模式都不会，出去不要说关注过肥朝的公众号！</p>\n<h3 id=\"11、模板方法模式\"><a href=\"#11、模板方法模式\" class=\"headerlink\" title=\"11、模板方法模式\"></a>11、模板方法模式</h3><blockquote>\n<p>让子类可以重写方法的一部分，而不是整个重写，你可以控制子类需要重写那些操作。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_0f3aa81b.png\" alt=\"image_0f3aa81b.png\"></p>\n<p>这个模式也是非常高频的模式。业务代码中经常遇到有很多相同的部分，我们可以做一个抽象类，子类来实现差异化，如果还不知道的，赶紧搜索一下，再次强调，非常高频。</p>\n<h3 id=\"12、访问者模式\"><a href=\"#12、访问者模式\" class=\"headerlink\" title=\"12、访问者模式\"></a>12、访问者模式</h3><blockquote>\n<p>提供一个方便的可维护的方式来操作一组对象。它使得你在不改变操作的对象前提下，可以修改或者扩展对象的行为。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_09845ad7.png\" alt=\"image_09845ad7.png\"></p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<h2 id=\"一、结构性模式：\"><a href=\"#一、结构性模式：\" class=\"headerlink\" title=\"一、结构性模式：\"></a>一、结构性模式：</h2><h3 id=\"1、适配器模式：\"><a href=\"#1、适配器模式：\" class=\"headerlink\" title=\"1、适配器模式：\"></a>1、适配器模式：</h3><blockquote>\n<p>常用于将一个新接口适配旧接口</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_0db7343e.png\" alt=\"image_0db7343e.png\"></p>\n<p>在我们业务代码中经常有新旧接口适配需求，可以采用该模式。</p>\n<h3 id=\"2、桥接模式：\"><a href=\"#2、桥接模式：\" class=\"headerlink\" title=\"2、桥接模式：\"></a>2、桥接模式：</h3><blockquote>\n<p>将抽象和抽象的具体实现进行解耦，这样可以使得抽象和抽象的具体实现可以独立进行变化。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_80280cd4.png\" alt=\"image_80280cd4.png\"></p>\n<p>：这个模式，其实我们每天都在用到，但是你可能却浑然不知。只要你用到面向接口编程，其实都是在用桥接模式。</p>\n<h3 id=\"3、组合模式\"><a href=\"#3、组合模式\" class=\"headerlink\" title=\"3、组合模式\"></a>3、组合模式</h3><blockquote>\n<p>让客户端看起来在处理单个对象和对象的组合是平等的，换句话说，某个类型的方法同时也接受自身类型作为参数。（So in other words methods on a type accepting the same type）</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_da86596b.png\" alt=\"image_da86596b.png\"></p>\n<p>从上面那句英文我们就可以得知，组合模式常用于递归操作的优化上，比如每个公司都有个boss系统，都会有什么菜单的功能。比如一级菜单下有二级菜单，二级菜单又有三级菜单。删除一级菜单的时候需要不断删除子菜单，那么这个设计模式你可以试试。总之，凡是有级联操作的，你都可以尝试这个设计模式。</p>\n<h3 id=\"4、装饰者模式\"><a href=\"#4、装饰者模式\" class=\"headerlink\" title=\"4、装饰者模式\"></a>4、装饰者模式</h3><blockquote>\n<p>动态的给一个对象附加额外的功能，因此它也是子类化的一种替代方法。该设计模式在JDK中广泛运用，以下只是列举一小部分</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_a62166f6.png\" alt=\"image_a62166f6.png\"></p>\n<p>这个模式使用就太广了，我们常用的AOP，既有动态代理，也有装饰者的味道。</p>\n<h3 id=\"5、门面模式\"><a href=\"#5、门面模式\" class=\"headerlink\" title=\"5、门面模式\"></a>5、门面模式</h3><blockquote>\n<p>为一组组件，接口，抽象或子系统提供简化的接口。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_cabc5bfb.png\" alt=\"image_cabc5bfb.png\"></p>\n<p>我们每天使用的SLFJ日志就是门面日志，比如我们使用Dubbo，向外提供的服务就尽量采用门面模式，然后服务在调用各种service做聚合。</p>\n<h3 id=\"6、享元模式\"><a href=\"#6、享元模式\" class=\"headerlink\" title=\"6、享元模式\"></a>6、享元模式</h3><blockquote>\n<p>使用缓存来减少对小对象的访问时间</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_db731042.png\" alt=\"image_db731042.png\"></p>\n<p>只要用到了缓存，基本都是在使用享元模式。很多同学都说自己的项目太low了，都没有用到什么设计模式，这不是开玩笑吗，你用个map缓存几个对象，基本上都运用了享元的思想。</p>\n<h3 id=\"7、代理模式\"><a href=\"#7、代理模式\" class=\"headerlink\" title=\"7、代理模式\"></a>7、代理模式</h3><blockquote>\n<p>代理模式用于向较简单的对象代替创建复杂或耗时的对象。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_e9562544.png\" alt=\"image_e9562544.png\"></p>\n<p>代理模式用得很广泛，基本所有大家知道的开源框架，都用到了动态代理。</p>\n<h2 id=\"二、创建模式\"><a href=\"#二、创建模式\" class=\"headerlink\" title=\"二、创建模式\"></a>二、创建模式</h2><h3 id=\"1、抽象工厂模式\"><a href=\"#1、抽象工厂模式\" class=\"headerlink\" title=\"1、抽象工厂模式\"></a>1、抽象工厂模式</h3><blockquote>\n<p>抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型。它使得应用程序能够和使用的框架的具体实现进行解耦。在JDK和许多开源框架，比如Spring中随处可见，它们很容易被发现。任何用于创建对象但返回接口或抽象类的，就是抽象工厂模式了。（any method that is used to create an object but still returns a interface or abstract class）</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_fbd05a32.png\" alt=\"image_fbd05a32.png\"></p>\n<p>从英文就可以得出，该模式可以与策略模式结合使用。</p>\n<h3 id=\"2、建造者模式\"><a href=\"#2、建造者模式\" class=\"headerlink\" title=\"2、建造者模式\"></a>2、建造者模式</h3><blockquote>\n<p>用于通过定义一个类来简化复杂对象的创建，该类的目的是构建另一个类的实例。构建器模式还允许实现Fluent接口。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_a7e0d82b.png\" alt=\"image_a7e0d82b.png\"></p>\n<p>这个在我们业务代码中使用的场景太广泛了。比如订单系统大部分项目都有，订单对象就是一个复杂对象，我们就可以采用建造者模式来做。</p>\n<h3 id=\"3、工厂方法\"><a href=\"#3、工厂方法\" class=\"headerlink\" title=\"3、工厂方法\"></a>3、工厂方法</h3><blockquote>\n<p>只是一个返回实际类型的方法。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_b2dcd320.png\" alt=\"image_b2dcd320.png\"></p>\n<p>这个属于大家都会的设计模式，不多过介绍。</p>\n<h3 id=\"4、原型模式\"><a href=\"#4、原型模式\" class=\"headerlink\" title=\"4、原型模式\"></a>4、原型模式</h3><blockquote>\n<p>使得类的实例能够生成自身的拷贝。如果创建一个对象的实例非常复杂且耗时时，就可以使用这种模式，而不重新创建一个新的实例，你可以拷贝一个对象并直接修改它。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_3135fcc2.png\" alt=\"image_3135fcc2.png\"></p>\n<p>这个你以为是冷门的设计模式，其实错了，这个是大热门的设计模式。比如我们业务代码，经常要各种DTO、BO、DO、VO转换，其实就可以参考原型设计模式的思想来做。</p>\n<h3 id=\"5、单例模式\"><a href=\"#5、单例模式\" class=\"headerlink\" title=\"5、单例模式\"></a>5、单例模式</h3><blockquote>\n<p>用来确保类只有一个实例。Joshua Bloch在Effetive Java中建议到，还有一种方法就是使用枚举。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_f4c365cb.png\" alt=\"image_f4c365cb.png\"></p>\n<p>在平时开发中，单例是我们用得最多的了，因为Spring的bean，默认就是单例级别的。单例属于大家基本都会的设计模式。</p>\n<h2 id=\"三、行为模式\"><a href=\"#三、行为模式\" class=\"headerlink\" title=\"三、行为模式\"></a>三、行为模式</h2><h3 id=\"1、责任链\"><a href=\"#1、责任链\" class=\"headerlink\" title=\"1、责任链\"></a>1、责任链</h3><blockquote>\n<p>通过把请求从一个对象传递到链条中下一个对象的方式来解除对象之间的耦合，直到请求被处理完毕。链中的对象是同一接口或抽象类的不同实现。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_26b58e72.png\" alt=\"image_26b58e72.png\"></p>\n<p>凡是带有<code>Filter</code>关键词的，基本都在用这个设计模式。在业务代码使用的场景实在是太多了，用到拦截器的地方基本都在用这个设计模式。</p>\n<h3 id=\"2、命令模式\"><a href=\"#2、命令模式\" class=\"headerlink\" title=\"2、命令模式\"></a>2、命令模式</h3><blockquote>\n<p>将命令包装在对象中，以便可以将其存储，传递到方法中，并像任何其他对象一样返回。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_12478821.png\" alt=\"image_12478821.png\"></p>\n<p>命令模式使用频率较高，和策略模式比较像，具体区别可以搜索一下。如果用过<code>Activiti</code>工作流引擎的朋友可以看一下里面的源码，很多地方都用到了命令模式。</p>\n<h3 id=\"3、解释器模式\"><a href=\"#3、解释器模式\" class=\"headerlink\" title=\"3、解释器模式\"></a>3、解释器模式</h3><blockquote>\n<p>此模式通常描述为该语言定义语法并使用该语法来解释该格式的语句。（This pattern generally describes defining a grammar for that language and using that grammar to interpret statements in that format.）</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_a76314fe.png\" alt=\"image_a76314fe.png\"></p>\n<p>这个比较冷门，肥朝没怎么用过，你用过的话可以留言告诉肥朝。</p>\n<h3 id=\"4、迭代器模式\"><a href=\"#4、迭代器模式\" class=\"headerlink\" title=\"4、迭代器模式\"></a>4、迭代器模式</h3><blockquote>\n<p>提供一个统一的方式来访问集合中的对象。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_56c75850.png\" alt=\"image_56c75850.png\"></p>\n<p>这个中间件和基础框架组的同学可能用得比较多，业务代码的话用得不多，不过JDK中的这种使用很经典，可以看看。</p>\n<h3 id=\"5、中介者模式\"><a href=\"#5、中介者模式\" class=\"headerlink\" title=\"5、中介者模式\"></a>5、中介者模式</h3><blockquote>\n<p>通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_4cc8d46f.png\" alt=\"image_4cc8d46f.png\"></p>\n<p>看到这个描述不用我多说什么，业务代码使用的场景太多了。比如你们用MQ，其实就是在用中介者模式。所以肥朝一再强调，即使是每天CRUD，关注肥朝一起学习，也能给你的CRUD项目，加上美颜+滤镜（设计模式）的加强效果。</p>\n<h3 id=\"6、备忘录模式\"><a href=\"#6、备忘录模式\" class=\"headerlink\" title=\"6、备忘录模式\"></a>6、备忘录模式</h3><blockquote>\n<p>生成对象状态的一个快照，以便对象可以恢复原始状态而不用暴露自身的内容。比如Date对象通过自身内部的一个long值来实现备忘录模式。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_6794e25f.png\" alt=\"image_6794e25f.png\"></p>\n<p>这个在业务中使用得不多，据肥朝了解其中一种场景是，你要把数据丢到MQ，但是MQ暂时不可用，那么你把数据暂存到DB，后面再轮询丢到MQ。如果你有更好的场景，留言告诉肥朝。</p>\n<h3 id=\"7、空对象模式\"><a href=\"#7、空对象模式\" class=\"headerlink\" title=\"7、空对象模式\"></a>7、空对象模式</h3><blockquote>\n<p>它允许您抽象空对象的处理。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_7f6ad923.png\" alt=\"image_7f6ad923.png\"></p>\n<p>这个业务代码用得不多，但是JDK中的这几个方法我们倒是挺常用的。</p>\n<h3 id=\"8、观察者模式\"><a href=\"#8、观察者模式\" class=\"headerlink\" title=\"8、观察者模式\"></a>8、观察者模式</h3><blockquote>\n<p>用于为组件提供一种灵活地向感兴趣的接收者广播消息的方式。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_7cbd31c6.png\" alt=\"image_7cbd31c6.png\"></p>\n<p>我们业务代码一般是基于Zookeeper来做观察者的。基本上用到ZK的地方，都是在用观察者模式，比如分布式锁，比如服务发现等。</p>\n<h3 id=\"9、状态模式\"><a href=\"#9、状态模式\" class=\"headerlink\" title=\"9、状态模式\"></a>9、状态模式</h3><blockquote>\n<p>允许您在运行时根据内部状态轻松更改对象的行为。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_8826e899.png\" alt=\"image_8826e899.png\"></p>\n<p>这个在业务代码用得就太广泛了，我就不信你们系统还没有“状态”了。比如我们常见的订单状态或者各种XX状态，都可以用得上。</p>\n<h3 id=\"10、策略模式\"><a href=\"#10、策略模式\" class=\"headerlink\" title=\"10、策略模式\"></a>10、策略模式</h3><blockquote>\n<p>使用这个模式来将一组算法封装成一系列对象。通过调用这些对象可以灵活的改变程序的功能。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_056a7a91.png\" alt=\"image_056a7a91.png\"></p>\n<p>这个太高频了，常用于优化大量的<code>if-else</code>,如果这个设计模式都不会，出去不要说关注过肥朝的公众号！</p>\n<h3 id=\"11、模板方法模式\"><a href=\"#11、模板方法模式\" class=\"headerlink\" title=\"11、模板方法模式\"></a>11、模板方法模式</h3><blockquote>\n<p>让子类可以重写方法的一部分，而不是整个重写，你可以控制子类需要重写那些操作。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_0f3aa81b.png\" alt=\"image_0f3aa81b.png\"></p>\n<p>这个模式也是非常高频的模式。业务代码中经常遇到有很多相同的部分，我们可以做一个抽象类，子类来实现差异化，如果还不知道的，赶紧搜索一下，再次强调，非常高频。</p>\n<h3 id=\"12、访问者模式\"><a href=\"#12、访问者模式\" class=\"headerlink\" title=\"12、访问者模式\"></a>12、访问者模式</h3><blockquote>\n<p>提供一个方便的可维护的方式来操作一组对象。它使得你在不改变操作的对象前提下，可以修改或者扩展对象的行为。</p>\n</blockquote>\n<p><img src=\"/2022/11/07/jdk-yuan-ma-zhong-nb-de-she-ji-mo-shi/image_09845ad7.png\" alt=\"image_09845ad7.png\"></p>\n"},{"title":"常见代码重构技巧","top":false,"cover":false,"toc":true,"mathjax":true,"summary":"常见代码重构技巧","date":"2022-11-08T01:55:44.000Z","password":null,"_content":"\n\n# 关于重构 \n\n## 为什么要重构 \n\n![image_83d6de95.png](常见代码重构技巧/image_83d6de95-20221108095355418.png) 1\\_代码重构漫画.jpeg\n\n项目在不断演进过程中，代码不停地在堆砌。如果没有人为代码的质量负责，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。\n\n造成这样的原因往往有以下几点：\n\n1.  编码之前缺乏有效的设计\n2.  成本上的考虑，在原功能堆砌式编程\n3.  缺乏有效代码质量监督机制\n\n对于此类问题，业界已有有很好的解决思路：通过持续不断的重构将代码中的“坏味道”清除掉。\n\n## 什么是重构 \n\n重构一书的作者Martin Fowler对重构的定义：\n\n> 重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。  \n> 重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。\n\n根据重构的规模可以大致分为大型重构和小型重构：\n\n大型重构：对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入bug的风险也会相对比较大。\n\n小型重构：对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名和注释、消除超大类或函数、提取重复代码等等。小型重构更多的是使用统一的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入bug的风险相对来说也会比较小。什么时候重构 新功能开发、修bug或者代码review中出现“代码坏味道”，我们就应该及时进行重构。持续在日常开发中进行小重构，能够降低重构和测试的成本。\n\n# 代码的坏味道 \n\n![image_047389be.png](常见代码重构技巧/image_047389be-20221108095355455.png) 2\\_代码常见问题.png\n\n代码重复\n\n *  实现逻辑相同、执行流程相同\n\n方法过长\n\n *  方法中的语句不在同一个抽象层级\n *  逻辑难以理解，需要大量的注释\n *  面向过程编程而非面向对象\n\n过大的类\n\n *  类做了太多的事情\n *  包含过多的实例变量和方法\n *  类的命名不足以描述所做的事情\n\n逻辑分散\n\n *  发散式变化：某个类经常因为不同的原因在不同的方向上发生变化\n *  散弹式修改：发生某种变化时，需要在多个类中做修改\n\n严重的情结依恋\n\n *  某个类的方法过多的使用其他类的成员\n\n数据泥团/基本类型偏执\n\n *  两个类、方法签名中包含相同的字段或参数\n *  应该使用类但使用基本类型，比如表示数值与币种的Money类、起始值与结束值的Range类\n\n不合理的继承体系\n\n *  继承打破了封装性，子类依赖其父类中特定功能的实现细节\n *  子类必须跟着其父类的更新而演变，除非父类是专门为了扩展而设计，并且有很好的文档说明\n\n过多的条件判断\n\n过长的参数列\n\n临时变量过多\n\n令人迷惑的暂时字段\n\n *  某个实例变量仅为某种特定情况而设置\n *  将实例变量与相应的方法提取到新的类中\n\n纯数据类\n\n *  仅包含字段和访问（读写）这些字段的方法\n *  此类被称为数据容器，应保持最小可变性\n\n不恰当的命名\n\n *  命名无法准确描述做的事情\n *  命名不符合约定俗称的惯例\n\n过多的注释\n\n## 坏代码的问题 \n\n *  难以复用\n *  系统关联性过多，导致很难分离可重用部分\n *  难于变化\n *  一处变化导致其他很多部分的修改，不利于系统稳定\n *  难于理解\n *  命名杂乱，结构混乱，难于阅读和理解\n *  难以测试\n *  分支、依赖较多，难以覆盖全面\n\n## 什么是好代码 \n\n![image_d67b805c.png](常见代码重构技巧/image_d67b805c-20221108095355391.png) 3\\_代码质量如何衡量.jpg\n\n代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁。这些词汇是从不同的维度去评价代码质量的。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。\n\n要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。\n\n# 如何重构 \n\n## SOLID原则 \n\n![image_f864e546.png](常见代码重构技巧/image_f864e546-20221108095355479.png) 4\\_SOLID原则.png\n\n### 单一职责原则 \n\n一个类只负责完成一个职责或者功能，不要存在多于一种导致类变更的原因。\n\n单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。\n\n### 开放-关闭原则 \n\n添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。\n\n开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。\n\n很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。\n\n### 里氏替换原则 \n\n子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。\n\n子类可以扩展父类的功能，但不能改变父类原有的功能\n\n> 父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。\n\n### 接口隔离原则 \n\n调用方不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。\n\n### 依赖反转原则 \n\n高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。\n\n### 迪米特法则 \n\n一个对象应该对其他对象保持最少的了解\n\n### 合成复用原则 \n\n尽量使用合成/聚合的方式，而不是使用继承。\n\n单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，告诉我们要对扩展开放，对修改关闭。\n\n## 设计模式 \n\n> 设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案。\n\n *  创建型：主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码\n *  结构型：主要通过类或对象的不同组合，解耦不同功能的耦合\n *  行为型：主要解决的是类或对象之间的交互行为的耦合\n\n![image_9db0426b.png](常见代码重构技巧/image_9db0426b-20221108095355436.png)![image_41c09a5c.png](常见代码重构技巧/image_41c09a5c.png)![image_2c6e506b.png](常见代码重构技巧/image_2c6e506b.png)![image_8fa858cb.png](常见代码重构技巧/image_8fa858cb.png)\n\n## 代码分层 \n\n![image_598a46ba.png](常见代码重构技巧/image_598a46ba.png) image.png\n\n模块结构说明\n\n *  server\\_main：配置层，负责整个项目的module管理，maven配置管理、资源管理等；\n *  server\\_application：应用接入层，承接外部流量入口，例如：RPC接口实现、消息处理、定时任务等；不要在此包含业务逻辑；\n *  server\\_biz：核心业务层，用例服务、领域实体、领域事件等\n *  server\\_irepository：资源接口层，负责资源接口的暴露\n *  server\\_repository：资源层，负责资源的proxy访问，统一外部资源访问，隔离变化。注意：这里强调的是弱业务性，强数据性；\n *  server\\_common：公共层，vo、工具等\n\n代码开发要遵守各层的规范，并注意层级之间的依赖关系。\n\n## 命名规范 \n\n> 一个好的命名应该要满足以下两个约束：\n>\n>  *  准确描述所做得事情\n>  *  格式符合通用的惯例\n>\n> 如果你觉得一个类或方法难以命名的时候，可能是其承载的功能太多了，需要进一步拆分。\n\n### 约定俗称的惯例 \n\n![image_ff852d0e.png](常见代码重构技巧/image_ff852d0e.png)\n\n### 类命名 \n\n> 类名使用大驼峰命名形式，类命通常使用名词或名词短语。接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如 Cloneable，Callable 等，表示实现该接口的类有某种功能或能力。\n\n![image_83a6a12c.png](常见代码重构技巧/image_83a6a12c.png)\n\n### 方法命名 \n\n> 方法命名采用小驼峰的形式，首字小写，往后的每个单词首字母都要大写。和类名不同的是，方法命名一般为动词或动词短语，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。\n\n![image_450be2e5.png](常见代码重构技巧/image_450be2e5.png)\n\n## 重构技巧 \n\n### 提炼方法 \n\n多个方法代码重复、方法中代码过长或者方法中的语句不在一个抽象层级。  \n方法是代码复用的最小粒度，方法过长不利于复用，可读性低，提炼方法往往是重构工作的第一步。\n\n意图导向编程：把处理某件事的流程和具体做事的实现方式分开。\n\n *  把一个问题分解为一系列功能性步骤，并假定这些功能步骤已经实现\n *  我们只需把把各个函数组织在一起即可解决这一问题\n *  在组织好整个功能后，我们在分别实现各个方法函数\n\n```java\n/** \n  * 1、交易信息开始于一串标准ASCII字符串。 \n  * 2、这个信息字符串必须转换成一个字符串的数组，数组存放的此次交易的领域语言中所包含的词汇元素（token)。 \n  * 3、每一个词汇必须标准化。 \n  * 4、包含超过150个词汇元素的交易，应该采用不同于小型交易的方式（不同的算法）来提交，以提高效率。 \n  * 5、如果提交成功，API返回”true”；失败，则返回”false”。 \n  */\npublic class Transaction {    \n  public Boolean commit(String command) {        \n    Boolean result = true;        \n    String[] tokens = tokenize(command);        \n    normalizeTokens(tokens);        \n    if (isALargeTransaction(tokens)) {            \n      result = processLargeTransaction(tokens);        \n    } else {            \n      result = processSmallTransaction(tokens);        \n    }        \n    return result;    \n  }\n}\n```\n\n### 以函数对象取代函数 \n\n将函数放进一个单独对象中，如此一来局部变量就变成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。\n\n### 引入参数对象 \n\n方法参数比较多时，将参数封装为参数对象\n\n### 移除对参数的赋值 \n\n```java\npublic int discount(int inputVal, int quantity, int yearToDate) {\n  if (inputVal > 50) inputVal -= 2;\n  if (quantity > 100) inputVal -= 1;\n  if (yearToDate > 10000) inputVal -= 4;\n  return inputVal;\n}\n\npublic int discount(int inputVal, int quantity, int yearToDate) { \n  int result = inputVal;\n  if (inputVal > 50) result -= 2; \n  if (quantity > 100) result -= 1; \n  if (yearToDate > 10000) result -= 4; \n  return result; \n}\n```\n\n### 将查询与修改分离 \n\n任何有返回值的方法，都不应该有副作用\n\n *  不要在convert中调用写操作，避免副作用\n *  常见的例外：将查询结果缓存到本地\n\n### 移除不必要临时变量 \n\n临时变量仅使用一次或者取值逻辑成本很低的情况下\n\n### 引入解释性变量 \n\n将复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途\n\n```java\nif ((platform.toUpperCase().indexOf(\"MAC\") > -1) \n    && (browser.toUpperCase().indexOf(\"IE\") > -1) && wasInitialized() && resize > 0) {   \n  // do something \n} \n  \nfinal boolean isMacOs = platform.toUpperCase().indexOf(\"MAC\") > -1; \nfinal boolean isIEBrowser = browser.toUpperCase().indexOf(\"IE\") > -1; \nfinal boolean wasResized = resize > 0; \nif (isMacOs && isIEBrowser && wasInitialized() && wasResized) {   \n  // do something \n}\n```\n\n### 使用卫语句替代嵌套条件判断 \n\n把复杂的条件表达式拆分成多个条件表达式，减少嵌套。嵌套了好几层的if - then-else语句，转换为多个if语句\n\n```java\n//未使用卫语句\npublic void getHello(int type) {\n    if (type == 1) {\n        return;\n    } else {\n        if (type == 2) {\n            return;\n        } else {\n            if (type == 3) {\n                return;\n            } else {\n                setHello();\n            }\n        }\n    }\n} \n\n//使用卫语句\npublic void getHello(int type) {\n    if (type == 1) {\n        return;\n    }\n    if (type == 2) {\n        return;\n    }\n    if (type == 3) {\n        return;\n    }\n    setHello();\n}\n```\n\n### 使用多态替代条件判断断 \n\n当存在这样一类条件表达式，它根据对象类型的不同选择不同的行为。可以将这种表达式的每个分支放进一个子类内的复写函数中，然后将原始函数声明为抽象函数。\n\n```java\npublic int calculate(int a, int b, String operator) {\n    int result = Integer.MIN_VALUE;\n \n    if (\"add\".equals(operator)) {\n        result = a + b;\n    } else if (\"multiply\".equals(operator)) {\n        result = a * b;\n    } else if (\"divide\".equals(operator)) {\n        result = a / b;\n    } else if (\"subtract\".equals(operator)) {\n        result = a - b;\n    }\n    return result;\n}\n```\n\n当出现大量类型检查和判断时，if else（或switch）语句的体积会比较臃肿，这无疑降低了代码的可读性。 另外，if else（或switch）本身就是一个“变化点”，当需要扩展新的类型时，我们不得不追加if else（或switch）语句块，以及相应的逻辑，这无疑降低了程序的可扩展性，也违反了面向对象的开闭原则。\n\n> 基于这种场景，我们可以考虑使用“多态”来代替冗长的条件判断，将if else（或switch）中的“变化点”封装到子类中。这样，就不需要使用if else（或switch）语句了，取而代之的是子类多态的实例，从而使得提高代码的可读性和可扩展性。很多设计模式使用都是这种套路，比如策略模式、状态模式。\n\n```java\npublic interface Operation { \n  int apply(int a, int b); \n}\n\npublic class Addition implements Operation { \n  @Override \n  public int apply(int a, int b) { \n    return a + b; \n  } \n}\n\npublic class OperatorFactory {\n    private final static Map<String, Operation> operationMap = new HashMap<>();\n    static {\n        operationMap.put(\"add\", new Addition());\n        operationMap.put(\"divide\", new Division());\n        // more operators\n    }\n \n    public static Operation getOperation(String operator) {\n        return operationMap.get(operator);\n    }\n}\n\npublic int calculate(int a, int b, String operator) {\n    if (OperatorFactory .getOperation == null) {\n       throw new IllegalArgumentException(\"Invalid Operator\");\n    }\n    return OperatorFactory .getOperation(operator).apply(a, b);\n}\n```\n\n### 使用异常替代返回错误码 \n\n非正常业务状态的处理，使用抛出异常的方式代替返回错误码\n\n *  不要使用异常处理用于正常的业务流程控制\n *  异常处理的性能成本非常高\n *  尽量使用标准异常\n *  避免在finally语句块中抛出异常\n *  如果同时抛出两个异常，则第一个异常的调用栈会丢失\n    \n    finally块中应只做关闭资源这类的事情\n\n```java\n//使用错误码\npublic boolean withdraw(int amount) {\n    if (balance < amount) {\n        return false;\n    } else {\n        balance -= amount;\n        return true;\n    }\n}\n\n//使用异常\npublic void withdraw(int amount) {\n    if (amount > balance) {\n        throw new IllegalArgumentException(\"amount too large\");    \n    }\n    balance -= amount;\n}\n```\n\n### 引入断言 \n\n某一段代码需要对程序状态做出某种假设，以断言明确表现这种假设。\n\n *  不要滥用断言，不要使用它来检查“应该为真”的条件，只使用它来检查“一定必须为真”的条件\n *  如果断言所指示的约束条件不能满足，代码是否仍能正常运行？如果可以就去掉断言\n\n### 引入Null对象或特殊对象 \n\n当使用一个方法返回的对象时，而这个对象可能为空，这个时候需要对这个对象进行操作前，需要进行判空，否则就会报空指针。当这种判断频繁的出现在各处代码之中，就会影响代码的美观程度和可读性，甚至增加Bug的几率。\n\n空引用的问题在Java中无法避免，但可以通过代码编程技巧（引入空对象）来改善这一问题。\n\n```java\n//空对象的例子\npublic class OperatorFactory { \n  static Map<String, Operation> operationMap = new HashMap<>(); \n  static { \n    operationMap.put(\"add\", new Addition()); \n    operationMap.put(\"divide\", new Division()); \n    // more operators \n  } \n  public static Optional<Operation> getOperation(String operator) { \n    return Optional.ofNullable(operationMap.get(operator)); \n  } \n} \npublic int calculate(int a, int b, String operator) { \n  Operation targetOperation = OperatorFactory.getOperation(operator) \n     .orElseThrow(() -> new IllegalArgumentException(\"Invalid Operator\")); \n  return targetOperation.apply(a, b); \n}\n\n//特殊对象的例子\npublic class InvalidOp implements Operation { \n  @Override \n  public int apply(int a, int b)  { \n    throw new IllegalArgumentException(\"Invalid Operator\");\n  } \n}\n```\n\n### 提炼类 \n\n根据单一职责原则，一个类应该有明确的责任边界。但在实际工作中，类会不断的扩展。当给某个类添加一项新责任时，你会觉得不值得分离出一个单独的类。于是，随着责任不断增加，这个类包含了大量的数据和函数，逻辑复杂不易理解。\n\n此时你需要考虑将哪些部分分离到一个单独的类中，可以依据高内聚低耦合的原则。如果某些数据和方法总是一起出现，或者某些数据经常同时变化，这就表明它们应该放到一个类中。另一种信号是类的子类化方式：如果你发现子类化只影响类的部分特性，或者类的特性需要以不同方式来子类化，这就意味着你需要分解原来的类。\n\n```java\n//原始类\npublic class Person {\n    private String name;\n    private String officeAreaCode;\n    private String officeNumber;\n\n    public String getName() {\n        return name;\n    }\n\n    public String getTelephoneNumber() {\n        return (\"(\" + officeAreaCode + \")\" + officeNumber);\n    }\n\n    public String getOfficeAreaCode() {\n        return officeAreaCode;\n    }\n\n    public void setOfficeAreaCode(String arg) {\n        officeAreaCode = arg;\n    }\n\n    public String getOfficeNumber() {\n        return officeNumber;\n    }\n\n    public void setOfficeNumber(String arg) {\n        officeNumber = arg;\n    }\n}\n\n//新提炼的类（以对象替换数据值）\npublic class TelephoneNumber {\n    private String areaCode;\n    private String number;\n\n    public String getTelephnoeNumber() {\n        return (\"(\" + getAreaCode() + \")\" + number);\n    }\n\n    String getAreaCode() {\n        return areaCode;\n    }\n\n    void setAreaCode(String arg) {\n        areaCode = arg;\n    }\n\n    String getNumber() {\n        return number;\n    }\n\n    void setNumber(String arg) {\n        number = arg;\n    }\n}\n```\n\n### 组合优先于继承 \n\n继承使实现代码重用的有力手段，但这并非总是完成这项工作的最佳工具，使用不当会导致软件变得很脆弱。与方法调用不同的是，继承打破了封装性。子类依赖于其父类中特定功能的实现细节，如果父类的实现随着发行版本的不同而变化，子类可能会遭到破坏，即使他的代码完全没有改变。\n\n举例说明，假设有一个程序使用HashSet，为了调优该程序的性能，需要统计HashSet自从它创建以来添加了多少个元素。为了提供该功能，我们编写一个HashSet的变体。\n\n```java\n// Inappropriate use of inheritance!\npublic class InstrumentedHashSet<E> extends HashSet<E> {\n    // The number of attempted element insertions\n    private int addCount = 0;\n\n    public InstrumentedHashSet() { }\n\n    public InstrumentedHashSet(int initCap, float loadFactor) {\n        super(initCap, loadFactor);\n    }\n\n    @Override\n    public boolean add(E e) {\n        addCount++;\n        return super.add(e);\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n        addCount += c.size();\n        return super.addAll(c);\n    }\n\n    public int getAddCount() {\n        return addCount;\n    }\n}\n```\n\n通过在新的类中增加一个私有域，它引用现有类的一个实例，这种设计被称为组合，因为现有的类变成了新类的一个组件。这样得到的类将会非常稳固，它不依赖现有类的实现细节。即使现有的类添加了新的方法，也不会影响新的类。许多设计模式使用就是这种套路，比如代理模式、装饰者模式\n\n```java\n// Reusable forwarding class\npublic class ForwardingSet<E> implements Set<E> {\n    private final Set<E> s;\n    public ForwardingSet(Set<E> s) { this.s = s; }\n  \n    @Override\n    public int size() { return s.size(); }\n    @Override\n    public boolean isEmpty() { return s.isEmpty(); }\n    @Override\n    public boolean contains(Object o) { return s.contains(o); }\n    @Override\n    public Iterator<E> iterator() { return s.iterator(); }\n    @Override\n    public Object[] toArray() { return s.toArray(); }\n    @Override\n    public <T> T[] toArray(T[] a) { return s.toArray(a); }\n    @Override\n    public boolean add(E e) { return s.add(e); }\n    @Override\n    public boolean remove(Object o) { return s.remove(o); }\n    @Override\n    public boolean containsAll(Collection<?> c) { return s.containsAll(c); }\n    @Override\n    public boolean addAll(Collection<? extends E> c) { return s.addAll(c); }\n    @Override\n    public boolean retainAll(Collection<?> c) { return s.retainAll(c); }\n    @Override\n    public boolean removeAll(Collection<?> c) { return s.removeAll(c); }\n    @Override\n    public void clear() { s.clear(); }\n}\n\n// Wrappter class - uses composition in place of inheritance\npublic class InstrumentedHashSet<E> extends ForwardingSet<E> {\n    private int addCount = 0;\n\n    public InstrumentedHashSet1(Set<E> s) {\n        super(s);\n    }\n\n    @Override\n    public boolean add(E e) {\n        addCount++;\n        return super.add(e);\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n        addCount += c.size();\n        return super.addAll(c);\n    }\n\n    public int getAddCount() {\n        return addCount;\n    }\n}\n```\n\n继承与组合如何取舍\n\n *  只有当子类真正是父类的子类型时，才适合继承。对于两个类A和B，只有两者之间确实存在“is-a”关系的时候，类B才应该继承A；\n *  在包的内部使用继承是非常安全的，子类和父类的实现都处在同一个程序员的控制之下；\n *  对于专门为了继承而设计并且具有很好的文档说明的类来说，使用继承也是非常安全的；\n *  其他情况就应该优先考虑组合的方式来实现\n\n### 接口优于抽象类 \n\nJava提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象类。自从Java8为接口增加缺省方法（default method），这两种机制都允许为实例方法提供实现。主要区别在于，为了实现由抽象类定义的类型，类必须称为抽象类的一个子类。因为Java只允许单继承，所以用抽象类作为类型定义受到了限制。\n\n接口相比于抽象类的优势：\n\n *  现有的类可以很容易被更新，以实现新的接口。\n *  接口是定义混合类型（比如Comparable）的理想选择。\n *  接口允许构造非层次结构的类型框架。\n\n接口虽然提供了缺省方法，但接口仍有有以下局限性：\n\n *  接口的变量修饰符只能是public static final的\n *  接口的方法修饰符只能是public的\n *  接口不存在构造函数，也不存在this\n *  可以给现有接口增加缺省方法，但不能确保这些方法在之前存在的实现中都能良好运行。\n *  因为这些默认方法是被注入到现有实现中的，它们的实现者并不知道，也没有许可\n\n接口缺省方法的设计目的和优势在于：\n\n为了接口的演化\n\n *  Java 8 之前我们知道，一个接口的所有方法其子类必须实现（当然，这个子类不是一个抽象类），但是 java 8 之后接口的默认方法可以选择不实现，如上的操作是可以通过编译期编译的。这样就避免了由 Java 7 升级到 Java 8 时项目编译报错了。Java8在核心集合接口中增加了许多新的缺省方法，主要是为了便于使用lambda。\n\n可以减少第三方工具类的创建\n\n *  例如在 List 等集合接口中都有一些默认方法，List 接口中默认提供 replaceAll(UnaryOperator)、sort(Comparator)、、spliterator()等默认方法，这些方法在接口内部创建，避免了为了这些方法而专门去创建相应的工具类。\n\n可以避免创建基类\n\n *  在 Java 8 之前我们可能需要创建一个基类来实现代码复用，而默认方法的出现，可以不必要去创建基类。\n\n由于接口的局限性和设计目的的不同，接口并不能完全替换抽象类。但是通过对接口提供一个抽象的骨架实现类，可以把接口和抽象类的优点结合起来。 接口负责定义类型，或许还提供一些缺省方法，而骨架实现类则负责实现除基本类型接口方法之外，剩下的非基本类型接口方法。扩展骨架实现占了实现接口之外的大部分工作。这就是模板方法（Template Method）设计模式。\n\n![image_24ceb509.png](常见代码重构技巧/image_24ceb509.png) Image \\[5\\].png\n\n接口Protocol：定义了RPC协议层两个主要的方法，export暴露服务和refer引用服务\n\n抽象类AbstractProtocol：封装了暴露服务之后的Exporter和引用服务之后的Invoker实例，并实现了服务销毁的逻辑\n\n具体实现类XxxProtocol：实现export暴露服务和refer引用服务具体逻辑\n\n### 优先考虑泛型 \n\n声明中具有一个或者多个类型参数（type parameter）的类或者接口，就是泛型（generic）类或者接口。泛型类和接口统称为泛型（generic type）。泛型从Java 5引入，提供了编译时类型安全检测机制。泛型的本质是参数化类型，通过一个参数来表示所操作的数据类型，并且可以限制这个参数的类型范围。泛型的好处就是编译期类型检测，避免类型转换。\n\n```java\n// 比较三个值并返回最大值\npublic static <T extends Comparable<T>> T maximum(T x, T y, T z) {   \n  T max = x; \n  // 假设x是初始最大值   \n  if ( y.compareTo( max ) > 0 ) {      \n    max = y; //y 更大  \n  }   if ( z.compareTo( max ) > 0 ) {     \n    max = z; // 现在 z 更大              \n  }   return max; // 返回最大对象\n}\n\npublic static void main( String args[] ) {   \n  System.out.printf( \"%d, %d 和 %d 中最大的数为 %d\\n\\n\",  3, 4, 5, maximum( 3, 4, 5 ));   \n  System.out.printf( \"%.1f, %.1f 和 %.1f 中最大的数为 %.1f\\n\\n\",  6.6, 8.8, 7.7,  maximum( 6.6, 8.8, 7.7 ));   \n  System.out.printf( \"%s, %s 和 %s 中最大的数为 %s\\n\",\"pear\", \"apple\", \"orange\", maximum( \"pear\", \"apple\", \"orange\" ) );\n}\n```\n\n#### 不要使用原生态类型 \n\n由于为了保持Java代码的兼容性，支持和原生态类型转换，并使用擦除机制实现的泛型。但是使用原生态类型就会失去泛型的优势，会受到编译器警告。\n\n#### 要尽可能地消除每一个非受检警告 \n\n每一条警告都表示可能在运行时抛出ClassCastException异常。要尽最大的努力去消除这些警告。如果无法消除但是可以证明引起警告的代码是安全的，就可以在尽可能小的范围中，使用＠SuppressWarnings(\"unchecked\")注解来禁止警告，但是要把禁止的原因记录下来。\n\n#### 利用有限制通配符来提升API的灵活性 \n\n参数化类型不支持协变的，即对于任何两个不同的类型Type1和Type2而言，List既不是List的子类型，也不是它的超类。为了解决这个问题，提高灵活性，Java提供了一种特殊的参数化类型，称作有限制的通配符类型，即List<? extends E>和List<? super E>。使用原则是producer-extends，consumer-super（PECS）。如果即是生产者，又是消费者，就没有必要使用通配符了。\n\n还有一种特殊的无限制通配符List<?>，表示某种类型但不确定。常用作泛型的引用，不可向其添加除Null以外的任何对象。\n\n```java\n//List<? extends E>\n// Number 可以认为 是Number 的 \"子类\"\nList<? extends Number> numberArray = new ArrayList<Number>(); \n// Integer 是 Number 的子类\nList<? extends Number> numberArray = new ArrayList<Integer>(); \n// Double 是 Number 的子类\nList<? extends Number> numberArray = new ArrayList<Double>();  \n\n//List<? super E>\n// Integer 可以认为是 Integer 的 \"父类\"\nList<? super Integer> array = new ArrayList<Integer>();、\n// Number 是 Integer 的 父类\nList<? super Integer> array = new ArrayList<Number>();\n// Object 是 Integer 的 父类\nList<? super Integer> array = new ArrayList<Object>();\n\npublic static <T> void copy(List<? super T> dest, List<? extends T> src) {    \n  int srcSize = src.size();    \n  if (srcSize > dest.size())        \n   throw new IndexOutOfBoundsException(\"Source does not fit in dest\");    \n  if (srcSize < COPY_THRESHOLD || (src instanceof RandomAccess && dest instanceof RandomAccess)) {        \n    for (int i=0; i<srcSize; i++)            \n    dest.set(i, src.get(i));    \n  } else {        \n    ListIterator<? super T> di=dest.listIterator();        \n    ListIterator<? extends T> si=src.listIterator();        \n    for (int i=0; i<srcSize; i++) {            \n      di.next();            \n      di.set(si.next());        \n    }    \n  }\n}\n```\n\n### 静态成员类优于非静态成员类 \n\n嵌套类（nested class）是指定义在另一个类的内部的类。嵌套类存在的目的只是为了它的外部类提供服务，如果其他的环境也会用到的话，应该成为一个顶层类（top-level class）。 嵌套类有四种：静态成员类（static member class）、非静态成员类（nonstatic member class）、匿名类（anonymous class）和 局部类（local class）。除了第一种之外，其他三种都称为内部类（inner class）。\n\n#### 匿名类（anonymous class） \n\n没有名字，声明的同时进行实例化，只能使用一次。当出现在非静态的环境中，会持有外部类实例的引用。通常用于创建函数对象和过程对象，不过现在会优先考虑lambda。\n\n#### 局部类（local class） \n\n任何可以声明局部变量的地方都可以声明局部类，同时遵循同样的作用域规则。跟匿名类不同的是，有名字可以重复使用。不过实际很少使用局部类。\n\n#### 静态成员类（static member class） \n\n最简单的一种嵌套类，声明在另一个类的内部，是这个类的静态成员，遵循同样的可访问性规则。常见的用法是作为公有的辅助类，只有与它的外部类一起使用才有意义。\n\n#### 非静态成员类（nonstatic member class） \n\n尽管语法上，跟静态成员类的唯一区别就是类的声明不包含static，但两者有很大的不同。非静态成员类的每个实例都隐含地与外部类的实例相关联，可以访问外部类的成员属性和方法。另外必须先创建外部类的实例之后才能创建非静态成员类的实例。\n\n总而言之，这四种嵌套类都有自己的用途。假设这个嵌套类属于一个方法的内部，如果只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就要把它做成匿名类。如果一个嵌套类需要在单个方法之外仍然可见，或者它太长了，不适合放在方法内部，就应该使用成员类。如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的，否则就做成静态的。\n\n### 优先使用模板/工具类 \n\n通过对常见场景的代码逻辑进行抽象封装，形成相应的模板工具类，可以大大减少重复代码，专注于业务逻辑，提高代码质量。\n\n### 分离对象的创建与使用 \n\n面向对象编程相对于面向过程，多了实例化这一步，而对象的创建必须要指定具体类型。我们常见的做法是“哪里用到，就在哪里创建”，使用实例和创建实例的是同一段代码。这似乎使代码更具有可读性，但是某些情况下造成了不必要的耦合。\n\n```java\npublic class BusinessObject {\n public void actionMethond {\n     //Other things\n     Service myServiceObj = new Service();\n       myServiceObj.doService();\n       //Other things\n    }\n}\n\npublic class BusinessObject {\n public void actionMethond {\n     //Other things\n     Service myServiceObj = new ServiceImpl();\n       myServiceObj.doService();\n       //Other things\n    }\n}\n\npublic class BusinessObject {\n   private Service myServiceObj;\n   public BusinessObject(Service aService) {\n       myServiceObj = aService;\n    }\n public void actionMethond {\n     //Other things\n       myServiceObj.doService();\n       //Other things\n    }\n}\n\npublic class BusinessObject {\n   private Service myServiceObj;\n   public BusinessObject() {\n       myServiceObj = ServiceFactory;\n    }\n public void actionMethond {\n     //Other things\n       myServiceObj.doService();\n       //Other things\n    }\n}\n```\n\n> 对象的创建者耦合的是对象的具体类型，而对象的使用者耦合的是对象的接口。也就是说，创建者关心的是这个对象是什么，而使用者关心的是它能干什么。这两者应该视为独立的考量，它们往往会因为不同的原因而改变。\n\n当对象的类型涉及多态、对象创建复杂（依赖较多）可以考虑将对象的创建过程分离出来，使得使用者不用关注对象的创建细节。设计模式中创建型模式的出发点就是如此，实际项目中可以使用工厂模式、构建器、依赖注入的方式。\n\n### 可访问性最小化 \n\n区分一个组件设计得好不好，一个很重要的因素在于，它对于外部组件而言，是否隐藏了其内部数据和实现细节。Java提供了访问控制机制来决定类、接口和成员的可访问性。实体的可访问性由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符（private、protected、public）共同决定的。\n\n对于顶层的（非嵌套的）类和接口，只有两种的访问级别：包级私有的（没有public修饰）和公有的（public修饰）。\n\n对于成员（实例/域、方法、嵌套类和嵌套接口）由四种的访问级别，可访问性如下递增：\n\n *  私有的（private修饰）--只有在声明该成员的顶层类内部才可以访问这个成员；\n *  包级私有的（默认）--声明该成员的包内部的任何类都可以访问这个成员；\n *  受保护的（protected修饰）--声明该成员的类的子类可以访问这个成员，并且声明该成员的包内部的任何类也可以访问这个成员；\n *  公有的（public修饰）--在任何地方都可以访问该成员；\n\n正确地使用这些修饰符对于实现信息隐藏是非常关键的，原则就是：尽可能地使每个类和成员不被外界访问（私有或包级私有）。这样好处就是在以后的发行版本中，可以对它进行修改、替换或者删除，而无须担心会影响现有的客户端程序。\n\n *  如果类或接口能够做成包级私有的，它就应该被做成包级私有的；\n *  如果一个包级私有的顶层类或接口只是在某一个类的内部被用到，就应该考虑使它成为那个类的私有嵌套类；\n *  公有类不应直接暴露实例域，应该提供相应的方法以保留将来改变该类的内部表示法的灵活性；\n *  当确定了类的公有API之后，应该把其他的成员都变成私有的；\n *  如果同一个包下的类之间存在比较多的访问时，就要考虑重新设计以减少这种耦合；\n\n### 可变性最小化 \n\n不可变类是指其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例时提供，并在对象的整个生命周期内固定不变。不可变类好处就是简单易用、线程安全、可自由共享而不容易出错。Java平台类库中包含许多不可变的类，比如String、基本类型包装类、BigDecimal等。\n\n为了使类成为不可变，要遵循下面五条规则：\n\n *  声明所有的域都是私有的\n *  声明所有的域都是final的\n *  如果一个指向新创建实例的引用在缺乏同步机制的情况下，从一个线程被传递到另一个线程，就必须确保正确的行为\n *  不提供任何会修改对象状态的方法\n *  保证类不会被扩展（防止子类化，类声明为final）\n *  防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏该类的不可变行为\n *  确保对任何可变组件的互斥访问\n *  如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法中返回该对象引用。在构造器、访问方法和readObject 方法中使用保护性拷贝技术\n\n可变性最小化的一些建议：\n\n *  除非有很好的理由要让类成为可变的类，否则它就应该是不可变的；\n *  如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性；\n *  除非有令人信服的理由要使域变成非final的，否则要使每个域都是private final的；\n *  构造器应该创建完全初始化的对象，并建立起所有的约束关系；\n\n# 质量如何保证 \n\n## 测试驱动开发 \n\n> 测试驱动开发（TDD）要求以测试作为开发过程的中心，要求在编写任何代码之前，首先编写用于产码行为的测试，而编写的代码又要以使测试通过为目标。TDD要求测试可以完全自动化地运行，并在对代码重构前后必须运行测试。\n\nTDD的最终目标是整洁可用的代码（clean code that works）。大多数的开发者大部分时间无法得到整洁可用的代码。办法是分而治之。首先解决目标中的“可用”问题，然后再解决“代码的整洁”问题。这与体系结构驱动（architecture-driven）的开发相反。\n\n采用TDD另一个好处就是让我们拥有一套伴随代码产生的详尽的自动化测试集。将来无论出于任何原因（需求、重构、性能改进）需要对代码进行维护时，在这套测试集的驱动下工作，我们代码将会一直是健壮的。\n\n## TDD的开发周期 \n\n![image_4605e609.png](常见代码重构技巧/image_4605e609.png) Image \\[6\\].png\n\n添加一个测试 -> 运行所有测试并检查测试结果 -> 编写代码以通过测试 -> 运行所有测试且全部通过 -> 重构代码，以消除重复设计，优化设计结构\n\n## 两个基本的原则 \n\n *  仅在测试失败时才编写代码并且只编写刚好使测试通过的代码\n *  编写下一个测试之前消除现有的重复设计，优化设计结构\n\n关注点分离是这两条规则隐含的另一个非常重要的原则。其表达的含义指在编码阶段先达到代码“可用”的目标，在重构阶段再追求“整洁”目标，每次只关注一件事！\n\n## 分层测试点 \n\n![image_e59205e3.png](常见代码重构技巧/image_e59205e3.png)\n\n# 参考资料 \n\n *  重构-改善既有代码的设计\n *  设计模式\n *  Effective Java\n *  敏捷软件开发与设计的最佳实践\n *  实现模式\n *  测试驱动开发                \n    \n\n  \n\n","source":"_posts/常见代码重构技巧.md","raw":"---\ntitle: 常见代码重构技巧\ntop: false\ncover: false\ntoc: true\nmathjax: true\nsummary: 常见代码重构技巧\ndate: 2022-11-08 09:55:44\npassword:\ntags:\n    - 技巧\n    - 重构\ncategories:\n    - java\n---\n\n\n# 关于重构 \n\n## 为什么要重构 \n\n![image_83d6de95.png](常见代码重构技巧/image_83d6de95-20221108095355418.png) 1\\_代码重构漫画.jpeg\n\n项目在不断演进过程中，代码不停地在堆砌。如果没有人为代码的质量负责，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。\n\n造成这样的原因往往有以下几点：\n\n1.  编码之前缺乏有效的设计\n2.  成本上的考虑，在原功能堆砌式编程\n3.  缺乏有效代码质量监督机制\n\n对于此类问题，业界已有有很好的解决思路：通过持续不断的重构将代码中的“坏味道”清除掉。\n\n## 什么是重构 \n\n重构一书的作者Martin Fowler对重构的定义：\n\n> 重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。  \n> 重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。\n\n根据重构的规模可以大致分为大型重构和小型重构：\n\n大型重构：对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入bug的风险也会相对比较大。\n\n小型重构：对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名和注释、消除超大类或函数、提取重复代码等等。小型重构更多的是使用统一的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入bug的风险相对来说也会比较小。什么时候重构 新功能开发、修bug或者代码review中出现“代码坏味道”，我们就应该及时进行重构。持续在日常开发中进行小重构，能够降低重构和测试的成本。\n\n# 代码的坏味道 \n\n![image_047389be.png](常见代码重构技巧/image_047389be-20221108095355455.png) 2\\_代码常见问题.png\n\n代码重复\n\n *  实现逻辑相同、执行流程相同\n\n方法过长\n\n *  方法中的语句不在同一个抽象层级\n *  逻辑难以理解，需要大量的注释\n *  面向过程编程而非面向对象\n\n过大的类\n\n *  类做了太多的事情\n *  包含过多的实例变量和方法\n *  类的命名不足以描述所做的事情\n\n逻辑分散\n\n *  发散式变化：某个类经常因为不同的原因在不同的方向上发生变化\n *  散弹式修改：发生某种变化时，需要在多个类中做修改\n\n严重的情结依恋\n\n *  某个类的方法过多的使用其他类的成员\n\n数据泥团/基本类型偏执\n\n *  两个类、方法签名中包含相同的字段或参数\n *  应该使用类但使用基本类型，比如表示数值与币种的Money类、起始值与结束值的Range类\n\n不合理的继承体系\n\n *  继承打破了封装性，子类依赖其父类中特定功能的实现细节\n *  子类必须跟着其父类的更新而演变，除非父类是专门为了扩展而设计，并且有很好的文档说明\n\n过多的条件判断\n\n过长的参数列\n\n临时变量过多\n\n令人迷惑的暂时字段\n\n *  某个实例变量仅为某种特定情况而设置\n *  将实例变量与相应的方法提取到新的类中\n\n纯数据类\n\n *  仅包含字段和访问（读写）这些字段的方法\n *  此类被称为数据容器，应保持最小可变性\n\n不恰当的命名\n\n *  命名无法准确描述做的事情\n *  命名不符合约定俗称的惯例\n\n过多的注释\n\n## 坏代码的问题 \n\n *  难以复用\n *  系统关联性过多，导致很难分离可重用部分\n *  难于变化\n *  一处变化导致其他很多部分的修改，不利于系统稳定\n *  难于理解\n *  命名杂乱，结构混乱，难于阅读和理解\n *  难以测试\n *  分支、依赖较多，难以覆盖全面\n\n## 什么是好代码 \n\n![image_d67b805c.png](常见代码重构技巧/image_d67b805c-20221108095355391.png) 3\\_代码质量如何衡量.jpg\n\n代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁。这些词汇是从不同的维度去评价代码质量的。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。\n\n要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。\n\n# 如何重构 \n\n## SOLID原则 \n\n![image_f864e546.png](常见代码重构技巧/image_f864e546-20221108095355479.png) 4\\_SOLID原则.png\n\n### 单一职责原则 \n\n一个类只负责完成一个职责或者功能，不要存在多于一种导致类变更的原因。\n\n单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。\n\n### 开放-关闭原则 \n\n添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。\n\n开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。\n\n很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。\n\n### 里氏替换原则 \n\n子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。\n\n子类可以扩展父类的功能，但不能改变父类原有的功能\n\n> 父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。\n\n### 接口隔离原则 \n\n调用方不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。\n\n### 依赖反转原则 \n\n高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。\n\n### 迪米特法则 \n\n一个对象应该对其他对象保持最少的了解\n\n### 合成复用原则 \n\n尽量使用合成/聚合的方式，而不是使用继承。\n\n单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，告诉我们要对扩展开放，对修改关闭。\n\n## 设计模式 \n\n> 设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案。\n\n *  创建型：主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码\n *  结构型：主要通过类或对象的不同组合，解耦不同功能的耦合\n *  行为型：主要解决的是类或对象之间的交互行为的耦合\n\n![image_9db0426b.png](常见代码重构技巧/image_9db0426b-20221108095355436.png)![image_41c09a5c.png](常见代码重构技巧/image_41c09a5c.png)![image_2c6e506b.png](常见代码重构技巧/image_2c6e506b.png)![image_8fa858cb.png](常见代码重构技巧/image_8fa858cb.png)\n\n## 代码分层 \n\n![image_598a46ba.png](常见代码重构技巧/image_598a46ba.png) image.png\n\n模块结构说明\n\n *  server\\_main：配置层，负责整个项目的module管理，maven配置管理、资源管理等；\n *  server\\_application：应用接入层，承接外部流量入口，例如：RPC接口实现、消息处理、定时任务等；不要在此包含业务逻辑；\n *  server\\_biz：核心业务层，用例服务、领域实体、领域事件等\n *  server\\_irepository：资源接口层，负责资源接口的暴露\n *  server\\_repository：资源层，负责资源的proxy访问，统一外部资源访问，隔离变化。注意：这里强调的是弱业务性，强数据性；\n *  server\\_common：公共层，vo、工具等\n\n代码开发要遵守各层的规范，并注意层级之间的依赖关系。\n\n## 命名规范 \n\n> 一个好的命名应该要满足以下两个约束：\n>\n>  *  准确描述所做得事情\n>  *  格式符合通用的惯例\n>\n> 如果你觉得一个类或方法难以命名的时候，可能是其承载的功能太多了，需要进一步拆分。\n\n### 约定俗称的惯例 \n\n![image_ff852d0e.png](常见代码重构技巧/image_ff852d0e.png)\n\n### 类命名 \n\n> 类名使用大驼峰命名形式，类命通常使用名词或名词短语。接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如 Cloneable，Callable 等，表示实现该接口的类有某种功能或能力。\n\n![image_83a6a12c.png](常见代码重构技巧/image_83a6a12c.png)\n\n### 方法命名 \n\n> 方法命名采用小驼峰的形式，首字小写，往后的每个单词首字母都要大写。和类名不同的是，方法命名一般为动词或动词短语，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。\n\n![image_450be2e5.png](常见代码重构技巧/image_450be2e5.png)\n\n## 重构技巧 \n\n### 提炼方法 \n\n多个方法代码重复、方法中代码过长或者方法中的语句不在一个抽象层级。  \n方法是代码复用的最小粒度，方法过长不利于复用，可读性低，提炼方法往往是重构工作的第一步。\n\n意图导向编程：把处理某件事的流程和具体做事的实现方式分开。\n\n *  把一个问题分解为一系列功能性步骤，并假定这些功能步骤已经实现\n *  我们只需把把各个函数组织在一起即可解决这一问题\n *  在组织好整个功能后，我们在分别实现各个方法函数\n\n```java\n/** \n  * 1、交易信息开始于一串标准ASCII字符串。 \n  * 2、这个信息字符串必须转换成一个字符串的数组，数组存放的此次交易的领域语言中所包含的词汇元素（token)。 \n  * 3、每一个词汇必须标准化。 \n  * 4、包含超过150个词汇元素的交易，应该采用不同于小型交易的方式（不同的算法）来提交，以提高效率。 \n  * 5、如果提交成功，API返回”true”；失败，则返回”false”。 \n  */\npublic class Transaction {    \n  public Boolean commit(String command) {        \n    Boolean result = true;        \n    String[] tokens = tokenize(command);        \n    normalizeTokens(tokens);        \n    if (isALargeTransaction(tokens)) {            \n      result = processLargeTransaction(tokens);        \n    } else {            \n      result = processSmallTransaction(tokens);        \n    }        \n    return result;    \n  }\n}\n```\n\n### 以函数对象取代函数 \n\n将函数放进一个单独对象中，如此一来局部变量就变成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。\n\n### 引入参数对象 \n\n方法参数比较多时，将参数封装为参数对象\n\n### 移除对参数的赋值 \n\n```java\npublic int discount(int inputVal, int quantity, int yearToDate) {\n  if (inputVal > 50) inputVal -= 2;\n  if (quantity > 100) inputVal -= 1;\n  if (yearToDate > 10000) inputVal -= 4;\n  return inputVal;\n}\n\npublic int discount(int inputVal, int quantity, int yearToDate) { \n  int result = inputVal;\n  if (inputVal > 50) result -= 2; \n  if (quantity > 100) result -= 1; \n  if (yearToDate > 10000) result -= 4; \n  return result; \n}\n```\n\n### 将查询与修改分离 \n\n任何有返回值的方法，都不应该有副作用\n\n *  不要在convert中调用写操作，避免副作用\n *  常见的例外：将查询结果缓存到本地\n\n### 移除不必要临时变量 \n\n临时变量仅使用一次或者取值逻辑成本很低的情况下\n\n### 引入解释性变量 \n\n将复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途\n\n```java\nif ((platform.toUpperCase().indexOf(\"MAC\") > -1) \n    && (browser.toUpperCase().indexOf(\"IE\") > -1) && wasInitialized() && resize > 0) {   \n  // do something \n} \n  \nfinal boolean isMacOs = platform.toUpperCase().indexOf(\"MAC\") > -1; \nfinal boolean isIEBrowser = browser.toUpperCase().indexOf(\"IE\") > -1; \nfinal boolean wasResized = resize > 0; \nif (isMacOs && isIEBrowser && wasInitialized() && wasResized) {   \n  // do something \n}\n```\n\n### 使用卫语句替代嵌套条件判断 \n\n把复杂的条件表达式拆分成多个条件表达式，减少嵌套。嵌套了好几层的if - then-else语句，转换为多个if语句\n\n```java\n//未使用卫语句\npublic void getHello(int type) {\n    if (type == 1) {\n        return;\n    } else {\n        if (type == 2) {\n            return;\n        } else {\n            if (type == 3) {\n                return;\n            } else {\n                setHello();\n            }\n        }\n    }\n} \n\n//使用卫语句\npublic void getHello(int type) {\n    if (type == 1) {\n        return;\n    }\n    if (type == 2) {\n        return;\n    }\n    if (type == 3) {\n        return;\n    }\n    setHello();\n}\n```\n\n### 使用多态替代条件判断断 \n\n当存在这样一类条件表达式，它根据对象类型的不同选择不同的行为。可以将这种表达式的每个分支放进一个子类内的复写函数中，然后将原始函数声明为抽象函数。\n\n```java\npublic int calculate(int a, int b, String operator) {\n    int result = Integer.MIN_VALUE;\n \n    if (\"add\".equals(operator)) {\n        result = a + b;\n    } else if (\"multiply\".equals(operator)) {\n        result = a * b;\n    } else if (\"divide\".equals(operator)) {\n        result = a / b;\n    } else if (\"subtract\".equals(operator)) {\n        result = a - b;\n    }\n    return result;\n}\n```\n\n当出现大量类型检查和判断时，if else（或switch）语句的体积会比较臃肿，这无疑降低了代码的可读性。 另外，if else（或switch）本身就是一个“变化点”，当需要扩展新的类型时，我们不得不追加if else（或switch）语句块，以及相应的逻辑，这无疑降低了程序的可扩展性，也违反了面向对象的开闭原则。\n\n> 基于这种场景，我们可以考虑使用“多态”来代替冗长的条件判断，将if else（或switch）中的“变化点”封装到子类中。这样，就不需要使用if else（或switch）语句了，取而代之的是子类多态的实例，从而使得提高代码的可读性和可扩展性。很多设计模式使用都是这种套路，比如策略模式、状态模式。\n\n```java\npublic interface Operation { \n  int apply(int a, int b); \n}\n\npublic class Addition implements Operation { \n  @Override \n  public int apply(int a, int b) { \n    return a + b; \n  } \n}\n\npublic class OperatorFactory {\n    private final static Map<String, Operation> operationMap = new HashMap<>();\n    static {\n        operationMap.put(\"add\", new Addition());\n        operationMap.put(\"divide\", new Division());\n        // more operators\n    }\n \n    public static Operation getOperation(String operator) {\n        return operationMap.get(operator);\n    }\n}\n\npublic int calculate(int a, int b, String operator) {\n    if (OperatorFactory .getOperation == null) {\n       throw new IllegalArgumentException(\"Invalid Operator\");\n    }\n    return OperatorFactory .getOperation(operator).apply(a, b);\n}\n```\n\n### 使用异常替代返回错误码 \n\n非正常业务状态的处理，使用抛出异常的方式代替返回错误码\n\n *  不要使用异常处理用于正常的业务流程控制\n *  异常处理的性能成本非常高\n *  尽量使用标准异常\n *  避免在finally语句块中抛出异常\n *  如果同时抛出两个异常，则第一个异常的调用栈会丢失\n    \n    finally块中应只做关闭资源这类的事情\n\n```java\n//使用错误码\npublic boolean withdraw(int amount) {\n    if (balance < amount) {\n        return false;\n    } else {\n        balance -= amount;\n        return true;\n    }\n}\n\n//使用异常\npublic void withdraw(int amount) {\n    if (amount > balance) {\n        throw new IllegalArgumentException(\"amount too large\");    \n    }\n    balance -= amount;\n}\n```\n\n### 引入断言 \n\n某一段代码需要对程序状态做出某种假设，以断言明确表现这种假设。\n\n *  不要滥用断言，不要使用它来检查“应该为真”的条件，只使用它来检查“一定必须为真”的条件\n *  如果断言所指示的约束条件不能满足，代码是否仍能正常运行？如果可以就去掉断言\n\n### 引入Null对象或特殊对象 \n\n当使用一个方法返回的对象时，而这个对象可能为空，这个时候需要对这个对象进行操作前，需要进行判空，否则就会报空指针。当这种判断频繁的出现在各处代码之中，就会影响代码的美观程度和可读性，甚至增加Bug的几率。\n\n空引用的问题在Java中无法避免，但可以通过代码编程技巧（引入空对象）来改善这一问题。\n\n```java\n//空对象的例子\npublic class OperatorFactory { \n  static Map<String, Operation> operationMap = new HashMap<>(); \n  static { \n    operationMap.put(\"add\", new Addition()); \n    operationMap.put(\"divide\", new Division()); \n    // more operators \n  } \n  public static Optional<Operation> getOperation(String operator) { \n    return Optional.ofNullable(operationMap.get(operator)); \n  } \n} \npublic int calculate(int a, int b, String operator) { \n  Operation targetOperation = OperatorFactory.getOperation(operator) \n     .orElseThrow(() -> new IllegalArgumentException(\"Invalid Operator\")); \n  return targetOperation.apply(a, b); \n}\n\n//特殊对象的例子\npublic class InvalidOp implements Operation { \n  @Override \n  public int apply(int a, int b)  { \n    throw new IllegalArgumentException(\"Invalid Operator\");\n  } \n}\n```\n\n### 提炼类 \n\n根据单一职责原则，一个类应该有明确的责任边界。但在实际工作中，类会不断的扩展。当给某个类添加一项新责任时，你会觉得不值得分离出一个单独的类。于是，随着责任不断增加，这个类包含了大量的数据和函数，逻辑复杂不易理解。\n\n此时你需要考虑将哪些部分分离到一个单独的类中，可以依据高内聚低耦合的原则。如果某些数据和方法总是一起出现，或者某些数据经常同时变化，这就表明它们应该放到一个类中。另一种信号是类的子类化方式：如果你发现子类化只影响类的部分特性，或者类的特性需要以不同方式来子类化，这就意味着你需要分解原来的类。\n\n```java\n//原始类\npublic class Person {\n    private String name;\n    private String officeAreaCode;\n    private String officeNumber;\n\n    public String getName() {\n        return name;\n    }\n\n    public String getTelephoneNumber() {\n        return (\"(\" + officeAreaCode + \")\" + officeNumber);\n    }\n\n    public String getOfficeAreaCode() {\n        return officeAreaCode;\n    }\n\n    public void setOfficeAreaCode(String arg) {\n        officeAreaCode = arg;\n    }\n\n    public String getOfficeNumber() {\n        return officeNumber;\n    }\n\n    public void setOfficeNumber(String arg) {\n        officeNumber = arg;\n    }\n}\n\n//新提炼的类（以对象替换数据值）\npublic class TelephoneNumber {\n    private String areaCode;\n    private String number;\n\n    public String getTelephnoeNumber() {\n        return (\"(\" + getAreaCode() + \")\" + number);\n    }\n\n    String getAreaCode() {\n        return areaCode;\n    }\n\n    void setAreaCode(String arg) {\n        areaCode = arg;\n    }\n\n    String getNumber() {\n        return number;\n    }\n\n    void setNumber(String arg) {\n        number = arg;\n    }\n}\n```\n\n### 组合优先于继承 \n\n继承使实现代码重用的有力手段，但这并非总是完成这项工作的最佳工具，使用不当会导致软件变得很脆弱。与方法调用不同的是，继承打破了封装性。子类依赖于其父类中特定功能的实现细节，如果父类的实现随着发行版本的不同而变化，子类可能会遭到破坏，即使他的代码完全没有改变。\n\n举例说明，假设有一个程序使用HashSet，为了调优该程序的性能，需要统计HashSet自从它创建以来添加了多少个元素。为了提供该功能，我们编写一个HashSet的变体。\n\n```java\n// Inappropriate use of inheritance!\npublic class InstrumentedHashSet<E> extends HashSet<E> {\n    // The number of attempted element insertions\n    private int addCount = 0;\n\n    public InstrumentedHashSet() { }\n\n    public InstrumentedHashSet(int initCap, float loadFactor) {\n        super(initCap, loadFactor);\n    }\n\n    @Override\n    public boolean add(E e) {\n        addCount++;\n        return super.add(e);\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n        addCount += c.size();\n        return super.addAll(c);\n    }\n\n    public int getAddCount() {\n        return addCount;\n    }\n}\n```\n\n通过在新的类中增加一个私有域，它引用现有类的一个实例，这种设计被称为组合，因为现有的类变成了新类的一个组件。这样得到的类将会非常稳固，它不依赖现有类的实现细节。即使现有的类添加了新的方法，也不会影响新的类。许多设计模式使用就是这种套路，比如代理模式、装饰者模式\n\n```java\n// Reusable forwarding class\npublic class ForwardingSet<E> implements Set<E> {\n    private final Set<E> s;\n    public ForwardingSet(Set<E> s) { this.s = s; }\n  \n    @Override\n    public int size() { return s.size(); }\n    @Override\n    public boolean isEmpty() { return s.isEmpty(); }\n    @Override\n    public boolean contains(Object o) { return s.contains(o); }\n    @Override\n    public Iterator<E> iterator() { return s.iterator(); }\n    @Override\n    public Object[] toArray() { return s.toArray(); }\n    @Override\n    public <T> T[] toArray(T[] a) { return s.toArray(a); }\n    @Override\n    public boolean add(E e) { return s.add(e); }\n    @Override\n    public boolean remove(Object o) { return s.remove(o); }\n    @Override\n    public boolean containsAll(Collection<?> c) { return s.containsAll(c); }\n    @Override\n    public boolean addAll(Collection<? extends E> c) { return s.addAll(c); }\n    @Override\n    public boolean retainAll(Collection<?> c) { return s.retainAll(c); }\n    @Override\n    public boolean removeAll(Collection<?> c) { return s.removeAll(c); }\n    @Override\n    public void clear() { s.clear(); }\n}\n\n// Wrappter class - uses composition in place of inheritance\npublic class InstrumentedHashSet<E> extends ForwardingSet<E> {\n    private int addCount = 0;\n\n    public InstrumentedHashSet1(Set<E> s) {\n        super(s);\n    }\n\n    @Override\n    public boolean add(E e) {\n        addCount++;\n        return super.add(e);\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n        addCount += c.size();\n        return super.addAll(c);\n    }\n\n    public int getAddCount() {\n        return addCount;\n    }\n}\n```\n\n继承与组合如何取舍\n\n *  只有当子类真正是父类的子类型时，才适合继承。对于两个类A和B，只有两者之间确实存在“is-a”关系的时候，类B才应该继承A；\n *  在包的内部使用继承是非常安全的，子类和父类的实现都处在同一个程序员的控制之下；\n *  对于专门为了继承而设计并且具有很好的文档说明的类来说，使用继承也是非常安全的；\n *  其他情况就应该优先考虑组合的方式来实现\n\n### 接口优于抽象类 \n\nJava提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象类。自从Java8为接口增加缺省方法（default method），这两种机制都允许为实例方法提供实现。主要区别在于，为了实现由抽象类定义的类型，类必须称为抽象类的一个子类。因为Java只允许单继承，所以用抽象类作为类型定义受到了限制。\n\n接口相比于抽象类的优势：\n\n *  现有的类可以很容易被更新，以实现新的接口。\n *  接口是定义混合类型（比如Comparable）的理想选择。\n *  接口允许构造非层次结构的类型框架。\n\n接口虽然提供了缺省方法，但接口仍有有以下局限性：\n\n *  接口的变量修饰符只能是public static final的\n *  接口的方法修饰符只能是public的\n *  接口不存在构造函数，也不存在this\n *  可以给现有接口增加缺省方法，但不能确保这些方法在之前存在的实现中都能良好运行。\n *  因为这些默认方法是被注入到现有实现中的，它们的实现者并不知道，也没有许可\n\n接口缺省方法的设计目的和优势在于：\n\n为了接口的演化\n\n *  Java 8 之前我们知道，一个接口的所有方法其子类必须实现（当然，这个子类不是一个抽象类），但是 java 8 之后接口的默认方法可以选择不实现，如上的操作是可以通过编译期编译的。这样就避免了由 Java 7 升级到 Java 8 时项目编译报错了。Java8在核心集合接口中增加了许多新的缺省方法，主要是为了便于使用lambda。\n\n可以减少第三方工具类的创建\n\n *  例如在 List 等集合接口中都有一些默认方法，List 接口中默认提供 replaceAll(UnaryOperator)、sort(Comparator)、、spliterator()等默认方法，这些方法在接口内部创建，避免了为了这些方法而专门去创建相应的工具类。\n\n可以避免创建基类\n\n *  在 Java 8 之前我们可能需要创建一个基类来实现代码复用，而默认方法的出现，可以不必要去创建基类。\n\n由于接口的局限性和设计目的的不同，接口并不能完全替换抽象类。但是通过对接口提供一个抽象的骨架实现类，可以把接口和抽象类的优点结合起来。 接口负责定义类型，或许还提供一些缺省方法，而骨架实现类则负责实现除基本类型接口方法之外，剩下的非基本类型接口方法。扩展骨架实现占了实现接口之外的大部分工作。这就是模板方法（Template Method）设计模式。\n\n![image_24ceb509.png](常见代码重构技巧/image_24ceb509.png) Image \\[5\\].png\n\n接口Protocol：定义了RPC协议层两个主要的方法，export暴露服务和refer引用服务\n\n抽象类AbstractProtocol：封装了暴露服务之后的Exporter和引用服务之后的Invoker实例，并实现了服务销毁的逻辑\n\n具体实现类XxxProtocol：实现export暴露服务和refer引用服务具体逻辑\n\n### 优先考虑泛型 \n\n声明中具有一个或者多个类型参数（type parameter）的类或者接口，就是泛型（generic）类或者接口。泛型类和接口统称为泛型（generic type）。泛型从Java 5引入，提供了编译时类型安全检测机制。泛型的本质是参数化类型，通过一个参数来表示所操作的数据类型，并且可以限制这个参数的类型范围。泛型的好处就是编译期类型检测，避免类型转换。\n\n```java\n// 比较三个值并返回最大值\npublic static <T extends Comparable<T>> T maximum(T x, T y, T z) {   \n  T max = x; \n  // 假设x是初始最大值   \n  if ( y.compareTo( max ) > 0 ) {      \n    max = y; //y 更大  \n  }   if ( z.compareTo( max ) > 0 ) {     \n    max = z; // 现在 z 更大              \n  }   return max; // 返回最大对象\n}\n\npublic static void main( String args[] ) {   \n  System.out.printf( \"%d, %d 和 %d 中最大的数为 %d\\n\\n\",  3, 4, 5, maximum( 3, 4, 5 ));   \n  System.out.printf( \"%.1f, %.1f 和 %.1f 中最大的数为 %.1f\\n\\n\",  6.6, 8.8, 7.7,  maximum( 6.6, 8.8, 7.7 ));   \n  System.out.printf( \"%s, %s 和 %s 中最大的数为 %s\\n\",\"pear\", \"apple\", \"orange\", maximum( \"pear\", \"apple\", \"orange\" ) );\n}\n```\n\n#### 不要使用原生态类型 \n\n由于为了保持Java代码的兼容性，支持和原生态类型转换，并使用擦除机制实现的泛型。但是使用原生态类型就会失去泛型的优势，会受到编译器警告。\n\n#### 要尽可能地消除每一个非受检警告 \n\n每一条警告都表示可能在运行时抛出ClassCastException异常。要尽最大的努力去消除这些警告。如果无法消除但是可以证明引起警告的代码是安全的，就可以在尽可能小的范围中，使用＠SuppressWarnings(\"unchecked\")注解来禁止警告，但是要把禁止的原因记录下来。\n\n#### 利用有限制通配符来提升API的灵活性 \n\n参数化类型不支持协变的，即对于任何两个不同的类型Type1和Type2而言，List既不是List的子类型，也不是它的超类。为了解决这个问题，提高灵活性，Java提供了一种特殊的参数化类型，称作有限制的通配符类型，即List<? extends E>和List<? super E>。使用原则是producer-extends，consumer-super（PECS）。如果即是生产者，又是消费者，就没有必要使用通配符了。\n\n还有一种特殊的无限制通配符List<?>，表示某种类型但不确定。常用作泛型的引用，不可向其添加除Null以外的任何对象。\n\n```java\n//List<? extends E>\n// Number 可以认为 是Number 的 \"子类\"\nList<? extends Number> numberArray = new ArrayList<Number>(); \n// Integer 是 Number 的子类\nList<? extends Number> numberArray = new ArrayList<Integer>(); \n// Double 是 Number 的子类\nList<? extends Number> numberArray = new ArrayList<Double>();  \n\n//List<? super E>\n// Integer 可以认为是 Integer 的 \"父类\"\nList<? super Integer> array = new ArrayList<Integer>();、\n// Number 是 Integer 的 父类\nList<? super Integer> array = new ArrayList<Number>();\n// Object 是 Integer 的 父类\nList<? super Integer> array = new ArrayList<Object>();\n\npublic static <T> void copy(List<? super T> dest, List<? extends T> src) {    \n  int srcSize = src.size();    \n  if (srcSize > dest.size())        \n   throw new IndexOutOfBoundsException(\"Source does not fit in dest\");    \n  if (srcSize < COPY_THRESHOLD || (src instanceof RandomAccess && dest instanceof RandomAccess)) {        \n    for (int i=0; i<srcSize; i++)            \n    dest.set(i, src.get(i));    \n  } else {        \n    ListIterator<? super T> di=dest.listIterator();        \n    ListIterator<? extends T> si=src.listIterator();        \n    for (int i=0; i<srcSize; i++) {            \n      di.next();            \n      di.set(si.next());        \n    }    \n  }\n}\n```\n\n### 静态成员类优于非静态成员类 \n\n嵌套类（nested class）是指定义在另一个类的内部的类。嵌套类存在的目的只是为了它的外部类提供服务，如果其他的环境也会用到的话，应该成为一个顶层类（top-level class）。 嵌套类有四种：静态成员类（static member class）、非静态成员类（nonstatic member class）、匿名类（anonymous class）和 局部类（local class）。除了第一种之外，其他三种都称为内部类（inner class）。\n\n#### 匿名类（anonymous class） \n\n没有名字，声明的同时进行实例化，只能使用一次。当出现在非静态的环境中，会持有外部类实例的引用。通常用于创建函数对象和过程对象，不过现在会优先考虑lambda。\n\n#### 局部类（local class） \n\n任何可以声明局部变量的地方都可以声明局部类，同时遵循同样的作用域规则。跟匿名类不同的是，有名字可以重复使用。不过实际很少使用局部类。\n\n#### 静态成员类（static member class） \n\n最简单的一种嵌套类，声明在另一个类的内部，是这个类的静态成员，遵循同样的可访问性规则。常见的用法是作为公有的辅助类，只有与它的外部类一起使用才有意义。\n\n#### 非静态成员类（nonstatic member class） \n\n尽管语法上，跟静态成员类的唯一区别就是类的声明不包含static，但两者有很大的不同。非静态成员类的每个实例都隐含地与外部类的实例相关联，可以访问外部类的成员属性和方法。另外必须先创建外部类的实例之后才能创建非静态成员类的实例。\n\n总而言之，这四种嵌套类都有自己的用途。假设这个嵌套类属于一个方法的内部，如果只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就要把它做成匿名类。如果一个嵌套类需要在单个方法之外仍然可见，或者它太长了，不适合放在方法内部，就应该使用成员类。如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的，否则就做成静态的。\n\n### 优先使用模板/工具类 \n\n通过对常见场景的代码逻辑进行抽象封装，形成相应的模板工具类，可以大大减少重复代码，专注于业务逻辑，提高代码质量。\n\n### 分离对象的创建与使用 \n\n面向对象编程相对于面向过程，多了实例化这一步，而对象的创建必须要指定具体类型。我们常见的做法是“哪里用到，就在哪里创建”，使用实例和创建实例的是同一段代码。这似乎使代码更具有可读性，但是某些情况下造成了不必要的耦合。\n\n```java\npublic class BusinessObject {\n public void actionMethond {\n     //Other things\n     Service myServiceObj = new Service();\n       myServiceObj.doService();\n       //Other things\n    }\n}\n\npublic class BusinessObject {\n public void actionMethond {\n     //Other things\n     Service myServiceObj = new ServiceImpl();\n       myServiceObj.doService();\n       //Other things\n    }\n}\n\npublic class BusinessObject {\n   private Service myServiceObj;\n   public BusinessObject(Service aService) {\n       myServiceObj = aService;\n    }\n public void actionMethond {\n     //Other things\n       myServiceObj.doService();\n       //Other things\n    }\n}\n\npublic class BusinessObject {\n   private Service myServiceObj;\n   public BusinessObject() {\n       myServiceObj = ServiceFactory;\n    }\n public void actionMethond {\n     //Other things\n       myServiceObj.doService();\n       //Other things\n    }\n}\n```\n\n> 对象的创建者耦合的是对象的具体类型，而对象的使用者耦合的是对象的接口。也就是说，创建者关心的是这个对象是什么，而使用者关心的是它能干什么。这两者应该视为独立的考量，它们往往会因为不同的原因而改变。\n\n当对象的类型涉及多态、对象创建复杂（依赖较多）可以考虑将对象的创建过程分离出来，使得使用者不用关注对象的创建细节。设计模式中创建型模式的出发点就是如此，实际项目中可以使用工厂模式、构建器、依赖注入的方式。\n\n### 可访问性最小化 \n\n区分一个组件设计得好不好，一个很重要的因素在于，它对于外部组件而言，是否隐藏了其内部数据和实现细节。Java提供了访问控制机制来决定类、接口和成员的可访问性。实体的可访问性由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符（private、protected、public）共同决定的。\n\n对于顶层的（非嵌套的）类和接口，只有两种的访问级别：包级私有的（没有public修饰）和公有的（public修饰）。\n\n对于成员（实例/域、方法、嵌套类和嵌套接口）由四种的访问级别，可访问性如下递增：\n\n *  私有的（private修饰）--只有在声明该成员的顶层类内部才可以访问这个成员；\n *  包级私有的（默认）--声明该成员的包内部的任何类都可以访问这个成员；\n *  受保护的（protected修饰）--声明该成员的类的子类可以访问这个成员，并且声明该成员的包内部的任何类也可以访问这个成员；\n *  公有的（public修饰）--在任何地方都可以访问该成员；\n\n正确地使用这些修饰符对于实现信息隐藏是非常关键的，原则就是：尽可能地使每个类和成员不被外界访问（私有或包级私有）。这样好处就是在以后的发行版本中，可以对它进行修改、替换或者删除，而无须担心会影响现有的客户端程序。\n\n *  如果类或接口能够做成包级私有的，它就应该被做成包级私有的；\n *  如果一个包级私有的顶层类或接口只是在某一个类的内部被用到，就应该考虑使它成为那个类的私有嵌套类；\n *  公有类不应直接暴露实例域，应该提供相应的方法以保留将来改变该类的内部表示法的灵活性；\n *  当确定了类的公有API之后，应该把其他的成员都变成私有的；\n *  如果同一个包下的类之间存在比较多的访问时，就要考虑重新设计以减少这种耦合；\n\n### 可变性最小化 \n\n不可变类是指其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例时提供，并在对象的整个生命周期内固定不变。不可变类好处就是简单易用、线程安全、可自由共享而不容易出错。Java平台类库中包含许多不可变的类，比如String、基本类型包装类、BigDecimal等。\n\n为了使类成为不可变，要遵循下面五条规则：\n\n *  声明所有的域都是私有的\n *  声明所有的域都是final的\n *  如果一个指向新创建实例的引用在缺乏同步机制的情况下，从一个线程被传递到另一个线程，就必须确保正确的行为\n *  不提供任何会修改对象状态的方法\n *  保证类不会被扩展（防止子类化，类声明为final）\n *  防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏该类的不可变行为\n *  确保对任何可变组件的互斥访问\n *  如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法中返回该对象引用。在构造器、访问方法和readObject 方法中使用保护性拷贝技术\n\n可变性最小化的一些建议：\n\n *  除非有很好的理由要让类成为可变的类，否则它就应该是不可变的；\n *  如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性；\n *  除非有令人信服的理由要使域变成非final的，否则要使每个域都是private final的；\n *  构造器应该创建完全初始化的对象，并建立起所有的约束关系；\n\n# 质量如何保证 \n\n## 测试驱动开发 \n\n> 测试驱动开发（TDD）要求以测试作为开发过程的中心，要求在编写任何代码之前，首先编写用于产码行为的测试，而编写的代码又要以使测试通过为目标。TDD要求测试可以完全自动化地运行，并在对代码重构前后必须运行测试。\n\nTDD的最终目标是整洁可用的代码（clean code that works）。大多数的开发者大部分时间无法得到整洁可用的代码。办法是分而治之。首先解决目标中的“可用”问题，然后再解决“代码的整洁”问题。这与体系结构驱动（architecture-driven）的开发相反。\n\n采用TDD另一个好处就是让我们拥有一套伴随代码产生的详尽的自动化测试集。将来无论出于任何原因（需求、重构、性能改进）需要对代码进行维护时，在这套测试集的驱动下工作，我们代码将会一直是健壮的。\n\n## TDD的开发周期 \n\n![image_4605e609.png](常见代码重构技巧/image_4605e609.png) Image \\[6\\].png\n\n添加一个测试 -> 运行所有测试并检查测试结果 -> 编写代码以通过测试 -> 运行所有测试且全部通过 -> 重构代码，以消除重复设计，优化设计结构\n\n## 两个基本的原则 \n\n *  仅在测试失败时才编写代码并且只编写刚好使测试通过的代码\n *  编写下一个测试之前消除现有的重复设计，优化设计结构\n\n关注点分离是这两条规则隐含的另一个非常重要的原则。其表达的含义指在编码阶段先达到代码“可用”的目标，在重构阶段再追求“整洁”目标，每次只关注一件事！\n\n## 分层测试点 \n\n![image_e59205e3.png](常见代码重构技巧/image_e59205e3.png)\n\n# 参考资料 \n\n *  重构-改善既有代码的设计\n *  设计模式\n *  Effective Java\n *  敏捷软件开发与设计的最佳实践\n *  实现模式\n *  测试驱动开发                \n    \n\n  \n\n","slug":"常见代码重构技巧","published":1,"updated":"2022-11-08T01:57:36.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cla7kcdgu0000tvld43pe9jy5","content":"<h1 id=\"关于重构\"><a href=\"#关于重构\" class=\"headerlink\" title=\"关于重构\"></a>关于重构</h1><h2 id=\"为什么要重构\"><a href=\"#为什么要重构\" class=\"headerlink\" title=\"为什么要重构\"></a>为什么要重构</h2><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_83d6de95-20221108095355418.png\" alt=\"image_83d6de95.png\"> 1_代码重构漫画.jpeg</p>\n<p>项目在不断演进过程中，代码不停地在堆砌。如果没有人为代码的质量负责，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。</p>\n<p>造成这样的原因往往有以下几点：</p>\n<ol>\n<li> 编码之前缺乏有效的设计</li>\n<li> 成本上的考虑，在原功能堆砌式编程</li>\n<li> 缺乏有效代码质量监督机制</li>\n</ol>\n<p>对于此类问题，业界已有有很好的解决思路：通过持续不断的重构将代码中的“坏味道”清除掉。</p>\n<h2 id=\"什么是重构\"><a href=\"#什么是重构\" class=\"headerlink\" title=\"什么是重构\"></a>什么是重构</h2><p>重构一书的作者Martin Fowler对重构的定义：</p>\n<blockquote>\n<p>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。<br>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</p>\n</blockquote>\n<p>根据重构的规模可以大致分为大型重构和小型重构：</p>\n<p>大型重构：对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入bug的风险也会相对比较大。</p>\n<p>小型重构：对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名和注释、消除超大类或函数、提取重复代码等等。小型重构更多的是使用统一的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入bug的风险相对来说也会比较小。什么时候重构 新功能开发、修bug或者代码review中出现“代码坏味道”，我们就应该及时进行重构。持续在日常开发中进行小重构，能够降低重构和测试的成本。</p>\n<h1 id=\"代码的坏味道\"><a href=\"#代码的坏味道\" class=\"headerlink\" title=\"代码的坏味道\"></a>代码的坏味道</h1><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_047389be-20221108095355455.png\" alt=\"image_047389be.png\"> 2_代码常见问题.png</p>\n<p>代码重复</p>\n<ul>\n<li> 实现逻辑相同、执行流程相同</li>\n</ul>\n<p>方法过长</p>\n<ul>\n<li> 方法中的语句不在同一个抽象层级</li>\n<li> 逻辑难以理解，需要大量的注释</li>\n<li> 面向过程编程而非面向对象</li>\n</ul>\n<p>过大的类</p>\n<ul>\n<li> 类做了太多的事情</li>\n<li> 包含过多的实例变量和方法</li>\n<li> 类的命名不足以描述所做的事情</li>\n</ul>\n<p>逻辑分散</p>\n<ul>\n<li> 发散式变化：某个类经常因为不同的原因在不同的方向上发生变化</li>\n<li> 散弹式修改：发生某种变化时，需要在多个类中做修改</li>\n</ul>\n<p>严重的情结依恋</p>\n<ul>\n<li> 某个类的方法过多的使用其他类的成员</li>\n</ul>\n<p>数据泥团/基本类型偏执</p>\n<ul>\n<li> 两个类、方法签名中包含相同的字段或参数</li>\n<li> 应该使用类但使用基本类型，比如表示数值与币种的Money类、起始值与结束值的Range类</li>\n</ul>\n<p>不合理的继承体系</p>\n<ul>\n<li> 继承打破了封装性，子类依赖其父类中特定功能的实现细节</li>\n<li> 子类必须跟着其父类的更新而演变，除非父类是专门为了扩展而设计，并且有很好的文档说明</li>\n</ul>\n<p>过多的条件判断</p>\n<p>过长的参数列</p>\n<p>临时变量过多</p>\n<p>令人迷惑的暂时字段</p>\n<ul>\n<li> 某个实例变量仅为某种特定情况而设置</li>\n<li> 将实例变量与相应的方法提取到新的类中</li>\n</ul>\n<p>纯数据类</p>\n<ul>\n<li> 仅包含字段和访问（读写）这些字段的方法</li>\n<li> 此类被称为数据容器，应保持最小可变性</li>\n</ul>\n<p>不恰当的命名</p>\n<ul>\n<li> 命名无法准确描述做的事情</li>\n<li> 命名不符合约定俗称的惯例</li>\n</ul>\n<p>过多的注释</p>\n<h2 id=\"坏代码的问题\"><a href=\"#坏代码的问题\" class=\"headerlink\" title=\"坏代码的问题\"></a>坏代码的问题</h2><ul>\n<li> 难以复用</li>\n<li> 系统关联性过多，导致很难分离可重用部分</li>\n<li> 难于变化</li>\n<li> 一处变化导致其他很多部分的修改，不利于系统稳定</li>\n<li> 难于理解</li>\n<li> 命名杂乱，结构混乱，难于阅读和理解</li>\n<li> 难以测试</li>\n<li> 分支、依赖较多，难以覆盖全面</li>\n</ul>\n<h2 id=\"什么是好代码\"><a href=\"#什么是好代码\" class=\"headerlink\" title=\"什么是好代码\"></a>什么是好代码</h2><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_d67b805c-20221108095355391.png\" alt=\"image_d67b805c.png\"> 3_代码质量如何衡量.jpg</p>\n<p>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁。这些词汇是从不同的维度去评价代码质量的。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</p>\n<p>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。</p>\n<h1 id=\"如何重构\"><a href=\"#如何重构\" class=\"headerlink\" title=\"如何重构\"></a>如何重构</h1><h2 id=\"SOLID原则\"><a href=\"#SOLID原则\" class=\"headerlink\" title=\"SOLID原则\"></a>SOLID原则</h2><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_f864e546-20221108095355479.png\" alt=\"image_f864e546.png\"> 4_SOLID原则.png</p>\n<h3 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h3><p>一个类只负责完成一个职责或者功能，不要存在多于一种导致类变更的原因。</p>\n<p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p>\n<h3 id=\"开放-关闭原则\"><a href=\"#开放-关闭原则\" class=\"headerlink\" title=\"开放-关闭原则\"></a>开放-关闭原则</h3><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。</p>\n<p>开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。</p>\n<p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p>\n<h3 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h3><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p>\n<p>子类可以扩展父类的功能，但不能改变父类原有的功能</p>\n<blockquote>\n<p>父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。</p>\n</blockquote>\n<h3 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h3><p>调用方不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>\n<h3 id=\"依赖反转原则\"><a href=\"#依赖反转原则\" class=\"headerlink\" title=\"依赖反转原则\"></a>依赖反转原则</h3><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p>\n<h3 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h3><p>一个对象应该对其他对象保持最少的了解</p>\n<h3 id=\"合成复用原则\"><a href=\"#合成复用原则\" class=\"headerlink\" title=\"合成复用原则\"></a>合成复用原则</h3><p>尽量使用合成/聚合的方式，而不是使用继承。</p>\n<p>单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，告诉我们要对扩展开放，对修改关闭。</p>\n<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><blockquote>\n<p>设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案。</p>\n</blockquote>\n<ul>\n<li> 创建型：主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码</li>\n<li> 结构型：主要通过类或对象的不同组合，解耦不同功能的耦合</li>\n<li> 行为型：主要解决的是类或对象之间的交互行为的耦合</li>\n</ul>\n<p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_9db0426b-20221108095355436.png\" alt=\"image_9db0426b.png\"><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_41c09a5c.png\" alt=\"image_41c09a5c.png\"><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_2c6e506b.png\" alt=\"image_2c6e506b.png\"><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_8fa858cb.png\" alt=\"image_8fa858cb.png\"></p>\n<h2 id=\"代码分层\"><a href=\"#代码分层\" class=\"headerlink\" title=\"代码分层\"></a>代码分层</h2><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_598a46ba.png\" alt=\"image_598a46ba.png\"> image.png</p>\n<p>模块结构说明</p>\n<ul>\n<li> server_main：配置层，负责整个项目的module管理，maven配置管理、资源管理等；</li>\n<li> server_application：应用接入层，承接外部流量入口，例如：RPC接口实现、消息处理、定时任务等；不要在此包含业务逻辑；</li>\n<li> server_biz：核心业务层，用例服务、领域实体、领域事件等</li>\n<li> server_irepository：资源接口层，负责资源接口的暴露</li>\n<li> server_repository：资源层，负责资源的proxy访问，统一外部资源访问，隔离变化。注意：这里强调的是弱业务性，强数据性；</li>\n<li> server_common：公共层，vo、工具等</li>\n</ul>\n<p>代码开发要遵守各层的规范，并注意层级之间的依赖关系。</p>\n<h2 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h2><blockquote>\n<p>一个好的命名应该要满足以下两个约束：</p>\n<ul>\n<li> 准确描述所做得事情</li>\n<li> 格式符合通用的惯例</li>\n</ul>\n<p>如果你觉得一个类或方法难以命名的时候，可能是其承载的功能太多了，需要进一步拆分。</p>\n</blockquote>\n<h3 id=\"约定俗称的惯例\"><a href=\"#约定俗称的惯例\" class=\"headerlink\" title=\"约定俗称的惯例\"></a>约定俗称的惯例</h3><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_ff852d0e.png\" alt=\"image_ff852d0e.png\"></p>\n<h3 id=\"类命名\"><a href=\"#类命名\" class=\"headerlink\" title=\"类命名\"></a>类命名</h3><blockquote>\n<p>类名使用大驼峰命名形式，类命通常使用名词或名词短语。接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如 Cloneable，Callable 等，表示实现该接口的类有某种功能或能力。</p>\n</blockquote>\n<p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_83a6a12c.png\" alt=\"image_83a6a12c.png\"></p>\n<h3 id=\"方法命名\"><a href=\"#方法命名\" class=\"headerlink\" title=\"方法命名\"></a>方法命名</h3><blockquote>\n<p>方法命名采用小驼峰的形式，首字小写，往后的每个单词首字母都要大写。和类名不同的是，方法命名一般为动词或动词短语，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。</p>\n</blockquote>\n<p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_450be2e5.png\" alt=\"image_450be2e5.png\"></p>\n<h2 id=\"重构技巧\"><a href=\"#重构技巧\" class=\"headerlink\" title=\"重构技巧\"></a>重构技巧</h2><h3 id=\"提炼方法\"><a href=\"#提炼方法\" class=\"headerlink\" title=\"提炼方法\"></a>提炼方法</h3><p>多个方法代码重复、方法中代码过长或者方法中的语句不在一个抽象层级。<br>方法是代码复用的最小粒度，方法过长不利于复用，可读性低，提炼方法往往是重构工作的第一步。</p>\n<p>意图导向编程：把处理某件事的流程和具体做事的实现方式分开。</p>\n<ul>\n<li> 把一个问题分解为一系列功能性步骤，并假定这些功能步骤已经实现</li>\n<li> 我们只需把把各个函数组织在一起即可解决这一问题</li>\n<li> 在组织好整个功能后，我们在分别实现各个方法函数</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/** \n  * 1、交易信息开始于一串标准ASCII字符串。 \n  * 2、这个信息字符串必须转换成一个字符串的数组，数组存放的此次交易的领域语言中所包含的词汇元素（token)。 \n  * 3、每一个词汇必须标准化。 \n  * 4、包含超过150个词汇元素的交易，应该采用不同于小型交易的方式（不同的算法）来提交，以提高效率。 \n  * 5、如果提交成功，API返回”true”；失败，则返回”false”。 \n  */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Transaction</span> <span class=\"token punctuation\">&#123;</span>    \n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Boolean</span> <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> command<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>        \n    <span class=\"token class-name\">Boolean</span> result <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tokens <span class=\"token operator\">=</span> <span class=\"token function\">tokenize</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token function\">normalizeTokens</span><span class=\"token punctuation\">(</span>tokens<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isALargeTransaction</span><span class=\"token punctuation\">(</span>tokens<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>            \n      result <span class=\"token operator\">=</span> <span class=\"token function\">processLargeTransaction</span><span class=\"token punctuation\">(</span>tokens<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>            \n      result <span class=\"token operator\">=</span> <span class=\"token function\">processSmallTransaction</span><span class=\"token punctuation\">(</span>tokens<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token punctuation\">&#125;</span>        \n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>    \n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"以函数对象取代函数\"><a href=\"#以函数对象取代函数\" class=\"headerlink\" title=\"以函数对象取代函数\"></a>以函数对象取代函数</h3><p>将函数放进一个单独对象中，如此一来局部变量就变成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。</p>\n<h3 id=\"引入参数对象\"><a href=\"#引入参数对象\" class=\"headerlink\" title=\"引入参数对象\"></a>引入参数对象</h3><p>方法参数比较多时，将参数封装为参数对象</p>\n<h3 id=\"移除对参数的赋值\"><a href=\"#移除对参数的赋值\" class=\"headerlink\" title=\"移除对参数的赋值\"></a>移除对参数的赋值</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">discount</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> inputVal<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> quantity<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> yearToDate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>inputVal <span class=\"token operator\">></span> <span class=\"token number\">50</span><span class=\"token punctuation\">)</span> inputVal <span class=\"token operator\">-=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>quantity <span class=\"token operator\">></span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span> inputVal <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>yearToDate <span class=\"token operator\">></span> <span class=\"token number\">10000</span><span class=\"token punctuation\">)</span> inputVal <span class=\"token operator\">-=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> inputVal<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">discount</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> inputVal<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> quantity<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> yearToDate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> \n  <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> inputVal<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>inputVal <span class=\"token operator\">></span> <span class=\"token number\">50</span><span class=\"token punctuation\">)</span> result <span class=\"token operator\">-=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>quantity <span class=\"token operator\">></span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span> result <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>yearToDate <span class=\"token operator\">></span> <span class=\"token number\">10000</span><span class=\"token punctuation\">)</span> result <span class=\"token operator\">-=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"将查询与修改分离\"><a href=\"#将查询与修改分离\" class=\"headerlink\" title=\"将查询与修改分离\"></a>将查询与修改分离</h3><p>任何有返回值的方法，都不应该有副作用</p>\n<ul>\n<li> 不要在convert中调用写操作，避免副作用</li>\n<li> 常见的例外：将查询结果缓存到本地</li>\n</ul>\n<h3 id=\"移除不必要临时变量\"><a href=\"#移除不必要临时变量\" class=\"headerlink\" title=\"移除不必要临时变量\"></a>移除不必要临时变量</h3><p>临时变量仅使用一次或者取值逻辑成本很低的情况下</p>\n<h3 id=\"引入解释性变量\"><a href=\"#引入解释性变量\" class=\"headerlink\" title=\"引入解释性变量\"></a>引入解释性变量</h3><p>将复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>platform<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MAC\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> \n    <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>browser<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"IE\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">wasInitialized</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> resize <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   \n  <span class=\"token comment\">// do something </span>\n<span class=\"token punctuation\">&#125;</span> \n  \n<span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> isMacOs <span class=\"token operator\">=</span> platform<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MAC\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> isIEBrowser <span class=\"token operator\">=</span> browser<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"IE\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> wasResized <span class=\"token operator\">=</span> resize <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isMacOs <span class=\"token operator\">&amp;&amp;</span> isIEBrowser <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">wasInitialized</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> wasResized<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   \n  <span class=\"token comment\">// do something </span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"使用卫语句替代嵌套条件判断\"><a href=\"#使用卫语句替代嵌套条件判断\" class=\"headerlink\" title=\"使用卫语句替代嵌套条件判断\"></a>使用卫语句替代嵌套条件判断</h3><p>把复杂的条件表达式拆分成多个条件表达式，减少嵌套。嵌套了好几层的if - then-else语句，转换为多个if语句</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//未使用卫语句</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">getHello</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token function\">setHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span> \n\n<span class=\"token comment\">//使用卫语句</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">getHello</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">setHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"使用多态替代条件判断断\"><a href=\"#使用多态替代条件判断断\" class=\"headerlink\" title=\"使用多态替代条件判断断\"></a>使用多态替代条件判断断</h3><p>当存在这样一类条件表达式，它根据对象类型的不同选择不同的行为。可以将这种表达式的每个分支放进一个子类内的复写函数中，然后将原始函数声明为抽象函数。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">calculate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> operator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span>MIN_VALUE<span class=\"token punctuation\">;</span>\n \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"add\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        result <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"multiply\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        result <span class=\"token operator\">=</span> a <span class=\"token operator\">*</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"divide\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        result <span class=\"token operator\">=</span> a <span class=\"token operator\">/</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"subtract\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        result <span class=\"token operator\">=</span> a <span class=\"token operator\">-</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当出现大量类型检查和判断时，if else（或switch）语句的体积会比较臃肿，这无疑降低了代码的可读性。 另外，if else（或switch）本身就是一个“变化点”，当需要扩展新的类型时，我们不得不追加if else（或switch）语句块，以及相应的逻辑，这无疑降低了程序的可扩展性，也违反了面向对象的开闭原则。</p>\n<blockquote>\n<p>基于这种场景，我们可以考虑使用“多态”来代替冗长的条件判断，将if else（或switch）中的“变化点”封装到子类中。这样，就不需要使用if else（或switch）语句了，取而代之的是子类多态的实例，从而使得提高代码的可读性和可扩展性。很多设计模式使用都是这种套路，比如策略模式、状态模式。</p>\n</blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Operation</span> <span class=\"token punctuation\">&#123;</span> \n  <span class=\"token keyword\">int</span> <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Addition</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Operation</span> <span class=\"token punctuation\">&#123;</span> \n  <span class=\"token annotation punctuation\">@Override</span> \n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> \n    <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span> \n  <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OperatorFactory</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Operation</span><span class=\"token punctuation\">></span></span> operationMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span>\n        operationMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"add\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Addition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        operationMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"divide\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Division</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// more operators</span>\n    <span class=\"token punctuation\">&#125;</span>\n \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Operation</span> <span class=\"token function\">getOperation</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> operator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> operationMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">calculate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> operator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">OperatorFactory</span> <span class=\"token punctuation\">.</span>getOperation <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Invalid Operator\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">OperatorFactory</span> <span class=\"token punctuation\">.</span><span class=\"token function\">getOperation</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"使用异常替代返回错误码\"><a href=\"#使用异常替代返回错误码\" class=\"headerlink\" title=\"使用异常替代返回错误码\"></a>使用异常替代返回错误码</h3><p>非正常业务状态的处理，使用抛出异常的方式代替返回错误码</p>\n<ul>\n<li> 不要使用异常处理用于正常的业务流程控制</li>\n<li> 异常处理的性能成本非常高</li>\n<li> 尽量使用标准异常</li>\n<li> 避免在finally语句块中抛出异常</li>\n<li>如果同时抛出两个异常，则第一个异常的调用栈会丢失 finally块中应只做关闭资源这类的事情</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//使用错误码</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> amount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>balance <span class=\"token operator\">&lt;</span> amount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n        balance <span class=\"token operator\">-=</span> amount<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//使用异常</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> amount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>amount <span class=\"token operator\">></span> balance<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"amount too large\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n    <span class=\"token punctuation\">&#125;</span>\n    balance <span class=\"token operator\">-=</span> amount<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"引入断言\"><a href=\"#引入断言\" class=\"headerlink\" title=\"引入断言\"></a>引入断言</h3><p>某一段代码需要对程序状态做出某种假设，以断言明确表现这种假设。</p>\n<ul>\n<li> 不要滥用断言，不要使用它来检查“应该为真”的条件，只使用它来检查“一定必须为真”的条件</li>\n<li> 如果断言所指示的约束条件不能满足，代码是否仍能正常运行？如果可以就去掉断言</li>\n</ul>\n<h3 id=\"引入Null对象或特殊对象\"><a href=\"#引入Null对象或特殊对象\" class=\"headerlink\" title=\"引入Null对象或特殊对象\"></a>引入Null对象或特殊对象</h3><p>当使用一个方法返回的对象时，而这个对象可能为空，这个时候需要对这个对象进行操作前，需要进行判空，否则就会报空指针。当这种判断频繁的出现在各处代码之中，就会影响代码的美观程度和可读性，甚至增加Bug的几率。</p>\n<p>空引用的问题在Java中无法避免，但可以通过代码编程技巧（引入空对象）来改善这一问题。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//空对象的例子</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OperatorFactory</span> <span class=\"token punctuation\">&#123;</span> \n  <span class=\"token keyword\">static</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Operation</span><span class=\"token punctuation\">></span></span> operationMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span> \n    operationMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"add\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Addition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    operationMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"divide\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Division</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token comment\">// more operators </span>\n  <span class=\"token punctuation\">&#125;</span> \n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Optional</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Operation</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">getOperation</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> operator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> \n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">Optional</span><span class=\"token punctuation\">.</span><span class=\"token function\">ofNullable</span><span class=\"token punctuation\">(</span>operationMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">calculate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> operator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> \n  <span class=\"token class-name\">Operation</span> targetOperation <span class=\"token operator\">=</span> <span class=\"token class-name\">OperatorFactory</span><span class=\"token punctuation\">.</span><span class=\"token function\">getOperation</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span> \n     <span class=\"token punctuation\">.</span><span class=\"token function\">orElseThrow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Invalid Operator\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">return</span> targetOperation<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//特殊对象的例子</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InvalidOp</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Operation</span> <span class=\"token punctuation\">&#123;</span> \n  <span class=\"token annotation punctuation\">@Override</span> \n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">&#123;</span> \n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Invalid Operator\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"提炼类\"><a href=\"#提炼类\" class=\"headerlink\" title=\"提炼类\"></a>提炼类</h3><p>根据单一职责原则，一个类应该有明确的责任边界。但在实际工作中，类会不断的扩展。当给某个类添加一项新责任时，你会觉得不值得分离出一个单独的类。于是，随着责任不断增加，这个类包含了大量的数据和函数，逻辑复杂不易理解。</p>\n<p>此时你需要考虑将哪些部分分离到一个单独的类中，可以依据高内聚低耦合的原则。如果某些数据和方法总是一起出现，或者某些数据经常同时变化，这就表明它们应该放到一个类中。另一种信号是类的子类化方式：如果你发现子类化只影响类的部分特性，或者类的特性需要以不同方式来子类化，这就意味着你需要分解原来的类。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//原始类</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> officeAreaCode<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> officeNumber<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getTelephoneNumber</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"(\"</span> <span class=\"token operator\">+</span> officeAreaCode <span class=\"token operator\">+</span> <span class=\"token string\">\")\"</span> <span class=\"token operator\">+</span> officeNumber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getOfficeAreaCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> officeAreaCode<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setOfficeAreaCode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        officeAreaCode <span class=\"token operator\">=</span> arg<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getOfficeNumber</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> officeNumber<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setOfficeNumber</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        officeNumber <span class=\"token operator\">=</span> arg<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//新提炼的类（以对象替换数据值）</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TelephoneNumber</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> areaCode<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> number<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getTelephnoeNumber</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"(\"</span> <span class=\"token operator\">+</span> <span class=\"token function\">getAreaCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\")\"</span> <span class=\"token operator\">+</span> number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token class-name\">String</span> <span class=\"token function\">getAreaCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> areaCode<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">setAreaCode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        areaCode <span class=\"token operator\">=</span> arg<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token class-name\">String</span> <span class=\"token function\">getNumber</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> number<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">setNumber</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        number <span class=\"token operator\">=</span> arg<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"组合优先于继承\"><a href=\"#组合优先于继承\" class=\"headerlink\" title=\"组合优先于继承\"></a>组合优先于继承</h3><p>继承使实现代码重用的有力手段，但这并非总是完成这项工作的最佳工具，使用不当会导致软件变得很脆弱。与方法调用不同的是，继承打破了封装性。子类依赖于其父类中特定功能的实现细节，如果父类的实现随着发行版本的不同而变化，子类可能会遭到破坏，即使他的代码完全没有改变。</p>\n<p>举例说明，假设有一个程序使用HashSet，为了调优该程序的性能，需要统计HashSet自从它创建以来添加了多少个元素。为了提供该功能，我们编写一个HashSet的变体。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// Inappropriate use of inheritance!</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InstrumentedHashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// The number of attempted element insertions</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> addCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">InstrumentedHashSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">InstrumentedHashSet</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> initCap<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> loadFactor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>initCap<span class=\"token punctuation\">,</span> loadFactor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        addCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        addCount <span class=\"token operator\">+=</span> c<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAddCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> addCount<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>通过在新的类中增加一个私有域，它引用现有类的一个实例，这种设计被称为组合，因为现有的类变成了新类的一个组件。这样得到的类将会非常稳固，它不依赖现有类的实现细节。即使现有的类添加了新的方法，也不会影响新的类。许多设计模式使用就是这种套路，比如代理模式、装饰者模式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// Reusable forwarding class</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ForwardingSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> s<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ForwardingSet</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>s <span class=\"token operator\">=</span> s<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n  \n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Iterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">containsAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">containsAll</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">retainAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">retainAll</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">removeAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">removeAll</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// Wrappter class - uses composition in place of inheritance</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InstrumentedHashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ForwardingSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> addCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">InstrumentedHashSet1</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        addCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        addCount <span class=\"token operator\">+=</span> c<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAddCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> addCount<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>继承与组合如何取舍</p>\n<ul>\n<li> 只有当子类真正是父类的子类型时，才适合继承。对于两个类A和B，只有两者之间确实存在“is-a”关系的时候，类B才应该继承A；</li>\n<li> 在包的内部使用继承是非常安全的，子类和父类的实现都处在同一个程序员的控制之下；</li>\n<li> 对于专门为了继承而设计并且具有很好的文档说明的类来说，使用继承也是非常安全的；</li>\n<li> 其他情况就应该优先考虑组合的方式来实现</li>\n</ul>\n<h3 id=\"接口优于抽象类\"><a href=\"#接口优于抽象类\" class=\"headerlink\" title=\"接口优于抽象类\"></a>接口优于抽象类</h3><p>Java提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象类。自从Java8为接口增加缺省方法（default method），这两种机制都允许为实例方法提供实现。主要区别在于，为了实现由抽象类定义的类型，类必须称为抽象类的一个子类。因为Java只允许单继承，所以用抽象类作为类型定义受到了限制。</p>\n<p>接口相比于抽象类的优势：</p>\n<ul>\n<li> 现有的类可以很容易被更新，以实现新的接口。</li>\n<li> 接口是定义混合类型（比如Comparable）的理想选择。</li>\n<li> 接口允许构造非层次结构的类型框架。</li>\n</ul>\n<p>接口虽然提供了缺省方法，但接口仍有有以下局限性：</p>\n<ul>\n<li> 接口的变量修饰符只能是public static final的</li>\n<li> 接口的方法修饰符只能是public的</li>\n<li> 接口不存在构造函数，也不存在this</li>\n<li> 可以给现有接口增加缺省方法，但不能确保这些方法在之前存在的实现中都能良好运行。</li>\n<li> 因为这些默认方法是被注入到现有实现中的，它们的实现者并不知道，也没有许可</li>\n</ul>\n<p>接口缺省方法的设计目的和优势在于：</p>\n<p>为了接口的演化</p>\n<ul>\n<li> Java 8 之前我们知道，一个接口的所有方法其子类必须实现（当然，这个子类不是一个抽象类），但是 java 8 之后接口的默认方法可以选择不实现，如上的操作是可以通过编译期编译的。这样就避免了由 Java 7 升级到 Java 8 时项目编译报错了。Java8在核心集合接口中增加了许多新的缺省方法，主要是为了便于使用lambda。</li>\n</ul>\n<p>可以减少第三方工具类的创建</p>\n<ul>\n<li> 例如在 List 等集合接口中都有一些默认方法，List 接口中默认提供 replaceAll(UnaryOperator)、sort(Comparator)、、spliterator()等默认方法，这些方法在接口内部创建，避免了为了这些方法而专门去创建相应的工具类。</li>\n</ul>\n<p>可以避免创建基类</p>\n<ul>\n<li> 在 Java 8 之前我们可能需要创建一个基类来实现代码复用，而默认方法的出现，可以不必要去创建基类。</li>\n</ul>\n<p>由于接口的局限性和设计目的的不同，接口并不能完全替换抽象类。但是通过对接口提供一个抽象的骨架实现类，可以把接口和抽象类的优点结合起来。 接口负责定义类型，或许还提供一些缺省方法，而骨架实现类则负责实现除基本类型接口方法之外，剩下的非基本类型接口方法。扩展骨架实现占了实现接口之外的大部分工作。这就是模板方法（Template Method）设计模式。</p>\n<p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_24ceb509.png\" alt=\"image_24ceb509.png\"> Image [5].png</p>\n<p>接口Protocol：定义了RPC协议层两个主要的方法，export暴露服务和refer引用服务</p>\n<p>抽象类AbstractProtocol：封装了暴露服务之后的Exporter和引用服务之后的Invoker实例，并实现了服务销毁的逻辑</p>\n<p>具体实现类XxxProtocol：实现export暴露服务和refer引用服务具体逻辑</p>\n<h3 id=\"优先考虑泛型\"><a href=\"#优先考虑泛型\" class=\"headerlink\" title=\"优先考虑泛型\"></a>优先考虑泛型</h3><p>声明中具有一个或者多个类型参数（type parameter）的类或者接口，就是泛型（generic）类或者接口。泛型类和接口统称为泛型（generic type）。泛型从Java 5引入，提供了编译时类型安全检测机制。泛型的本质是参数化类型，通过一个参数来表示所操作的数据类型，并且可以限制这个参数的类型范围。泛型的好处就是编译期类型检测，避免类型转换。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 比较三个值并返回最大值</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Comparable</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">maximum</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span> x<span class=\"token punctuation\">,</span> <span class=\"token class-name\">T</span> y<span class=\"token punctuation\">,</span> <span class=\"token class-name\">T</span> z<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   \n  <span class=\"token class-name\">T</span> max <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span> \n  <span class=\"token comment\">// 假设x是初始最大值   </span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> y<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span> max <span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>      \n    max <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span> <span class=\"token comment\">//y 更大  </span>\n  <span class=\"token punctuation\">&#125;</span>   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> z<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span> max <span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>     \n    max <span class=\"token operator\">=</span> z<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 现在 z 更大              </span>\n  <span class=\"token punctuation\">&#125;</span>   <span class=\"token keyword\">return</span> max<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 返回最大对象</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span> <span class=\"token class-name\">String</span> args<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   \n  <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"%d, %d 和 %d 中最大的数为 %d\\n\\n\"</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token function\">maximum</span><span class=\"token punctuation\">(</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   \n  <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"%.1f, %.1f 和 %.1f 中最大的数为 %.1f\\n\\n\"</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">6.6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8.8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7.7</span><span class=\"token punctuation\">,</span>  <span class=\"token function\">maximum</span><span class=\"token punctuation\">(</span> <span class=\"token number\">6.6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8.8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7.7</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   \n  <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"%s, %s 和 %s 中最大的数为 %s\\n\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"pear\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"orange\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">maximum</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"pear\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"orange\"</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"不要使用原生态类型\"><a href=\"#不要使用原生态类型\" class=\"headerlink\" title=\"不要使用原生态类型\"></a>不要使用原生态类型</h4><p>由于为了保持Java代码的兼容性，支持和原生态类型转换，并使用擦除机制实现的泛型。但是使用原生态类型就会失去泛型的优势，会受到编译器警告。</p>\n<h4 id=\"要尽可能地消除每一个非受检警告\"><a href=\"#要尽可能地消除每一个非受检警告\" class=\"headerlink\" title=\"要尽可能地消除每一个非受检警告\"></a>要尽可能地消除每一个非受检警告</h4><p>每一条警告都表示可能在运行时抛出ClassCastException异常。要尽最大的努力去消除这些警告。如果无法消除但是可以证明引起警告的代码是安全的，就可以在尽可能小的范围中，使用＠SuppressWarnings(“unchecked”)注解来禁止警告，但是要把禁止的原因记录下来。</p>\n<h4 id=\"利用有限制通配符来提升API的灵活性\"><a href=\"#利用有限制通配符来提升API的灵活性\" class=\"headerlink\" title=\"利用有限制通配符来提升API的灵活性\"></a>利用有限制通配符来提升API的灵活性</h4><p>参数化类型不支持协变的，即对于任何两个不同的类型Type1和Type2而言，List既不是List的子类型，也不是它的超类。为了解决这个问题，提高灵活性，Java提供了一种特殊的参数化类型，称作有限制的通配符类型，即List&lt;? extends E&gt;和List&lt;? super E&gt;。使用原则是producer-extends，consumer-super（PECS）。如果即是生产者，又是消费者，就没有必要使用通配符了。</p>\n<p>还有一种特殊的无限制通配符List&lt;?&gt;，表示某种类型但不确定。常用作泛型的引用，不可向其添加除Null以外的任何对象。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//List&lt;? extends E></span>\n<span class=\"token comment\">// Number 可以认为 是Number 的 \"子类\"</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Number</span><span class=\"token punctuation\">></span></span> numberArray <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Number</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\">// Integer 是 Number 的子类</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Number</span><span class=\"token punctuation\">></span></span> numberArray <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\">// Double 是 Number 的子类</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Number</span><span class=\"token punctuation\">></span></span> numberArray <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Double</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n\n<span class=\"token comment\">//List&lt;? super E></span>\n<span class=\"token comment\">// Integer 可以认为是 Integer 的 \"父类\"</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> array <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>、\n<span class=\"token comment\">// Number 是 Integer 的 父类</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> array <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Number</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Object 是 Integer 的 父类</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> array <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">void</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> dest<span class=\"token punctuation\">,</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> src<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>    \n  <span class=\"token keyword\">int</span> srcSize <span class=\"token operator\">=</span> src<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>srcSize <span class=\"token operator\">></span> dest<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>        \n   <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IndexOutOfBoundsException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Source does not fit in dest\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>srcSize <span class=\"token operator\">&lt;</span> COPY_THRESHOLD <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>src <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">RandomAccess</span> <span class=\"token operator\">&amp;&amp;</span> dest <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">RandomAccess</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>        \n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>srcSize<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>            \n    dest<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> src<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n  <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>        \n    <span class=\"token class-name\">ListIterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> di<span class=\"token operator\">=</span>dest<span class=\"token punctuation\">.</span><span class=\"token function\">listIterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token class-name\">ListIterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> si<span class=\"token operator\">=</span>src<span class=\"token punctuation\">.</span><span class=\"token function\">listIterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>srcSize<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>            \n      di<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            \n      di<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>si<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token punctuation\">&#125;</span>    \n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"静态成员类优于非静态成员类\"><a href=\"#静态成员类优于非静态成员类\" class=\"headerlink\" title=\"静态成员类优于非静态成员类\"></a>静态成员类优于非静态成员类</h3><p>嵌套类（nested class）是指定义在另一个类的内部的类。嵌套类存在的目的只是为了它的外部类提供服务，如果其他的环境也会用到的话，应该成为一个顶层类（top-level class）。 嵌套类有四种：静态成员类（static member class）、非静态成员类（nonstatic member class）、匿名类（anonymous class）和 局部类（local class）。除了第一种之外，其他三种都称为内部类（inner class）。</p>\n<h4 id=\"匿名类（anonymous-class）\"><a href=\"#匿名类（anonymous-class）\" class=\"headerlink\" title=\"匿名类（anonymous class）\"></a>匿名类（anonymous class）</h4><p>没有名字，声明的同时进行实例化，只能使用一次。当出现在非静态的环境中，会持有外部类实例的引用。通常用于创建函数对象和过程对象，不过现在会优先考虑lambda。</p>\n<h4 id=\"局部类（local-class）\"><a href=\"#局部类（local-class）\" class=\"headerlink\" title=\"局部类（local class）\"></a>局部类（local class）</h4><p>任何可以声明局部变量的地方都可以声明局部类，同时遵循同样的作用域规则。跟匿名类不同的是，有名字可以重复使用。不过实际很少使用局部类。</p>\n<h4 id=\"静态成员类（static-member-class）\"><a href=\"#静态成员类（static-member-class）\" class=\"headerlink\" title=\"静态成员类（static member class）\"></a>静态成员类（static member class）</h4><p>最简单的一种嵌套类，声明在另一个类的内部，是这个类的静态成员，遵循同样的可访问性规则。常见的用法是作为公有的辅助类，只有与它的外部类一起使用才有意义。</p>\n<h4 id=\"非静态成员类（nonstatic-member-class）\"><a href=\"#非静态成员类（nonstatic-member-class）\" class=\"headerlink\" title=\"非静态成员类（nonstatic member class）\"></a>非静态成员类（nonstatic member class）</h4><p>尽管语法上，跟静态成员类的唯一区别就是类的声明不包含static，但两者有很大的不同。非静态成员类的每个实例都隐含地与外部类的实例相关联，可以访问外部类的成员属性和方法。另外必须先创建外部类的实例之后才能创建非静态成员类的实例。</p>\n<p>总而言之，这四种嵌套类都有自己的用途。假设这个嵌套类属于一个方法的内部，如果只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就要把它做成匿名类。如果一个嵌套类需要在单个方法之外仍然可见，或者它太长了，不适合放在方法内部，就应该使用成员类。如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的，否则就做成静态的。</p>\n<h3 id=\"优先使用模板-工具类\"><a href=\"#优先使用模板-工具类\" class=\"headerlink\" title=\"优先使用模板/工具类\"></a>优先使用模板/工具类</h3><p>通过对常见场景的代码逻辑进行抽象封装，形成相应的模板工具类，可以大大减少重复代码，专注于业务逻辑，提高代码质量。</p>\n<h3 id=\"分离对象的创建与使用\"><a href=\"#分离对象的创建与使用\" class=\"headerlink\" title=\"分离对象的创建与使用\"></a>分离对象的创建与使用</h3><p>面向对象编程相对于面向过程，多了实例化这一步，而对象的创建必须要指定具体类型。我们常见的做法是“哪里用到，就在哪里创建”，使用实例和创建实例的是同一段代码。这似乎使代码更具有可读性，但是某些情况下造成了不必要的耦合。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BusinessObject</span> <span class=\"token punctuation\">&#123;</span>\n <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> actionMethond <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token comment\">//Other things</span>\n     <span class=\"token class-name\">Service</span> myServiceObj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Service</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       myServiceObj<span class=\"token punctuation\">.</span><span class=\"token function\">doService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token comment\">//Other things</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BusinessObject</span> <span class=\"token punctuation\">&#123;</span>\n <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> actionMethond <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token comment\">//Other things</span>\n     <span class=\"token class-name\">Service</span> myServiceObj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ServiceImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       myServiceObj<span class=\"token punctuation\">.</span><span class=\"token function\">doService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token comment\">//Other things</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BusinessObject</span> <span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">private</span> <span class=\"token class-name\">Service</span> myServiceObj<span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">public</span> <span class=\"token class-name\">BusinessObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Service</span> aService<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       myServiceObj <span class=\"token operator\">=</span> aService<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> actionMethond <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token comment\">//Other things</span>\n       myServiceObj<span class=\"token punctuation\">.</span><span class=\"token function\">doService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token comment\">//Other things</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BusinessObject</span> <span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">private</span> <span class=\"token class-name\">Service</span> myServiceObj<span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">public</span> <span class=\"token class-name\">BusinessObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       myServiceObj <span class=\"token operator\">=</span> <span class=\"token class-name\">ServiceFactory</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> actionMethond <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token comment\">//Other things</span>\n       myServiceObj<span class=\"token punctuation\">.</span><span class=\"token function\">doService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token comment\">//Other things</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>对象的创建者耦合的是对象的具体类型，而对象的使用者耦合的是对象的接口。也就是说，创建者关心的是这个对象是什么，而使用者关心的是它能干什么。这两者应该视为独立的考量，它们往往会因为不同的原因而改变。</p>\n</blockquote>\n<p>当对象的类型涉及多态、对象创建复杂（依赖较多）可以考虑将对象的创建过程分离出来，使得使用者不用关注对象的创建细节。设计模式中创建型模式的出发点就是如此，实际项目中可以使用工厂模式、构建器、依赖注入的方式。</p>\n<h3 id=\"可访问性最小化\"><a href=\"#可访问性最小化\" class=\"headerlink\" title=\"可访问性最小化\"></a>可访问性最小化</h3><p>区分一个组件设计得好不好，一个很重要的因素在于，它对于外部组件而言，是否隐藏了其内部数据和实现细节。Java提供了访问控制机制来决定类、接口和成员的可访问性。实体的可访问性由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符（private、protected、public）共同决定的。</p>\n<p>对于顶层的（非嵌套的）类和接口，只有两种的访问级别：包级私有的（没有public修饰）和公有的（public修饰）。</p>\n<p>对于成员（实例/域、方法、嵌套类和嵌套接口）由四种的访问级别，可访问性如下递增：</p>\n<ul>\n<li> 私有的（private修饰）–只有在声明该成员的顶层类内部才可以访问这个成员；</li>\n<li> 包级私有的（默认）–声明该成员的包内部的任何类都可以访问这个成员；</li>\n<li> 受保护的（protected修饰）–声明该成员的类的子类可以访问这个成员，并且声明该成员的包内部的任何类也可以访问这个成员；</li>\n<li> 公有的（public修饰）–在任何地方都可以访问该成员；</li>\n</ul>\n<p>正确地使用这些修饰符对于实现信息隐藏是非常关键的，原则就是：尽可能地使每个类和成员不被外界访问（私有或包级私有）。这样好处就是在以后的发行版本中，可以对它进行修改、替换或者删除，而无须担心会影响现有的客户端程序。</p>\n<ul>\n<li> 如果类或接口能够做成包级私有的，它就应该被做成包级私有的；</li>\n<li> 如果一个包级私有的顶层类或接口只是在某一个类的内部被用到，就应该考虑使它成为那个类的私有嵌套类；</li>\n<li> 公有类不应直接暴露实例域，应该提供相应的方法以保留将来改变该类的内部表示法的灵活性；</li>\n<li> 当确定了类的公有API之后，应该把其他的成员都变成私有的；</li>\n<li> 如果同一个包下的类之间存在比较多的访问时，就要考虑重新设计以减少这种耦合；</li>\n</ul>\n<h3 id=\"可变性最小化\"><a href=\"#可变性最小化\" class=\"headerlink\" title=\"可变性最小化\"></a>可变性最小化</h3><p>不可变类是指其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例时提供，并在对象的整个生命周期内固定不变。不可变类好处就是简单易用、线程安全、可自由共享而不容易出错。Java平台类库中包含许多不可变的类，比如String、基本类型包装类、BigDecimal等。</p>\n<p>为了使类成为不可变，要遵循下面五条规则：</p>\n<ul>\n<li> 声明所有的域都是私有的</li>\n<li> 声明所有的域都是final的</li>\n<li> 如果一个指向新创建实例的引用在缺乏同步机制的情况下，从一个线程被传递到另一个线程，就必须确保正确的行为</li>\n<li> 不提供任何会修改对象状态的方法</li>\n<li> 保证类不会被扩展（防止子类化，类声明为final）</li>\n<li> 防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏该类的不可变行为</li>\n<li> 确保对任何可变组件的互斥访问</li>\n<li> 如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法中返回该对象引用。在构造器、访问方法和readObject 方法中使用保护性拷贝技术</li>\n</ul>\n<p>可变性最小化的一些建议：</p>\n<ul>\n<li> 除非有很好的理由要让类成为可变的类，否则它就应该是不可变的；</li>\n<li> 如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性；</li>\n<li> 除非有令人信服的理由要使域变成非final的，否则要使每个域都是private final的；</li>\n<li> 构造器应该创建完全初始化的对象，并建立起所有的约束关系；</li>\n</ul>\n<h1 id=\"质量如何保证\"><a href=\"#质量如何保证\" class=\"headerlink\" title=\"质量如何保证\"></a>质量如何保证</h1><h2 id=\"测试驱动开发\"><a href=\"#测试驱动开发\" class=\"headerlink\" title=\"测试驱动开发\"></a>测试驱动开发</h2><blockquote>\n<p>测试驱动开发（TDD）要求以测试作为开发过程的中心，要求在编写任何代码之前，首先编写用于产码行为的测试，而编写的代码又要以使测试通过为目标。TDD要求测试可以完全自动化地运行，并在对代码重构前后必须运行测试。</p>\n</blockquote>\n<p>TDD的最终目标是整洁可用的代码（clean code that works）。大多数的开发者大部分时间无法得到整洁可用的代码。办法是分而治之。首先解决目标中的“可用”问题，然后再解决“代码的整洁”问题。这与体系结构驱动（architecture-driven）的开发相反。</p>\n<p>采用TDD另一个好处就是让我们拥有一套伴随代码产生的详尽的自动化测试集。将来无论出于任何原因（需求、重构、性能改进）需要对代码进行维护时，在这套测试集的驱动下工作，我们代码将会一直是健壮的。</p>\n<h2 id=\"TDD的开发周期\"><a href=\"#TDD的开发周期\" class=\"headerlink\" title=\"TDD的开发周期\"></a>TDD的开发周期</h2><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_4605e609.png\" alt=\"image_4605e609.png\"> Image [6].png</p>\n<p>添加一个测试 -&gt; 运行所有测试并检查测试结果 -&gt; 编写代码以通过测试 -&gt; 运行所有测试且全部通过 -&gt; 重构代码，以消除重复设计，优化设计结构</p>\n<h2 id=\"两个基本的原则\"><a href=\"#两个基本的原则\" class=\"headerlink\" title=\"两个基本的原则\"></a>两个基本的原则</h2><ul>\n<li> 仅在测试失败时才编写代码并且只编写刚好使测试通过的代码</li>\n<li> 编写下一个测试之前消除现有的重复设计，优化设计结构</li>\n</ul>\n<p>关注点分离是这两条规则隐含的另一个非常重要的原则。其表达的含义指在编码阶段先达到代码“可用”的目标，在重构阶段再追求“整洁”目标，每次只关注一件事！</p>\n<h2 id=\"分层测试点\"><a href=\"#分层测试点\" class=\"headerlink\" title=\"分层测试点\"></a>分层测试点</h2><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_e59205e3.png\" alt=\"image_e59205e3.png\"></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li> 重构-改善既有代码的设计</li>\n<li> 设计模式</li>\n<li> Effective Java</li>\n<li> 敏捷软件开发与设计的最佳实践</li>\n<li> 实现模式</li>\n<li>测试驱动开发                 </li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<h1 id=\"关于重构\"><a href=\"#关于重构\" class=\"headerlink\" title=\"关于重构\"></a>关于重构</h1><h2 id=\"为什么要重构\"><a href=\"#为什么要重构\" class=\"headerlink\" title=\"为什么要重构\"></a>为什么要重构</h2><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_83d6de95-20221108095355418.png\" alt=\"image_83d6de95.png\"> 1_代码重构漫画.jpeg</p>\n<p>项目在不断演进过程中，代码不停地在堆砌。如果没有人为代码的质量负责，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。</p>\n<p>造成这样的原因往往有以下几点：</p>\n<ol>\n<li> 编码之前缺乏有效的设计</li>\n<li> 成本上的考虑，在原功能堆砌式编程</li>\n<li> 缺乏有效代码质量监督机制</li>\n</ol>\n<p>对于此类问题，业界已有有很好的解决思路：通过持续不断的重构将代码中的“坏味道”清除掉。</p>\n<h2 id=\"什么是重构\"><a href=\"#什么是重构\" class=\"headerlink\" title=\"什么是重构\"></a>什么是重构</h2><p>重构一书的作者Martin Fowler对重构的定义：</p>\n<blockquote>\n<p>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。<br>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</p>\n</blockquote>\n<p>根据重构的规模可以大致分为大型重构和小型重构：</p>\n<p>大型重构：对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入bug的风险也会相对比较大。</p>\n<p>小型重构：对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名和注释、消除超大类或函数、提取重复代码等等。小型重构更多的是使用统一的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入bug的风险相对来说也会比较小。什么时候重构 新功能开发、修bug或者代码review中出现“代码坏味道”，我们就应该及时进行重构。持续在日常开发中进行小重构，能够降低重构和测试的成本。</p>\n<h1 id=\"代码的坏味道\"><a href=\"#代码的坏味道\" class=\"headerlink\" title=\"代码的坏味道\"></a>代码的坏味道</h1><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_047389be-20221108095355455.png\" alt=\"image_047389be.png\"> 2_代码常见问题.png</p>\n<p>代码重复</p>\n<ul>\n<li> 实现逻辑相同、执行流程相同</li>\n</ul>\n<p>方法过长</p>\n<ul>\n<li> 方法中的语句不在同一个抽象层级</li>\n<li> 逻辑难以理解，需要大量的注释</li>\n<li> 面向过程编程而非面向对象</li>\n</ul>\n<p>过大的类</p>\n<ul>\n<li> 类做了太多的事情</li>\n<li> 包含过多的实例变量和方法</li>\n<li> 类的命名不足以描述所做的事情</li>\n</ul>\n<p>逻辑分散</p>\n<ul>\n<li> 发散式变化：某个类经常因为不同的原因在不同的方向上发生变化</li>\n<li> 散弹式修改：发生某种变化时，需要在多个类中做修改</li>\n</ul>\n<p>严重的情结依恋</p>\n<ul>\n<li> 某个类的方法过多的使用其他类的成员</li>\n</ul>\n<p>数据泥团/基本类型偏执</p>\n<ul>\n<li> 两个类、方法签名中包含相同的字段或参数</li>\n<li> 应该使用类但使用基本类型，比如表示数值与币种的Money类、起始值与结束值的Range类</li>\n</ul>\n<p>不合理的继承体系</p>\n<ul>\n<li> 继承打破了封装性，子类依赖其父类中特定功能的实现细节</li>\n<li> 子类必须跟着其父类的更新而演变，除非父类是专门为了扩展而设计，并且有很好的文档说明</li>\n</ul>\n<p>过多的条件判断</p>\n<p>过长的参数列</p>\n<p>临时变量过多</p>\n<p>令人迷惑的暂时字段</p>\n<ul>\n<li> 某个实例变量仅为某种特定情况而设置</li>\n<li> 将实例变量与相应的方法提取到新的类中</li>\n</ul>\n<p>纯数据类</p>\n<ul>\n<li> 仅包含字段和访问（读写）这些字段的方法</li>\n<li> 此类被称为数据容器，应保持最小可变性</li>\n</ul>\n<p>不恰当的命名</p>\n<ul>\n<li> 命名无法准确描述做的事情</li>\n<li> 命名不符合约定俗称的惯例</li>\n</ul>\n<p>过多的注释</p>\n<h2 id=\"坏代码的问题\"><a href=\"#坏代码的问题\" class=\"headerlink\" title=\"坏代码的问题\"></a>坏代码的问题</h2><ul>\n<li> 难以复用</li>\n<li> 系统关联性过多，导致很难分离可重用部分</li>\n<li> 难于变化</li>\n<li> 一处变化导致其他很多部分的修改，不利于系统稳定</li>\n<li> 难于理解</li>\n<li> 命名杂乱，结构混乱，难于阅读和理解</li>\n<li> 难以测试</li>\n<li> 分支、依赖较多，难以覆盖全面</li>\n</ul>\n<h2 id=\"什么是好代码\"><a href=\"#什么是好代码\" class=\"headerlink\" title=\"什么是好代码\"></a>什么是好代码</h2><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_d67b805c-20221108095355391.png\" alt=\"image_d67b805c.png\"> 3_代码质量如何衡量.jpg</p>\n<p>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁。这些词汇是从不同的维度去评价代码质量的。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</p>\n<p>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。</p>\n<h1 id=\"如何重构\"><a href=\"#如何重构\" class=\"headerlink\" title=\"如何重构\"></a>如何重构</h1><h2 id=\"SOLID原则\"><a href=\"#SOLID原则\" class=\"headerlink\" title=\"SOLID原则\"></a>SOLID原则</h2><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_f864e546-20221108095355479.png\" alt=\"image_f864e546.png\"> 4_SOLID原则.png</p>\n<h3 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h3><p>一个类只负责完成一个职责或者功能，不要存在多于一种导致类变更的原因。</p>\n<p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、松耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p>\n<h3 id=\"开放-关闭原则\"><a href=\"#开放-关闭原则\" class=\"headerlink\" title=\"开放-关闭原则\"></a>开放-关闭原则</h3><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。</p>\n<p>开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。</p>\n<p>很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是 23 种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p>\n<h3 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h3><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p>\n<p>子类可以扩展父类的功能，但不能改变父类原有的功能</p>\n<blockquote>\n<p>父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。</p>\n</blockquote>\n<h3 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h3><p>调用方不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>\n<h3 id=\"依赖反转原则\"><a href=\"#依赖反转原则\" class=\"headerlink\" title=\"依赖反转原则\"></a>依赖反转原则</h3><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p>\n<h3 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h3><p>一个对象应该对其他对象保持最少的了解</p>\n<h3 id=\"合成复用原则\"><a href=\"#合成复用原则\" class=\"headerlink\" title=\"合成复用原则\"></a>合成复用原则</h3><p>尽量使用合成/聚合的方式，而不是使用继承。</p>\n<p>单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，告诉我们要对扩展开放，对修改关闭。</p>\n<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><blockquote>\n<p>设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案。</p>\n</blockquote>\n<ul>\n<li> 创建型：主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码</li>\n<li> 结构型：主要通过类或对象的不同组合，解耦不同功能的耦合</li>\n<li> 行为型：主要解决的是类或对象之间的交互行为的耦合</li>\n</ul>\n<p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_9db0426b-20221108095355436.png\" alt=\"image_9db0426b.png\"><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_41c09a5c.png\" alt=\"image_41c09a5c.png\"><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_2c6e506b.png\" alt=\"image_2c6e506b.png\"><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_8fa858cb.png\" alt=\"image_8fa858cb.png\"></p>\n<h2 id=\"代码分层\"><a href=\"#代码分层\" class=\"headerlink\" title=\"代码分层\"></a>代码分层</h2><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_598a46ba.png\" alt=\"image_598a46ba.png\"> image.png</p>\n<p>模块结构说明</p>\n<ul>\n<li> server_main：配置层，负责整个项目的module管理，maven配置管理、资源管理等；</li>\n<li> server_application：应用接入层，承接外部流量入口，例如：RPC接口实现、消息处理、定时任务等；不要在此包含业务逻辑；</li>\n<li> server_biz：核心业务层，用例服务、领域实体、领域事件等</li>\n<li> server_irepository：资源接口层，负责资源接口的暴露</li>\n<li> server_repository：资源层，负责资源的proxy访问，统一外部资源访问，隔离变化。注意：这里强调的是弱业务性，强数据性；</li>\n<li> server_common：公共层，vo、工具等</li>\n</ul>\n<p>代码开发要遵守各层的规范，并注意层级之间的依赖关系。</p>\n<h2 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h2><blockquote>\n<p>一个好的命名应该要满足以下两个约束：</p>\n<ul>\n<li> 准确描述所做得事情</li>\n<li> 格式符合通用的惯例</li>\n</ul>\n<p>如果你觉得一个类或方法难以命名的时候，可能是其承载的功能太多了，需要进一步拆分。</p>\n</blockquote>\n<h3 id=\"约定俗称的惯例\"><a href=\"#约定俗称的惯例\" class=\"headerlink\" title=\"约定俗称的惯例\"></a>约定俗称的惯例</h3><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_ff852d0e.png\" alt=\"image_ff852d0e.png\"></p>\n<h3 id=\"类命名\"><a href=\"#类命名\" class=\"headerlink\" title=\"类命名\"></a>类命名</h3><blockquote>\n<p>类名使用大驼峰命名形式，类命通常使用名词或名词短语。接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如 Cloneable，Callable 等，表示实现该接口的类有某种功能或能力。</p>\n</blockquote>\n<p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_83a6a12c.png\" alt=\"image_83a6a12c.png\"></p>\n<h3 id=\"方法命名\"><a href=\"#方法命名\" class=\"headerlink\" title=\"方法命名\"></a>方法命名</h3><blockquote>\n<p>方法命名采用小驼峰的形式，首字小写，往后的每个单词首字母都要大写。和类名不同的是，方法命名一般为动词或动词短语，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。</p>\n</blockquote>\n<p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_450be2e5.png\" alt=\"image_450be2e5.png\"></p>\n<h2 id=\"重构技巧\"><a href=\"#重构技巧\" class=\"headerlink\" title=\"重构技巧\"></a>重构技巧</h2><h3 id=\"提炼方法\"><a href=\"#提炼方法\" class=\"headerlink\" title=\"提炼方法\"></a>提炼方法</h3><p>多个方法代码重复、方法中代码过长或者方法中的语句不在一个抽象层级。<br>方法是代码复用的最小粒度，方法过长不利于复用，可读性低，提炼方法往往是重构工作的第一步。</p>\n<p>意图导向编程：把处理某件事的流程和具体做事的实现方式分开。</p>\n<ul>\n<li> 把一个问题分解为一系列功能性步骤，并假定这些功能步骤已经实现</li>\n<li> 我们只需把把各个函数组织在一起即可解决这一问题</li>\n<li> 在组织好整个功能后，我们在分别实现各个方法函数</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">/** \n  * 1、交易信息开始于一串标准ASCII字符串。 \n  * 2、这个信息字符串必须转换成一个字符串的数组，数组存放的此次交易的领域语言中所包含的词汇元素（token)。 \n  * 3、每一个词汇必须标准化。 \n  * 4、包含超过150个词汇元素的交易，应该采用不同于小型交易的方式（不同的算法）来提交，以提高效率。 \n  * 5、如果提交成功，API返回”true”；失败，则返回”false”。 \n  */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Transaction</span> <span class=\"token punctuation\">&#123;</span>    \n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">Boolean</span> <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> command<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>        \n    <span class=\"token class-name\">Boolean</span> result <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tokens <span class=\"token operator\">=</span> <span class=\"token function\">tokenize</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token function\">normalizeTokens</span><span class=\"token punctuation\">(</span>tokens<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isALargeTransaction</span><span class=\"token punctuation\">(</span>tokens<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>            \n      result <span class=\"token operator\">=</span> <span class=\"token function\">processLargeTransaction</span><span class=\"token punctuation\">(</span>tokens<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>            \n      result <span class=\"token operator\">=</span> <span class=\"token function\">processSmallTransaction</span><span class=\"token punctuation\">(</span>tokens<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token punctuation\">&#125;</span>        \n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>    \n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"以函数对象取代函数\"><a href=\"#以函数对象取代函数\" class=\"headerlink\" title=\"以函数对象取代函数\"></a>以函数对象取代函数</h3><p>将函数放进一个单独对象中，如此一来局部变量就变成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。</p>\n<h3 id=\"引入参数对象\"><a href=\"#引入参数对象\" class=\"headerlink\" title=\"引入参数对象\"></a>引入参数对象</h3><p>方法参数比较多时，将参数封装为参数对象</p>\n<h3 id=\"移除对参数的赋值\"><a href=\"#移除对参数的赋值\" class=\"headerlink\" title=\"移除对参数的赋值\"></a>移除对参数的赋值</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">discount</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> inputVal<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> quantity<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> yearToDate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>inputVal <span class=\"token operator\">></span> <span class=\"token number\">50</span><span class=\"token punctuation\">)</span> inputVal <span class=\"token operator\">-=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>quantity <span class=\"token operator\">></span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span> inputVal <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>yearToDate <span class=\"token operator\">></span> <span class=\"token number\">10000</span><span class=\"token punctuation\">)</span> inputVal <span class=\"token operator\">-=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> inputVal<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">discount</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> inputVal<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> quantity<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> yearToDate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> \n  <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> inputVal<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>inputVal <span class=\"token operator\">></span> <span class=\"token number\">50</span><span class=\"token punctuation\">)</span> result <span class=\"token operator\">-=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>quantity <span class=\"token operator\">></span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span> result <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>yearToDate <span class=\"token operator\">></span> <span class=\"token number\">10000</span><span class=\"token punctuation\">)</span> result <span class=\"token operator\">-=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"将查询与修改分离\"><a href=\"#将查询与修改分离\" class=\"headerlink\" title=\"将查询与修改分离\"></a>将查询与修改分离</h3><p>任何有返回值的方法，都不应该有副作用</p>\n<ul>\n<li> 不要在convert中调用写操作，避免副作用</li>\n<li> 常见的例外：将查询结果缓存到本地</li>\n</ul>\n<h3 id=\"移除不必要临时变量\"><a href=\"#移除不必要临时变量\" class=\"headerlink\" title=\"移除不必要临时变量\"></a>移除不必要临时变量</h3><p>临时变量仅使用一次或者取值逻辑成本很低的情况下</p>\n<h3 id=\"引入解释性变量\"><a href=\"#引入解释性变量\" class=\"headerlink\" title=\"引入解释性变量\"></a>引入解释性变量</h3><p>将复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>platform<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MAC\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> \n    <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>browser<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"IE\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">wasInitialized</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> resize <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   \n  <span class=\"token comment\">// do something </span>\n<span class=\"token punctuation\">&#125;</span> \n  \n<span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> isMacOs <span class=\"token operator\">=</span> platform<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"MAC\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> isIEBrowser <span class=\"token operator\">=</span> browser<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"IE\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> wasResized <span class=\"token operator\">=</span> resize <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isMacOs <span class=\"token operator\">&amp;&amp;</span> isIEBrowser <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">wasInitialized</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> wasResized<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   \n  <span class=\"token comment\">// do something </span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"使用卫语句替代嵌套条件判断\"><a href=\"#使用卫语句替代嵌套条件判断\" class=\"headerlink\" title=\"使用卫语句替代嵌套条件判断\"></a>使用卫语句替代嵌套条件判断</h3><p>把复杂的条件表达式拆分成多个条件表达式，减少嵌套。嵌套了好几层的if - then-else语句，转换为多个if语句</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//未使用卫语句</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">getHello</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token function\">setHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span> \n\n<span class=\"token comment\">//使用卫语句</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">getHello</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">setHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"使用多态替代条件判断断\"><a href=\"#使用多态替代条件判断断\" class=\"headerlink\" title=\"使用多态替代条件判断断\"></a>使用多态替代条件判断断</h3><p>当存在这样一类条件表达式，它根据对象类型的不同选择不同的行为。可以将这种表达式的每个分支放进一个子类内的复写函数中，然后将原始函数声明为抽象函数。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">calculate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> operator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span>MIN_VALUE<span class=\"token punctuation\">;</span>\n \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"add\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        result <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"multiply\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        result <span class=\"token operator\">=</span> a <span class=\"token operator\">*</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"divide\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        result <span class=\"token operator\">=</span> a <span class=\"token operator\">/</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"subtract\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        result <span class=\"token operator\">=</span> a <span class=\"token operator\">-</span> b<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当出现大量类型检查和判断时，if else（或switch）语句的体积会比较臃肿，这无疑降低了代码的可读性。 另外，if else（或switch）本身就是一个“变化点”，当需要扩展新的类型时，我们不得不追加if else（或switch）语句块，以及相应的逻辑，这无疑降低了程序的可扩展性，也违反了面向对象的开闭原则。</p>\n<blockquote>\n<p>基于这种场景，我们可以考虑使用“多态”来代替冗长的条件判断，将if else（或switch）中的“变化点”封装到子类中。这样，就不需要使用if else（或switch）语句了，取而代之的是子类多态的实例，从而使得提高代码的可读性和可扩展性。很多设计模式使用都是这种套路，比如策略模式、状态模式。</p>\n</blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Operation</span> <span class=\"token punctuation\">&#123;</span> \n  <span class=\"token keyword\">int</span> <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Addition</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Operation</span> <span class=\"token punctuation\">&#123;</span> \n  <span class=\"token annotation punctuation\">@Override</span> \n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> \n    <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span> \n  <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OperatorFactory</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Operation</span><span class=\"token punctuation\">></span></span> operationMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span>\n        operationMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"add\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Addition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        operationMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"divide\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Division</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// more operators</span>\n    <span class=\"token punctuation\">&#125;</span>\n \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Operation</span> <span class=\"token function\">getOperation</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> operator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> operationMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">calculate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> operator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">OperatorFactory</span> <span class=\"token punctuation\">.</span>getOperation <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Invalid Operator\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">OperatorFactory</span> <span class=\"token punctuation\">.</span><span class=\"token function\">getOperation</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"使用异常替代返回错误码\"><a href=\"#使用异常替代返回错误码\" class=\"headerlink\" title=\"使用异常替代返回错误码\"></a>使用异常替代返回错误码</h3><p>非正常业务状态的处理，使用抛出异常的方式代替返回错误码</p>\n<ul>\n<li> 不要使用异常处理用于正常的业务流程控制</li>\n<li> 异常处理的性能成本非常高</li>\n<li> 尽量使用标准异常</li>\n<li> 避免在finally语句块中抛出异常</li>\n<li>如果同时抛出两个异常，则第一个异常的调用栈会丢失 finally块中应只做关闭资源这类的事情</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//使用错误码</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> amount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>balance <span class=\"token operator\">&lt;</span> amount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n        balance <span class=\"token operator\">-=</span> amount<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//使用异常</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> amount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>amount <span class=\"token operator\">></span> balance<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"amount too large\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n    <span class=\"token punctuation\">&#125;</span>\n    balance <span class=\"token operator\">-=</span> amount<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"引入断言\"><a href=\"#引入断言\" class=\"headerlink\" title=\"引入断言\"></a>引入断言</h3><p>某一段代码需要对程序状态做出某种假设，以断言明确表现这种假设。</p>\n<ul>\n<li> 不要滥用断言，不要使用它来检查“应该为真”的条件，只使用它来检查“一定必须为真”的条件</li>\n<li> 如果断言所指示的约束条件不能满足，代码是否仍能正常运行？如果可以就去掉断言</li>\n</ul>\n<h3 id=\"引入Null对象或特殊对象\"><a href=\"#引入Null对象或特殊对象\" class=\"headerlink\" title=\"引入Null对象或特殊对象\"></a>引入Null对象或特殊对象</h3><p>当使用一个方法返回的对象时，而这个对象可能为空，这个时候需要对这个对象进行操作前，需要进行判空，否则就会报空指针。当这种判断频繁的出现在各处代码之中，就会影响代码的美观程度和可读性，甚至增加Bug的几率。</p>\n<p>空引用的问题在Java中无法避免，但可以通过代码编程技巧（引入空对象）来改善这一问题。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//空对象的例子</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OperatorFactory</span> <span class=\"token punctuation\">&#123;</span> \n  <span class=\"token keyword\">static</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Operation</span><span class=\"token punctuation\">></span></span> operationMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">static</span> <span class=\"token punctuation\">&#123;</span> \n    operationMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"add\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Addition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    operationMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"divide\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Division</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token comment\">// more operators </span>\n  <span class=\"token punctuation\">&#125;</span> \n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Optional</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Operation</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">getOperation</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> operator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> \n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">Optional</span><span class=\"token punctuation\">.</span><span class=\"token function\">ofNullable</span><span class=\"token punctuation\">(</span>operationMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">calculate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> operator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> \n  <span class=\"token class-name\">Operation</span> targetOperation <span class=\"token operator\">=</span> <span class=\"token class-name\">OperatorFactory</span><span class=\"token punctuation\">.</span><span class=\"token function\">getOperation</span><span class=\"token punctuation\">(</span>operator<span class=\"token punctuation\">)</span> \n     <span class=\"token punctuation\">.</span><span class=\"token function\">orElseThrow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Invalid Operator\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">return</span> targetOperation<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//特殊对象的例子</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InvalidOp</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Operation</span> <span class=\"token punctuation\">&#123;</span> \n  <span class=\"token annotation punctuation\">@Override</span> \n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">&#123;</span> \n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Invalid Operator\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"提炼类\"><a href=\"#提炼类\" class=\"headerlink\" title=\"提炼类\"></a>提炼类</h3><p>根据单一职责原则，一个类应该有明确的责任边界。但在实际工作中，类会不断的扩展。当给某个类添加一项新责任时，你会觉得不值得分离出一个单独的类。于是，随着责任不断增加，这个类包含了大量的数据和函数，逻辑复杂不易理解。</p>\n<p>此时你需要考虑将哪些部分分离到一个单独的类中，可以依据高内聚低耦合的原则。如果某些数据和方法总是一起出现，或者某些数据经常同时变化，这就表明它们应该放到一个类中。另一种信号是类的子类化方式：如果你发现子类化只影响类的部分特性，或者类的特性需要以不同方式来子类化，这就意味着你需要分解原来的类。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//原始类</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> officeAreaCode<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> officeNumber<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getTelephoneNumber</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"(\"</span> <span class=\"token operator\">+</span> officeAreaCode <span class=\"token operator\">+</span> <span class=\"token string\">\")\"</span> <span class=\"token operator\">+</span> officeNumber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getOfficeAreaCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> officeAreaCode<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setOfficeAreaCode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        officeAreaCode <span class=\"token operator\">=</span> arg<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getOfficeNumber</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> officeNumber<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setOfficeNumber</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        officeNumber <span class=\"token operator\">=</span> arg<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//新提炼的类（以对象替换数据值）</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TelephoneNumber</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> areaCode<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> number<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getTelephnoeNumber</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"(\"</span> <span class=\"token operator\">+</span> <span class=\"token function\">getAreaCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\")\"</span> <span class=\"token operator\">+</span> number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token class-name\">String</span> <span class=\"token function\">getAreaCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> areaCode<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">setAreaCode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        areaCode <span class=\"token operator\">=</span> arg<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token class-name\">String</span> <span class=\"token function\">getNumber</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> number<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">setNumber</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        number <span class=\"token operator\">=</span> arg<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"组合优先于继承\"><a href=\"#组合优先于继承\" class=\"headerlink\" title=\"组合优先于继承\"></a>组合优先于继承</h3><p>继承使实现代码重用的有力手段，但这并非总是完成这项工作的最佳工具，使用不当会导致软件变得很脆弱。与方法调用不同的是，继承打破了封装性。子类依赖于其父类中特定功能的实现细节，如果父类的实现随着发行版本的不同而变化，子类可能会遭到破坏，即使他的代码完全没有改变。</p>\n<p>举例说明，假设有一个程序使用HashSet，为了调优该程序的性能，需要统计HashSet自从它创建以来添加了多少个元素。为了提供该功能，我们编写一个HashSet的变体。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// Inappropriate use of inheritance!</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InstrumentedHashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">HashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// The number of attempted element insertions</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> addCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">InstrumentedHashSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">InstrumentedHashSet</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> initCap<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> loadFactor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>initCap<span class=\"token punctuation\">,</span> loadFactor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        addCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        addCount <span class=\"token operator\">+=</span> c<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAddCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> addCount<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>通过在新的类中增加一个私有域，它引用现有类的一个实例，这种设计被称为组合，因为现有的类变成了新类的一个组件。这样得到的类将会非常稳固，它不依赖现有类的实现细节。即使现有的类添加了新的方法，也不会影响新的类。许多设计模式使用就是这种套路，比如代理模式、装饰者模式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// Reusable forwarding class</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ForwardingSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> s<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ForwardingSet</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>s <span class=\"token operator\">=</span> s<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n  \n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Iterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">containsAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">containsAll</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">retainAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">retainAll</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">removeAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">removeAll</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// Wrappter class - uses composition in place of inheritance</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InstrumentedHashSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ForwardingSet</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> addCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">InstrumentedHashSet1</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Set</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        addCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">E</span><span class=\"token punctuation\">></span></span> c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        addCount <span class=\"token operator\">+=</span> c<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAddCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> addCount<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>继承与组合如何取舍</p>\n<ul>\n<li> 只有当子类真正是父类的子类型时，才适合继承。对于两个类A和B，只有两者之间确实存在“is-a”关系的时候，类B才应该继承A；</li>\n<li> 在包的内部使用继承是非常安全的，子类和父类的实现都处在同一个程序员的控制之下；</li>\n<li> 对于专门为了继承而设计并且具有很好的文档说明的类来说，使用继承也是非常安全的；</li>\n<li> 其他情况就应该优先考虑组合的方式来实现</li>\n</ul>\n<h3 id=\"接口优于抽象类\"><a href=\"#接口优于抽象类\" class=\"headerlink\" title=\"接口优于抽象类\"></a>接口优于抽象类</h3><p>Java提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象类。自从Java8为接口增加缺省方法（default method），这两种机制都允许为实例方法提供实现。主要区别在于，为了实现由抽象类定义的类型，类必须称为抽象类的一个子类。因为Java只允许单继承，所以用抽象类作为类型定义受到了限制。</p>\n<p>接口相比于抽象类的优势：</p>\n<ul>\n<li> 现有的类可以很容易被更新，以实现新的接口。</li>\n<li> 接口是定义混合类型（比如Comparable）的理想选择。</li>\n<li> 接口允许构造非层次结构的类型框架。</li>\n</ul>\n<p>接口虽然提供了缺省方法，但接口仍有有以下局限性：</p>\n<ul>\n<li> 接口的变量修饰符只能是public static final的</li>\n<li> 接口的方法修饰符只能是public的</li>\n<li> 接口不存在构造函数，也不存在this</li>\n<li> 可以给现有接口增加缺省方法，但不能确保这些方法在之前存在的实现中都能良好运行。</li>\n<li> 因为这些默认方法是被注入到现有实现中的，它们的实现者并不知道，也没有许可</li>\n</ul>\n<p>接口缺省方法的设计目的和优势在于：</p>\n<p>为了接口的演化</p>\n<ul>\n<li> Java 8 之前我们知道，一个接口的所有方法其子类必须实现（当然，这个子类不是一个抽象类），但是 java 8 之后接口的默认方法可以选择不实现，如上的操作是可以通过编译期编译的。这样就避免了由 Java 7 升级到 Java 8 时项目编译报错了。Java8在核心集合接口中增加了许多新的缺省方法，主要是为了便于使用lambda。</li>\n</ul>\n<p>可以减少第三方工具类的创建</p>\n<ul>\n<li> 例如在 List 等集合接口中都有一些默认方法，List 接口中默认提供 replaceAll(UnaryOperator)、sort(Comparator)、、spliterator()等默认方法，这些方法在接口内部创建，避免了为了这些方法而专门去创建相应的工具类。</li>\n</ul>\n<p>可以避免创建基类</p>\n<ul>\n<li> 在 Java 8 之前我们可能需要创建一个基类来实现代码复用，而默认方法的出现，可以不必要去创建基类。</li>\n</ul>\n<p>由于接口的局限性和设计目的的不同，接口并不能完全替换抽象类。但是通过对接口提供一个抽象的骨架实现类，可以把接口和抽象类的优点结合起来。 接口负责定义类型，或许还提供一些缺省方法，而骨架实现类则负责实现除基本类型接口方法之外，剩下的非基本类型接口方法。扩展骨架实现占了实现接口之外的大部分工作。这就是模板方法（Template Method）设计模式。</p>\n<p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_24ceb509.png\" alt=\"image_24ceb509.png\"> Image [5].png</p>\n<p>接口Protocol：定义了RPC协议层两个主要的方法，export暴露服务和refer引用服务</p>\n<p>抽象类AbstractProtocol：封装了暴露服务之后的Exporter和引用服务之后的Invoker实例，并实现了服务销毁的逻辑</p>\n<p>具体实现类XxxProtocol：实现export暴露服务和refer引用服务具体逻辑</p>\n<h3 id=\"优先考虑泛型\"><a href=\"#优先考虑泛型\" class=\"headerlink\" title=\"优先考虑泛型\"></a>优先考虑泛型</h3><p>声明中具有一个或者多个类型参数（type parameter）的类或者接口，就是泛型（generic）类或者接口。泛型类和接口统称为泛型（generic type）。泛型从Java 5引入，提供了编译时类型安全检测机制。泛型的本质是参数化类型，通过一个参数来表示所操作的数据类型，并且可以限制这个参数的类型范围。泛型的好处就是编译期类型检测，避免类型转换。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 比较三个值并返回最大值</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Comparable</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">maximum</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span> x<span class=\"token punctuation\">,</span> <span class=\"token class-name\">T</span> y<span class=\"token punctuation\">,</span> <span class=\"token class-name\">T</span> z<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   \n  <span class=\"token class-name\">T</span> max <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span> \n  <span class=\"token comment\">// 假设x是初始最大值   </span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> y<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span> max <span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>      \n    max <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span> <span class=\"token comment\">//y 更大  </span>\n  <span class=\"token punctuation\">&#125;</span>   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> z<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span> max <span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>     \n    max <span class=\"token operator\">=</span> z<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 现在 z 更大              </span>\n  <span class=\"token punctuation\">&#125;</span>   <span class=\"token keyword\">return</span> max<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 返回最大对象</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span> <span class=\"token class-name\">String</span> args<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   \n  <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"%d, %d 和 %d 中最大的数为 %d\\n\\n\"</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token function\">maximum</span><span class=\"token punctuation\">(</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   \n  <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"%.1f, %.1f 和 %.1f 中最大的数为 %.1f\\n\\n\"</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">6.6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8.8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7.7</span><span class=\"token punctuation\">,</span>  <span class=\"token function\">maximum</span><span class=\"token punctuation\">(</span> <span class=\"token number\">6.6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8.8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7.7</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   \n  <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"%s, %s 和 %s 中最大的数为 %s\\n\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"pear\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"orange\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">maximum</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"pear\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"orange\"</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"不要使用原生态类型\"><a href=\"#不要使用原生态类型\" class=\"headerlink\" title=\"不要使用原生态类型\"></a>不要使用原生态类型</h4><p>由于为了保持Java代码的兼容性，支持和原生态类型转换，并使用擦除机制实现的泛型。但是使用原生态类型就会失去泛型的优势，会受到编译器警告。</p>\n<h4 id=\"要尽可能地消除每一个非受检警告\"><a href=\"#要尽可能地消除每一个非受检警告\" class=\"headerlink\" title=\"要尽可能地消除每一个非受检警告\"></a>要尽可能地消除每一个非受检警告</h4><p>每一条警告都表示可能在运行时抛出ClassCastException异常。要尽最大的努力去消除这些警告。如果无法消除但是可以证明引起警告的代码是安全的，就可以在尽可能小的范围中，使用＠SuppressWarnings(“unchecked”)注解来禁止警告，但是要把禁止的原因记录下来。</p>\n<h4 id=\"利用有限制通配符来提升API的灵活性\"><a href=\"#利用有限制通配符来提升API的灵活性\" class=\"headerlink\" title=\"利用有限制通配符来提升API的灵活性\"></a>利用有限制通配符来提升API的灵活性</h4><p>参数化类型不支持协变的，即对于任何两个不同的类型Type1和Type2而言，List既不是List的子类型，也不是它的超类。为了解决这个问题，提高灵活性，Java提供了一种特殊的参数化类型，称作有限制的通配符类型，即List&lt;? extends E&gt;和List&lt;? super E&gt;。使用原则是producer-extends，consumer-super（PECS）。如果即是生产者，又是消费者，就没有必要使用通配符了。</p>\n<p>还有一种特殊的无限制通配符List&lt;?&gt;，表示某种类型但不确定。常用作泛型的引用，不可向其添加除Null以外的任何对象。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">//List&lt;? extends E></span>\n<span class=\"token comment\">// Number 可以认为 是Number 的 \"子类\"</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Number</span><span class=\"token punctuation\">></span></span> numberArray <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Number</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\">// Integer 是 Number 的子类</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Number</span><span class=\"token punctuation\">></span></span> numberArray <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\">// Double 是 Number 的子类</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Number</span><span class=\"token punctuation\">></span></span> numberArray <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Double</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n\n<span class=\"token comment\">//List&lt;? super E></span>\n<span class=\"token comment\">// Integer 可以认为是 Integer 的 \"父类\"</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> array <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>、\n<span class=\"token comment\">// Number 是 Integer 的 父类</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> array <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Number</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Object 是 Integer 的 父类</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> array <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">void</span> <span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> dest<span class=\"token punctuation\">,</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> src<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>    \n  <span class=\"token keyword\">int</span> srcSize <span class=\"token operator\">=</span> src<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>srcSize <span class=\"token operator\">></span> dest<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>        \n   <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IndexOutOfBoundsException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Source does not fit in dest\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>srcSize <span class=\"token operator\">&lt;</span> COPY_THRESHOLD <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>src <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">RandomAccess</span> <span class=\"token operator\">&amp;&amp;</span> dest <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">RandomAccess</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>        \n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>srcSize<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>            \n    dest<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> src<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n  <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>        \n    <span class=\"token class-name\">ListIterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> di<span class=\"token operator\">=</span>dest<span class=\"token punctuation\">.</span><span class=\"token function\">listIterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token class-name\">ListIterator</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> si<span class=\"token operator\">=</span>src<span class=\"token punctuation\">.</span><span class=\"token function\">listIterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>srcSize<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>            \n      di<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>            \n      di<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>si<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        \n    <span class=\"token punctuation\">&#125;</span>    \n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"静态成员类优于非静态成员类\"><a href=\"#静态成员类优于非静态成员类\" class=\"headerlink\" title=\"静态成员类优于非静态成员类\"></a>静态成员类优于非静态成员类</h3><p>嵌套类（nested class）是指定义在另一个类的内部的类。嵌套类存在的目的只是为了它的外部类提供服务，如果其他的环境也会用到的话，应该成为一个顶层类（top-level class）。 嵌套类有四种：静态成员类（static member class）、非静态成员类（nonstatic member class）、匿名类（anonymous class）和 局部类（local class）。除了第一种之外，其他三种都称为内部类（inner class）。</p>\n<h4 id=\"匿名类（anonymous-class）\"><a href=\"#匿名类（anonymous-class）\" class=\"headerlink\" title=\"匿名类（anonymous class）\"></a>匿名类（anonymous class）</h4><p>没有名字，声明的同时进行实例化，只能使用一次。当出现在非静态的环境中，会持有外部类实例的引用。通常用于创建函数对象和过程对象，不过现在会优先考虑lambda。</p>\n<h4 id=\"局部类（local-class）\"><a href=\"#局部类（local-class）\" class=\"headerlink\" title=\"局部类（local class）\"></a>局部类（local class）</h4><p>任何可以声明局部变量的地方都可以声明局部类，同时遵循同样的作用域规则。跟匿名类不同的是，有名字可以重复使用。不过实际很少使用局部类。</p>\n<h4 id=\"静态成员类（static-member-class）\"><a href=\"#静态成员类（static-member-class）\" class=\"headerlink\" title=\"静态成员类（static member class）\"></a>静态成员类（static member class）</h4><p>最简单的一种嵌套类，声明在另一个类的内部，是这个类的静态成员，遵循同样的可访问性规则。常见的用法是作为公有的辅助类，只有与它的外部类一起使用才有意义。</p>\n<h4 id=\"非静态成员类（nonstatic-member-class）\"><a href=\"#非静态成员类（nonstatic-member-class）\" class=\"headerlink\" title=\"非静态成员类（nonstatic member class）\"></a>非静态成员类（nonstatic member class）</h4><p>尽管语法上，跟静态成员类的唯一区别就是类的声明不包含static，但两者有很大的不同。非静态成员类的每个实例都隐含地与外部类的实例相关联，可以访问外部类的成员属性和方法。另外必须先创建外部类的实例之后才能创建非静态成员类的实例。</p>\n<p>总而言之，这四种嵌套类都有自己的用途。假设这个嵌套类属于一个方法的内部，如果只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就要把它做成匿名类。如果一个嵌套类需要在单个方法之外仍然可见，或者它太长了，不适合放在方法内部，就应该使用成员类。如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的，否则就做成静态的。</p>\n<h3 id=\"优先使用模板-工具类\"><a href=\"#优先使用模板-工具类\" class=\"headerlink\" title=\"优先使用模板/工具类\"></a>优先使用模板/工具类</h3><p>通过对常见场景的代码逻辑进行抽象封装，形成相应的模板工具类，可以大大减少重复代码，专注于业务逻辑，提高代码质量。</p>\n<h3 id=\"分离对象的创建与使用\"><a href=\"#分离对象的创建与使用\" class=\"headerlink\" title=\"分离对象的创建与使用\"></a>分离对象的创建与使用</h3><p>面向对象编程相对于面向过程，多了实例化这一步，而对象的创建必须要指定具体类型。我们常见的做法是“哪里用到，就在哪里创建”，使用实例和创建实例的是同一段代码。这似乎使代码更具有可读性，但是某些情况下造成了不必要的耦合。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BusinessObject</span> <span class=\"token punctuation\">&#123;</span>\n <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> actionMethond <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token comment\">//Other things</span>\n     <span class=\"token class-name\">Service</span> myServiceObj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Service</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       myServiceObj<span class=\"token punctuation\">.</span><span class=\"token function\">doService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token comment\">//Other things</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BusinessObject</span> <span class=\"token punctuation\">&#123;</span>\n <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> actionMethond <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token comment\">//Other things</span>\n     <span class=\"token class-name\">Service</span> myServiceObj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ServiceImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       myServiceObj<span class=\"token punctuation\">.</span><span class=\"token function\">doService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token comment\">//Other things</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BusinessObject</span> <span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">private</span> <span class=\"token class-name\">Service</span> myServiceObj<span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">public</span> <span class=\"token class-name\">BusinessObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Service</span> aService<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       myServiceObj <span class=\"token operator\">=</span> aService<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> actionMethond <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token comment\">//Other things</span>\n       myServiceObj<span class=\"token punctuation\">.</span><span class=\"token function\">doService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token comment\">//Other things</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BusinessObject</span> <span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">private</span> <span class=\"token class-name\">Service</span> myServiceObj<span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">public</span> <span class=\"token class-name\">BusinessObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       myServiceObj <span class=\"token operator\">=</span> <span class=\"token class-name\">ServiceFactory</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> actionMethond <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token comment\">//Other things</span>\n       myServiceObj<span class=\"token punctuation\">.</span><span class=\"token function\">doService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token comment\">//Other things</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>对象的创建者耦合的是对象的具体类型，而对象的使用者耦合的是对象的接口。也就是说，创建者关心的是这个对象是什么，而使用者关心的是它能干什么。这两者应该视为独立的考量，它们往往会因为不同的原因而改变。</p>\n</blockquote>\n<p>当对象的类型涉及多态、对象创建复杂（依赖较多）可以考虑将对象的创建过程分离出来，使得使用者不用关注对象的创建细节。设计模式中创建型模式的出发点就是如此，实际项目中可以使用工厂模式、构建器、依赖注入的方式。</p>\n<h3 id=\"可访问性最小化\"><a href=\"#可访问性最小化\" class=\"headerlink\" title=\"可访问性最小化\"></a>可访问性最小化</h3><p>区分一个组件设计得好不好，一个很重要的因素在于，它对于外部组件而言，是否隐藏了其内部数据和实现细节。Java提供了访问控制机制来决定类、接口和成员的可访问性。实体的可访问性由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符（private、protected、public）共同决定的。</p>\n<p>对于顶层的（非嵌套的）类和接口，只有两种的访问级别：包级私有的（没有public修饰）和公有的（public修饰）。</p>\n<p>对于成员（实例/域、方法、嵌套类和嵌套接口）由四种的访问级别，可访问性如下递增：</p>\n<ul>\n<li> 私有的（private修饰）–只有在声明该成员的顶层类内部才可以访问这个成员；</li>\n<li> 包级私有的（默认）–声明该成员的包内部的任何类都可以访问这个成员；</li>\n<li> 受保护的（protected修饰）–声明该成员的类的子类可以访问这个成员，并且声明该成员的包内部的任何类也可以访问这个成员；</li>\n<li> 公有的（public修饰）–在任何地方都可以访问该成员；</li>\n</ul>\n<p>正确地使用这些修饰符对于实现信息隐藏是非常关键的，原则就是：尽可能地使每个类和成员不被外界访问（私有或包级私有）。这样好处就是在以后的发行版本中，可以对它进行修改、替换或者删除，而无须担心会影响现有的客户端程序。</p>\n<ul>\n<li> 如果类或接口能够做成包级私有的，它就应该被做成包级私有的；</li>\n<li> 如果一个包级私有的顶层类或接口只是在某一个类的内部被用到，就应该考虑使它成为那个类的私有嵌套类；</li>\n<li> 公有类不应直接暴露实例域，应该提供相应的方法以保留将来改变该类的内部表示法的灵活性；</li>\n<li> 当确定了类的公有API之后，应该把其他的成员都变成私有的；</li>\n<li> 如果同一个包下的类之间存在比较多的访问时，就要考虑重新设计以减少这种耦合；</li>\n</ul>\n<h3 id=\"可变性最小化\"><a href=\"#可变性最小化\" class=\"headerlink\" title=\"可变性最小化\"></a>可变性最小化</h3><p>不可变类是指其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例时提供，并在对象的整个生命周期内固定不变。不可变类好处就是简单易用、线程安全、可自由共享而不容易出错。Java平台类库中包含许多不可变的类，比如String、基本类型包装类、BigDecimal等。</p>\n<p>为了使类成为不可变，要遵循下面五条规则：</p>\n<ul>\n<li> 声明所有的域都是私有的</li>\n<li> 声明所有的域都是final的</li>\n<li> 如果一个指向新创建实例的引用在缺乏同步机制的情况下，从一个线程被传递到另一个线程，就必须确保正确的行为</li>\n<li> 不提供任何会修改对象状态的方法</li>\n<li> 保证类不会被扩展（防止子类化，类声明为final）</li>\n<li> 防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏该类的不可变行为</li>\n<li> 确保对任何可变组件的互斥访问</li>\n<li> 如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法中返回该对象引用。在构造器、访问方法和readObject 方法中使用保护性拷贝技术</li>\n</ul>\n<p>可变性最小化的一些建议：</p>\n<ul>\n<li> 除非有很好的理由要让类成为可变的类，否则它就应该是不可变的；</li>\n<li> 如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性；</li>\n<li> 除非有令人信服的理由要使域变成非final的，否则要使每个域都是private final的；</li>\n<li> 构造器应该创建完全初始化的对象，并建立起所有的约束关系；</li>\n</ul>\n<h1 id=\"质量如何保证\"><a href=\"#质量如何保证\" class=\"headerlink\" title=\"质量如何保证\"></a>质量如何保证</h1><h2 id=\"测试驱动开发\"><a href=\"#测试驱动开发\" class=\"headerlink\" title=\"测试驱动开发\"></a>测试驱动开发</h2><blockquote>\n<p>测试驱动开发（TDD）要求以测试作为开发过程的中心，要求在编写任何代码之前，首先编写用于产码行为的测试，而编写的代码又要以使测试通过为目标。TDD要求测试可以完全自动化地运行，并在对代码重构前后必须运行测试。</p>\n</blockquote>\n<p>TDD的最终目标是整洁可用的代码（clean code that works）。大多数的开发者大部分时间无法得到整洁可用的代码。办法是分而治之。首先解决目标中的“可用”问题，然后再解决“代码的整洁”问题。这与体系结构驱动（architecture-driven）的开发相反。</p>\n<p>采用TDD另一个好处就是让我们拥有一套伴随代码产生的详尽的自动化测试集。将来无论出于任何原因（需求、重构、性能改进）需要对代码进行维护时，在这套测试集的驱动下工作，我们代码将会一直是健壮的。</p>\n<h2 id=\"TDD的开发周期\"><a href=\"#TDD的开发周期\" class=\"headerlink\" title=\"TDD的开发周期\"></a>TDD的开发周期</h2><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_4605e609.png\" alt=\"image_4605e609.png\"> Image [6].png</p>\n<p>添加一个测试 -&gt; 运行所有测试并检查测试结果 -&gt; 编写代码以通过测试 -&gt; 运行所有测试且全部通过 -&gt; 重构代码，以消除重复设计，优化设计结构</p>\n<h2 id=\"两个基本的原则\"><a href=\"#两个基本的原则\" class=\"headerlink\" title=\"两个基本的原则\"></a>两个基本的原则</h2><ul>\n<li> 仅在测试失败时才编写代码并且只编写刚好使测试通过的代码</li>\n<li> 编写下一个测试之前消除现有的重复设计，优化设计结构</li>\n</ul>\n<p>关注点分离是这两条规则隐含的另一个非常重要的原则。其表达的含义指在编码阶段先达到代码“可用”的目标，在重构阶段再追求“整洁”目标，每次只关注一件事！</p>\n<h2 id=\"分层测试点\"><a href=\"#分层测试点\" class=\"headerlink\" title=\"分层测试点\"></a>分层测试点</h2><p><img src=\"/2022/11/08/chang-jian-dai-ma-chong-gou-ji-qiao/image_e59205e3.png\" alt=\"image_e59205e3.png\"></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li> 重构-改善既有代码的设计</li>\n<li> 设计模式</li>\n<li> Effective Java</li>\n<li> 敏捷软件开发与设计的最佳实践</li>\n<li> 实现模式</li>\n<li>测试驱动开发                 </li>\n</ul>\n"},{"title":"消息队列原理和选型","top":false,"cover":false,"toc":true,"mathjax":true,"summary":"消息队列原理和选型","date":"2022-11-08T02:11:04.000Z","password":null,"_content":"![image_97d0e8f2.png](消息队列原理和选型/image_97d0e8f2.png)\n\n消息队列中间件重要吗？面试必问问题之一，你说重不重要。我有时会问同事，为啥你用 RabbitMQ，不用 Kafka，或者 RocketMQ 呢，他给我的回答 “因为公司用的就是这个，大家都这么用”，如果你去面试，直接就被 Pass，今天这篇文章，告诉你如何回答。\n\n这篇文章，我重点突出消息队列选型，弱化每种队列内部的实现细节，精华提炼，可读性更强！\n\n常用的消息队列主要这 4 种，分别为 Kafka、RabbitMQ、RocketMQ 和 ActiveMQ，主要介绍前三，不BB，上思维导图！\n\n![image_a36c2593.png](消息队列原理和选型/image_a36c2593.png)\n\n## 消息队列基础\n\n### 什么是消息队列？\n\n消息队列是在消息的传输过程中保存消息的容器，用于接收消息并以文件的方式存储，一个消息队列可以被一个也可以被多个消费者消费，包含以下 3 元素：\n\n *  Producer：消息生产者，负责产生和发送消息到 Broker；\n *  Broker：消息处理中心，负责消息存储、确认、重试等，一般其中会包含多个 Queue；\n *  Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理。\n\n![image_6d065553.png](消息队列原理和选型/image_6d065553.png)\n\n### 消息队列模式\n\n *  点对点模式：多个生产者可以向同一个消息队列发送消息，一个具体的消息只能由一个消费者消费。\n\n![image_d1df2887.png](消息队列原理和选型/image_d1df2887.png)\n\n *  发布/订阅模式：单个消息可以被多个订阅者并发的获取和处理。\n\n![image_175157f1.png](消息队列原理和选型/image_175157f1.png)\n\n### 消息队列应用场景\n\n *  应用解耦 ：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节。\n *  异步处理 ：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息。\n *  流量削锋 ：当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的”载体”，在下游有能力处理的时候，再进行分发与处理。\n *  日志处理 ：日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。\n *  消息通讯 ：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯，比如实现点对点消息队列，或者聊天室等。\n *  消息广播 ：如果没有消息队列，每当一个新的业务方接入，我们都要接入一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量。\n\n## 常用消息队列\n\n由于官方社区现在对 ActiveMQ 5.x 维护越来越少，较少在大规模吞吐的场景中使用，所以我们主要讲解 Kafka、RabbitMQ 和 RocketMQ。\n\n### Kafka\nApache Kafka 最初由 LinkedIn 公司基于独特的设计实现为一个分布式的提交日志系统，之后成为 Apache 项目的一部分，号称大数据的杀手锏，在数据采集、传输、存储的过程中发挥着举足轻重的作用。\n\n它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台 ，它同时也是一款开源的基于发布订阅模式的消息引擎系统。\n\n#### 重要概念\n\n *  主题（Topic） ：消息的种类称为主题，可以说一个主题代表了一类消息，相当于是对消息进行分类，主题就像是数据库中的表。\n *  分区（partition） ：主题可以被分为若干个分区，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性。\n *  批次 ：为了提高效率， 消息会分批次写入 Kafka，批次就代指的是一组消息。\n *  消费者群组（Consumer Group） ：消费者群组指的就是由一个或多个消费者组成的群体。\n *  Broker : 一个独立的 Kafka 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。\n *  Broker 集群 ：broker 集群由一个或多个 broker 组成。\n *  重平衡（Rebalance） ：消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。\n\n#### Kafka 架构\n\n一个典型的 Kafka 集群中包含 Producer、broker、Consumer Group、Zookeeper 集群。\n\nKafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。\n\n![image_0325f376.png](消息队列原理和选型/image_0325f376.png)\n\n#### Kafka 工作原理\n\n消息经过序列化后，通过不同的分区策略，找到对应的分区。\n\n相同主题和分区的消息，会被存放在同一个批次里 ，然后由一个独立的线程负责把它们发到 Kafka Broker 上。\n\n![image_ae0ce795.png](消息队列原理和选型/image_ae0ce795.png)\n\n分区的策略包括顺序轮询、随机轮询和 key hash 这 3 种方式，那什么是分区呢？\n\n分区是 Kafka 读写数据的最小粒度，比如主题 A 有 15 条消息，有 5 个分区，如果采用顺序轮询的方式，15 条消息会顺序分配给这 5 个分区，后续消费的时候，也是按照分区粒度消费。\n\n![image_0eb903df.png](消息队列原理和选型/image_0eb903df.png)\n\n由于分区可以部署在多个不同的机器上，所以可以通过分区实现 Kafka 的伸缩性，比如主题 A 的 5 个分区，分别部署在 5 台机器上，如果下线一台，分区就变为 4。\n\nKafka 消费是通过消费群组完成，同一个消费者群组，一个消费者可以消费多个分区，但是一个分区，只能被一个消费者消费。\n\n![image_c57014d0.png](消息队列原理和选型/image_c57014d0.png)\n\n如果消费者增加，会触发 Rebalance，也就是分区和消费者需要重新配对 。\n\n不同的消费群组互不干涉 ，比如下图的 2 个消费群组，可以分别消费这 4 个分区的消息，互不影响。\n\n![image_14d8f72e.png](消息队列原理和选型/image_14d8f72e.png)\n\n### RocketMQ \n\nRocketMQ 是阿里开源的消息中间件，它是纯 Java 开发，具有高性能、高可靠、高实时、适合大规模分布式系统应用的特点。\n\nRocketMQ 思路起源于 Kafka，但并不是 Kafka 的一个 Copy，它对消息的可靠传输及事务性做了优化 ，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binlog 分发等场景。\n\n#### 重要概念 \n\n *  Name 服务器（NameServer） ：充当注册中心，类似 Kafka 中的 Zookeeper。\n *  Broker : 一个独立的 RocketMQ 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量。\n *  主题（Topic） ：消息的第一级类型，一条消息必须有一个 Topic。\n *  子主题（Tag） ：消息的第二级类型，同一业务模块不同目的的消息就可以用相同 Topic 和不同的 Tag 来标识。\n *  分组（Group） ：一个组可以订阅多个 Topic，包括生产者组（Producer Group）和消费者组（Consumer Group）。\n *  队列（Queue） ：可以类比 Kafka 的分区 Partition。\n\n#### RocketMQ 工作原理 \n\nRockerMQ 中的消息模型就是按照主题模型所实现的，包括 Producer Group、Topic、Consumer Group 三个角色。\n\n为了提高并发能力，一个 Topic 包含多个 Queue ，生产者组根据主题将消息放入对应的 Topic，下图是采用轮询的方式找到里面的 Queue。\n\nRockerMQ 中的消费群组和 Queue，可以类比 Kafka 中的消费群组和 Partition：不同的消费者组互不干扰，一个 Queue 只能被一个消费者消费，一个消费者可以消费多个 Queue。\n\n消费 Queue 的过程中，通过偏移量记录消费的位置。\n\n![image_de577e1c.png](消息队列原理和选型/image_de577e1c.png)\n\n#### RocketMQ 架构 \n\nRocketMQ 技术架构中有四大角色 NameServer、Broker、Producer 和 Consumer，下面主要介绍 Broker。\n\nBroker 用于存放 Queue，一个 Broker 可以配置多个 Topic，一个 Topic 中存在多个 Queue。\n\n如果某个 Topic 消息量很大，应该给它多配置几个 Queue，并且尽量多分布在不同 broker 上，以减轻某个 broker 的压力。Topic 消息量都比较均匀的情况下，如果某个 broker 上的队列越多，则该 broker 压力越大。\n\n![image_9ea86f58.png](消息队列原理和选型/image_9ea86f58.png)\n\n简单提一下，Broker 通过集群部署，并且提供了 master/slave 的结构，slave 定时从 master 同步数据（同步刷盘或者异步刷盘），如果 master 宕机，则 slave 提供消费服务，但是不能写入消息。\n\n看到这里，大家应该可以发现，RocketMQ 的设计和 Kafka 真的很像！\n\n### RabbitMQ \n\nRabbitMQ 2007 年发布，是使用 Erlang 语言开发的开源消息队列系统，基于 AMQP 协议来实现。\n\nAMQP 的主要特征是面向消息、队列、路由、可靠性、安全。AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。\n\n#### 重要概念 \n\n *  信道（Channel） ：消息读写等操作在信道中进行，客户端可以建立多个信道，每个信道代表一个会话任务。\n *  交换器（Exchange） ：接收消息，按照路由规则将消息路由到一个或者多个队列；如果路由不到，或者返回给生产者，或者直接丢弃。\n *  路由键（RoutingKey） ：生产者将消息发送给交换器的时候，会发送一个 RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。\n *  绑定（Binding） ：交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个 RoutingKey。\n\n#### RabbitMQ 工作原理 \n\nAMQP 协议模型由三部分组成：生产者、消费者和服务端，执行流程如下：\n\n1.  生产者是连接到 Server，建立一个连接，开启一个信道。\n2.  生产者声明交换器和队列，设置相关属性，并通过路由键将交换器和队列进行绑定。\n3.  消费者也需要进行建立连接，开启信道等操作，便于接收消息。\n4.  生产者发送消息，发送到服务端中的虚拟主机。\n5.  虚拟主机中的交换器根据路由键选择路由规则，发送到不同的消息队列中。\n6.  订阅了消息队列的消费者就可以获取到消息，进行消费。\n\n![image_ea5d47d1.png](消息队列原理和选型/image_ea5d47d1.png)\n\n#### 常用交换器 \n\nRabbitMQ 常用的交换器类型有 direct、topic、fanout、headers 四种。\n\n具体的使用方法，可以参考官网：\n\n *  官网入口：https://www.rabbitmq.com/getstarted.html\n\n![image_8b2ddfc9.png](消息队列原理和选型/image_8b2ddfc9.png)\n\n\n## 消息队列对比&选型 \n\n![image_743e1430.png](消息队列原理和选型/image_743e1430.png)\n\n### 消息队列对比 \n\n#### Kafka \n\n优点：\n\n *  高吞吐、低延迟 ：Kafka 最大的特点就是收发消息非常快，Kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒；\n *  高伸缩性 ：每个主题（topic）包含多个分区（partition），主题中的分区可以分布在不同的主机（broker）中；\n *  高稳定性 ：Kafka 是分布式的，一个数据多个副本，某个节点宕机，Kafka 集群能够正常工作；\n *  持久性、可靠性、可回溯 ：Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，支持消息回溯；\n *  消息有序：通过控制能够保证所有消息被消费且仅被消费一次；\n *  有优秀的第三方 Kafka Web 管理界面 Kafka-Manager，在日志领域比较成熟，被多家公司和多个开源项目使用。\n\n缺点：\n\n *  Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长；\n *  不支持消息路由，不支持延迟发送，不支持消息重试；\n *  社区更新较慢。\n\n#### RocketMQ \n\n优点：\n\n *  高吞吐 ：借鉴 Kafka 的设计，单一队列百万消息的堆积能力；\n *  高伸缩性 ：灵活的分布式横向扩展部署架构，整体架构其实和 kafka 很像；\n *  高容错性 ：通过ACK机制，保证消息一定能正常消费；\n *  持久化、可回溯 ：消息可以持久化到磁盘中，支持消息回溯；\n *  消息有序：在一个队列中可靠的先进先出（FIFO）和严格的顺序传递；\n *  支持发布/订阅和点对点消息模型，支持拉、推两种消息模式；\n *  提供 docker 镜像用于隔离测试和云集群部署，提供配置、指标和监控等功能丰富的 Dashboard。\n\n缺点：\n\n *  不支持消息路由， 支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟 ；\n *  部分支持消息有序：需要将同一类的消息 hash 到同一个队列 Queue 中，才能支持消息的顺序，如果同一类消息散落到不同的 Queue中，就不能支持消息的顺序。\n *  社区活跃度一般。\n\n#### RabbitMQ \n\n优点：\n\n *  支持几乎所有最受欢迎的编程语言 ：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等等；\n *  支持消息路由 ：RabbitMQ 可以通过不同的交换器支持不同种类的消息路由；\n *  消息时序 ：通过延时队列，可以指定消息的延时时间，过期时间TTL等；\n *  支持容错处理：通过交付重试和死信交换器（DLX）来处理消息处理故障；\n *  提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker；\n *  社区活跃度高。\n\n缺点：\n\n *  Erlang 开发，很难去看懂源码，不利于做二次开发和维护 ，基本只能依赖于开源社区的快速维护和修复 bug；\n *  RabbitMQ 吞吐量会低一些 ，这是因为他做的实现机制比较重；\n *  不支持消息有序、持久化不好、不支持消息回溯、伸缩性一般。\n\n### 消息队列选型 \n\n *  Kafka：追求高吞吐量，一开始的目的就是用于日志收集和传输， 适合产生大量数据的互联网服务的数据收集业务 ，大型公司建议可以选用， 如果有日志采集功能，肯定是首选 kafka。\n *  RocketMQ： 天生为金融互联网领域而生，对于可靠性要求很高的场景 ，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RocketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验， 如果你的业务有上述并发场景，建议可以选择 RocketMQ。\n *  RabbitMQ：结合 erlang 语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护，不过 RabbitMQ 的社区十分活跃，可以解决开发过程中遇到的 bug。 如果你的数据量没有那么大，小公司优先选择功能比较完备的 RabbitMQ。\n *  ActiveMQ：官方社区现在对 ActiveMQ 5.x 维护越来越少， 较少在大规模吞吐的场景中使用。","source":"_posts/消息队列原理和选型.md","raw":"---\ntitle: 消息队列原理和选型\ntop: false\ncover: false\ntoc: true\nmathjax: true\nsummary: 消息队列原理和选型\ndate: 2022-11-08 10:11:04\npassword:\ntags:\n    - mq\n    - 中间件\ncategories:\n    - 消息队列\n---\n![image_97d0e8f2.png](消息队列原理和选型/image_97d0e8f2.png)\n\n消息队列中间件重要吗？面试必问问题之一，你说重不重要。我有时会问同事，为啥你用 RabbitMQ，不用 Kafka，或者 RocketMQ 呢，他给我的回答 “因为公司用的就是这个，大家都这么用”，如果你去面试，直接就被 Pass，今天这篇文章，告诉你如何回答。\n\n这篇文章，我重点突出消息队列选型，弱化每种队列内部的实现细节，精华提炼，可读性更强！\n\n常用的消息队列主要这 4 种，分别为 Kafka、RabbitMQ、RocketMQ 和 ActiveMQ，主要介绍前三，不BB，上思维导图！\n\n![image_a36c2593.png](消息队列原理和选型/image_a36c2593.png)\n\n## 消息队列基础\n\n### 什么是消息队列？\n\n消息队列是在消息的传输过程中保存消息的容器，用于接收消息并以文件的方式存储，一个消息队列可以被一个也可以被多个消费者消费，包含以下 3 元素：\n\n *  Producer：消息生产者，负责产生和发送消息到 Broker；\n *  Broker：消息处理中心，负责消息存储、确认、重试等，一般其中会包含多个 Queue；\n *  Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理。\n\n![image_6d065553.png](消息队列原理和选型/image_6d065553.png)\n\n### 消息队列模式\n\n *  点对点模式：多个生产者可以向同一个消息队列发送消息，一个具体的消息只能由一个消费者消费。\n\n![image_d1df2887.png](消息队列原理和选型/image_d1df2887.png)\n\n *  发布/订阅模式：单个消息可以被多个订阅者并发的获取和处理。\n\n![image_175157f1.png](消息队列原理和选型/image_175157f1.png)\n\n### 消息队列应用场景\n\n *  应用解耦 ：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节。\n *  异步处理 ：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息。\n *  流量削锋 ：当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的”载体”，在下游有能力处理的时候，再进行分发与处理。\n *  日志处理 ：日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。\n *  消息通讯 ：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯，比如实现点对点消息队列，或者聊天室等。\n *  消息广播 ：如果没有消息队列，每当一个新的业务方接入，我们都要接入一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量。\n\n## 常用消息队列\n\n由于官方社区现在对 ActiveMQ 5.x 维护越来越少，较少在大规模吞吐的场景中使用，所以我们主要讲解 Kafka、RabbitMQ 和 RocketMQ。\n\n### Kafka\nApache Kafka 最初由 LinkedIn 公司基于独特的设计实现为一个分布式的提交日志系统，之后成为 Apache 项目的一部分，号称大数据的杀手锏，在数据采集、传输、存储的过程中发挥着举足轻重的作用。\n\n它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台 ，它同时也是一款开源的基于发布订阅模式的消息引擎系统。\n\n#### 重要概念\n\n *  主题（Topic） ：消息的种类称为主题，可以说一个主题代表了一类消息，相当于是对消息进行分类，主题就像是数据库中的表。\n *  分区（partition） ：主题可以被分为若干个分区，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性。\n *  批次 ：为了提高效率， 消息会分批次写入 Kafka，批次就代指的是一组消息。\n *  消费者群组（Consumer Group） ：消费者群组指的就是由一个或多个消费者组成的群体。\n *  Broker : 一个独立的 Kafka 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。\n *  Broker 集群 ：broker 集群由一个或多个 broker 组成。\n *  重平衡（Rebalance） ：消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。\n\n#### Kafka 架构\n\n一个典型的 Kafka 集群中包含 Producer、broker、Consumer Group、Zookeeper 集群。\n\nKafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。\n\n![image_0325f376.png](消息队列原理和选型/image_0325f376.png)\n\n#### Kafka 工作原理\n\n消息经过序列化后，通过不同的分区策略，找到对应的分区。\n\n相同主题和分区的消息，会被存放在同一个批次里 ，然后由一个独立的线程负责把它们发到 Kafka Broker 上。\n\n![image_ae0ce795.png](消息队列原理和选型/image_ae0ce795.png)\n\n分区的策略包括顺序轮询、随机轮询和 key hash 这 3 种方式，那什么是分区呢？\n\n分区是 Kafka 读写数据的最小粒度，比如主题 A 有 15 条消息，有 5 个分区，如果采用顺序轮询的方式，15 条消息会顺序分配给这 5 个分区，后续消费的时候，也是按照分区粒度消费。\n\n![image_0eb903df.png](消息队列原理和选型/image_0eb903df.png)\n\n由于分区可以部署在多个不同的机器上，所以可以通过分区实现 Kafka 的伸缩性，比如主题 A 的 5 个分区，分别部署在 5 台机器上，如果下线一台，分区就变为 4。\n\nKafka 消费是通过消费群组完成，同一个消费者群组，一个消费者可以消费多个分区，但是一个分区，只能被一个消费者消费。\n\n![image_c57014d0.png](消息队列原理和选型/image_c57014d0.png)\n\n如果消费者增加，会触发 Rebalance，也就是分区和消费者需要重新配对 。\n\n不同的消费群组互不干涉 ，比如下图的 2 个消费群组，可以分别消费这 4 个分区的消息，互不影响。\n\n![image_14d8f72e.png](消息队列原理和选型/image_14d8f72e.png)\n\n### RocketMQ \n\nRocketMQ 是阿里开源的消息中间件，它是纯 Java 开发，具有高性能、高可靠、高实时、适合大规模分布式系统应用的特点。\n\nRocketMQ 思路起源于 Kafka，但并不是 Kafka 的一个 Copy，它对消息的可靠传输及事务性做了优化 ，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binlog 分发等场景。\n\n#### 重要概念 \n\n *  Name 服务器（NameServer） ：充当注册中心，类似 Kafka 中的 Zookeeper。\n *  Broker : 一个独立的 RocketMQ 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量。\n *  主题（Topic） ：消息的第一级类型，一条消息必须有一个 Topic。\n *  子主题（Tag） ：消息的第二级类型，同一业务模块不同目的的消息就可以用相同 Topic 和不同的 Tag 来标识。\n *  分组（Group） ：一个组可以订阅多个 Topic，包括生产者组（Producer Group）和消费者组（Consumer Group）。\n *  队列（Queue） ：可以类比 Kafka 的分区 Partition。\n\n#### RocketMQ 工作原理 \n\nRockerMQ 中的消息模型就是按照主题模型所实现的，包括 Producer Group、Topic、Consumer Group 三个角色。\n\n为了提高并发能力，一个 Topic 包含多个 Queue ，生产者组根据主题将消息放入对应的 Topic，下图是采用轮询的方式找到里面的 Queue。\n\nRockerMQ 中的消费群组和 Queue，可以类比 Kafka 中的消费群组和 Partition：不同的消费者组互不干扰，一个 Queue 只能被一个消费者消费，一个消费者可以消费多个 Queue。\n\n消费 Queue 的过程中，通过偏移量记录消费的位置。\n\n![image_de577e1c.png](消息队列原理和选型/image_de577e1c.png)\n\n#### RocketMQ 架构 \n\nRocketMQ 技术架构中有四大角色 NameServer、Broker、Producer 和 Consumer，下面主要介绍 Broker。\n\nBroker 用于存放 Queue，一个 Broker 可以配置多个 Topic，一个 Topic 中存在多个 Queue。\n\n如果某个 Topic 消息量很大，应该给它多配置几个 Queue，并且尽量多分布在不同 broker 上，以减轻某个 broker 的压力。Topic 消息量都比较均匀的情况下，如果某个 broker 上的队列越多，则该 broker 压力越大。\n\n![image_9ea86f58.png](消息队列原理和选型/image_9ea86f58.png)\n\n简单提一下，Broker 通过集群部署，并且提供了 master/slave 的结构，slave 定时从 master 同步数据（同步刷盘或者异步刷盘），如果 master 宕机，则 slave 提供消费服务，但是不能写入消息。\n\n看到这里，大家应该可以发现，RocketMQ 的设计和 Kafka 真的很像！\n\n### RabbitMQ \n\nRabbitMQ 2007 年发布，是使用 Erlang 语言开发的开源消息队列系统，基于 AMQP 协议来实现。\n\nAMQP 的主要特征是面向消息、队列、路由、可靠性、安全。AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。\n\n#### 重要概念 \n\n *  信道（Channel） ：消息读写等操作在信道中进行，客户端可以建立多个信道，每个信道代表一个会话任务。\n *  交换器（Exchange） ：接收消息，按照路由规则将消息路由到一个或者多个队列；如果路由不到，或者返回给生产者，或者直接丢弃。\n *  路由键（RoutingKey） ：生产者将消息发送给交换器的时候，会发送一个 RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。\n *  绑定（Binding） ：交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个 RoutingKey。\n\n#### RabbitMQ 工作原理 \n\nAMQP 协议模型由三部分组成：生产者、消费者和服务端，执行流程如下：\n\n1.  生产者是连接到 Server，建立一个连接，开启一个信道。\n2.  生产者声明交换器和队列，设置相关属性，并通过路由键将交换器和队列进行绑定。\n3.  消费者也需要进行建立连接，开启信道等操作，便于接收消息。\n4.  生产者发送消息，发送到服务端中的虚拟主机。\n5.  虚拟主机中的交换器根据路由键选择路由规则，发送到不同的消息队列中。\n6.  订阅了消息队列的消费者就可以获取到消息，进行消费。\n\n![image_ea5d47d1.png](消息队列原理和选型/image_ea5d47d1.png)\n\n#### 常用交换器 \n\nRabbitMQ 常用的交换器类型有 direct、topic、fanout、headers 四种。\n\n具体的使用方法，可以参考官网：\n\n *  官网入口：https://www.rabbitmq.com/getstarted.html\n\n![image_8b2ddfc9.png](消息队列原理和选型/image_8b2ddfc9.png)\n\n\n## 消息队列对比&选型 \n\n![image_743e1430.png](消息队列原理和选型/image_743e1430.png)\n\n### 消息队列对比 \n\n#### Kafka \n\n优点：\n\n *  高吞吐、低延迟 ：Kafka 最大的特点就是收发消息非常快，Kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒；\n *  高伸缩性 ：每个主题（topic）包含多个分区（partition），主题中的分区可以分布在不同的主机（broker）中；\n *  高稳定性 ：Kafka 是分布式的，一个数据多个副本，某个节点宕机，Kafka 集群能够正常工作；\n *  持久性、可靠性、可回溯 ：Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，支持消息回溯；\n *  消息有序：通过控制能够保证所有消息被消费且仅被消费一次；\n *  有优秀的第三方 Kafka Web 管理界面 Kafka-Manager，在日志领域比较成熟，被多家公司和多个开源项目使用。\n\n缺点：\n\n *  Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长；\n *  不支持消息路由，不支持延迟发送，不支持消息重试；\n *  社区更新较慢。\n\n#### RocketMQ \n\n优点：\n\n *  高吞吐 ：借鉴 Kafka 的设计，单一队列百万消息的堆积能力；\n *  高伸缩性 ：灵活的分布式横向扩展部署架构，整体架构其实和 kafka 很像；\n *  高容错性 ：通过ACK机制，保证消息一定能正常消费；\n *  持久化、可回溯 ：消息可以持久化到磁盘中，支持消息回溯；\n *  消息有序：在一个队列中可靠的先进先出（FIFO）和严格的顺序传递；\n *  支持发布/订阅和点对点消息模型，支持拉、推两种消息模式；\n *  提供 docker 镜像用于隔离测试和云集群部署，提供配置、指标和监控等功能丰富的 Dashboard。\n\n缺点：\n\n *  不支持消息路由， 支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟 ；\n *  部分支持消息有序：需要将同一类的消息 hash 到同一个队列 Queue 中，才能支持消息的顺序，如果同一类消息散落到不同的 Queue中，就不能支持消息的顺序。\n *  社区活跃度一般。\n\n#### RabbitMQ \n\n优点：\n\n *  支持几乎所有最受欢迎的编程语言 ：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等等；\n *  支持消息路由 ：RabbitMQ 可以通过不同的交换器支持不同种类的消息路由；\n *  消息时序 ：通过延时队列，可以指定消息的延时时间，过期时间TTL等；\n *  支持容错处理：通过交付重试和死信交换器（DLX）来处理消息处理故障；\n *  提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker；\n *  社区活跃度高。\n\n缺点：\n\n *  Erlang 开发，很难去看懂源码，不利于做二次开发和维护 ，基本只能依赖于开源社区的快速维护和修复 bug；\n *  RabbitMQ 吞吐量会低一些 ，这是因为他做的实现机制比较重；\n *  不支持消息有序、持久化不好、不支持消息回溯、伸缩性一般。\n\n### 消息队列选型 \n\n *  Kafka：追求高吞吐量，一开始的目的就是用于日志收集和传输， 适合产生大量数据的互联网服务的数据收集业务 ，大型公司建议可以选用， 如果有日志采集功能，肯定是首选 kafka。\n *  RocketMQ： 天生为金融互联网领域而生，对于可靠性要求很高的场景 ，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RocketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验， 如果你的业务有上述并发场景，建议可以选择 RocketMQ。\n *  RabbitMQ：结合 erlang 语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护，不过 RabbitMQ 的社区十分活跃，可以解决开发过程中遇到的 bug。 如果你的数据量没有那么大，小公司优先选择功能比较完备的 RabbitMQ。\n *  ActiveMQ：官方社区现在对 ActiveMQ 5.x 维护越来越少， 较少在大规模吞吐的场景中使用。","slug":"消息队列原理和选型","published":1,"updated":"2022-11-08T02:18:56.723Z","_id":"cla7kwx9700004sld281xf8oo","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_97d0e8f2.png\" alt=\"image_97d0e8f2.png\"></p>\n<p>消息队列中间件重要吗？面试必问问题之一，你说重不重要。我有时会问同事，为啥你用 RabbitMQ，不用 Kafka，或者 RocketMQ 呢，他给我的回答 “因为公司用的就是这个，大家都这么用”，如果你去面试，直接就被 Pass，今天这篇文章，告诉你如何回答。</p>\n<p>这篇文章，我重点突出消息队列选型，弱化每种队列内部的实现细节，精华提炼，可读性更强！</p>\n<p>常用的消息队列主要这 4 种，分别为 Kafka、RabbitMQ、RocketMQ 和 ActiveMQ，主要介绍前三，不BB，上思维导图！</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_a36c2593.png\" alt=\"image_a36c2593.png\"></p>\n<h2 id=\"消息队列基础\"><a href=\"#消息队列基础\" class=\"headerlink\" title=\"消息队列基础\"></a>消息队列基础</h2><h3 id=\"什么是消息队列？\"><a href=\"#什么是消息队列？\" class=\"headerlink\" title=\"什么是消息队列？\"></a>什么是消息队列？</h3><p>消息队列是在消息的传输过程中保存消息的容器，用于接收消息并以文件的方式存储，一个消息队列可以被一个也可以被多个消费者消费，包含以下 3 元素：</p>\n<ul>\n<li> Producer：消息生产者，负责产生和发送消息到 Broker；</li>\n<li> Broker：消息处理中心，负责消息存储、确认、重试等，一般其中会包含多个 Queue；</li>\n<li> Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理。</li>\n</ul>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_6d065553.png\" alt=\"image_6d065553.png\"></p>\n<h3 id=\"消息队列模式\"><a href=\"#消息队列模式\" class=\"headerlink\" title=\"消息队列模式\"></a>消息队列模式</h3><ul>\n<li> 点对点模式：多个生产者可以向同一个消息队列发送消息，一个具体的消息只能由一个消费者消费。</li>\n</ul>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_d1df2887.png\" alt=\"image_d1df2887.png\"></p>\n<ul>\n<li> 发布/订阅模式：单个消息可以被多个订阅者并发的获取和处理。</li>\n</ul>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_175157f1.png\" alt=\"image_175157f1.png\"></p>\n<h3 id=\"消息队列应用场景\"><a href=\"#消息队列应用场景\" class=\"headerlink\" title=\"消息队列应用场景\"></a>消息队列应用场景</h3><ul>\n<li> 应用解耦 ：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节。</li>\n<li> 异步处理 ：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息。</li>\n<li> 流量削锋 ：当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的”载体”，在下游有能力处理的时候，再进行分发与处理。</li>\n<li> 日志处理 ：日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。</li>\n<li> 消息通讯 ：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯，比如实现点对点消息队列，或者聊天室等。</li>\n<li> 消息广播 ：如果没有消息队列，每当一个新的业务方接入，我们都要接入一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量。</li>\n</ul>\n<h2 id=\"常用消息队列\"><a href=\"#常用消息队列\" class=\"headerlink\" title=\"常用消息队列\"></a>常用消息队列</h2><p>由于官方社区现在对 ActiveMQ 5.x 维护越来越少，较少在大规模吞吐的场景中使用，所以我们主要讲解 Kafka、RabbitMQ 和 RocketMQ。</p>\n<h3 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h3><p>Apache Kafka 最初由 LinkedIn 公司基于独特的设计实现为一个分布式的提交日志系统，之后成为 Apache 项目的一部分，号称大数据的杀手锏，在数据采集、传输、存储的过程中发挥着举足轻重的作用。</p>\n<p>它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台 ，它同时也是一款开源的基于发布订阅模式的消息引擎系统。</p>\n<h4 id=\"重要概念\"><a href=\"#重要概念\" class=\"headerlink\" title=\"重要概念\"></a>重要概念</h4><ul>\n<li> 主题（Topic） ：消息的种类称为主题，可以说一个主题代表了一类消息，相当于是对消息进行分类，主题就像是数据库中的表。</li>\n<li> 分区（partition） ：主题可以被分为若干个分区，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性。</li>\n<li> 批次 ：为了提高效率， 消息会分批次写入 Kafka，批次就代指的是一组消息。</li>\n<li> 消费者群组（Consumer Group） ：消费者群组指的就是由一个或多个消费者组成的群体。</li>\n<li> Broker : 一个独立的 Kafka 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。</li>\n<li> Broker 集群 ：broker 集群由一个或多个 broker 组成。</li>\n<li> 重平衡（Rebalance） ：消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。</li>\n</ul>\n<h4 id=\"Kafka-架构\"><a href=\"#Kafka-架构\" class=\"headerlink\" title=\"Kafka 架构\"></a>Kafka 架构</h4><p>一个典型的 Kafka 集群中包含 Producer、broker、Consumer Group、Zookeeper 集群。</p>\n<p>Kafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_0325f376.png\" alt=\"image_0325f376.png\"></p>\n<h4 id=\"Kafka-工作原理\"><a href=\"#Kafka-工作原理\" class=\"headerlink\" title=\"Kafka 工作原理\"></a>Kafka 工作原理</h4><p>消息经过序列化后，通过不同的分区策略，找到对应的分区。</p>\n<p>相同主题和分区的消息，会被存放在同一个批次里 ，然后由一个独立的线程负责把它们发到 Kafka Broker 上。</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_ae0ce795.png\" alt=\"image_ae0ce795.png\"></p>\n<p>分区的策略包括顺序轮询、随机轮询和 key hash 这 3 种方式，那什么是分区呢？</p>\n<p>分区是 Kafka 读写数据的最小粒度，比如主题 A 有 15 条消息，有 5 个分区，如果采用顺序轮询的方式，15 条消息会顺序分配给这 5 个分区，后续消费的时候，也是按照分区粒度消费。</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_0eb903df.png\" alt=\"image_0eb903df.png\"></p>\n<p>由于分区可以部署在多个不同的机器上，所以可以通过分区实现 Kafka 的伸缩性，比如主题 A 的 5 个分区，分别部署在 5 台机器上，如果下线一台，分区就变为 4。</p>\n<p>Kafka 消费是通过消费群组完成，同一个消费者群组，一个消费者可以消费多个分区，但是一个分区，只能被一个消费者消费。</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_c57014d0.png\" alt=\"image_c57014d0.png\"></p>\n<p>如果消费者增加，会触发 Rebalance，也就是分区和消费者需要重新配对 。</p>\n<p>不同的消费群组互不干涉 ，比如下图的 2 个消费群组，可以分别消费这 4 个分区的消息，互不影响。</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_14d8f72e.png\" alt=\"image_14d8f72e.png\"></p>\n<h3 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h3><p>RocketMQ 是阿里开源的消息中间件，它是纯 Java 开发，具有高性能、高可靠、高实时、适合大规模分布式系统应用的特点。</p>\n<p>RocketMQ 思路起源于 Kafka，但并不是 Kafka 的一个 Copy，它对消息的可靠传输及事务性做了优化 ，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binlog 分发等场景。</p>\n<h4 id=\"重要概念-1\"><a href=\"#重要概念-1\" class=\"headerlink\" title=\"重要概念\"></a>重要概念</h4><ul>\n<li> Name 服务器（NameServer） ：充当注册中心，类似 Kafka 中的 Zookeeper。</li>\n<li> Broker : 一个独立的 RocketMQ 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量。</li>\n<li> 主题（Topic） ：消息的第一级类型，一条消息必须有一个 Topic。</li>\n<li> 子主题（Tag） ：消息的第二级类型，同一业务模块不同目的的消息就可以用相同 Topic 和不同的 Tag 来标识。</li>\n<li> 分组（Group） ：一个组可以订阅多个 Topic，包括生产者组（Producer Group）和消费者组（Consumer Group）。</li>\n<li> 队列（Queue） ：可以类比 Kafka 的分区 Partition。</li>\n</ul>\n<h4 id=\"RocketMQ-工作原理\"><a href=\"#RocketMQ-工作原理\" class=\"headerlink\" title=\"RocketMQ 工作原理\"></a>RocketMQ 工作原理</h4><p>RockerMQ 中的消息模型就是按照主题模型所实现的，包括 Producer Group、Topic、Consumer Group 三个角色。</p>\n<p>为了提高并发能力，一个 Topic 包含多个 Queue ，生产者组根据主题将消息放入对应的 Topic，下图是采用轮询的方式找到里面的 Queue。</p>\n<p>RockerMQ 中的消费群组和 Queue，可以类比 Kafka 中的消费群组和 Partition：不同的消费者组互不干扰，一个 Queue 只能被一个消费者消费，一个消费者可以消费多个 Queue。</p>\n<p>消费 Queue 的过程中，通过偏移量记录消费的位置。</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_de577e1c.png\" alt=\"image_de577e1c.png\"></p>\n<h4 id=\"RocketMQ-架构\"><a href=\"#RocketMQ-架构\" class=\"headerlink\" title=\"RocketMQ 架构\"></a>RocketMQ 架构</h4><p>RocketMQ 技术架构中有四大角色 NameServer、Broker、Producer 和 Consumer，下面主要介绍 Broker。</p>\n<p>Broker 用于存放 Queue，一个 Broker 可以配置多个 Topic，一个 Topic 中存在多个 Queue。</p>\n<p>如果某个 Topic 消息量很大，应该给它多配置几个 Queue，并且尽量多分布在不同 broker 上，以减轻某个 broker 的压力。Topic 消息量都比较均匀的情况下，如果某个 broker 上的队列越多，则该 broker 压力越大。</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_9ea86f58.png\" alt=\"image_9ea86f58.png\"></p>\n<p>简单提一下，Broker 通过集群部署，并且提供了 master/slave 的结构，slave 定时从 master 同步数据（同步刷盘或者异步刷盘），如果 master 宕机，则 slave 提供消费服务，但是不能写入消息。</p>\n<p>看到这里，大家应该可以发现，RocketMQ 的设计和 Kafka 真的很像！</p>\n<h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><p>RabbitMQ 2007 年发布，是使用 Erlang 语言开发的开源消息队列系统，基于 AMQP 协议来实现。</p>\n<p>AMQP 的主要特征是面向消息、队列、路由、可靠性、安全。AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p>\n<h4 id=\"重要概念-2\"><a href=\"#重要概念-2\" class=\"headerlink\" title=\"重要概念\"></a>重要概念</h4><ul>\n<li> 信道（Channel） ：消息读写等操作在信道中进行，客户端可以建立多个信道，每个信道代表一个会话任务。</li>\n<li> 交换器（Exchange） ：接收消息，按照路由规则将消息路由到一个或者多个队列；如果路由不到，或者返回给生产者，或者直接丢弃。</li>\n<li> 路由键（RoutingKey） ：生产者将消息发送给交换器的时候，会发送一个 RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。</li>\n<li> 绑定（Binding） ：交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个 RoutingKey。</li>\n</ul>\n<h4 id=\"RabbitMQ-工作原理\"><a href=\"#RabbitMQ-工作原理\" class=\"headerlink\" title=\"RabbitMQ 工作原理\"></a>RabbitMQ 工作原理</h4><p>AMQP 协议模型由三部分组成：生产者、消费者和服务端，执行流程如下：</p>\n<ol>\n<li> 生产者是连接到 Server，建立一个连接，开启一个信道。</li>\n<li> 生产者声明交换器和队列，设置相关属性，并通过路由键将交换器和队列进行绑定。</li>\n<li> 消费者也需要进行建立连接，开启信道等操作，便于接收消息。</li>\n<li> 生产者发送消息，发送到服务端中的虚拟主机。</li>\n<li> 虚拟主机中的交换器根据路由键选择路由规则，发送到不同的消息队列中。</li>\n<li> 订阅了消息队列的消费者就可以获取到消息，进行消费。</li>\n</ol>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_ea5d47d1.png\" alt=\"image_ea5d47d1.png\"></p>\n<h4 id=\"常用交换器\"><a href=\"#常用交换器\" class=\"headerlink\" title=\"常用交换器\"></a>常用交换器</h4><p>RabbitMQ 常用的交换器类型有 direct、topic、fanout、headers 四种。</p>\n<p>具体的使用方法，可以参考官网：</p>\n<ul>\n<li> 官网入口：<a href=\"https://www.rabbitmq.com/getstarted.html\">https://www.rabbitmq.com/getstarted.html</a></li>\n</ul>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_8b2ddfc9.png\" alt=\"image_8b2ddfc9.png\"></p>\n<h2 id=\"消息队列对比-amp-选型\"><a href=\"#消息队列对比-amp-选型\" class=\"headerlink\" title=\"消息队列对比&amp;选型\"></a>消息队列对比&amp;选型</h2><p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_743e1430.png\" alt=\"image_743e1430.png\"></p>\n<h3 id=\"消息队列对比\"><a href=\"#消息队列对比\" class=\"headerlink\" title=\"消息队列对比\"></a>消息队列对比</h3><h4 id=\"Kafka-1\"><a href=\"#Kafka-1\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h4><p>优点：</p>\n<ul>\n<li> 高吞吐、低延迟 ：Kafka 最大的特点就是收发消息非常快，Kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒；</li>\n<li> 高伸缩性 ：每个主题（topic）包含多个分区（partition），主题中的分区可以分布在不同的主机（broker）中；</li>\n<li> 高稳定性 ：Kafka 是分布式的，一个数据多个副本，某个节点宕机，Kafka 集群能够正常工作；</li>\n<li> 持久性、可靠性、可回溯 ：Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，支持消息回溯；</li>\n<li> 消息有序：通过控制能够保证所有消息被消费且仅被消费一次；</li>\n<li> 有优秀的第三方 Kafka Web 管理界面 Kafka-Manager，在日志领域比较成熟，被多家公司和多个开源项目使用。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li> Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长；</li>\n<li> 不支持消息路由，不支持延迟发送，不支持消息重试；</li>\n<li> 社区更新较慢。</li>\n</ul>\n<h4 id=\"RocketMQ-1\"><a href=\"#RocketMQ-1\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h4><p>优点：</p>\n<ul>\n<li> 高吞吐 ：借鉴 Kafka 的设计，单一队列百万消息的堆积能力；</li>\n<li> 高伸缩性 ：灵活的分布式横向扩展部署架构，整体架构其实和 kafka 很像；</li>\n<li> 高容错性 ：通过ACK机制，保证消息一定能正常消费；</li>\n<li> 持久化、可回溯 ：消息可以持久化到磁盘中，支持消息回溯；</li>\n<li> 消息有序：在一个队列中可靠的先进先出（FIFO）和严格的顺序传递；</li>\n<li> 支持发布/订阅和点对点消息模型，支持拉、推两种消息模式；</li>\n<li> 提供 docker 镜像用于隔离测试和云集群部署，提供配置、指标和监控等功能丰富的 Dashboard。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li> 不支持消息路由， 支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟 ；</li>\n<li> 部分支持消息有序：需要将同一类的消息 hash 到同一个队列 Queue 中，才能支持消息的顺序，如果同一类消息散落到不同的 Queue中，就不能支持消息的顺序。</li>\n<li> 社区活跃度一般。</li>\n</ul>\n<h4 id=\"RabbitMQ-1\"><a href=\"#RabbitMQ-1\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h4><p>优点：</p>\n<ul>\n<li> 支持几乎所有最受欢迎的编程语言 ：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等等；</li>\n<li> 支持消息路由 ：RabbitMQ 可以通过不同的交换器支持不同种类的消息路由；</li>\n<li> 消息时序 ：通过延时队列，可以指定消息的延时时间，过期时间TTL等；</li>\n<li> 支持容错处理：通过交付重试和死信交换器（DLX）来处理消息处理故障；</li>\n<li> 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker；</li>\n<li> 社区活跃度高。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li> Erlang 开发，很难去看懂源码，不利于做二次开发和维护 ，基本只能依赖于开源社区的快速维护和修复 bug；</li>\n<li> RabbitMQ 吞吐量会低一些 ，这是因为他做的实现机制比较重；</li>\n<li> 不支持消息有序、持久化不好、不支持消息回溯、伸缩性一般。</li>\n</ul>\n<h3 id=\"消息队列选型\"><a href=\"#消息队列选型\" class=\"headerlink\" title=\"消息队列选型\"></a>消息队列选型</h3><ul>\n<li> Kafka：追求高吞吐量，一开始的目的就是用于日志收集和传输， 适合产生大量数据的互联网服务的数据收集业务 ，大型公司建议可以选用， 如果有日志采集功能，肯定是首选 kafka。</li>\n<li> RocketMQ： 天生为金融互联网领域而生，对于可靠性要求很高的场景 ，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RocketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验， 如果你的业务有上述并发场景，建议可以选择 RocketMQ。</li>\n<li> RabbitMQ：结合 erlang 语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护，不过 RabbitMQ 的社区十分活跃，可以解决开发过程中遇到的 bug。 如果你的数据量没有那么大，小公司优先选择功能比较完备的 RabbitMQ。</li>\n<li> ActiveMQ：官方社区现在对 ActiveMQ 5.x 维护越来越少， 较少在大规模吞吐的场景中使用。</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_97d0e8f2.png\" alt=\"image_97d0e8f2.png\"></p>\n<p>消息队列中间件重要吗？面试必问问题之一，你说重不重要。我有时会问同事，为啥你用 RabbitMQ，不用 Kafka，或者 RocketMQ 呢，他给我的回答 “因为公司用的就是这个，大家都这么用”，如果你去面试，直接就被 Pass，今天这篇文章，告诉你如何回答。</p>\n<p>这篇文章，我重点突出消息队列选型，弱化每种队列内部的实现细节，精华提炼，可读性更强！</p>\n<p>常用的消息队列主要这 4 种，分别为 Kafka、RabbitMQ、RocketMQ 和 ActiveMQ，主要介绍前三，不BB，上思维导图！</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_a36c2593.png\" alt=\"image_a36c2593.png\"></p>\n<h2 id=\"消息队列基础\"><a href=\"#消息队列基础\" class=\"headerlink\" title=\"消息队列基础\"></a>消息队列基础</h2><h3 id=\"什么是消息队列？\"><a href=\"#什么是消息队列？\" class=\"headerlink\" title=\"什么是消息队列？\"></a>什么是消息队列？</h3><p>消息队列是在消息的传输过程中保存消息的容器，用于接收消息并以文件的方式存储，一个消息队列可以被一个也可以被多个消费者消费，包含以下 3 元素：</p>\n<ul>\n<li> Producer：消息生产者，负责产生和发送消息到 Broker；</li>\n<li> Broker：消息处理中心，负责消息存储、确认、重试等，一般其中会包含多个 Queue；</li>\n<li> Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理。</li>\n</ul>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_6d065553.png\" alt=\"image_6d065553.png\"></p>\n<h3 id=\"消息队列模式\"><a href=\"#消息队列模式\" class=\"headerlink\" title=\"消息队列模式\"></a>消息队列模式</h3><ul>\n<li> 点对点模式：多个生产者可以向同一个消息队列发送消息，一个具体的消息只能由一个消费者消费。</li>\n</ul>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_d1df2887.png\" alt=\"image_d1df2887.png\"></p>\n<ul>\n<li> 发布/订阅模式：单个消息可以被多个订阅者并发的获取和处理。</li>\n</ul>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_175157f1.png\" alt=\"image_175157f1.png\"></p>\n<h3 id=\"消息队列应用场景\"><a href=\"#消息队列应用场景\" class=\"headerlink\" title=\"消息队列应用场景\"></a>消息队列应用场景</h3><ul>\n<li> 应用解耦 ：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节。</li>\n<li> 异步处理 ：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息。</li>\n<li> 流量削锋 ：当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的”载体”，在下游有能力处理的时候，再进行分发与处理。</li>\n<li> 日志处理 ：日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。</li>\n<li> 消息通讯 ：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯，比如实现点对点消息队列，或者聊天室等。</li>\n<li> 消息广播 ：如果没有消息队列，每当一个新的业务方接入，我们都要接入一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量。</li>\n</ul>\n<h2 id=\"常用消息队列\"><a href=\"#常用消息队列\" class=\"headerlink\" title=\"常用消息队列\"></a>常用消息队列</h2><p>由于官方社区现在对 ActiveMQ 5.x 维护越来越少，较少在大规模吞吐的场景中使用，所以我们主要讲解 Kafka、RabbitMQ 和 RocketMQ。</p>\n<h3 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h3><p>Apache Kafka 最初由 LinkedIn 公司基于独特的设计实现为一个分布式的提交日志系统，之后成为 Apache 项目的一部分，号称大数据的杀手锏，在数据采集、传输、存储的过程中发挥着举足轻重的作用。</p>\n<p>它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台 ，它同时也是一款开源的基于发布订阅模式的消息引擎系统。</p>\n<h4 id=\"重要概念\"><a href=\"#重要概念\" class=\"headerlink\" title=\"重要概念\"></a>重要概念</h4><ul>\n<li> 主题（Topic） ：消息的种类称为主题，可以说一个主题代表了一类消息，相当于是对消息进行分类，主题就像是数据库中的表。</li>\n<li> 分区（partition） ：主题可以被分为若干个分区，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性。</li>\n<li> 批次 ：为了提高效率， 消息会分批次写入 Kafka，批次就代指的是一组消息。</li>\n<li> 消费者群组（Consumer Group） ：消费者群组指的就是由一个或多个消费者组成的群体。</li>\n<li> Broker : 一个独立的 Kafka 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。</li>\n<li> Broker 集群 ：broker 集群由一个或多个 broker 组成。</li>\n<li> 重平衡（Rebalance） ：消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。</li>\n</ul>\n<h4 id=\"Kafka-架构\"><a href=\"#Kafka-架构\" class=\"headerlink\" title=\"Kafka 架构\"></a>Kafka 架构</h4><p>一个典型的 Kafka 集群中包含 Producer、broker、Consumer Group、Zookeeper 集群。</p>\n<p>Kafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_0325f376.png\" alt=\"image_0325f376.png\"></p>\n<h4 id=\"Kafka-工作原理\"><a href=\"#Kafka-工作原理\" class=\"headerlink\" title=\"Kafka 工作原理\"></a>Kafka 工作原理</h4><p>消息经过序列化后，通过不同的分区策略，找到对应的分区。</p>\n<p>相同主题和分区的消息，会被存放在同一个批次里 ，然后由一个独立的线程负责把它们发到 Kafka Broker 上。</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_ae0ce795.png\" alt=\"image_ae0ce795.png\"></p>\n<p>分区的策略包括顺序轮询、随机轮询和 key hash 这 3 种方式，那什么是分区呢？</p>\n<p>分区是 Kafka 读写数据的最小粒度，比如主题 A 有 15 条消息，有 5 个分区，如果采用顺序轮询的方式，15 条消息会顺序分配给这 5 个分区，后续消费的时候，也是按照分区粒度消费。</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_0eb903df.png\" alt=\"image_0eb903df.png\"></p>\n<p>由于分区可以部署在多个不同的机器上，所以可以通过分区实现 Kafka 的伸缩性，比如主题 A 的 5 个分区，分别部署在 5 台机器上，如果下线一台，分区就变为 4。</p>\n<p>Kafka 消费是通过消费群组完成，同一个消费者群组，一个消费者可以消费多个分区，但是一个分区，只能被一个消费者消费。</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_c57014d0.png\" alt=\"image_c57014d0.png\"></p>\n<p>如果消费者增加，会触发 Rebalance，也就是分区和消费者需要重新配对 。</p>\n<p>不同的消费群组互不干涉 ，比如下图的 2 个消费群组，可以分别消费这 4 个分区的消息，互不影响。</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_14d8f72e.png\" alt=\"image_14d8f72e.png\"></p>\n<h3 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h3><p>RocketMQ 是阿里开源的消息中间件，它是纯 Java 开发，具有高性能、高可靠、高实时、适合大规模分布式系统应用的特点。</p>\n<p>RocketMQ 思路起源于 Kafka，但并不是 Kafka 的一个 Copy，它对消息的可靠传输及事务性做了优化 ，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binlog 分发等场景。</p>\n<h4 id=\"重要概念-1\"><a href=\"#重要概念-1\" class=\"headerlink\" title=\"重要概念\"></a>重要概念</h4><ul>\n<li> Name 服务器（NameServer） ：充当注册中心，类似 Kafka 中的 Zookeeper。</li>\n<li> Broker : 一个独立的 RocketMQ 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量。</li>\n<li> 主题（Topic） ：消息的第一级类型，一条消息必须有一个 Topic。</li>\n<li> 子主题（Tag） ：消息的第二级类型，同一业务模块不同目的的消息就可以用相同 Topic 和不同的 Tag 来标识。</li>\n<li> 分组（Group） ：一个组可以订阅多个 Topic，包括生产者组（Producer Group）和消费者组（Consumer Group）。</li>\n<li> 队列（Queue） ：可以类比 Kafka 的分区 Partition。</li>\n</ul>\n<h4 id=\"RocketMQ-工作原理\"><a href=\"#RocketMQ-工作原理\" class=\"headerlink\" title=\"RocketMQ 工作原理\"></a>RocketMQ 工作原理</h4><p>RockerMQ 中的消息模型就是按照主题模型所实现的，包括 Producer Group、Topic、Consumer Group 三个角色。</p>\n<p>为了提高并发能力，一个 Topic 包含多个 Queue ，生产者组根据主题将消息放入对应的 Topic，下图是采用轮询的方式找到里面的 Queue。</p>\n<p>RockerMQ 中的消费群组和 Queue，可以类比 Kafka 中的消费群组和 Partition：不同的消费者组互不干扰，一个 Queue 只能被一个消费者消费，一个消费者可以消费多个 Queue。</p>\n<p>消费 Queue 的过程中，通过偏移量记录消费的位置。</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_de577e1c.png\" alt=\"image_de577e1c.png\"></p>\n<h4 id=\"RocketMQ-架构\"><a href=\"#RocketMQ-架构\" class=\"headerlink\" title=\"RocketMQ 架构\"></a>RocketMQ 架构</h4><p>RocketMQ 技术架构中有四大角色 NameServer、Broker、Producer 和 Consumer，下面主要介绍 Broker。</p>\n<p>Broker 用于存放 Queue，一个 Broker 可以配置多个 Topic，一个 Topic 中存在多个 Queue。</p>\n<p>如果某个 Topic 消息量很大，应该给它多配置几个 Queue，并且尽量多分布在不同 broker 上，以减轻某个 broker 的压力。Topic 消息量都比较均匀的情况下，如果某个 broker 上的队列越多，则该 broker 压力越大。</p>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_9ea86f58.png\" alt=\"image_9ea86f58.png\"></p>\n<p>简单提一下，Broker 通过集群部署，并且提供了 master/slave 的结构，slave 定时从 master 同步数据（同步刷盘或者异步刷盘），如果 master 宕机，则 slave 提供消费服务，但是不能写入消息。</p>\n<p>看到这里，大家应该可以发现，RocketMQ 的设计和 Kafka 真的很像！</p>\n<h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><p>RabbitMQ 2007 年发布，是使用 Erlang 语言开发的开源消息队列系统，基于 AMQP 协议来实现。</p>\n<p>AMQP 的主要特征是面向消息、队列、路由、可靠性、安全。AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p>\n<h4 id=\"重要概念-2\"><a href=\"#重要概念-2\" class=\"headerlink\" title=\"重要概念\"></a>重要概念</h4><ul>\n<li> 信道（Channel） ：消息读写等操作在信道中进行，客户端可以建立多个信道，每个信道代表一个会话任务。</li>\n<li> 交换器（Exchange） ：接收消息，按照路由规则将消息路由到一个或者多个队列；如果路由不到，或者返回给生产者，或者直接丢弃。</li>\n<li> 路由键（RoutingKey） ：生产者将消息发送给交换器的时候，会发送一个 RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。</li>\n<li> 绑定（Binding） ：交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个 RoutingKey。</li>\n</ul>\n<h4 id=\"RabbitMQ-工作原理\"><a href=\"#RabbitMQ-工作原理\" class=\"headerlink\" title=\"RabbitMQ 工作原理\"></a>RabbitMQ 工作原理</h4><p>AMQP 协议模型由三部分组成：生产者、消费者和服务端，执行流程如下：</p>\n<ol>\n<li> 生产者是连接到 Server，建立一个连接，开启一个信道。</li>\n<li> 生产者声明交换器和队列，设置相关属性，并通过路由键将交换器和队列进行绑定。</li>\n<li> 消费者也需要进行建立连接，开启信道等操作，便于接收消息。</li>\n<li> 生产者发送消息，发送到服务端中的虚拟主机。</li>\n<li> 虚拟主机中的交换器根据路由键选择路由规则，发送到不同的消息队列中。</li>\n<li> 订阅了消息队列的消费者就可以获取到消息，进行消费。</li>\n</ol>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_ea5d47d1.png\" alt=\"image_ea5d47d1.png\"></p>\n<h4 id=\"常用交换器\"><a href=\"#常用交换器\" class=\"headerlink\" title=\"常用交换器\"></a>常用交换器</h4><p>RabbitMQ 常用的交换器类型有 direct、topic、fanout、headers 四种。</p>\n<p>具体的使用方法，可以参考官网：</p>\n<ul>\n<li> 官网入口：<a href=\"https://www.rabbitmq.com/getstarted.html\">https://www.rabbitmq.com/getstarted.html</a></li>\n</ul>\n<p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_8b2ddfc9.png\" alt=\"image_8b2ddfc9.png\"></p>\n<h2 id=\"消息队列对比-amp-选型\"><a href=\"#消息队列对比-amp-选型\" class=\"headerlink\" title=\"消息队列对比&amp;选型\"></a>消息队列对比&amp;选型</h2><p><img src=\"/2022/11/08/xiao-xi-dui-lie-yuan-li-he-xuan-xing/image_743e1430.png\" alt=\"image_743e1430.png\"></p>\n<h3 id=\"消息队列对比\"><a href=\"#消息队列对比\" class=\"headerlink\" title=\"消息队列对比\"></a>消息队列对比</h3><h4 id=\"Kafka-1\"><a href=\"#Kafka-1\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h4><p>优点：</p>\n<ul>\n<li> 高吞吐、低延迟 ：Kafka 最大的特点就是收发消息非常快，Kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒；</li>\n<li> 高伸缩性 ：每个主题（topic）包含多个分区（partition），主题中的分区可以分布在不同的主机（broker）中；</li>\n<li> 高稳定性 ：Kafka 是分布式的，一个数据多个副本，某个节点宕机，Kafka 集群能够正常工作；</li>\n<li> 持久性、可靠性、可回溯 ：Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，支持消息回溯；</li>\n<li> 消息有序：通过控制能够保证所有消息被消费且仅被消费一次；</li>\n<li> 有优秀的第三方 Kafka Web 管理界面 Kafka-Manager，在日志领域比较成熟，被多家公司和多个开源项目使用。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li> Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长；</li>\n<li> 不支持消息路由，不支持延迟发送，不支持消息重试；</li>\n<li> 社区更新较慢。</li>\n</ul>\n<h4 id=\"RocketMQ-1\"><a href=\"#RocketMQ-1\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h4><p>优点：</p>\n<ul>\n<li> 高吞吐 ：借鉴 Kafka 的设计，单一队列百万消息的堆积能力；</li>\n<li> 高伸缩性 ：灵活的分布式横向扩展部署架构，整体架构其实和 kafka 很像；</li>\n<li> 高容错性 ：通过ACK机制，保证消息一定能正常消费；</li>\n<li> 持久化、可回溯 ：消息可以持久化到磁盘中，支持消息回溯；</li>\n<li> 消息有序：在一个队列中可靠的先进先出（FIFO）和严格的顺序传递；</li>\n<li> 支持发布/订阅和点对点消息模型，支持拉、推两种消息模式；</li>\n<li> 提供 docker 镜像用于隔离测试和云集群部署，提供配置、指标和监控等功能丰富的 Dashboard。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li> 不支持消息路由， 支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟 ；</li>\n<li> 部分支持消息有序：需要将同一类的消息 hash 到同一个队列 Queue 中，才能支持消息的顺序，如果同一类消息散落到不同的 Queue中，就不能支持消息的顺序。</li>\n<li> 社区活跃度一般。</li>\n</ul>\n<h4 id=\"RabbitMQ-1\"><a href=\"#RabbitMQ-1\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h4><p>优点：</p>\n<ul>\n<li> 支持几乎所有最受欢迎的编程语言 ：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等等；</li>\n<li> 支持消息路由 ：RabbitMQ 可以通过不同的交换器支持不同种类的消息路由；</li>\n<li> 消息时序 ：通过延时队列，可以指定消息的延时时间，过期时间TTL等；</li>\n<li> 支持容错处理：通过交付重试和死信交换器（DLX）来处理消息处理故障；</li>\n<li> 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker；</li>\n<li> 社区活跃度高。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li> Erlang 开发，很难去看懂源码，不利于做二次开发和维护 ，基本只能依赖于开源社区的快速维护和修复 bug；</li>\n<li> RabbitMQ 吞吐量会低一些 ，这是因为他做的实现机制比较重；</li>\n<li> 不支持消息有序、持久化不好、不支持消息回溯、伸缩性一般。</li>\n</ul>\n<h3 id=\"消息队列选型\"><a href=\"#消息队列选型\" class=\"headerlink\" title=\"消息队列选型\"></a>消息队列选型</h3><ul>\n<li> Kafka：追求高吞吐量，一开始的目的就是用于日志收集和传输， 适合产生大量数据的互联网服务的数据收集业务 ，大型公司建议可以选用， 如果有日志采集功能，肯定是首选 kafka。</li>\n<li> RocketMQ： 天生为金融互联网领域而生，对于可靠性要求很高的场景 ，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RocketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验， 如果你的业务有上述并发场景，建议可以选择 RocketMQ。</li>\n<li> RabbitMQ：结合 erlang 语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护，不过 RabbitMQ 的社区十分活跃，可以解决开发过程中遇到的 bug。 如果你的数据量没有那么大，小公司优先选择功能比较完备的 RabbitMQ。</li>\n<li> ActiveMQ：官方社区现在对 ActiveMQ 5.x 维护越来越少， 较少在大规模吞吐的场景中使用。</li>\n</ul>\n"},{"title":"分布式锁的多种实现","top":false,"cover":false,"toc":true,"mathjax":true,"summary":"分布式锁的多种实现分布式锁的多种实现","date":"2022-11-09T03:07:16.000Z","password":null,"_content":"\n *  分布式锁概述\n *  数据库分布式锁\n *  Redis分布式锁\n *  Zookeeper分布式锁\n *  三种分布式锁对比\n\n## 1. 分布式锁概述\n\n我们的系统都是分布式部署的，日常开发中，秒杀下单、抢购商品 等等业务场景，为了防⽌库存超卖，都需要用到分布式锁 。\n\n> 分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。\n\n业界流行的分布式锁实现，一般有这3种方式：\n\n *  基于数据库实现的分布式锁\n *  基于Redis实现的分布式锁\n *  基于Zookeeper实现的分布式锁\n\n## 2. 基于数据库的分布式锁\n\n### 2.1 数据库悲观锁实现的分布式锁\n\n可以使用`select ... for update`来实现分布式锁。我们自己的项目，分布式定时任务 ，就使用类似的实现方案，我给大家来展示个简单版的哈\n\n表结构如下：\n\n```java\nCREATE TABLE `t_resource_lock` (\n  `key_resource` varchar(45) COLLATE utf8_bin NOT NULL DEFAULT '资源主键',\n  `status` char(1) COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT 'S,F,P',\n  `lock_flag` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '1是已经锁 0是未锁',\n  `begin_time` datetime DEFAULT NULL COMMENT '开始时间',\n  `end_time` datetime DEFAULT NULL COMMENT '结束时间',\n  `client_ip` varchar(45) COLLATE utf8_bin NOT NULL DEFAULT '抢到锁的IP',\n  `time` int(10) unsigned NOT NULL DEFAULT '60' COMMENT '方法生命周期内只允许一个结点获取一次锁，单位：分钟',\n  PRIMARY KEY (`key_resource`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin\n```\n\n加锁`lock`方法的伪代码如下：\n\n```java\n@Transcational //一定要加事务\npublic boolean lock(String keyResource，int time){\n   resourceLock = 'select * from t_resource_lock where key_resource ='#{keySource}' for update';\n   \n   try{\n    if(resourceLock==null){\n      //插入锁的数据\n      resourceLock = new ResourceLock();\n      resourceLock.setTime(time);\n      resourceLock.setLockFlag(1);  //上锁\n      resourceLock.setStatus(P); //处理中\n      resourceLock.setBeginTime(new Date());\n      int count = \"insert into resourceLock\"; \n      if(count==1){\n         //获取锁成功\n         return true;\n      }\n      return false;\n   }\n   }catch(Exception x){\n      return false;\n   }\n   \n   //没上锁并且锁已经超时，即可以获取锁成功\n   if(resourceLock.getLockFlag=='0'&&'S'.equals(resourceLock.getstatus)\n    && new Date()>=resourceLock.addDateTime(resourceLock.getBeginTime(,time)){\n      resourceLock.setLockFlag(1);  //上锁\n      resourceLock.setStatus(P); //处理中\n      resourceLock.setBeginTime(new Date());\n      //update resourceLock;\n      return true;\n   }else if(new Date()>=resourceLock.addDateTime(resourceLock.getBeginTime(,time)){\n     //超时未正常执行结束,获取锁失败\n     return false;\n   }else{\n     return false;\n   } \n}\n```\n\n解锁`unlock`方法的伪代码如下：\n\n```java\npublic void unlock(String v，status){\n      resourceLock.setLockFlag(0);  //解锁\n      resourceLock.setStatus(status); S:表示成功，F表示失败\n      //update resourceLock;\n      return ;\n}\n```\n\n整体流程：\n\n```java\ntry{\nif(lock(keyResource,time)){ //加锁\n   status = process();//你的业务逻辑处理。\n }\n} finally{\n    unlock(keyResource,status); //释放锁\n}\n```\n\n其实这个悲观锁实现的分布式锁，整体的流程还是比较清晰的。就是先`select ... for update`锁住主键`key_resource`那个记录，如果为空，则可以插入一条记录，如果已有记录判断下状态和时间 ，是否已经超时 。这里需要注意一下哈，必须要加事务 哈。\n\n### 2.2 数据库乐观锁实现的分布式锁\n\n除了悲观锁，还可以用乐观锁实现分布式锁 。乐观锁，顾名思义，就是很乐观，每次更新操作，都觉得不会存在并发冲突，只有更新失败后，才重试。它是基于CAS思想实现的。我以前的公司，扣减余额 就是用这种方案。\n\n> 搞个version字段，每次更新修改，都会自增加一，然后去更新余额时，把查出来的那个版本号，带上条件去更新，如果是上次那个版本号，就更新，如果不是，表示别人并发修改过了，就继续重试。\n\n大概流程如下：\n\n1.  查询版本号和余额\n\n```java\nselect version,balance from account where user_id ='666';\n```\n\n假设查到版本号是oldVersion=1.\n\n1.  逻辑处理，判断余额\n\n```java\nif(balance<扣减金额){\n   return；\n}\n\nleft_balance = balance - 扣减金额;\n```\n\n1.  进行扣减余额\n\n```java\nupdate account set balance = #{left_balance} ,version = version+1 where version \n= #{oldVersion} and balance>= #{left_balance} and user_id ='666';\n```\n\n大家可以看下这个流程图哈：\n\n ![image_92a9dd04.png](http://markdown.liangtengyu.com:9999/images//image_92a9dd04.png) \n\n这种方式适合并发不高 的场景，一般需要设置一下重试的次数\n\n## 3.基于Redis实现的分布式锁\n\nRedis分布式锁一般有以下这几种实现方式：\n\n *  setnx + expire\n *  setnx + value值是过期时间\n *  set的扩展命令（set ex px nx）\n *  set ex px nx + 校验唯一随机值,再删除\n *  Redisson\n *  Redisson + RedLock\n\n### 3.1 setnx + expire\n\n聊到Redis分布式锁，很多小伙伴反手就是`setnx + expire`，如下：\n\n```java\nif（jedis.setnx(key,lock_value) == 1）{ //setnx加锁\n    expire（key，100）; //设置过期时间\n    try {\n        do something  //业务处理\n    }catch(){\n    }\n  finally {\n       jedis.del(key); //释放锁\n    }\n}\n```\n\n这段代码是可以加锁成功，但是你有没有发现问题，加锁操作和设置超时时间是分开的 。假设在执行完`setnx`加锁后，正要执行`expire`设置过期时间时，进程`crash`掉或者要重启维护了，那这个锁就长生不老 了，别的线程永远获取不到锁啦，所以分布式锁不能这么实现 ！\n\n### 3.2 setnx + value值是过期时间\n\n```java\nlong expires = System.currentTimeMillis() + expireTime; //系统时间+设置的过期时间\nString expiresStr = String.valueOf(expires);\n\n// 如果当前锁不存在，返回加锁成功\nif (jedis.setnx(key, expiresStr) == 1) {\n        return true;\n} \n// 如果锁已经存在，获取锁的过期时间\nString currentValueStr = jedis.get(key);\n\n// 如果获取到的过期时间，小于系统当前时间，表示已经过期\nif (currentValueStr != null && Long.parseLong(currentValueStr) < System.currentTimeMillis()) {\n\n     // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈）\n    String oldValueStr = jedis.getSet(key, expiresStr);\n    \n    if (oldValueStr != null && oldValueStr.equals(currentValueStr)) {\n         // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁\n         return true;\n    }\n}\n        \n//其他情况，均返回加锁失败\nreturn false;\n}\n```\n\n日常开发中，有些小伙伴就是这么实现分布式锁的，但是会有这些缺点 ：\n\n *  过期时间是客户端自己生成的，分布式环境下， 每个客户端的时间必须同步。\n *  没有保存持有者的唯一标识， 可能被别的客户端释放/解锁 。\n *  锁过期的时候，并发多个客户端同时请求过来，都执行了 `jedis.getSet()`，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间， 可能被别的客户端覆盖。\n\n### 3.3 set的扩展命令(set ex px nx)\n\n这个命令的几个参数分别表示什么意思呢？跟大家复习一下：\n\n```java\nSET key value [EX seconds] [PX milliseconds] [NX|XX]\n```\n\n *  EX second ：设置键的过期时间为 `second`秒。\n *  PX millisecond ：设置键的过期时间为 `millisecond`毫秒。\n *  NX ：只在键不存在时，才对键进行设置操作。\n *  XX ：只在键已经存在时，才对键进行设置操作。\n\n```java\nif（jedis.set(key, lock_value, \"NX\", \"EX\", 100s) == 1）{ //加锁\n    try {\n        do something  //业务处理\n    }catch(){\n  }\n  finally {\n       jedis.del(key); //释放锁\n    }\n}\n```\n\n这个方案可能存在这样的问题：\n\n *  锁过期释放了，业务还没执行完。\n *  锁被别的线程误删。\n\n有些伙伴可能会有个疑问，就是锁为什么会被别的线程误删 呢？假设并发多线程场景下，线程A获得了锁，但是它没释放锁的话，线程B是获取不到锁的 ，所以按道理它是执行不到加锁下面的代码滴，怎么会导致锁被别的线程误删呢？\n\n> 假设线程A和B，都想用`key`加锁，最后A抢到锁加锁成功，但是由于执行业务逻辑的耗时很长，超过了设置的超时时间`100s`。这时候，Redis就自动释放了`key`锁。这时候线程B就可以加锁成功了，接下啦，它也执行业务逻辑处理。假设碰巧这时候，A执行完自己的业务逻辑，它就去释放锁，但是它就把B的锁给释放了。\n\n### 3.4 set ex px nx + 校验唯一随机值,再删除\n\n为了解决锁被别的线程误删 问题。可以在`set ex px nx`的基础上，加上个校验的唯一随机值，如下：\n\n```java\nif（jedis.set(key, uni_request_id, \"NX\", \"EX\", 100s) == 1）{ //加锁\n    try {\n        do something  //业务处理\n    }catch(){\n  }\n  finally {\n       //判断是不是当前线程加的锁,是才释放\n       if (uni_request_id.equals(jedis.get(key))) {\n          jedis.del(key); //释放锁\n        }\n    }\n}\n```\n\n在这里，判断当前线程加的锁和释放锁不是一个原子操作 。如果调用`jedis.del()`释放锁的时候，可能这把锁已经不属于当前客户端 ，会解除他人加的锁。\n\n一般可以用lua脚本来包一下。lua脚本如下：\n\n```java\nif redis.call('get',KEYS[1]) == ARGV[1] then \n   return redis.call('del',KEYS[1]) \nelse\n   return 0\nend;\n```\n\n这种方式比较不错了，一般情况下，已经可以使用这种实现方式。但是还是存在：锁过期释放了，业务还没执行完的问题 。\n\n### 3.5 Redisson\n\n对于可能存在锁过期释放，业务没执行完 的问题。我们可以稍微把锁过期时间设置长一些，大于正常业务处理时间就好啦。如果你觉得不是很稳，还可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。\n\n当前开源框架Redisson解决了这个问题。可以看下Redisson底层原理图：\n\n ![image_6ae9d764.png](http://markdown.liangtengyu.com:9999/images//image_6ae9d764.png) \n\n只要线程一加锁成功，就会启动一个`watch dog`看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用`watch dog`解决了锁过期释放，业务没执行完问题 。\n\n### 3.6 Redisson + RedLock\n\n前面六种方案都只是基于Redis单机版 的分布式锁讨论，还不是很完美。因为Redis 一般都是集群部署的：\n\n ![image_f90141b7.png](http://markdown.liangtengyu.com:9999/images//image_f90141b7.png) \n\n如果线程一在`Redis`的`master`节点上拿到了锁，但是加锁的`key`还没同步到`slave`节点。恰好这时，`master`节点发生故障，一个`slave`节点就会升级为`master`节点。线程二就可以顺理成章获取同个`key`的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。\n\n为了解决这个问题，Redis作者antirez提出一种高级的分布式锁算法：Redlock 。它的核心思想是这样的：\n\n> 部署多个Redis master，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。\n\n我们假设当前有5个Redis master节点，在5台服务器上面运行这些Redis实例。\n\n ![image_669de3e0.png](http://markdown.liangtengyu.com:9999/images//image_669de3e0.png) RedLock的实现步骤:\n\n1.  获取当前时间，以毫秒为单位。\n2.  按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。\n3.  客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1，这里是5/2+1=3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s> 30ms+40ms+50ms+4m0s+50ms）\n4.  如果取到了锁，key的真正有效时间就变啦，需要减去获取锁所使用的时间。\n5.  如果获取锁失败（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。\n\n简化下步骤就是：\n\n *  按顺序向5个master节点请求加锁\n *  根据设置的超时时间来判断，是不是要跳过该master节点。\n *  如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。\n *  如果获取锁失败，解锁！\n\nRedisson实现了redLock版本的锁 ，有兴趣的小伙伴，可以去了解一下哈~\n\n## 4. Zookeeper分布式锁\n\n在学习Zookeeper分布式锁之前，我们复习一下Zookeeper的节点哈。\n\nZookeeper的节点Znode有四种类型：\n\n *  持久节点 ：默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在。\n *  持久节点顺序节点 ：所谓顺序节点，就是在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号，持久节点顺序节点就是有顺序的持久节点。\n *  临时节点 ：和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。\n *  临时顺序节点 ：有顺序的临时节点。\n\nZookeeper分布式锁实现应用了临时顺序节点 。这里不贴代码啦，来讲下zk分布式锁的实现原理吧。\n\n### 4.1 zk获取锁过程\n\n当第一个客户端请求过来时，Zookeeper客户端会创建一个持久节点`locks`。如果它（Client1）想获得锁，需要在`locks`节点下创建一个顺序节点`lock1`.如图\n\n ![image_bd68a96a.png](http://markdown.liangtengyu.com:9999/images//image_bd68a96a.png) \n\n接着，客户端Client1会查找`locks`下面的所有临时顺序子节点，判断自己的节点`lock1`是不是排序最小的那一个，如果是，则成功获得锁。\n\n ![image_d2f64ca3.png](http://markdown.liangtengyu.com:9999/images//image_d2f64ca3.png) \n\n这时候如果又来一个客户端client2前来尝试获得锁，它会在locks下再创建一个临时节点`lock2`\n\n ![image_071b7d88.png](http://markdown.liangtengyu.com:9999/images//image_071b7d88.png) \n\n客户端client2一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock2是不是最小的，此时，发现lock1才是最小的，于是获取锁失败。获取锁失败，它是不会甘心的，client2向它排序靠前的节点lock1注册Watcher事件，用来监听lock1是否存在，也就是说client2抢锁失败进入等待状态。\n\n ![image_b489bef9.png](http://markdown.liangtengyu.com:9999/images//image_b489bef9.png) \n\n此时，如果再来一个客户端Client3来尝试获取锁，它会在locks下再创建一个临时节点lock3\n\n ![image_aa38b5f6.png](http://markdown.liangtengyu.com:9999/images//image_aa38b5f6.png) 同样的，client3一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock3是不是最小的，发现自己不是最小的，就获取锁失败。它也是不会甘心的，它会向在它前面的节点lock2注册Watcher事件，以监听lock2节点是否存在。\n\n ![image_1cec9bce.png](http://markdown.liangtengyu.com:9999/images//image_1cec9bce.png) \n\n### 4.2 释放锁\n\n我们再来看看释放锁的流程，Zookeeper的客户端业务完成或者发生故障，都会删除临时节点，释放锁。如果是任务完成，Client1会显式调用删除lock1的指令\n\n ![image_93a8ea85.png](http://markdown.liangtengyu.com:9999/images//image_93a8ea85.png) \n\n如果是客户端故障了，根据临时节点得特性，lock1是会自动删除的\n\n ![image_e929ee6e.png](http://markdown.liangtengyu.com:9999/images//image_e929ee6e.png) \n\nlock1节点被删除后，Client2可开心了，因为它一直监听着lock1。lock1节点删除，Client2立刻收到通知，也会查找locks下面的所有临时顺序子节点，发下lock2是最小，就获得锁。\n\n ![image_5b5c8168.png](http://markdown.liangtengyu.com:9999/images//image_5b5c8168.png) \n\n同理，Client2获得锁之后，Client3也对它虎视眈眈，啊哈哈~\n\n *  Zookeeper设计定位就是分布式协调，简单易用。如果获取不到锁，只需添加一个监听器即可，很适合做分布式锁。\n *  Zookeeper作为分布式锁也缺点：如果有很多的客户端频繁的申请加锁、释放锁，对于Zookeeper集群的压力会比较大。\n\n## 5. 三种分布式锁对比\n\n### 5.1 数据库分布式锁实现\n\n优点：\n\n *  简单，使用方便，不需要引入 `Redis、zookeeper`等中间件。\n\n缺点：\n\n *  不适合高并发的场景\n *  db操作性能较差；\n\n### 5.2 Redis分布式锁实现\n\n优点：\n\n *  性能好，适合高并发场景\n *  较轻量级\n *  有较好的框架支持，如Redisson\n\n缺点：\n\n *  过期时间不好控制\n *  需要考虑锁被别的线程误删场景\n\n### 5.3 Zookeeper分布式锁实现\n\n缺点：\n\n *  性能不如redis实现的分布式锁\n *  比较重的分布式锁。\n\n优点：\n\n *  有较好的性能和可靠性\n *  有封装较好的框架，如Curator\n\n### 5.4 对比汇总\n\n *  从性能角度（从高到低）Redis > Zookeeper >= 数据库；\n *  从理解的难易程度角度（从低到高）数据库 > Redis > Zookeeper；\n *  从实现的复杂性角度（从低到高）Zookeeper > Redis > 数据库；\n *  从可靠性角度（从高到低）Zookeeper > Redis > 数据库。\n","source":"_posts/分布式锁的多种实现.md","raw":"---\ntitle: 分布式锁的多种实现\ntop: false\ncover: false\ntoc: true\nmathjax: true\nsummary: 分布式锁的多种实现分布式锁的多种实现\ndate: 2022-11-09 11:07:16\npassword:\ntags:\n    - 锁\ncategories:\n    - java\n    - 分布式\n---\n\n *  分布式锁概述\n *  数据库分布式锁\n *  Redis分布式锁\n *  Zookeeper分布式锁\n *  三种分布式锁对比\n\n## 1. 分布式锁概述\n\n我们的系统都是分布式部署的，日常开发中，秒杀下单、抢购商品 等等业务场景，为了防⽌库存超卖，都需要用到分布式锁 。\n\n> 分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。\n\n业界流行的分布式锁实现，一般有这3种方式：\n\n *  基于数据库实现的分布式锁\n *  基于Redis实现的分布式锁\n *  基于Zookeeper实现的分布式锁\n\n## 2. 基于数据库的分布式锁\n\n### 2.1 数据库悲观锁实现的分布式锁\n\n可以使用`select ... for update`来实现分布式锁。我们自己的项目，分布式定时任务 ，就使用类似的实现方案，我给大家来展示个简单版的哈\n\n表结构如下：\n\n```java\nCREATE TABLE `t_resource_lock` (\n  `key_resource` varchar(45) COLLATE utf8_bin NOT NULL DEFAULT '资源主键',\n  `status` char(1) COLLATE utf8_bin NOT NULL DEFAULT '' COMMENT 'S,F,P',\n  `lock_flag` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '1是已经锁 0是未锁',\n  `begin_time` datetime DEFAULT NULL COMMENT '开始时间',\n  `end_time` datetime DEFAULT NULL COMMENT '结束时间',\n  `client_ip` varchar(45) COLLATE utf8_bin NOT NULL DEFAULT '抢到锁的IP',\n  `time` int(10) unsigned NOT NULL DEFAULT '60' COMMENT '方法生命周期内只允许一个结点获取一次锁，单位：分钟',\n  PRIMARY KEY (`key_resource`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin\n```\n\n加锁`lock`方法的伪代码如下：\n\n```java\n@Transcational //一定要加事务\npublic boolean lock(String keyResource，int time){\n   resourceLock = 'select * from t_resource_lock where key_resource ='#{keySource}' for update';\n   \n   try{\n    if(resourceLock==null){\n      //插入锁的数据\n      resourceLock = new ResourceLock();\n      resourceLock.setTime(time);\n      resourceLock.setLockFlag(1);  //上锁\n      resourceLock.setStatus(P); //处理中\n      resourceLock.setBeginTime(new Date());\n      int count = \"insert into resourceLock\"; \n      if(count==1){\n         //获取锁成功\n         return true;\n      }\n      return false;\n   }\n   }catch(Exception x){\n      return false;\n   }\n   \n   //没上锁并且锁已经超时，即可以获取锁成功\n   if(resourceLock.getLockFlag=='0'&&'S'.equals(resourceLock.getstatus)\n    && new Date()>=resourceLock.addDateTime(resourceLock.getBeginTime(,time)){\n      resourceLock.setLockFlag(1);  //上锁\n      resourceLock.setStatus(P); //处理中\n      resourceLock.setBeginTime(new Date());\n      //update resourceLock;\n      return true;\n   }else if(new Date()>=resourceLock.addDateTime(resourceLock.getBeginTime(,time)){\n     //超时未正常执行结束,获取锁失败\n     return false;\n   }else{\n     return false;\n   } \n}\n```\n\n解锁`unlock`方法的伪代码如下：\n\n```java\npublic void unlock(String v，status){\n      resourceLock.setLockFlag(0);  //解锁\n      resourceLock.setStatus(status); S:表示成功，F表示失败\n      //update resourceLock;\n      return ;\n}\n```\n\n整体流程：\n\n```java\ntry{\nif(lock(keyResource,time)){ //加锁\n   status = process();//你的业务逻辑处理。\n }\n} finally{\n    unlock(keyResource,status); //释放锁\n}\n```\n\n其实这个悲观锁实现的分布式锁，整体的流程还是比较清晰的。就是先`select ... for update`锁住主键`key_resource`那个记录，如果为空，则可以插入一条记录，如果已有记录判断下状态和时间 ，是否已经超时 。这里需要注意一下哈，必须要加事务 哈。\n\n### 2.2 数据库乐观锁实现的分布式锁\n\n除了悲观锁，还可以用乐观锁实现分布式锁 。乐观锁，顾名思义，就是很乐观，每次更新操作，都觉得不会存在并发冲突，只有更新失败后，才重试。它是基于CAS思想实现的。我以前的公司，扣减余额 就是用这种方案。\n\n> 搞个version字段，每次更新修改，都会自增加一，然后去更新余额时，把查出来的那个版本号，带上条件去更新，如果是上次那个版本号，就更新，如果不是，表示别人并发修改过了，就继续重试。\n\n大概流程如下：\n\n1.  查询版本号和余额\n\n```java\nselect version,balance from account where user_id ='666';\n```\n\n假设查到版本号是oldVersion=1.\n\n1.  逻辑处理，判断余额\n\n```java\nif(balance<扣减金额){\n   return；\n}\n\nleft_balance = balance - 扣减金额;\n```\n\n1.  进行扣减余额\n\n```java\nupdate account set balance = #{left_balance} ,version = version+1 where version \n= #{oldVersion} and balance>= #{left_balance} and user_id ='666';\n```\n\n大家可以看下这个流程图哈：\n\n ![image_92a9dd04.png](http://markdown.liangtengyu.com:9999/images//image_92a9dd04.png) \n\n这种方式适合并发不高 的场景，一般需要设置一下重试的次数\n\n## 3.基于Redis实现的分布式锁\n\nRedis分布式锁一般有以下这几种实现方式：\n\n *  setnx + expire\n *  setnx + value值是过期时间\n *  set的扩展命令（set ex px nx）\n *  set ex px nx + 校验唯一随机值,再删除\n *  Redisson\n *  Redisson + RedLock\n\n### 3.1 setnx + expire\n\n聊到Redis分布式锁，很多小伙伴反手就是`setnx + expire`，如下：\n\n```java\nif（jedis.setnx(key,lock_value) == 1）{ //setnx加锁\n    expire（key，100）; //设置过期时间\n    try {\n        do something  //业务处理\n    }catch(){\n    }\n  finally {\n       jedis.del(key); //释放锁\n    }\n}\n```\n\n这段代码是可以加锁成功，但是你有没有发现问题，加锁操作和设置超时时间是分开的 。假设在执行完`setnx`加锁后，正要执行`expire`设置过期时间时，进程`crash`掉或者要重启维护了，那这个锁就长生不老 了，别的线程永远获取不到锁啦，所以分布式锁不能这么实现 ！\n\n### 3.2 setnx + value值是过期时间\n\n```java\nlong expires = System.currentTimeMillis() + expireTime; //系统时间+设置的过期时间\nString expiresStr = String.valueOf(expires);\n\n// 如果当前锁不存在，返回加锁成功\nif (jedis.setnx(key, expiresStr) == 1) {\n        return true;\n} \n// 如果锁已经存在，获取锁的过期时间\nString currentValueStr = jedis.get(key);\n\n// 如果获取到的过期时间，小于系统当前时间，表示已经过期\nif (currentValueStr != null && Long.parseLong(currentValueStr) < System.currentTimeMillis()) {\n\n     // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈）\n    String oldValueStr = jedis.getSet(key, expiresStr);\n    \n    if (oldValueStr != null && oldValueStr.equals(currentValueStr)) {\n         // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁\n         return true;\n    }\n}\n        \n//其他情况，均返回加锁失败\nreturn false;\n}\n```\n\n日常开发中，有些小伙伴就是这么实现分布式锁的，但是会有这些缺点 ：\n\n *  过期时间是客户端自己生成的，分布式环境下， 每个客户端的时间必须同步。\n *  没有保存持有者的唯一标识， 可能被别的客户端释放/解锁 。\n *  锁过期的时候，并发多个客户端同时请求过来，都执行了 `jedis.getSet()`，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间， 可能被别的客户端覆盖。\n\n### 3.3 set的扩展命令(set ex px nx)\n\n这个命令的几个参数分别表示什么意思呢？跟大家复习一下：\n\n```java\nSET key value [EX seconds] [PX milliseconds] [NX|XX]\n```\n\n *  EX second ：设置键的过期时间为 `second`秒。\n *  PX millisecond ：设置键的过期时间为 `millisecond`毫秒。\n *  NX ：只在键不存在时，才对键进行设置操作。\n *  XX ：只在键已经存在时，才对键进行设置操作。\n\n```java\nif（jedis.set(key, lock_value, \"NX\", \"EX\", 100s) == 1）{ //加锁\n    try {\n        do something  //业务处理\n    }catch(){\n  }\n  finally {\n       jedis.del(key); //释放锁\n    }\n}\n```\n\n这个方案可能存在这样的问题：\n\n *  锁过期释放了，业务还没执行完。\n *  锁被别的线程误删。\n\n有些伙伴可能会有个疑问，就是锁为什么会被别的线程误删 呢？假设并发多线程场景下，线程A获得了锁，但是它没释放锁的话，线程B是获取不到锁的 ，所以按道理它是执行不到加锁下面的代码滴，怎么会导致锁被别的线程误删呢？\n\n> 假设线程A和B，都想用`key`加锁，最后A抢到锁加锁成功，但是由于执行业务逻辑的耗时很长，超过了设置的超时时间`100s`。这时候，Redis就自动释放了`key`锁。这时候线程B就可以加锁成功了，接下啦，它也执行业务逻辑处理。假设碰巧这时候，A执行完自己的业务逻辑，它就去释放锁，但是它就把B的锁给释放了。\n\n### 3.4 set ex px nx + 校验唯一随机值,再删除\n\n为了解决锁被别的线程误删 问题。可以在`set ex px nx`的基础上，加上个校验的唯一随机值，如下：\n\n```java\nif（jedis.set(key, uni_request_id, \"NX\", \"EX\", 100s) == 1）{ //加锁\n    try {\n        do something  //业务处理\n    }catch(){\n  }\n  finally {\n       //判断是不是当前线程加的锁,是才释放\n       if (uni_request_id.equals(jedis.get(key))) {\n          jedis.del(key); //释放锁\n        }\n    }\n}\n```\n\n在这里，判断当前线程加的锁和释放锁不是一个原子操作 。如果调用`jedis.del()`释放锁的时候，可能这把锁已经不属于当前客户端 ，会解除他人加的锁。\n\n一般可以用lua脚本来包一下。lua脚本如下：\n\n```java\nif redis.call('get',KEYS[1]) == ARGV[1] then \n   return redis.call('del',KEYS[1]) \nelse\n   return 0\nend;\n```\n\n这种方式比较不错了，一般情况下，已经可以使用这种实现方式。但是还是存在：锁过期释放了，业务还没执行完的问题 。\n\n### 3.5 Redisson\n\n对于可能存在锁过期释放，业务没执行完 的问题。我们可以稍微把锁过期时间设置长一些，大于正常业务处理时间就好啦。如果你觉得不是很稳，还可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。\n\n当前开源框架Redisson解决了这个问题。可以看下Redisson底层原理图：\n\n ![image_6ae9d764.png](http://markdown.liangtengyu.com:9999/images//image_6ae9d764.png) \n\n只要线程一加锁成功，就会启动一个`watch dog`看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用`watch dog`解决了锁过期释放，业务没执行完问题 。\n\n### 3.6 Redisson + RedLock\n\n前面六种方案都只是基于Redis单机版 的分布式锁讨论，还不是很完美。因为Redis 一般都是集群部署的：\n\n ![image_f90141b7.png](http://markdown.liangtengyu.com:9999/images//image_f90141b7.png) \n\n如果线程一在`Redis`的`master`节点上拿到了锁，但是加锁的`key`还没同步到`slave`节点。恰好这时，`master`节点发生故障，一个`slave`节点就会升级为`master`节点。线程二就可以顺理成章获取同个`key`的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。\n\n为了解决这个问题，Redis作者antirez提出一种高级的分布式锁算法：Redlock 。它的核心思想是这样的：\n\n> 部署多个Redis master，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。\n\n我们假设当前有5个Redis master节点，在5台服务器上面运行这些Redis实例。\n\n ![image_669de3e0.png](http://markdown.liangtengyu.com:9999/images//image_669de3e0.png) RedLock的实现步骤:\n\n1.  获取当前时间，以毫秒为单位。\n2.  按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。\n3.  客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1，这里是5/2+1=3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s> 30ms+40ms+50ms+4m0s+50ms）\n4.  如果取到了锁，key的真正有效时间就变啦，需要减去获取锁所使用的时间。\n5.  如果获取锁失败（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。\n\n简化下步骤就是：\n\n *  按顺序向5个master节点请求加锁\n *  根据设置的超时时间来判断，是不是要跳过该master节点。\n *  如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。\n *  如果获取锁失败，解锁！\n\nRedisson实现了redLock版本的锁 ，有兴趣的小伙伴，可以去了解一下哈~\n\n## 4. Zookeeper分布式锁\n\n在学习Zookeeper分布式锁之前，我们复习一下Zookeeper的节点哈。\n\nZookeeper的节点Znode有四种类型：\n\n *  持久节点 ：默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在。\n *  持久节点顺序节点 ：所谓顺序节点，就是在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号，持久节点顺序节点就是有顺序的持久节点。\n *  临时节点 ：和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。\n *  临时顺序节点 ：有顺序的临时节点。\n\nZookeeper分布式锁实现应用了临时顺序节点 。这里不贴代码啦，来讲下zk分布式锁的实现原理吧。\n\n### 4.1 zk获取锁过程\n\n当第一个客户端请求过来时，Zookeeper客户端会创建一个持久节点`locks`。如果它（Client1）想获得锁，需要在`locks`节点下创建一个顺序节点`lock1`.如图\n\n ![image_bd68a96a.png](http://markdown.liangtengyu.com:9999/images//image_bd68a96a.png) \n\n接着，客户端Client1会查找`locks`下面的所有临时顺序子节点，判断自己的节点`lock1`是不是排序最小的那一个，如果是，则成功获得锁。\n\n ![image_d2f64ca3.png](http://markdown.liangtengyu.com:9999/images//image_d2f64ca3.png) \n\n这时候如果又来一个客户端client2前来尝试获得锁，它会在locks下再创建一个临时节点`lock2`\n\n ![image_071b7d88.png](http://markdown.liangtengyu.com:9999/images//image_071b7d88.png) \n\n客户端client2一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock2是不是最小的，此时，发现lock1才是最小的，于是获取锁失败。获取锁失败，它是不会甘心的，client2向它排序靠前的节点lock1注册Watcher事件，用来监听lock1是否存在，也就是说client2抢锁失败进入等待状态。\n\n ![image_b489bef9.png](http://markdown.liangtengyu.com:9999/images//image_b489bef9.png) \n\n此时，如果再来一个客户端Client3来尝试获取锁，它会在locks下再创建一个临时节点lock3\n\n ![image_aa38b5f6.png](http://markdown.liangtengyu.com:9999/images//image_aa38b5f6.png) 同样的，client3一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock3是不是最小的，发现自己不是最小的，就获取锁失败。它也是不会甘心的，它会向在它前面的节点lock2注册Watcher事件，以监听lock2节点是否存在。\n\n ![image_1cec9bce.png](http://markdown.liangtengyu.com:9999/images//image_1cec9bce.png) \n\n### 4.2 释放锁\n\n我们再来看看释放锁的流程，Zookeeper的客户端业务完成或者发生故障，都会删除临时节点，释放锁。如果是任务完成，Client1会显式调用删除lock1的指令\n\n ![image_93a8ea85.png](http://markdown.liangtengyu.com:9999/images//image_93a8ea85.png) \n\n如果是客户端故障了，根据临时节点得特性，lock1是会自动删除的\n\n ![image_e929ee6e.png](http://markdown.liangtengyu.com:9999/images//image_e929ee6e.png) \n\nlock1节点被删除后，Client2可开心了，因为它一直监听着lock1。lock1节点删除，Client2立刻收到通知，也会查找locks下面的所有临时顺序子节点，发下lock2是最小，就获得锁。\n\n ![image_5b5c8168.png](http://markdown.liangtengyu.com:9999/images//image_5b5c8168.png) \n\n同理，Client2获得锁之后，Client3也对它虎视眈眈，啊哈哈~\n\n *  Zookeeper设计定位就是分布式协调，简单易用。如果获取不到锁，只需添加一个监听器即可，很适合做分布式锁。\n *  Zookeeper作为分布式锁也缺点：如果有很多的客户端频繁的申请加锁、释放锁，对于Zookeeper集群的压力会比较大。\n\n## 5. 三种分布式锁对比\n\n### 5.1 数据库分布式锁实现\n\n优点：\n\n *  简单，使用方便，不需要引入 `Redis、zookeeper`等中间件。\n\n缺点：\n\n *  不适合高并发的场景\n *  db操作性能较差；\n\n### 5.2 Redis分布式锁实现\n\n优点：\n\n *  性能好，适合高并发场景\n *  较轻量级\n *  有较好的框架支持，如Redisson\n\n缺点：\n\n *  过期时间不好控制\n *  需要考虑锁被别的线程误删场景\n\n### 5.3 Zookeeper分布式锁实现\n\n缺点：\n\n *  性能不如redis实现的分布式锁\n *  比较重的分布式锁。\n\n优点：\n\n *  有较好的性能和可靠性\n *  有封装较好的框架，如Curator\n\n### 5.4 对比汇总\n\n *  从性能角度（从高到低）Redis > Zookeeper >= 数据库；\n *  从理解的难易程度角度（从低到高）数据库 > Redis > Zookeeper；\n *  从实现的复杂性角度（从低到高）Zookeeper > Redis > 数据库；\n *  从可靠性角度（从高到低）Zookeeper > Redis > 数据库。\n","slug":"分布式锁的多种实现","published":1,"updated":"2022-11-09T03:28:46.407Z","_id":"cla92uluj0000fdld41jbaz3k","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li> 分布式锁概述</li>\n<li> 数据库分布式锁</li>\n<li> Redis分布式锁</li>\n<li> Zookeeper分布式锁</li>\n<li> 三种分布式锁对比</li>\n</ul>\n<h2 id=\"1-分布式锁概述\"><a href=\"#1-分布式锁概述\" class=\"headerlink\" title=\"1. 分布式锁概述\"></a>1. 分布式锁概述</h2><p>我们的系统都是分布式部署的，日常开发中，秒杀下单、抢购商品 等等业务场景，为了防⽌库存超卖，都需要用到分布式锁 。</p>\n<blockquote>\n<p>分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。</p>\n</blockquote>\n<p>业界流行的分布式锁实现，一般有这3种方式：</p>\n<ul>\n<li> 基于数据库实现的分布式锁</li>\n<li> 基于Redis实现的分布式锁</li>\n<li> 基于Zookeeper实现的分布式锁</li>\n</ul>\n<h2 id=\"2-基于数据库的分布式锁\"><a href=\"#2-基于数据库的分布式锁\" class=\"headerlink\" title=\"2. 基于数据库的分布式锁\"></a>2. 基于数据库的分布式锁</h2><h3 id=\"2-1-数据库悲观锁实现的分布式锁\"><a href=\"#2-1-数据库悲观锁实现的分布式锁\" class=\"headerlink\" title=\"2.1 数据库悲观锁实现的分布式锁\"></a>2.1 数据库悲观锁实现的分布式锁</h3><p>可以使用<code>select ... for update</code>来实现分布式锁。我们自己的项目，分布式定时任务 ，就使用类似的实现方案，我给大家来展示个简单版的哈</p>\n<p>表结构如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">CREATE TABLE `t_resource_lock` <span class=\"token punctuation\">(</span>\n  `key_resource` <span class=\"token function\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">45</span><span class=\"token punctuation\">)</span> COLLATE utf8_bin NOT NULL DEFAULT <span class=\"token string\">'资源主键'</span><span class=\"token punctuation\">,</span>\n  `status` <span class=\"token keyword\">char</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> COLLATE utf8_bin NOT NULL DEFAULT <span class=\"token string\">''</span> COMMENT <span class=\"token string\">'S,F,P'</span><span class=\"token punctuation\">,</span>\n  `lock_flag` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> unsigned NOT NULL DEFAULT <span class=\"token string\">'0'</span> COMMENT <span class=\"token string\">'1是已经锁 0是未锁'</span><span class=\"token punctuation\">,</span>\n  `begin_time` datetime DEFAULT NULL COMMENT <span class=\"token string\">'开始时间'</span><span class=\"token punctuation\">,</span>\n  `end_time` datetime DEFAULT NULL COMMENT <span class=\"token string\">'结束时间'</span><span class=\"token punctuation\">,</span>\n  `client_ip` <span class=\"token function\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">45</span><span class=\"token punctuation\">)</span> COLLATE utf8_bin NOT NULL DEFAULT <span class=\"token string\">'抢到锁的IP'</span><span class=\"token punctuation\">,</span>\n  `time` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> unsigned NOT NULL DEFAULT <span class=\"token string\">'60'</span> COMMENT <span class=\"token string\">'方法生命周期内只允许一个结点获取一次锁，单位：分钟'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\">PRIMARY</span> KEY <span class=\"token punctuation\">(</span>`key_resource`<span class=\"token punctuation\">)</span> <span class=\"token class-name\">USING</span> BTREE\n<span class=\"token punctuation\">)</span> ENGINE<span class=\"token operator\">=</span><span class=\"token class-name\">InnoDB</span> <span class=\"token class-name\">DEFAULT</span> CHARSET<span class=\"token operator\">=</span>utf8 COLLATE<span class=\"token operator\">=</span>utf8_bin<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>加锁<code>lock</code>方法的伪代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Transcational</span> <span class=\"token comment\">//一定要加事务</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> keyResource，<span class=\"token keyword\">int</span> time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n   resourceLock <span class=\"token operator\">=</span> <span class=\"token string\">'select * from t_resource_lock where key_resource ='</span>#<span class=\"token punctuation\">&#123;</span>keySource<span class=\"token punctuation\">&#125;</span><span class=\"token string\">' for update'</span><span class=\"token punctuation\">;</span>\n   \n   <span class=\"token keyword\">try</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>resourceLock<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//插入锁的数据</span>\n      resourceLock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ResourceLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setTime</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setLockFlag</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//上锁</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setStatus</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">P</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//处理中</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setBeginTime</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token string\">\"insert into resourceLock\"</span><span class=\"token punctuation\">;</span> \n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>count<span class=\"token operator\">==</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n         <span class=\"token comment\">//获取锁成功</span>\n         <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">&#125;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span>\n   <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span>\n   \n   <span class=\"token comment\">//没上锁并且锁已经超时，即可以获取锁成功</span>\n   <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>resourceLock<span class=\"token punctuation\">.</span>getLockFlag<span class=\"token operator\">==</span><span class=\"token string\">'0'</span><span class=\"token operator\">&amp;&amp;</span><span class=\"token string\">'S'</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>resourceLock<span class=\"token punctuation\">.</span>getstatus<span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">>=</span>resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">addDateTime</span><span class=\"token punctuation\">(</span>resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">getBeginTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span>time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setLockFlag</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//上锁</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setStatus</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">P</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//处理中</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setBeginTime</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//update resourceLock;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">>=</span>resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">addDateTime</span><span class=\"token punctuation\">(</span>resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">getBeginTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span>time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token comment\">//超时未正常执行结束,获取锁失败</span>\n     <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>解锁<code>unlock</code>方法的伪代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> v，status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setLockFlag</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//解锁</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setStatus</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token class-name\">S</span><span class=\"token operator\">:</span>表示成功，<span class=\"token class-name\">F</span>表示失败\n      <span class=\"token comment\">//update resourceLock;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>整体流程：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">try</span><span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>keyResource<span class=\"token punctuation\">,</span>time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//加锁</span>\n   status <span class=\"token operator\">=</span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//你的业务逻辑处理。</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">finally</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span>keyResource<span class=\"token punctuation\">,</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//释放锁</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其实这个悲观锁实现的分布式锁，整体的流程还是比较清晰的。就是先<code>select ... for update</code>锁住主键<code>key_resource</code>那个记录，如果为空，则可以插入一条记录，如果已有记录判断下状态和时间 ，是否已经超时 。这里需要注意一下哈，必须要加事务 哈。</p>\n<h3 id=\"2-2-数据库乐观锁实现的分布式锁\"><a href=\"#2-2-数据库乐观锁实现的分布式锁\" class=\"headerlink\" title=\"2.2 数据库乐观锁实现的分布式锁\"></a>2.2 数据库乐观锁实现的分布式锁</h3><p>除了悲观锁，还可以用乐观锁实现分布式锁 。乐观锁，顾名思义，就是很乐观，每次更新操作，都觉得不会存在并发冲突，只有更新失败后，才重试。它是基于CAS思想实现的。我以前的公司，扣减余额 就是用这种方案。</p>\n<blockquote>\n<p>搞个version字段，每次更新修改，都会自增加一，然后去更新余额时，把查出来的那个版本号，带上条件去更新，如果是上次那个版本号，就更新，如果不是，表示别人并发修改过了，就继续重试。</p>\n</blockquote>\n<p>大概流程如下：</p>\n<ol>\n<li> 查询版本号和余额</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">select version<span class=\"token punctuation\">,</span>balance from account where user_id <span class=\"token operator\">=</span><span class=\"token string\">'666'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>假设查到版本号是oldVersion=1.</p>\n<ol>\n<li> 逻辑处理，判断余额</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>balance<span class=\"token operator\">&lt;</span>扣减金额<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">return</span>；\n<span class=\"token punctuation\">&#125;</span>\n\nleft_balance <span class=\"token operator\">=</span> balance <span class=\"token operator\">-</span> 扣减金额<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol>\n<li> 进行扣减余额</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">update account set balance <span class=\"token operator\">=</span> #<span class=\"token punctuation\">&#123;</span>left_balance<span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">,</span>version <span class=\"token operator\">=</span> version<span class=\"token operator\">+</span><span class=\"token number\">1</span> where version \n<span class=\"token operator\">=</span> #<span class=\"token punctuation\">&#123;</span>oldVersion<span class=\"token punctuation\">&#125;</span> and balance<span class=\"token operator\">>=</span> #<span class=\"token punctuation\">&#123;</span>left_balance<span class=\"token punctuation\">&#125;</span> and user_id <span class=\"token operator\">=</span><span class=\"token string\">'666'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>大家可以看下这个流程图哈：</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_92a9dd04.png\" alt=\"image_92a9dd04.png\"> </p>\n<p>这种方式适合并发不高 的场景，一般需要设置一下重试的次数</p>\n<h2 id=\"3-基于Redis实现的分布式锁\"><a href=\"#3-基于Redis实现的分布式锁\" class=\"headerlink\" title=\"3.基于Redis实现的分布式锁\"></a>3.基于Redis实现的分布式锁</h2><p>Redis分布式锁一般有以下这几种实现方式：</p>\n<ul>\n<li> setnx + expire</li>\n<li> setnx + value值是过期时间</li>\n<li> set的扩展命令（set ex px nx）</li>\n<li> set ex px nx + 校验唯一随机值,再删除</li>\n<li> Redisson</li>\n<li> Redisson + RedLock</li>\n</ul>\n<h3 id=\"3-1-setnx-expire\"><a href=\"#3-1-setnx-expire\" class=\"headerlink\" title=\"3.1 setnx + expire\"></a>3.1 setnx + expire</h3><p>聊到Redis分布式锁，很多小伙伴反手就是<code>setnx + expire</code>，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">if</span>（jedis<span class=\"token punctuation\">.</span><span class=\"token function\">setnx</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span>lock_value<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span>）<span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//setnx加锁</span>\n    expire（key，<span class=\"token number\">100</span>）<span class=\"token punctuation\">;</span> <span class=\"token comment\">//设置过期时间</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">do</span> something  <span class=\"token comment\">//业务处理</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span>\n       jedis<span class=\"token punctuation\">.</span><span class=\"token function\">del</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//释放锁</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这段代码是可以加锁成功，但是你有没有发现问题，加锁操作和设置超时时间是分开的 。假设在执行完<code>setnx</code>加锁后，正要执行<code>expire</code>设置过期时间时，进程<code>crash</code>掉或者要重启维护了，那这个锁就长生不老 了，别的线程永远获取不到锁啦，所以分布式锁不能这么实现 ！</p>\n<h3 id=\"3-2-setnx-value值是过期时间\"><a href=\"#3-2-setnx-value值是过期时间\" class=\"headerlink\" title=\"3.2 setnx + value值是过期时间\"></a>3.2 setnx + value值是过期时间</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">long</span> expires <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> expireTime<span class=\"token punctuation\">;</span> <span class=\"token comment\">//系统时间+设置的过期时间</span>\n<span class=\"token class-name\">String</span> expiresStr <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>expires<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 如果当前锁不存在，返回加锁成功</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>jedis<span class=\"token punctuation\">.</span><span class=\"token function\">setnx</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> expiresStr<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token comment\">// 如果锁已经存在，获取锁的过期时间</span>\n<span class=\"token class-name\">String</span> currentValueStr <span class=\"token operator\">=</span> jedis<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 如果获取到的过期时间，小于系统当前时间，表示已经过期</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>currentValueStr <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token class-name\">Long</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseLong</span><span class=\"token punctuation\">(</span>currentValueStr<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n     <span class=\"token comment\">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈）</span>\n    <span class=\"token class-name\">String</span> oldValueStr <span class=\"token operator\">=</span> jedis<span class=\"token punctuation\">.</span><span class=\"token function\">getSet</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> expiresStr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldValueStr <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> oldValueStr<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>currentValueStr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n         <span class=\"token comment\">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁</span>\n         <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n        \n<span class=\"token comment\">//其他情况，均返回加锁失败</span>\n<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>日常开发中，有些小伙伴就是这么实现分布式锁的，但是会有这些缺点 ：</p>\n<ul>\n<li> 过期时间是客户端自己生成的，分布式环境下， 每个客户端的时间必须同步。</li>\n<li> 没有保存持有者的唯一标识， 可能被别的客户端释放/解锁 。</li>\n<li> 锁过期的时候，并发多个客户端同时请求过来，都执行了 <code>jedis.getSet()</code>，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间， 可能被别的客户端覆盖。</li>\n</ul>\n<h3 id=\"3-3-set的扩展命令-set-ex-px-nx\"><a href=\"#3-3-set的扩展命令-set-ex-px-nx\" class=\"headerlink\" title=\"3.3 set的扩展命令(set ex px nx)\"></a>3.3 set的扩展命令(set ex px nx)</h3><p>这个命令的几个参数分别表示什么意思呢？跟大家复习一下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">SET key value <span class=\"token punctuation\">[</span>EX seconds<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>PX milliseconds<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>NX<span class=\"token operator\">|</span>XX<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li> EX second ：设置键的过期时间为 <code>second</code>秒。</li>\n<li> PX millisecond ：设置键的过期时间为 <code>millisecond</code>毫秒。</li>\n<li> NX ：只在键不存在时，才对键进行设置操作。</li>\n<li> XX ：只在键已经存在时，才对键进行设置操作。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">if</span>（jedis<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> lock_value<span class=\"token punctuation\">,</span> <span class=\"token string\">\"NX\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"EX\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span>s<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span>）<span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//加锁</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">do</span> something  <span class=\"token comment\">//业务处理</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span>\n       jedis<span class=\"token punctuation\">.</span><span class=\"token function\">del</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//释放锁</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个方案可能存在这样的问题：</p>\n<ul>\n<li> 锁过期释放了，业务还没执行完。</li>\n<li> 锁被别的线程误删。</li>\n</ul>\n<p>有些伙伴可能会有个疑问，就是锁为什么会被别的线程误删 呢？假设并发多线程场景下，线程A获得了锁，但是它没释放锁的话，线程B是获取不到锁的 ，所以按道理它是执行不到加锁下面的代码滴，怎么会导致锁被别的线程误删呢？</p>\n<blockquote>\n<p>假设线程A和B，都想用<code>key</code>加锁，最后A抢到锁加锁成功，但是由于执行业务逻辑的耗时很长，超过了设置的超时时间<code>100s</code>。这时候，Redis就自动释放了<code>key</code>锁。这时候线程B就可以加锁成功了，接下啦，它也执行业务逻辑处理。假设碰巧这时候，A执行完自己的业务逻辑，它就去释放锁，但是它就把B的锁给释放了。</p>\n</blockquote>\n<h3 id=\"3-4-set-ex-px-nx-校验唯一随机值-再删除\"><a href=\"#3-4-set-ex-px-nx-校验唯一随机值-再删除\" class=\"headerlink\" title=\"3.4 set ex px nx + 校验唯一随机值,再删除\"></a>3.4 set ex px nx + 校验唯一随机值,再删除</h3><p>为了解决锁被别的线程误删 问题。可以在<code>set ex px nx</code>的基础上，加上个校验的唯一随机值，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">if</span>（jedis<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> uni_request_id<span class=\"token punctuation\">,</span> <span class=\"token string\">\"NX\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"EX\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span>s<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span>）<span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//加锁</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">do</span> something  <span class=\"token comment\">//业务处理</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token comment\">//判断是不是当前线程加的锁,是才释放</span>\n       <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>uni_request_id<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>jedis<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n          jedis<span class=\"token punctuation\">.</span><span class=\"token function\">del</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//释放锁</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在这里，判断当前线程加的锁和释放锁不是一个原子操作 。如果调用<code>jedis.del()</code>释放锁的时候，可能这把锁已经不属于当前客户端 ，会解除他人加的锁。</p>\n<p>一般可以用lua脚本来包一下。lua脚本如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> redis<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token string\">'get'</span><span class=\"token punctuation\">,</span>KEYS<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> ARGV<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> then \n   <span class=\"token keyword\">return</span> redis<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token string\">'del'</span><span class=\"token punctuation\">,</span>KEYS<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> \n<span class=\"token keyword\">else</span>\n   <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\nend<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这种方式比较不错了，一般情况下，已经可以使用这种实现方式。但是还是存在：锁过期释放了，业务还没执行完的问题 。</p>\n<h3 id=\"3-5-Redisson\"><a href=\"#3-5-Redisson\" class=\"headerlink\" title=\"3.5 Redisson\"></a>3.5 Redisson</h3><p>对于可能存在锁过期释放，业务没执行完 的问题。我们可以稍微把锁过期时间设置长一些，大于正常业务处理时间就好啦。如果你觉得不是很稳，还可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。</p>\n<p>当前开源框架Redisson解决了这个问题。可以看下Redisson底层原理图：</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_6ae9d764.png\" alt=\"image_6ae9d764.png\"> </p>\n<p>只要线程一加锁成功，就会启动一个<code>watch dog</code>看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用<code>watch dog</code>解决了锁过期释放，业务没执行完问题 。</p>\n<h3 id=\"3-6-Redisson-RedLock\"><a href=\"#3-6-Redisson-RedLock\" class=\"headerlink\" title=\"3.6 Redisson + RedLock\"></a>3.6 Redisson + RedLock</h3><p>前面六种方案都只是基于Redis单机版 的分布式锁讨论，还不是很完美。因为Redis 一般都是集群部署的：</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_f90141b7.png\" alt=\"image_f90141b7.png\"> </p>\n<p>如果线程一在<code>Redis</code>的<code>master</code>节点上拿到了锁，但是加锁的<code>key</code>还没同步到<code>slave</code>节点。恰好这时，<code>master</code>节点发生故障，一个<code>slave</code>节点就会升级为<code>master</code>节点。线程二就可以顺理成章获取同个<code>key</code>的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。</p>\n<p>为了解决这个问题，Redis作者antirez提出一种高级的分布式锁算法：Redlock 。它的核心思想是这样的：</p>\n<blockquote>\n<p>部署多个Redis master，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。</p>\n</blockquote>\n<p>我们假设当前有5个Redis master节点，在5台服务器上面运行这些Redis实例。</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_669de3e0.png\" alt=\"image_669de3e0.png\"> RedLock的实现步骤:</p>\n<ol>\n<li> 获取当前时间，以毫秒为单位。</li>\n<li> 按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。</li>\n<li> 客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1，这里是5/2+1=3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s&gt; 30ms+40ms+50ms+4m0s+50ms）</li>\n<li> 如果取到了锁，key的真正有效时间就变啦，需要减去获取锁所使用的时间。</li>\n<li> 如果获取锁失败（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。</li>\n</ol>\n<p>简化下步骤就是：</p>\n<ul>\n<li> 按顺序向5个master节点请求加锁</li>\n<li> 根据设置的超时时间来判断，是不是要跳过该master节点。</li>\n<li> 如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。</li>\n<li> 如果获取锁失败，解锁！</li>\n</ul>\n<p>Redisson实现了redLock版本的锁 ，有兴趣的小伙伴，可以去了解一下哈~</p>\n<h2 id=\"4-Zookeeper分布式锁\"><a href=\"#4-Zookeeper分布式锁\" class=\"headerlink\" title=\"4. Zookeeper分布式锁\"></a>4. Zookeeper分布式锁</h2><p>在学习Zookeeper分布式锁之前，我们复习一下Zookeeper的节点哈。</p>\n<p>Zookeeper的节点Znode有四种类型：</p>\n<ul>\n<li> 持久节点 ：默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在。</li>\n<li> 持久节点顺序节点 ：所谓顺序节点，就是在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号，持久节点顺序节点就是有顺序的持久节点。</li>\n<li> 临时节点 ：和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。</li>\n<li> 临时顺序节点 ：有顺序的临时节点。</li>\n</ul>\n<p>Zookeeper分布式锁实现应用了临时顺序节点 。这里不贴代码啦，来讲下zk分布式锁的实现原理吧。</p>\n<h3 id=\"4-1-zk获取锁过程\"><a href=\"#4-1-zk获取锁过程\" class=\"headerlink\" title=\"4.1 zk获取锁过程\"></a>4.1 zk获取锁过程</h3><p>当第一个客户端请求过来时，Zookeeper客户端会创建一个持久节点<code>locks</code>。如果它（Client1）想获得锁，需要在<code>locks</code>节点下创建一个顺序节点<code>lock1</code>.如图</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_bd68a96a.png\" alt=\"image_bd68a96a.png\"> </p>\n<p>接着，客户端Client1会查找<code>locks</code>下面的所有临时顺序子节点，判断自己的节点<code>lock1</code>是不是排序最小的那一个，如果是，则成功获得锁。</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_d2f64ca3.png\" alt=\"image_d2f64ca3.png\"> </p>\n<p>这时候如果又来一个客户端client2前来尝试获得锁，它会在locks下再创建一个临时节点<code>lock2</code></p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_071b7d88.png\" alt=\"image_071b7d88.png\"> </p>\n<p>客户端client2一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock2是不是最小的，此时，发现lock1才是最小的，于是获取锁失败。获取锁失败，它是不会甘心的，client2向它排序靠前的节点lock1注册Watcher事件，用来监听lock1是否存在，也就是说client2抢锁失败进入等待状态。</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_b489bef9.png\" alt=\"image_b489bef9.png\"> </p>\n<p>此时，如果再来一个客户端Client3来尝试获取锁，它会在locks下再创建一个临时节点lock3</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_aa38b5f6.png\" alt=\"image_aa38b5f6.png\"> 同样的，client3一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock3是不是最小的，发现自己不是最小的，就获取锁失败。它也是不会甘心的，它会向在它前面的节点lock2注册Watcher事件，以监听lock2节点是否存在。</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_1cec9bce.png\" alt=\"image_1cec9bce.png\"> </p>\n<h3 id=\"4-2-释放锁\"><a href=\"#4-2-释放锁\" class=\"headerlink\" title=\"4.2 释放锁\"></a>4.2 释放锁</h3><p>我们再来看看释放锁的流程，Zookeeper的客户端业务完成或者发生故障，都会删除临时节点，释放锁。如果是任务完成，Client1会显式调用删除lock1的指令</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_93a8ea85.png\" alt=\"image_93a8ea85.png\"> </p>\n<p>如果是客户端故障了，根据临时节点得特性，lock1是会自动删除的</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_e929ee6e.png\" alt=\"image_e929ee6e.png\"> </p>\n<p>lock1节点被删除后，Client2可开心了，因为它一直监听着lock1。lock1节点删除，Client2立刻收到通知，也会查找locks下面的所有临时顺序子节点，发下lock2是最小，就获得锁。</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_5b5c8168.png\" alt=\"image_5b5c8168.png\"> </p>\n<p>同理，Client2获得锁之后，Client3也对它虎视眈眈，啊哈哈~</p>\n<ul>\n<li> Zookeeper设计定位就是分布式协调，简单易用。如果获取不到锁，只需添加一个监听器即可，很适合做分布式锁。</li>\n<li> Zookeeper作为分布式锁也缺点：如果有很多的客户端频繁的申请加锁、释放锁，对于Zookeeper集群的压力会比较大。</li>\n</ul>\n<h2 id=\"5-三种分布式锁对比\"><a href=\"#5-三种分布式锁对比\" class=\"headerlink\" title=\"5. 三种分布式锁对比\"></a>5. 三种分布式锁对比</h2><h3 id=\"5-1-数据库分布式锁实现\"><a href=\"#5-1-数据库分布式锁实现\" class=\"headerlink\" title=\"5.1 数据库分布式锁实现\"></a>5.1 数据库分布式锁实现</h3><p>优点：</p>\n<ul>\n<li> 简单，使用方便，不需要引入 <code>Redis、zookeeper</code>等中间件。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li> 不适合高并发的场景</li>\n<li> db操作性能较差；</li>\n</ul>\n<h3 id=\"5-2-Redis分布式锁实现\"><a href=\"#5-2-Redis分布式锁实现\" class=\"headerlink\" title=\"5.2 Redis分布式锁实现\"></a>5.2 Redis分布式锁实现</h3><p>优点：</p>\n<ul>\n<li> 性能好，适合高并发场景</li>\n<li> 较轻量级</li>\n<li> 有较好的框架支持，如Redisson</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li> 过期时间不好控制</li>\n<li> 需要考虑锁被别的线程误删场景</li>\n</ul>\n<h3 id=\"5-3-Zookeeper分布式锁实现\"><a href=\"#5-3-Zookeeper分布式锁实现\" class=\"headerlink\" title=\"5.3 Zookeeper分布式锁实现\"></a>5.3 Zookeeper分布式锁实现</h3><p>缺点：</p>\n<ul>\n<li> 性能不如redis实现的分布式锁</li>\n<li> 比较重的分布式锁。</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li> 有较好的性能和可靠性</li>\n<li> 有封装较好的框架，如Curator</li>\n</ul>\n<h3 id=\"5-4-对比汇总\"><a href=\"#5-4-对比汇总\" class=\"headerlink\" title=\"5.4 对比汇总\"></a>5.4 对比汇总</h3><ul>\n<li> 从性能角度（从高到低）Redis &gt; Zookeeper &gt;= 数据库；</li>\n<li> 从理解的难易程度角度（从低到高）数据库 &gt; Redis &gt; Zookeeper；</li>\n<li> 从实现的复杂性角度（从低到高）Zookeeper &gt; Redis &gt; 数据库；</li>\n<li> 从可靠性角度（从高到低）Zookeeper &gt; Redis &gt; 数据库。</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<ul>\n<li> 分布式锁概述</li>\n<li> 数据库分布式锁</li>\n<li> Redis分布式锁</li>\n<li> Zookeeper分布式锁</li>\n<li> 三种分布式锁对比</li>\n</ul>\n<h2 id=\"1-分布式锁概述\"><a href=\"#1-分布式锁概述\" class=\"headerlink\" title=\"1. 分布式锁概述\"></a>1. 分布式锁概述</h2><p>我们的系统都是分布式部署的，日常开发中，秒杀下单、抢购商品 等等业务场景，为了防⽌库存超卖，都需要用到分布式锁 。</p>\n<blockquote>\n<p>分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。</p>\n</blockquote>\n<p>业界流行的分布式锁实现，一般有这3种方式：</p>\n<ul>\n<li> 基于数据库实现的分布式锁</li>\n<li> 基于Redis实现的分布式锁</li>\n<li> 基于Zookeeper实现的分布式锁</li>\n</ul>\n<h2 id=\"2-基于数据库的分布式锁\"><a href=\"#2-基于数据库的分布式锁\" class=\"headerlink\" title=\"2. 基于数据库的分布式锁\"></a>2. 基于数据库的分布式锁</h2><h3 id=\"2-1-数据库悲观锁实现的分布式锁\"><a href=\"#2-1-数据库悲观锁实现的分布式锁\" class=\"headerlink\" title=\"2.1 数据库悲观锁实现的分布式锁\"></a>2.1 数据库悲观锁实现的分布式锁</h3><p>可以使用<code>select ... for update</code>来实现分布式锁。我们自己的项目，分布式定时任务 ，就使用类似的实现方案，我给大家来展示个简单版的哈</p>\n<p>表结构如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">CREATE TABLE `t_resource_lock` <span class=\"token punctuation\">(</span>\n  `key_resource` <span class=\"token function\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">45</span><span class=\"token punctuation\">)</span> COLLATE utf8_bin NOT NULL DEFAULT <span class=\"token string\">'资源主键'</span><span class=\"token punctuation\">,</span>\n  `status` <span class=\"token keyword\">char</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> COLLATE utf8_bin NOT NULL DEFAULT <span class=\"token string\">''</span> COMMENT <span class=\"token string\">'S,F,P'</span><span class=\"token punctuation\">,</span>\n  `lock_flag` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> unsigned NOT NULL DEFAULT <span class=\"token string\">'0'</span> COMMENT <span class=\"token string\">'1是已经锁 0是未锁'</span><span class=\"token punctuation\">,</span>\n  `begin_time` datetime DEFAULT NULL COMMENT <span class=\"token string\">'开始时间'</span><span class=\"token punctuation\">,</span>\n  `end_time` datetime DEFAULT NULL COMMENT <span class=\"token string\">'结束时间'</span><span class=\"token punctuation\">,</span>\n  `client_ip` <span class=\"token function\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">45</span><span class=\"token punctuation\">)</span> COLLATE utf8_bin NOT NULL DEFAULT <span class=\"token string\">'抢到锁的IP'</span><span class=\"token punctuation\">,</span>\n  `time` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> unsigned NOT NULL DEFAULT <span class=\"token string\">'60'</span> COMMENT <span class=\"token string\">'方法生命周期内只允许一个结点获取一次锁，单位：分钟'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\">PRIMARY</span> KEY <span class=\"token punctuation\">(</span>`key_resource`<span class=\"token punctuation\">)</span> <span class=\"token class-name\">USING</span> BTREE\n<span class=\"token punctuation\">)</span> ENGINE<span class=\"token operator\">=</span><span class=\"token class-name\">InnoDB</span> <span class=\"token class-name\">DEFAULT</span> CHARSET<span class=\"token operator\">=</span>utf8 COLLATE<span class=\"token operator\">=</span>utf8_bin<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>加锁<code>lock</code>方法的伪代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Transcational</span> <span class=\"token comment\">//一定要加事务</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> keyResource，<span class=\"token keyword\">int</span> time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n   resourceLock <span class=\"token operator\">=</span> <span class=\"token string\">'select * from t_resource_lock where key_resource ='</span>#<span class=\"token punctuation\">&#123;</span>keySource<span class=\"token punctuation\">&#125;</span><span class=\"token string\">' for update'</span><span class=\"token punctuation\">;</span>\n   \n   <span class=\"token keyword\">try</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>resourceLock<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token comment\">//插入锁的数据</span>\n      resourceLock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ResourceLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setTime</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setLockFlag</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//上锁</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setStatus</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">P</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//处理中</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setBeginTime</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> <span class=\"token string\">\"insert into resourceLock\"</span><span class=\"token punctuation\">;</span> \n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>count<span class=\"token operator\">==</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n         <span class=\"token comment\">//获取锁成功</span>\n         <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">&#125;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span>\n   <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span>\n   \n   <span class=\"token comment\">//没上锁并且锁已经超时，即可以获取锁成功</span>\n   <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>resourceLock<span class=\"token punctuation\">.</span>getLockFlag<span class=\"token operator\">==</span><span class=\"token string\">'0'</span><span class=\"token operator\">&amp;&amp;</span><span class=\"token string\">'S'</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>resourceLock<span class=\"token punctuation\">.</span>getstatus<span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">>=</span>resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">addDateTime</span><span class=\"token punctuation\">(</span>resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">getBeginTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span>time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setLockFlag</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//上锁</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setStatus</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">P</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//处理中</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setBeginTime</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">//update resourceLock;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">>=</span>resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">addDateTime</span><span class=\"token punctuation\">(</span>resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">getBeginTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">,</span>time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token comment\">//超时未正常执行结束,获取锁失败</span>\n     <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>解锁<code>unlock</code>方法的伪代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> v，status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setLockFlag</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//解锁</span>\n      resourceLock<span class=\"token punctuation\">.</span><span class=\"token function\">setStatus</span><span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token class-name\">S</span><span class=\"token operator\">:</span>表示成功，<span class=\"token class-name\">F</span>表示失败\n      <span class=\"token comment\">//update resourceLock;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>整体流程：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">try</span><span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>keyResource<span class=\"token punctuation\">,</span>time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//加锁</span>\n   status <span class=\"token operator\">=</span> <span class=\"token function\">process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//你的业务逻辑处理。</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">finally</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span>keyResource<span class=\"token punctuation\">,</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//释放锁</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其实这个悲观锁实现的分布式锁，整体的流程还是比较清晰的。就是先<code>select ... for update</code>锁住主键<code>key_resource</code>那个记录，如果为空，则可以插入一条记录，如果已有记录判断下状态和时间 ，是否已经超时 。这里需要注意一下哈，必须要加事务 哈。</p>\n<h3 id=\"2-2-数据库乐观锁实现的分布式锁\"><a href=\"#2-2-数据库乐观锁实现的分布式锁\" class=\"headerlink\" title=\"2.2 数据库乐观锁实现的分布式锁\"></a>2.2 数据库乐观锁实现的分布式锁</h3><p>除了悲观锁，还可以用乐观锁实现分布式锁 。乐观锁，顾名思义，就是很乐观，每次更新操作，都觉得不会存在并发冲突，只有更新失败后，才重试。它是基于CAS思想实现的。我以前的公司，扣减余额 就是用这种方案。</p>\n<blockquote>\n<p>搞个version字段，每次更新修改，都会自增加一，然后去更新余额时，把查出来的那个版本号，带上条件去更新，如果是上次那个版本号，就更新，如果不是，表示别人并发修改过了，就继续重试。</p>\n</blockquote>\n<p>大概流程如下：</p>\n<ol>\n<li> 查询版本号和余额</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">select version<span class=\"token punctuation\">,</span>balance from account where user_id <span class=\"token operator\">=</span><span class=\"token string\">'666'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>假设查到版本号是oldVersion=1.</p>\n<ol>\n<li> 逻辑处理，判断余额</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>balance<span class=\"token operator\">&lt;</span>扣减金额<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n   <span class=\"token keyword\">return</span>；\n<span class=\"token punctuation\">&#125;</span>\n\nleft_balance <span class=\"token operator\">=</span> balance <span class=\"token operator\">-</span> 扣减金额<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ol>\n<li> 进行扣减余额</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">update account set balance <span class=\"token operator\">=</span> #<span class=\"token punctuation\">&#123;</span>left_balance<span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">,</span>version <span class=\"token operator\">=</span> version<span class=\"token operator\">+</span><span class=\"token number\">1</span> where version \n<span class=\"token operator\">=</span> #<span class=\"token punctuation\">&#123;</span>oldVersion<span class=\"token punctuation\">&#125;</span> and balance<span class=\"token operator\">>=</span> #<span class=\"token punctuation\">&#123;</span>left_balance<span class=\"token punctuation\">&#125;</span> and user_id <span class=\"token operator\">=</span><span class=\"token string\">'666'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>大家可以看下这个流程图哈：</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_92a9dd04.png\" alt=\"image_92a9dd04.png\"> </p>\n<p>这种方式适合并发不高 的场景，一般需要设置一下重试的次数</p>\n<h2 id=\"3-基于Redis实现的分布式锁\"><a href=\"#3-基于Redis实现的分布式锁\" class=\"headerlink\" title=\"3.基于Redis实现的分布式锁\"></a>3.基于Redis实现的分布式锁</h2><p>Redis分布式锁一般有以下这几种实现方式：</p>\n<ul>\n<li> setnx + expire</li>\n<li> setnx + value值是过期时间</li>\n<li> set的扩展命令（set ex px nx）</li>\n<li> set ex px nx + 校验唯一随机值,再删除</li>\n<li> Redisson</li>\n<li> Redisson + RedLock</li>\n</ul>\n<h3 id=\"3-1-setnx-expire\"><a href=\"#3-1-setnx-expire\" class=\"headerlink\" title=\"3.1 setnx + expire\"></a>3.1 setnx + expire</h3><p>聊到Redis分布式锁，很多小伙伴反手就是<code>setnx + expire</code>，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">if</span>（jedis<span class=\"token punctuation\">.</span><span class=\"token function\">setnx</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span>lock_value<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span>）<span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//setnx加锁</span>\n    expire（key，<span class=\"token number\">100</span>）<span class=\"token punctuation\">;</span> <span class=\"token comment\">//设置过期时间</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">do</span> something  <span class=\"token comment\">//业务处理</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span>\n       jedis<span class=\"token punctuation\">.</span><span class=\"token function\">del</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//释放锁</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这段代码是可以加锁成功，但是你有没有发现问题，加锁操作和设置超时时间是分开的 。假设在执行完<code>setnx</code>加锁后，正要执行<code>expire</code>设置过期时间时，进程<code>crash</code>掉或者要重启维护了，那这个锁就长生不老 了，别的线程永远获取不到锁啦，所以分布式锁不能这么实现 ！</p>\n<h3 id=\"3-2-setnx-value值是过期时间\"><a href=\"#3-2-setnx-value值是过期时间\" class=\"headerlink\" title=\"3.2 setnx + value值是过期时间\"></a>3.2 setnx + value值是过期时间</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">long</span> expires <span class=\"token operator\">=</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> expireTime<span class=\"token punctuation\">;</span> <span class=\"token comment\">//系统时间+设置的过期时间</span>\n<span class=\"token class-name\">String</span> expiresStr <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>expires<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 如果当前锁不存在，返回加锁成功</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>jedis<span class=\"token punctuation\">.</span><span class=\"token function\">setnx</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> expiresStr<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token comment\">// 如果锁已经存在，获取锁的过期时间</span>\n<span class=\"token class-name\">String</span> currentValueStr <span class=\"token operator\">=</span> jedis<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 如果获取到的过期时间，小于系统当前时间，表示已经过期</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>currentValueStr <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token class-name\">Long</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseLong</span><span class=\"token punctuation\">(</span>currentValueStr<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\n     <span class=\"token comment\">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈）</span>\n    <span class=\"token class-name\">String</span> oldValueStr <span class=\"token operator\">=</span> jedis<span class=\"token punctuation\">.</span><span class=\"token function\">getSet</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> expiresStr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldValueStr <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> oldValueStr<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>currentValueStr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n         <span class=\"token comment\">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁</span>\n         <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n        \n<span class=\"token comment\">//其他情况，均返回加锁失败</span>\n<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>日常开发中，有些小伙伴就是这么实现分布式锁的，但是会有这些缺点 ：</p>\n<ul>\n<li> 过期时间是客户端自己生成的，分布式环境下， 每个客户端的时间必须同步。</li>\n<li> 没有保存持有者的唯一标识， 可能被别的客户端释放/解锁 。</li>\n<li> 锁过期的时候，并发多个客户端同时请求过来，都执行了 <code>jedis.getSet()</code>，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间， 可能被别的客户端覆盖。</li>\n</ul>\n<h3 id=\"3-3-set的扩展命令-set-ex-px-nx\"><a href=\"#3-3-set的扩展命令-set-ex-px-nx\" class=\"headerlink\" title=\"3.3 set的扩展命令(set ex px nx)\"></a>3.3 set的扩展命令(set ex px nx)</h3><p>这个命令的几个参数分别表示什么意思呢？跟大家复习一下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">SET key value <span class=\"token punctuation\">[</span>EX seconds<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>PX milliseconds<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>NX<span class=\"token operator\">|</span>XX<span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li> EX second ：设置键的过期时间为 <code>second</code>秒。</li>\n<li> PX millisecond ：设置键的过期时间为 <code>millisecond</code>毫秒。</li>\n<li> NX ：只在键不存在时，才对键进行设置操作。</li>\n<li> XX ：只在键已经存在时，才对键进行设置操作。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">if</span>（jedis<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> lock_value<span class=\"token punctuation\">,</span> <span class=\"token string\">\"NX\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"EX\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span>s<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span>）<span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//加锁</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">do</span> something  <span class=\"token comment\">//业务处理</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span>\n       jedis<span class=\"token punctuation\">.</span><span class=\"token function\">del</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//释放锁</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个方案可能存在这样的问题：</p>\n<ul>\n<li> 锁过期释放了，业务还没执行完。</li>\n<li> 锁被别的线程误删。</li>\n</ul>\n<p>有些伙伴可能会有个疑问，就是锁为什么会被别的线程误删 呢？假设并发多线程场景下，线程A获得了锁，但是它没释放锁的话，线程B是获取不到锁的 ，所以按道理它是执行不到加锁下面的代码滴，怎么会导致锁被别的线程误删呢？</p>\n<blockquote>\n<p>假设线程A和B，都想用<code>key</code>加锁，最后A抢到锁加锁成功，但是由于执行业务逻辑的耗时很长，超过了设置的超时时间<code>100s</code>。这时候，Redis就自动释放了<code>key</code>锁。这时候线程B就可以加锁成功了，接下啦，它也执行业务逻辑处理。假设碰巧这时候，A执行完自己的业务逻辑，它就去释放锁，但是它就把B的锁给释放了。</p>\n</blockquote>\n<h3 id=\"3-4-set-ex-px-nx-校验唯一随机值-再删除\"><a href=\"#3-4-set-ex-px-nx-校验唯一随机值-再删除\" class=\"headerlink\" title=\"3.4 set ex px nx + 校验唯一随机值,再删除\"></a>3.4 set ex px nx + 校验唯一随机值,再删除</h3><p>为了解决锁被别的线程误删 问题。可以在<code>set ex px nx</code>的基础上，加上个校验的唯一随机值，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">if</span>（jedis<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> uni_request_id<span class=\"token punctuation\">,</span> <span class=\"token string\">\"NX\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"EX\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span>s<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span>）<span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//加锁</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">do</span> something  <span class=\"token comment\">//业务处理</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token comment\">//判断是不是当前线程加的锁,是才释放</span>\n       <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>uni_request_id<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>jedis<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n          jedis<span class=\"token punctuation\">.</span><span class=\"token function\">del</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//释放锁</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在这里，判断当前线程加的锁和释放锁不是一个原子操作 。如果调用<code>jedis.del()</code>释放锁的时候，可能这把锁已经不属于当前客户端 ，会解除他人加的锁。</p>\n<p>一般可以用lua脚本来包一下。lua脚本如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> redis<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token string\">'get'</span><span class=\"token punctuation\">,</span>KEYS<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> ARGV<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> then \n   <span class=\"token keyword\">return</span> redis<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token string\">'del'</span><span class=\"token punctuation\">,</span>KEYS<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> \n<span class=\"token keyword\">else</span>\n   <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\nend<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这种方式比较不错了，一般情况下，已经可以使用这种实现方式。但是还是存在：锁过期释放了，业务还没执行完的问题 。</p>\n<h3 id=\"3-5-Redisson\"><a href=\"#3-5-Redisson\" class=\"headerlink\" title=\"3.5 Redisson\"></a>3.5 Redisson</h3><p>对于可能存在锁过期释放，业务没执行完 的问题。我们可以稍微把锁过期时间设置长一些，大于正常业务处理时间就好啦。如果你觉得不是很稳，还可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。</p>\n<p>当前开源框架Redisson解决了这个问题。可以看下Redisson底层原理图：</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_6ae9d764.png\" alt=\"image_6ae9d764.png\"> </p>\n<p>只要线程一加锁成功，就会启动一个<code>watch dog</code>看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用<code>watch dog</code>解决了锁过期释放，业务没执行完问题 。</p>\n<h3 id=\"3-6-Redisson-RedLock\"><a href=\"#3-6-Redisson-RedLock\" class=\"headerlink\" title=\"3.6 Redisson + RedLock\"></a>3.6 Redisson + RedLock</h3><p>前面六种方案都只是基于Redis单机版 的分布式锁讨论，还不是很完美。因为Redis 一般都是集群部署的：</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_f90141b7.png\" alt=\"image_f90141b7.png\"> </p>\n<p>如果线程一在<code>Redis</code>的<code>master</code>节点上拿到了锁，但是加锁的<code>key</code>还没同步到<code>slave</code>节点。恰好这时，<code>master</code>节点发生故障，一个<code>slave</code>节点就会升级为<code>master</code>节点。线程二就可以顺理成章获取同个<code>key</code>的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。</p>\n<p>为了解决这个问题，Redis作者antirez提出一种高级的分布式锁算法：Redlock 。它的核心思想是这样的：</p>\n<blockquote>\n<p>部署多个Redis master，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。</p>\n</blockquote>\n<p>我们假设当前有5个Redis master节点，在5台服务器上面运行这些Redis实例。</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_669de3e0.png\" alt=\"image_669de3e0.png\"> RedLock的实现步骤:</p>\n<ol>\n<li> 获取当前时间，以毫秒为单位。</li>\n<li> 按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。</li>\n<li> 客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1，这里是5/2+1=3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s&gt; 30ms+40ms+50ms+4m0s+50ms）</li>\n<li> 如果取到了锁，key的真正有效时间就变啦，需要减去获取锁所使用的时间。</li>\n<li> 如果获取锁失败（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。</li>\n</ol>\n<p>简化下步骤就是：</p>\n<ul>\n<li> 按顺序向5个master节点请求加锁</li>\n<li> 根据设置的超时时间来判断，是不是要跳过该master节点。</li>\n<li> 如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。</li>\n<li> 如果获取锁失败，解锁！</li>\n</ul>\n<p>Redisson实现了redLock版本的锁 ，有兴趣的小伙伴，可以去了解一下哈~</p>\n<h2 id=\"4-Zookeeper分布式锁\"><a href=\"#4-Zookeeper分布式锁\" class=\"headerlink\" title=\"4. Zookeeper分布式锁\"></a>4. Zookeeper分布式锁</h2><p>在学习Zookeeper分布式锁之前，我们复习一下Zookeeper的节点哈。</p>\n<p>Zookeeper的节点Znode有四种类型：</p>\n<ul>\n<li> 持久节点 ：默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在。</li>\n<li> 持久节点顺序节点 ：所谓顺序节点，就是在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号，持久节点顺序节点就是有顺序的持久节点。</li>\n<li> 临时节点 ：和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。</li>\n<li> 临时顺序节点 ：有顺序的临时节点。</li>\n</ul>\n<p>Zookeeper分布式锁实现应用了临时顺序节点 。这里不贴代码啦，来讲下zk分布式锁的实现原理吧。</p>\n<h3 id=\"4-1-zk获取锁过程\"><a href=\"#4-1-zk获取锁过程\" class=\"headerlink\" title=\"4.1 zk获取锁过程\"></a>4.1 zk获取锁过程</h3><p>当第一个客户端请求过来时，Zookeeper客户端会创建一个持久节点<code>locks</code>。如果它（Client1）想获得锁，需要在<code>locks</code>节点下创建一个顺序节点<code>lock1</code>.如图</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_bd68a96a.png\" alt=\"image_bd68a96a.png\"> </p>\n<p>接着，客户端Client1会查找<code>locks</code>下面的所有临时顺序子节点，判断自己的节点<code>lock1</code>是不是排序最小的那一个，如果是，则成功获得锁。</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_d2f64ca3.png\" alt=\"image_d2f64ca3.png\"> </p>\n<p>这时候如果又来一个客户端client2前来尝试获得锁，它会在locks下再创建一个临时节点<code>lock2</code></p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_071b7d88.png\" alt=\"image_071b7d88.png\"> </p>\n<p>客户端client2一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock2是不是最小的，此时，发现lock1才是最小的，于是获取锁失败。获取锁失败，它是不会甘心的，client2向它排序靠前的节点lock1注册Watcher事件，用来监听lock1是否存在，也就是说client2抢锁失败进入等待状态。</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_b489bef9.png\" alt=\"image_b489bef9.png\"> </p>\n<p>此时，如果再来一个客户端Client3来尝试获取锁，它会在locks下再创建一个临时节点lock3</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_aa38b5f6.png\" alt=\"image_aa38b5f6.png\"> 同样的，client3一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock3是不是最小的，发现自己不是最小的，就获取锁失败。它也是不会甘心的，它会向在它前面的节点lock2注册Watcher事件，以监听lock2节点是否存在。</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_1cec9bce.png\" alt=\"image_1cec9bce.png\"> </p>\n<h3 id=\"4-2-释放锁\"><a href=\"#4-2-释放锁\" class=\"headerlink\" title=\"4.2 释放锁\"></a>4.2 释放锁</h3><p>我们再来看看释放锁的流程，Zookeeper的客户端业务完成或者发生故障，都会删除临时节点，释放锁。如果是任务完成，Client1会显式调用删除lock1的指令</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_93a8ea85.png\" alt=\"image_93a8ea85.png\"> </p>\n<p>如果是客户端故障了，根据临时节点得特性，lock1是会自动删除的</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_e929ee6e.png\" alt=\"image_e929ee6e.png\"> </p>\n<p>lock1节点被删除后，Client2可开心了，因为它一直监听着lock1。lock1节点删除，Client2立刻收到通知，也会查找locks下面的所有临时顺序子节点，发下lock2是最小，就获得锁。</p>\n<p> <img src=\"http://markdown.liangtengyu.com:9999/images//image_5b5c8168.png\" alt=\"image_5b5c8168.png\"> </p>\n<p>同理，Client2获得锁之后，Client3也对它虎视眈眈，啊哈哈~</p>\n<ul>\n<li> Zookeeper设计定位就是分布式协调，简单易用。如果获取不到锁，只需添加一个监听器即可，很适合做分布式锁。</li>\n<li> Zookeeper作为分布式锁也缺点：如果有很多的客户端频繁的申请加锁、释放锁，对于Zookeeper集群的压力会比较大。</li>\n</ul>\n<h2 id=\"5-三种分布式锁对比\"><a href=\"#5-三种分布式锁对比\" class=\"headerlink\" title=\"5. 三种分布式锁对比\"></a>5. 三种分布式锁对比</h2><h3 id=\"5-1-数据库分布式锁实现\"><a href=\"#5-1-数据库分布式锁实现\" class=\"headerlink\" title=\"5.1 数据库分布式锁实现\"></a>5.1 数据库分布式锁实现</h3><p>优点：</p>\n<ul>\n<li> 简单，使用方便，不需要引入 <code>Redis、zookeeper</code>等中间件。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li> 不适合高并发的场景</li>\n<li> db操作性能较差；</li>\n</ul>\n<h3 id=\"5-2-Redis分布式锁实现\"><a href=\"#5-2-Redis分布式锁实现\" class=\"headerlink\" title=\"5.2 Redis分布式锁实现\"></a>5.2 Redis分布式锁实现</h3><p>优点：</p>\n<ul>\n<li> 性能好，适合高并发场景</li>\n<li> 较轻量级</li>\n<li> 有较好的框架支持，如Redisson</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li> 过期时间不好控制</li>\n<li> 需要考虑锁被别的线程误删场景</li>\n</ul>\n<h3 id=\"5-3-Zookeeper分布式锁实现\"><a href=\"#5-3-Zookeeper分布式锁实现\" class=\"headerlink\" title=\"5.3 Zookeeper分布式锁实现\"></a>5.3 Zookeeper分布式锁实现</h3><p>缺点：</p>\n<ul>\n<li> 性能不如redis实现的分布式锁</li>\n<li> 比较重的分布式锁。</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li> 有较好的性能和可靠性</li>\n<li> 有封装较好的框架，如Curator</li>\n</ul>\n<h3 id=\"5-4-对比汇总\"><a href=\"#5-4-对比汇总\" class=\"headerlink\" title=\"5.4 对比汇总\"></a>5.4 对比汇总</h3><ul>\n<li> 从性能角度（从高到低）Redis &gt; Zookeeper &gt;= 数据库；</li>\n<li> 从理解的难易程度角度（从低到高）数据库 &gt; Redis &gt; Zookeeper；</li>\n<li> 从实现的复杂性角度（从低到高）Zookeeper &gt; Redis &gt; 数据库；</li>\n<li> 从可靠性角度（从高到低）Zookeeper &gt; Redis &gt; 数据库。</li>\n</ul>\n"},{"title":"推荐17个提升开发效率轮子","top":false,"cover":false,"toc":true,"mathjax":true,"summary":"推荐17个提升开发效率轮子","date":"2022-11-09T03:38:35.000Z","password":null,"_content":"## 1. Collections \n\n首先出场的是`java.util`包下的`Collections`类，该类主要用于操作集合或者返回集合，我个人非常喜欢用它。\n\n### 1.1 排序 \n\n在工作中经常有对集合排序的需求。\n\n看看使用`Collections`工具是如何实现升序和降序的：\n\n```java\n  List<Integer> list = new ArrayList<>();\n  list.add(2);\n  list.add(1);\n  list.add(3);\n  Collections.sort(list);//升序\n  System.out.println(list);\n  Collections.reverse(list);//降序\n  System.out.println(list);\n```\n\n执行结果：\n\n```java\n[1, 2, 3]\n[3, 2, 1]\n```\n\n### 1.2 获取最大或最小值 \n\n有时候需要找出集合中的`最大值`或者`最小值`，这时可以使用Collections的`max`和`min`方法。例如：\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(2);\nlist.add(1);\nlist.add(3);\nInteger max = Collections.max(list);//获取最大值\nInteger min = Collections.min(list);//获取最小值\nSystem.out.println(max);\nSystem.out.println(min);\n```\n\n执行结果：\n\n```java\n3\n1\n```\n\n### 1.3 转换线程安全集合 \n\n我们都知道，java中的很多集合，比如：ArrayList、LinkedList、HashMap、HashSet等，都是线程不安全的。\n\n换句话说，这些集合在多线程的环境中，添加数据会出现异常。\n\n这时，可以用Collections的`synchronizedxxx`方法，将这些线程不安全的集合，直接转换成线程安全集合。例如：\n\n```java\n  List<Integer> list = new ArrayList<>();\n  list.add(2);\n  list.add(1);\n  list.add(3);\n\n  List<Integer> integers = Collections.synchronizedList(list);//将ArrayList转换成线程安全集合\n  System.out.println(integers);\n```\n\n它的底层会创建`SynchronizedRandomAccessList`或者`SynchronizedList`类，这两个类的很多方法都会用`synchronized`加锁。\n\n### 1.4 返回空集合 \n\n有时，我们在判空之后，需要返回空集合，就可以使用`emptyList`方法，例如：\n\n```java\nprivate List<Integer> fun(List<Integer> list) {\n    if (list == null || list.size() == 0) {\n        return Collections.emptyList();\n    }\n    //业务处理\n    return list;\n}\n```\n\n### 1.5 二分查找 \n\n`binarySearch`方法提供了一个非常好用的`二分查找`功能，只用传入指定集合和需要找到的key即可。例如：\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(2);\nlist.add(1);\nlist.add(3);\n\nint i = Collections.binarySearch(list, 3);//二分查找\nSystem.out.println(i );\n```\n\n执行结果：\n\n```java\n2\n```\n\n### 1.6 转换成不可修改集合 \n\n为了防止后续的程序把某个集合的结果修改了，有时候我们需要把某个集合定义成不可修改的，使用Collections的`unmodifiablexxx`方法就能轻松实现：\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(2);\nlist.add(1);\nlist.add(3);\n\nList<Integer> integers = Collections.unmodifiableList(list);\nintegers.add(4);\nSystem.out.println(integers);\n```\n\n执行结果：\n\n```java\nException in thread \"main\" java.lang.UnsupportedOperationException\n at java.util.Collections$UnmodifiableCollection.add(Collections.java:1055)\n at com.sue.jump.service.test1.UtilTest.main(UtilTest.java:19)\n```\n\n当然Collections工具类中还有很多常用的方法，在这里就不一一介绍了，需要你自己去探索。\n\n![image_22c2f25a.png](推荐17个提升开发效率轮子/image_22c2f25a.png) ![image_71d4889f.png](推荐17个提升开发效率轮子/image_71d4889f.png)\n\n## 2. CollectionUtils \n\n对集合操作，除了前面说的`Collections`工具类之后，`CollectionUtils`工具类也非常常用。\n\n目前比较主流的是`spring`的`org.springframework.util`包下的CollectionUtils工具类。![image_f8deb8c1.png](推荐17个提升开发效率轮子/image_f8deb8c1.png)\n\n和`apache`的`org.apache.commons.collections`包下的CollectionUtils工具类。\n\n![image_5cf672b2.png](推荐17个提升开发效率轮子/image_5cf672b2.png)\n\n![image_98de130d.png](推荐17个提升开发效率轮子/image_98de130d.png)\n\n> 我个人更推荐使用apache的包下的CollectionUtils工具类，因为它的工具更多更全面。\n\n举个简单的例子，`spring`的CollectionUtils工具类没有判断集合不为空的方法。而`apache`的CollectionUtils工具类却有。\n\n下面我们以`apache`的CollectionUtils工具类为例，介绍一下常用方法。\n\n### 2.1 集合判空 \n\n通过CollectionUtils工具类的`isEmpty`方法可以轻松判断集合是否为空，`isNotEmpty`方法判断集合不为空。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(2);\nlist.add(1);\nlist.add(3);\n\nif (CollectionUtils.isEmpty(list)) {\n    System.out.println(\"集合为空\");\n}\n\nif (CollectionUtils.isNotEmpty(list)) {\n    System.out.println(\"集合不为空\");\n}\n```\n\n### 2.2 对两个集合进行操作 \n\n有时候我们需要对已有的两个集合进行操作，比如取交集或者并集等。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(2);\nlist.add(1);\nlist.add(3);\n\nList<Integer> list2 = new ArrayList<>();\nlist2.add(2);\nlist2.add(4);\n\n//获取并集\nCollection<Integer> unionList = CollectionUtils.union(list, list2);\nSystem.out.println(unionList);\n\n//获取交集\nCollection<Integer> intersectionList = CollectionUtils.intersection(list, list2);\nSystem.out.println(intersectionList);\n\n//获取交集的补集\nCollection<Integer> disjunctionList = CollectionUtils.disjunction(list, list2);\nSystem.out.println(disjunctionList);\n\n//获取差集\nCollection<Integer> subtractList = CollectionUtils.subtract(list, list2);\nSystem.out.println(subtractList);\n```\n\n执行结果：\n\n```java\n[1, 2, 3, 4]\n[2]\n[1, 3, 4]\n[1, 3]\n```\n\n说句实话，对两个集合的操作，在实际工作中用得挺多的，特别是很多批量的场景中。以前我们需要写一堆代码，但没想到有现成的轮子。\n\n## 3. Lists \n\n如果你引入`com.google.guava`的pom文件，会获得很多好用的小工具。这里推荐一款`com.google.common.collect`包下的集合工具：`Lists`。\n\n它是在太好用了，让我爱不释手。\n\n### 3.1 创建空集合 \n\n有时候，我们想创建一个空集合。这时可以用Lists的`newArrayList`方法，例如：\n\n```java\nList<Integer> list = Lists.newArrayList();\n```\n\n### 3.2 快速初始化集合 \n\n有时候，我们想给一个集合中初始化一些元素。这时可以用Lists的newArrayList方法，例如：\n\n```java\nList<Integer> list = Lists.newArrayList(1, 2, 3);\n```\n\n执行结果：\n\n```java\n[1, 2, 3]\n```\n\n### 3.3 笛卡尔积 \n\n如果你想将两个集合做`笛卡尔积`，Lists的`cartesianProduct`方法可以帮你实现：\n\n```java\nList<Integer> list1 = Lists.newArrayList(1, 2, 3);\nList<Integer> list2 = Lists.newArrayList(4,5);\nList<List<Integer>> productList = Lists.cartesianProduct(list1,list2);\nSystem.out.println(productList);\n```\n\n执行结果：\n\n```java\n[[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]\n```\n\n### 3.4 分页 \n\n如果你想将一个`大集合`分成若干个`小集合`，可以使用Lists的`partition`方法：\n\n```java\nList<Integer> list = Lists.newArrayList(1, 2, 3, 4, 5);\nList<List<Integer>> partitionList = Lists.partition(list, 2);\nSystem.out.println(partitionList);\n```\n\n执行结果：\n\n```java\n[[1, 2], [3, 4], [5]]\n```\n\n这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。\n\n这个是我最喜欢的方法之一，经常在项目中使用。\n\n比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。\n\n### 3.5 流处理 \n\n如果我们想把某个集合转换成另外一个接口，可以使用Lists的`transform`方法。例如：\n\n```java\nList<String> list = Lists.newArrayList(\"a\",\"b\",\"c\");\nList<String> transformList = Lists.transform(list, x -> x.toUpperCase());\nSystem.out.println(transformList);\n```\n\n将小写字母转换成了大写字母。\n\n### 3.6 颠倒顺序 \n\nLists的有颠倒顺序的方法`reverse`。例如：\n\n```java\nList<Integer> list = Lists.newArrayList(3, 1, 2);\nList<Integer> reverseList = Lists.reverse(list);\nSystem.out.println(reverseList);\n```\n\n执行结果：\n\n```java\n[2, 1, 3]\n```\n\nlist的原始顺序是312，使用`reverse`方法颠倒顺序之后，变成了213。\n\nLists还有其他的好用的工具，我在这里只是抛砖引玉，有兴趣的朋友，可以仔细研究一下。![image_040afd70.png](推荐17个提升开发效率轮子/image_040afd70.png)\n\n## 4. Objects \n\n在`jdk7`之后，提供了`Objects`工具类，我们可以通过它操作对象。\n\n### 4.1 对象判空 \n\n在java中万事万物皆对象，对象的判空可以说无处不在。Objects的`isNull`方法判断对象是否为空，而`nonNull`方法判断对象是否不为空。例如：\n\n```java\nInteger integer = new Integer(1);\n\nif (Objects.isNull(integer)) {\n    System.out.println(\"对象为空\");\n}\n\nif (Objects.nonNull(integer)) {\n    System.out.println(\"对象不为空\");\n}\n```\n\n### 4.2 对象为空抛异常 \n\n如果我们想在对象为空时，抛出空指针异常，可以使用Objects的`requireNonNull`方法。例如：\n\n```java\nInteger integer1 = new Integer(128);\n\nObjects.requireNonNull(integer1);\nObjects.requireNonNull(integer1, \"参数不能为空\");\nObjects.requireNonNull(integer1, () -> \"参数不能为空\");\n```\n\n### 4.3 判断两个对象是否相等 \n\n我们经常需要判断两个对象是否相等，Objects给我们提供了`equals`方法，能非常方便的实现：\n\n```java\nInteger integer1 = new Integer(1);\nInteger integer2 = new Integer(1);\n\nSystem.out.println(Objects.equals(integer1, integer2));\n```\n\n执行结果：\n\n```java\ntrue\n```\n\n但使用这个方法有坑，比如例子改成：\n\n```java\nInteger integer1 = new Integer(1);\nLong integer2 = new Long(1);\n\nSystem.out.println(Objects.equals(integer1, integer2));\n```\n\n执行结果：\n\n```java\nfalse\n```\n\n具体原因不细说了，有兴趣的小伙们可以看看我的另一篇文章《[Objects.equals有坑][Objects.equals]》，里面有非常详细的讲解。\n\n### 4.4 获取对象的hashCode \n\n如果你想获取某个对象的hashCode，可以使用Objects的`hashCode`方法。例如：\n\n```java\nString str = new String(\"abc\");\nSystem.out.println(Objects.hashCode(str));\n```\n\n执行结果：\n\n```java\n96354\n```\n\nObjects的内容先介绍到这里，有兴趣的小伙们，可以看看下面更多的方法：![image_d64a89cc.png](推荐17个提升开发效率轮子/image_d64a89cc.png)\n\n## 5. BooleanUtils \n\n在java中布尔值，随处可见。\n\n如果你使用了布尔的包装类：`Boolean`，总感觉有点麻烦，因为它有三种值：`null`、`true`、`false`。我们在处理Boolean对象时，需要经常判空。\n\n头疼！！！\n\n但如果使用`BooleanUtils`类处理布尔值，心情一下子就愉悦起来了。\n\n### 5.1 判断true或false \n\n如果你想判断某个参数的值是true或false，可以直接使用`isTrue`或`isFalse`方法。例如：\n\n```java\nBoolean aBoolean = new Boolean(true);\nSystem.out.println(BooleanUtils.isTrue(aBoolean));\nSystem.out.println(BooleanUtils.isFalse(aBoolean));\n```\n\n### 5.2 判断不为true或不为false \n\n有时候，需要判断某个参数不为true，即是null或者false。或者判断不为false，即是null或者true。\n\n可以使用`isNotTrue`或`isNotFalse`方法。例如：\n\n```java\nBoolean aBoolean = new Boolean(true);\nBoolean aBoolean1 = null;\nSystem.out.println(BooleanUtils.isNotTrue(aBoolean));\nSystem.out.println(BooleanUtils.isNotTrue(aBoolean1));\nSystem.out.println(BooleanUtils.isNotFalse(aBoolean));\nSystem.out.println(BooleanUtils.isNotFalse(aBoolean1));\n```\n\n执行结果：\n\n```java\nfalse\ntrue\ntrue\ntrue\n```\n\n### 5.3 转换成数字 \n\n如果你想将true转换成数字1，false转换成数字0，可以使用`toInteger`方法：\n\n```java\nBoolean aBoolean = new Boolean(true);\nBoolean aBoolean1 = new Boolean(false);\nSystem.out.println(BooleanUtils.toInteger(aBoolean));\nSystem.out.println(BooleanUtils.toInteger(aBoolean1));\n```\n\n执行结果：\n\n```java\n1\n0\n```\n\n### 5.4 Boolean转换成布尔值 \n\n我们有时候需要将包装类`Boolean`对象，转换成原始的`boolean`对象，可以使用`toBoolean`方法。例如：\n\n```java\nBoolean aBoolean = new Boolean(true);\nBoolean aBoolean1 = null;\nSystem.out.println(BooleanUtils.toBoolean(aBoolean));\nSystem.out.println(BooleanUtils.toBoolean(aBoolean1));\nSystem.out.println(BooleanUtils.toBooleanDefaultIfNull(aBoolean1, false));\n```\n\n我们无需额外的判空了，而且还可以设置Boolean对象为空时返回的默认值。\n\nBooleanUtils类的方法还有很多，有兴趣的小伙伴可以看看下面的内容：![image_56af129c.png](推荐17个提升开发效率轮子/image_56af129c.png)\n\n## 6. StringUtils \n\n`字符串`（String）在我们的日常工作中，用得非常非常非常多。\n\n在我们的代码中经常需要对字符串判空，截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。\n\n如果只用String类提供的那些方法，我们需要手写大量的额外代码，不然容易出现各种异常。\n\n现在有个好消息是：`org.apache.commons.lang3`包下的`StringUtils`工具类，给我们提供了非常丰富的选择。\n\n### 6.1 字符串判空 \n\n其实空字符串，不只是null一种，还有\"\"，\" \"，\"null\"等等，多种情况。\n\nStringUtils给我们提供了多个判空的静态方法，例如：\n\n```java\n String str1 = null;\nString str2 = \"\";\nString str3 = \" \";\nString str4 = \"abc\";\nSystem.out.println(StringUtils.isEmpty(str1));\nSystem.out.println(StringUtils.isEmpty(str2));\nSystem.out.println(StringUtils.isEmpty(str3));\nSystem.out.println(StringUtils.isEmpty(str4));\nSystem.out.println(\"=====\");\nSystem.out.println(StringUtils.isNotEmpty(str1));\nSystem.out.println(StringUtils.isNotEmpty(str2));\nSystem.out.println(StringUtils.isNotEmpty(str3));\nSystem.out.println(StringUtils.isNotEmpty(str4));\nSystem.out.println(\"=====\");\nSystem.out.println(StringUtils.isBlank(str1));\nSystem.out.println(StringUtils.isBlank(str2));\nSystem.out.println(StringUtils.isBlank(str3));\nSystem.out.println(StringUtils.isBlank(str4));\nSystem.out.println(\"=====\");\nSystem.out.println(StringUtils.isNotBlank(str1));\nSystem.out.println(StringUtils.isNotBlank(str2));\nSystem.out.println(StringUtils.isNotBlank(str3));\nSystem.out.println(StringUtils.isNotBlank(str4));\n```\n\n执行结果：\n\n```java\ntrue\ntrue\nfalse\nfalse\n=====\nfalse\nfalse\ntrue\ntrue\n=====\ntrue\ntrue\ntrue\nfalse\n=====\nfalse\nfalse\nfalse\ntrue\n```\n\n示例中的：`isEmpty`、`isNotEmpty`、`isBlank`和`isNotBlank`，这4个判空方法你们可以根据实际情况使用。\n\n> 优先推荐使用`isBlank`和`isNotBlank`方法，因为它会把`\" \"`也考虑进去。\n\n### 6.2 分隔字符串 \n\n分隔字符串是常见需求，如果直接使用String类的split方法，就可能会出现空指针异常。\n\n```java\nString str1 = null;\nSystem.out.println(StringUtils.split(str1,\",\"));\nSystem.out.println(str1.split(\",\"));\n```\n\n执行结果：\n\n```java\nnull\nException in thread \"main\" java.lang.NullPointerException\n at com.sue.jump.service.test1.UtilTest.main(UtilTest.java:21)\n```\n\n使用StringUtils的split方法会返回null，而使用String的split方法会报指针异常。\n\n### 6.3 判断是否纯数字 \n\n给定一个字符串，判断它是否为纯数字，可以使用`isNumeric`方法。例如：\n\n```java\nString str1 = \"123\";\nString str2 = \"123q\";\nString str3 = \"0.33\";\nSystem.out.println(StringUtils.isNumeric(str1));\nSystem.out.println(StringUtils.isNumeric(str2));\nSystem.out.println(StringUtils.isNumeric(str3));\n```\n\n执行结果：\n\n```java\ntrue\nfalse\nfalse\n```\n\n### 6.4 将集合拼接成字符串 \n\n有时候，我们需要将某个集合的内容，拼接成一个字符串，然后输出，这时可以使用`join`方法。例如：\n\n```java\nList<String> list = Lists.newArrayList(\"a\", \"b\", \"c\");\nList<Integer> list2 = Lists.newArrayList(1, 2, 3);\nSystem.out.println(StringUtils.join(list, \",\"));\nSystem.out.println(StringUtils.join(list2, \" \"));\n```\n\n执行结果：\n\n```java\na,b,c\n1 2 3\n```\n\n当然还有很多实用的方法，我在这里就不一一介绍了。![image_48270fb5.png](推荐17个提升开发效率轮子/image_48270fb5.png)\n\n![image_77defa60.png](推荐17个提升开发效率轮子/image_77defa60.png)\n\n## 7. Assert \n\n很多时候，我们需要在代码中做判断：如果不满足条件，则抛异常。\n\n有没有统一的封装呢?\n\n其实`spring`给我们提供了`Assert`类，它表示`断言`。\n\n### 7.1 断言参数是否为空 \n\n断言`参数`是否空，如果不满足条件，则直接抛异常。\n\n```java\nString str = null;\nAssert.isNull(str, \"str必须为空\");\nAssert.isNull(str, () -> \"str必须为空\");\nAssert.notNull(str, \"str不能为空\");\n```\n\n如果不满足条件就会抛出`IllegalArgumentException`异常。\n\n### 7.2 断言集合是否为空 \n\n断言`集合`是否空，如果不满足条件，则直接抛异常。\n\n```java\nList<String> list = null;\nMap<String, String> map = null;\nAssert.notEmpty(list, \"list不能为空\");\nAssert.notEmpty(list, () -> \"list不能为空\");\nAssert.notEmpty(map, \"map不能为空\");\n```\n\n如果不满足条件就会抛出`IllegalArgumentException`异常。\n\n### 7.3 断言条件是否为空 \n\n断言是否满足某个`条件`，如果不满足条件，则直接抛异常。\n\n```java\nList<String> list = null;\nAssert.isTrue(CollectionUtils.isNotEmpty(list), \"list不能为空\");\nAssert.isTrue(CollectionUtils.isNotEmpty(list), () -> \"list不能为空\");\n```\n\n当然Assert类还有一些其他的功能，这里就不多介绍了。![image_b1853624.png](推荐17个提升开发效率轮子/image_b1853624.png)\n\n## 8. IOUtils \n\n`IO`流在我们日常工作中也用得比较多，尽管java已经给我们提供了丰富的API。\n\n但我们不得不每次读取文件，或者写入文件之后，写一些重复的的代码。手动在`finally`代码块中关闭流，不然可能会造成`内存溢出`。\n\n有个好消息是：如果你使用`org.apache.commons.io`包下的`IOUtils`类，会节省大量的时间。\n\n### 8.1 读取文件 \n\n如果你想将某个txt文件中的数据，读取到字符串当中，可以使用IOUtils类的`toString`方法。例如：\n\n```java\nString str = IOUtils.toString(new FileInputStream(\"/temp/a.txt\"), StandardCharsets.UTF_8);\nSystem.out.println(str);\n```\n\n### 8.2 写入文件 \n\n如果你想将某个字符串的内容，写入到指定文件当中，可以使用IOUtils类的`write`方法。例如：\n\n```java\nString str = \"abcde\";\nIOUtils.write(str, new FileOutputStream(\"/temp/b.tx\"), StandardCharsets.UTF_8);\n```\n\n### 8.3 文件拷贝 \n\n如果你想将某个文件中的所有内容，都拷贝到另一个文件当中，可以使用IOUtils类的`copy`方法。例如：\n\n```java\nIOUtils.copy(new FileInputStream(\"/temp/a.txt\"), new FileOutputStream(\"/temp/b.txt\"));\n```\n\n### 8.4 读取文件内容到字节数组 \n\n如果你想将某个文件中的内容，读取字节数组中，可以使用IOUtils类的`toByteArray`方法。例如：\n\n```java\nbyte[] bytes = IOUtils.toByteArray(new FileInputStream(\"/temp/a.txt\"));\n```\n\nIOUtils类非常实用，感兴趣的小伙们，可以看看下面内容。![image_fadda8b7.png](推荐17个提升开发效率轮子/image_fadda8b7.png)\n\n## 9. MDC \n\n`MDC`是`org.slf4j`包下的一个类，它的全称是Mapped Diagnostic Context，我们可以认为它是一个线程安全的存放诊断日志的容器。\n\nMDC的底层是用了`ThreadLocal`来保存数据的。\n\n我们可以用它传递参数。\n\n例如现在有这样一种场景：我们使用`RestTemplate`调用远程接口时，有时需要在`header`中传递信息，比如：traceId，source等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。\n\n这种业务场景就能通过`ClientHttpRequestInterceptor`接口实现，具体做法如下：\n\n第一步，定义一个LogFilter拦截所有接口请求，在MDC中设置traceId：\n\n```java\npublic class LogFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        MdcUtil.add(UUID.randomUUID().toString());\n        System.out.println(\"记录请求日志\");\n        chain.doFilter(request, response);\n        System.out.println(\"记录响应日志\");\n    }\n\n    @Override\n    public void destroy() {\n    }\n}\n```\n\n第二步，实现`ClientHttpRequestInterceptor`接口，MDC中获取当前请求的traceId，然后设置到header中：\n\n```java\npublic class RestTemplateInterceptor implements ClientHttpRequestInterceptor {\n\n    @Override\n    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {\n        request.getHeaders().set(\"traceId\", MdcUtil.get());\n        return execution.execute(request, body);\n    }\n}\n```\n\n第三步，定义配置类，配置上面定义的`RestTemplateInterceptor`类：\n\n```java\n@Configuration\npublic class RestTemplateConfiguration {\n\n    @Bean\n    public RestTemplate restTemplate() {\n        RestTemplate restTemplate = new RestTemplate();\n        restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));\n        return restTemplate;\n    }\n\n    @Bean\n    public RestTemplateInterceptor restTemplateInterceptor() {\n        return new RestTemplateInterceptor();\n    }\n}\n```\n\n其中MdcUtil其实是利用MDC工具在ThreadLocal中存储和获取traceId\n\n```java\npublic class MdcUtil {\n\n    private static final String TRACE_ID = \"TRACE_ID\";\n\n    public static String get() {\n        return MDC.get(TRACE_ID);\n    }\n\n    public static void add(String value) {\n        MDC.put(TRACE_ID, value);\n    }\n}\n```\n\n当然，这个例子中没有演示MdcUtil类的add方法具体调的地方，我们可以在filter中执行接口方法之前，生成traceId，调用MdcUtil类的add方法添加到MDC中，然后在同一个请求的其他地方就能通过MdcUtil类的get方法获取到该traceId。\n\n能使用MDC保存traceId等参数的根本原因是，用户请求到应用服务器，Tomcat会从线程池中分配一个线程去处理该请求。\n\n那么该请求的整个过程中，保存到MDC的ThreadLocal中的参数，也是该线程独享的，所以不会有线程安全问题。\n\n## 10. ClassUtils \n\nspring的`org.springframework.util`包下的`ClassUtils`类，它里面有很多让我们惊喜的功能。\n\n它里面包含了类和对象相关的很多非常实用的方法。\n\n### 10.1 获取对象的所有接口 \n\n如果你想获取某个对象的所有接口，可以使用ClassUtils的`getAllInterfaces`方法。例如：\n\n```java\nClass<?>[] allInterfaces = ClassUtils.getAllInterfaces(new User());\n```\n\n### 10.2 获取某个类的包名 \n\n如果你想获取某个类的包名，可以使用ClassUtils的`getPackageName`方法。例如：\n\n```java\nString packageName = ClassUtils.getPackageName(User.class);\nSystem.out.println(packageName);\n```\n\n### 10.3 判断某个类是否内部类 \n\n如果你想判断某个类是否内部类，可以使用ClassUtils的`isInnerClass`方法。例如：\n\n```java\nSystem.out.println(ClassUtils.isInnerClass(User.class));\n```\n\n### 10.4 判断对象是否代理对象 \n\n如果你想判断对象是否代理对象，可以使用ClassUtils的`isCglibProxy`方法。例如：\n\n```java\nSystem.out.println(ClassUtils.isCglibProxy(new User()));\n```\n\nClassUtils还有很多有用的方法，等待着你去发掘。感兴趣的朋友，可以看看下面内容：![image_dec3e504.png](推荐17个提升开发效率轮子/image_dec3e504.png)\n\n## 11. BeanUtils \n\nspring给我们提供了一个`JavaBean`的工具类，它在`org.springframework.beans`包下面，它的名字叫做：`BeanUtils`。\n\n让我们一起看看这个工具可以带给我们哪些惊喜。\n\n### 11.1 拷贝对象的属性 \n\n曾几何时，你有没有这样的需求：把某个对象中的所有属性，都拷贝到另外一个对象中。这时就能使用BeanUtils的`copyProperties`方法。例如：\n\n```java\nUser user1 = new User();\nuser1.setId(1L);\nuser1.setName(\"苏三说技术\");\nuser1.setAddress(\"成都\");\n\nUser user2 = new User();\nBeanUtils.copyProperties(user1, user2);\nSystem.out.println(user2);\n```\n\n### 11.2 实例化某个类 \n\n如果你想通过反射实例化一个类的对象，可以使用BeanUtils的`instantiateClass`方法。例如：\n\n```java\nUser user = BeanUtils.instantiateClass(User.class);\nSystem.out.println(user);\n```\n\n### 11.3 获取指定类的指定方法 \n\n如果你想获取某个类的指定方法，可以使用BeanUtils的`findDeclaredMethod`方法。例如：\n\n```java\nMethod declaredMethod = BeanUtils.findDeclaredMethod(User.class, \"getId\");\nSystem.out.println(declaredMethod.getName());\n```\n\n### 11.4 获取指定方法的参数 \n\n如果你想获取某个方法的参数，可以使用BeanUtils的`findPropertyForMethod`方法。例如：\n\n```java\nMethod declaredMethod = BeanUtils.findDeclaredMethod(User.class, \"getId\");\nPropertyDescriptor propertyForMethod = BeanUtils.findPropertyForMethod(declaredMethod);\nSystem.out.println(propertyForMethod.getName());\n```\n\n如果你对BeanUtils比较感兴趣，可以看看下面内容：![image_7eeac46e.png](推荐17个提升开发效率轮子/image_7eeac46e.png)\n\n## 12. ReflectionUtils \n\n有时候，我们需要在项目中使用`反射`功能，如果使用最原始的方法来开发，代码量会非常多，而且很麻烦，它需要处理一大堆异常以及访问权限等问题。\n\n好消息是spring给我们提供了一个`ReflectionUtils`工具，它在`org.springframework.util`包下面。\n\n### 12.1 获取方法 \n\n如果你想获取某个类的某个方法，可以使用ReflectionUtils类的`findMethod`方法。例如：\n\n```java\nMethod method = ReflectionUtils.findMethod(User.class, \"getId\");\n```\n\n### 12.2 获取字段 \n\n如果你想获取某个类的某个字段，可以使用ReflectionUtils类的`findField`方法。例如：\n\n```java\nField field = ReflectionUtils.findField(User.class, \"id\");\n```\n\n### 12.3 执行方法 \n\n如果你想通过反射调用某个方法，传递参数，可以使用ReflectionUtils类的`invokeMethod`方法。例如：\n\n```java\n ReflectionUtils.invokeMethod(method, springContextsUtil.getBean(beanName), param);\n```\n\n### 12.4 判断字段是否常量 \n\n如果你想判断某个字段是否常量，可以使用ReflectionUtils类的`isPublicStaticFinal`方法。例如：\n\n```java\nField field = ReflectionUtils.findField(User.class, \"id\");\nSystem.out.println(ReflectionUtils.isPublicStaticFinal(field));\n```\n\n### 12.5 判断是否equals方法 \n\n如果你想判断某个方法是否equals方法，可以使用ReflectionUtils类的`isEqualsMethod`方法。例如：\n\n```java\nMethod method = ReflectionUtils.findMethod(User.class, \"getId\");\nSystem.out.println(ReflectionUtils.isEqualsMethod(method));\n```\n\n当然这个类还有不少有趣的方法，感兴趣的朋友，可以看看下面内容：![image_ea531c2a.png](推荐17个提升开发效率轮子/image_ea531c2a.png)\n\n## 13. Base64Utils \n\n有时候，为了安全考虑，需要将参数只用`base64`编码。\n\n这时就能直接使用`org.springframework.util`包下的`Base64Utils`工具类。\n\n它里面包含：`encode`和`decode`方法，用于对数据进行加密和解密。例如：\n\n```java\nString str = \"abc\";\nString encode = new String(Base64Utils.encode(str.getBytes()));\nSystem.out.println(\"加密后：\" + encode);\ntry {\n    String decode = new String(Base64Utils.decode(encode.getBytes()), \"utf8\");\n    System.out.println(\"解密后：\" + decode);\n} catch (UnsupportedEncodingException e) {\n    e.printStackTrace();\n}\n```\n\n执行结果：\n\n```java\n加密后：YWJj\n解密后：abc\n```\n\n## 14. StandardCharsets \n\n我们在做字符转换的时候，经常需要指定字符编码，比如：UTF-8、ISO-8859-1等等。\n\n这时就可以直接使用`java.nio.charset`包下的`StandardCharsets`类中静态变量。\n\n例如：\n\n```java\nString str = \"abc\";\nString encode = new String(Base64Utils.encode(str.getBytes()));\nSystem.out.println(\"加密后：\" + encode);\nString decode = new String(Base64Utils.decode(encode.getBytes())\n, StandardCharsets.UTF_8);\nSystem.out.println(\"解密后：\" + decode);\n```\n\n## 15. DigestUtils \n\n有时候，我们需要对数据进行加密处理，比如：md5或sha256。\n\n可以使用apache的`org.apache.commons.codec.digest`包下的`DigestUtils`类。\n\n### 15.1 md5加密 \n\n如果你想对数据进行md5加密，可以使用DigestUtils的`md5Hex`方法。例如：\n\n```java\nString md5Hex = DigestUtils.md5Hex(\"苏三说技术\");\nSystem.out.println(md5Hex);\n```\n\n### 15.2 sha256加密 \n\n如果你想对数据进行sha256加密，可以使用DigestUtils的`sha256Hex`方法。例如：\n\n```java\nString md5Hex = DigestUtils.sha256Hex(\"苏三说技术\");\nSystem.out.println(md5Hex);\n```\n\n当然这个工具还有很多其他的加密方法：![image_fec0346f.png](推荐17个提升开发效率轮子/image_fec0346f.png)\n\n## 16. SerializationUtils \n\n有时候，我们需要把数据进行`序列化`和`反序列化`处理。\n\n传统的做法是某个类实现`Serializable`接口，然后重新它的`writeObject`和`readObject`方法。\n\n但如果使用`org.springframework.util`包下的`SerializationUtils`工具类，能更轻松实现序列化和反序列化功能。例如：\n\n```java\nMap<String, String> map = Maps.newHashMap();\nmap.put(\"a\", \"1\");\nmap.put(\"b\", \"2\");\nmap.put(\"c\", \"3\");\nbyte[] serialize = SerializationUtils.serialize(map);\nObject deserialize = SerializationUtils.deserialize(serialize);\nSystem.out.println(deserialize);\n```\n\n## 17. HttpStatus \n\n很多时候，我们会在代码中定义http的返回码，比如：接口正常返回200，异常返回500，接口找不到返回404，接口不可用返回502等。\n\n```java\nprivate int SUCCESS_CODE = 200;\nprivate int ERROR_CODE = 500;\nprivate int NOT_FOUND_CODE = 404;\n```\n\n其实`org.springframework.http`包下的HttpStatus枚举，或者`org.apache.http`包下的`HttpStatus`接口，已经把常用的http返回码给我们定义好了，直接拿来用就可以了，真的不用再重复定义了。\n\n![image_d1a5a95c.png](推荐17个提升开发效率轮子/image_d1a5a95c.png)","source":"_posts/推荐17个提升开发效率轮子.md","raw":"---\ntitle: 推荐17个提升开发效率轮子\ntop: false\ncover: false\ntoc: true\nmathjax: true\nsummary: 推荐17个提升开发效率轮子\ndate: 2022-11-09 11:38:35\npassword:\ntags:\n    - 轮子\ncategories:\n    - java\n    - 工具\n---\n## 1. Collections \n\n首先出场的是`java.util`包下的`Collections`类，该类主要用于操作集合或者返回集合，我个人非常喜欢用它。\n\n### 1.1 排序 \n\n在工作中经常有对集合排序的需求。\n\n看看使用`Collections`工具是如何实现升序和降序的：\n\n```java\n  List<Integer> list = new ArrayList<>();\n  list.add(2);\n  list.add(1);\n  list.add(3);\n  Collections.sort(list);//升序\n  System.out.println(list);\n  Collections.reverse(list);//降序\n  System.out.println(list);\n```\n\n执行结果：\n\n```java\n[1, 2, 3]\n[3, 2, 1]\n```\n\n### 1.2 获取最大或最小值 \n\n有时候需要找出集合中的`最大值`或者`最小值`，这时可以使用Collections的`max`和`min`方法。例如：\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(2);\nlist.add(1);\nlist.add(3);\nInteger max = Collections.max(list);//获取最大值\nInteger min = Collections.min(list);//获取最小值\nSystem.out.println(max);\nSystem.out.println(min);\n```\n\n执行结果：\n\n```java\n3\n1\n```\n\n### 1.3 转换线程安全集合 \n\n我们都知道，java中的很多集合，比如：ArrayList、LinkedList、HashMap、HashSet等，都是线程不安全的。\n\n换句话说，这些集合在多线程的环境中，添加数据会出现异常。\n\n这时，可以用Collections的`synchronizedxxx`方法，将这些线程不安全的集合，直接转换成线程安全集合。例如：\n\n```java\n  List<Integer> list = new ArrayList<>();\n  list.add(2);\n  list.add(1);\n  list.add(3);\n\n  List<Integer> integers = Collections.synchronizedList(list);//将ArrayList转换成线程安全集合\n  System.out.println(integers);\n```\n\n它的底层会创建`SynchronizedRandomAccessList`或者`SynchronizedList`类，这两个类的很多方法都会用`synchronized`加锁。\n\n### 1.4 返回空集合 \n\n有时，我们在判空之后，需要返回空集合，就可以使用`emptyList`方法，例如：\n\n```java\nprivate List<Integer> fun(List<Integer> list) {\n    if (list == null || list.size() == 0) {\n        return Collections.emptyList();\n    }\n    //业务处理\n    return list;\n}\n```\n\n### 1.5 二分查找 \n\n`binarySearch`方法提供了一个非常好用的`二分查找`功能，只用传入指定集合和需要找到的key即可。例如：\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(2);\nlist.add(1);\nlist.add(3);\n\nint i = Collections.binarySearch(list, 3);//二分查找\nSystem.out.println(i );\n```\n\n执行结果：\n\n```java\n2\n```\n\n### 1.6 转换成不可修改集合 \n\n为了防止后续的程序把某个集合的结果修改了，有时候我们需要把某个集合定义成不可修改的，使用Collections的`unmodifiablexxx`方法就能轻松实现：\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(2);\nlist.add(1);\nlist.add(3);\n\nList<Integer> integers = Collections.unmodifiableList(list);\nintegers.add(4);\nSystem.out.println(integers);\n```\n\n执行结果：\n\n```java\nException in thread \"main\" java.lang.UnsupportedOperationException\n at java.util.Collections$UnmodifiableCollection.add(Collections.java:1055)\n at com.sue.jump.service.test1.UtilTest.main(UtilTest.java:19)\n```\n\n当然Collections工具类中还有很多常用的方法，在这里就不一一介绍了，需要你自己去探索。\n\n![image_22c2f25a.png](推荐17个提升开发效率轮子/image_22c2f25a.png) ![image_71d4889f.png](推荐17个提升开发效率轮子/image_71d4889f.png)\n\n## 2. CollectionUtils \n\n对集合操作，除了前面说的`Collections`工具类之后，`CollectionUtils`工具类也非常常用。\n\n目前比较主流的是`spring`的`org.springframework.util`包下的CollectionUtils工具类。![image_f8deb8c1.png](推荐17个提升开发效率轮子/image_f8deb8c1.png)\n\n和`apache`的`org.apache.commons.collections`包下的CollectionUtils工具类。\n\n![image_5cf672b2.png](推荐17个提升开发效率轮子/image_5cf672b2.png)\n\n![image_98de130d.png](推荐17个提升开发效率轮子/image_98de130d.png)\n\n> 我个人更推荐使用apache的包下的CollectionUtils工具类，因为它的工具更多更全面。\n\n举个简单的例子，`spring`的CollectionUtils工具类没有判断集合不为空的方法。而`apache`的CollectionUtils工具类却有。\n\n下面我们以`apache`的CollectionUtils工具类为例，介绍一下常用方法。\n\n### 2.1 集合判空 \n\n通过CollectionUtils工具类的`isEmpty`方法可以轻松判断集合是否为空，`isNotEmpty`方法判断集合不为空。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(2);\nlist.add(1);\nlist.add(3);\n\nif (CollectionUtils.isEmpty(list)) {\n    System.out.println(\"集合为空\");\n}\n\nif (CollectionUtils.isNotEmpty(list)) {\n    System.out.println(\"集合不为空\");\n}\n```\n\n### 2.2 对两个集合进行操作 \n\n有时候我们需要对已有的两个集合进行操作，比如取交集或者并集等。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(2);\nlist.add(1);\nlist.add(3);\n\nList<Integer> list2 = new ArrayList<>();\nlist2.add(2);\nlist2.add(4);\n\n//获取并集\nCollection<Integer> unionList = CollectionUtils.union(list, list2);\nSystem.out.println(unionList);\n\n//获取交集\nCollection<Integer> intersectionList = CollectionUtils.intersection(list, list2);\nSystem.out.println(intersectionList);\n\n//获取交集的补集\nCollection<Integer> disjunctionList = CollectionUtils.disjunction(list, list2);\nSystem.out.println(disjunctionList);\n\n//获取差集\nCollection<Integer> subtractList = CollectionUtils.subtract(list, list2);\nSystem.out.println(subtractList);\n```\n\n执行结果：\n\n```java\n[1, 2, 3, 4]\n[2]\n[1, 3, 4]\n[1, 3]\n```\n\n说句实话，对两个集合的操作，在实际工作中用得挺多的，特别是很多批量的场景中。以前我们需要写一堆代码，但没想到有现成的轮子。\n\n## 3. Lists \n\n如果你引入`com.google.guava`的pom文件，会获得很多好用的小工具。这里推荐一款`com.google.common.collect`包下的集合工具：`Lists`。\n\n它是在太好用了，让我爱不释手。\n\n### 3.1 创建空集合 \n\n有时候，我们想创建一个空集合。这时可以用Lists的`newArrayList`方法，例如：\n\n```java\nList<Integer> list = Lists.newArrayList();\n```\n\n### 3.2 快速初始化集合 \n\n有时候，我们想给一个集合中初始化一些元素。这时可以用Lists的newArrayList方法，例如：\n\n```java\nList<Integer> list = Lists.newArrayList(1, 2, 3);\n```\n\n执行结果：\n\n```java\n[1, 2, 3]\n```\n\n### 3.3 笛卡尔积 \n\n如果你想将两个集合做`笛卡尔积`，Lists的`cartesianProduct`方法可以帮你实现：\n\n```java\nList<Integer> list1 = Lists.newArrayList(1, 2, 3);\nList<Integer> list2 = Lists.newArrayList(4,5);\nList<List<Integer>> productList = Lists.cartesianProduct(list1,list2);\nSystem.out.println(productList);\n```\n\n执行结果：\n\n```java\n[[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]\n```\n\n### 3.4 分页 \n\n如果你想将一个`大集合`分成若干个`小集合`，可以使用Lists的`partition`方法：\n\n```java\nList<Integer> list = Lists.newArrayList(1, 2, 3, 4, 5);\nList<List<Integer>> partitionList = Lists.partition(list, 2);\nSystem.out.println(partitionList);\n```\n\n执行结果：\n\n```java\n[[1, 2], [3, 4], [5]]\n```\n\n这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。\n\n这个是我最喜欢的方法之一，经常在项目中使用。\n\n比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。\n\n### 3.5 流处理 \n\n如果我们想把某个集合转换成另外一个接口，可以使用Lists的`transform`方法。例如：\n\n```java\nList<String> list = Lists.newArrayList(\"a\",\"b\",\"c\");\nList<String> transformList = Lists.transform(list, x -> x.toUpperCase());\nSystem.out.println(transformList);\n```\n\n将小写字母转换成了大写字母。\n\n### 3.6 颠倒顺序 \n\nLists的有颠倒顺序的方法`reverse`。例如：\n\n```java\nList<Integer> list = Lists.newArrayList(3, 1, 2);\nList<Integer> reverseList = Lists.reverse(list);\nSystem.out.println(reverseList);\n```\n\n执行结果：\n\n```java\n[2, 1, 3]\n```\n\nlist的原始顺序是312，使用`reverse`方法颠倒顺序之后，变成了213。\n\nLists还有其他的好用的工具，我在这里只是抛砖引玉，有兴趣的朋友，可以仔细研究一下。![image_040afd70.png](推荐17个提升开发效率轮子/image_040afd70.png)\n\n## 4. Objects \n\n在`jdk7`之后，提供了`Objects`工具类，我们可以通过它操作对象。\n\n### 4.1 对象判空 \n\n在java中万事万物皆对象，对象的判空可以说无处不在。Objects的`isNull`方法判断对象是否为空，而`nonNull`方法判断对象是否不为空。例如：\n\n```java\nInteger integer = new Integer(1);\n\nif (Objects.isNull(integer)) {\n    System.out.println(\"对象为空\");\n}\n\nif (Objects.nonNull(integer)) {\n    System.out.println(\"对象不为空\");\n}\n```\n\n### 4.2 对象为空抛异常 \n\n如果我们想在对象为空时，抛出空指针异常，可以使用Objects的`requireNonNull`方法。例如：\n\n```java\nInteger integer1 = new Integer(128);\n\nObjects.requireNonNull(integer1);\nObjects.requireNonNull(integer1, \"参数不能为空\");\nObjects.requireNonNull(integer1, () -> \"参数不能为空\");\n```\n\n### 4.3 判断两个对象是否相等 \n\n我们经常需要判断两个对象是否相等，Objects给我们提供了`equals`方法，能非常方便的实现：\n\n```java\nInteger integer1 = new Integer(1);\nInteger integer2 = new Integer(1);\n\nSystem.out.println(Objects.equals(integer1, integer2));\n```\n\n执行结果：\n\n```java\ntrue\n```\n\n但使用这个方法有坑，比如例子改成：\n\n```java\nInteger integer1 = new Integer(1);\nLong integer2 = new Long(1);\n\nSystem.out.println(Objects.equals(integer1, integer2));\n```\n\n执行结果：\n\n```java\nfalse\n```\n\n具体原因不细说了，有兴趣的小伙们可以看看我的另一篇文章《[Objects.equals有坑][Objects.equals]》，里面有非常详细的讲解。\n\n### 4.4 获取对象的hashCode \n\n如果你想获取某个对象的hashCode，可以使用Objects的`hashCode`方法。例如：\n\n```java\nString str = new String(\"abc\");\nSystem.out.println(Objects.hashCode(str));\n```\n\n执行结果：\n\n```java\n96354\n```\n\nObjects的内容先介绍到这里，有兴趣的小伙们，可以看看下面更多的方法：![image_d64a89cc.png](推荐17个提升开发效率轮子/image_d64a89cc.png)\n\n## 5. BooleanUtils \n\n在java中布尔值，随处可见。\n\n如果你使用了布尔的包装类：`Boolean`，总感觉有点麻烦，因为它有三种值：`null`、`true`、`false`。我们在处理Boolean对象时，需要经常判空。\n\n头疼！！！\n\n但如果使用`BooleanUtils`类处理布尔值，心情一下子就愉悦起来了。\n\n### 5.1 判断true或false \n\n如果你想判断某个参数的值是true或false，可以直接使用`isTrue`或`isFalse`方法。例如：\n\n```java\nBoolean aBoolean = new Boolean(true);\nSystem.out.println(BooleanUtils.isTrue(aBoolean));\nSystem.out.println(BooleanUtils.isFalse(aBoolean));\n```\n\n### 5.2 判断不为true或不为false \n\n有时候，需要判断某个参数不为true，即是null或者false。或者判断不为false，即是null或者true。\n\n可以使用`isNotTrue`或`isNotFalse`方法。例如：\n\n```java\nBoolean aBoolean = new Boolean(true);\nBoolean aBoolean1 = null;\nSystem.out.println(BooleanUtils.isNotTrue(aBoolean));\nSystem.out.println(BooleanUtils.isNotTrue(aBoolean1));\nSystem.out.println(BooleanUtils.isNotFalse(aBoolean));\nSystem.out.println(BooleanUtils.isNotFalse(aBoolean1));\n```\n\n执行结果：\n\n```java\nfalse\ntrue\ntrue\ntrue\n```\n\n### 5.3 转换成数字 \n\n如果你想将true转换成数字1，false转换成数字0，可以使用`toInteger`方法：\n\n```java\nBoolean aBoolean = new Boolean(true);\nBoolean aBoolean1 = new Boolean(false);\nSystem.out.println(BooleanUtils.toInteger(aBoolean));\nSystem.out.println(BooleanUtils.toInteger(aBoolean1));\n```\n\n执行结果：\n\n```java\n1\n0\n```\n\n### 5.4 Boolean转换成布尔值 \n\n我们有时候需要将包装类`Boolean`对象，转换成原始的`boolean`对象，可以使用`toBoolean`方法。例如：\n\n```java\nBoolean aBoolean = new Boolean(true);\nBoolean aBoolean1 = null;\nSystem.out.println(BooleanUtils.toBoolean(aBoolean));\nSystem.out.println(BooleanUtils.toBoolean(aBoolean1));\nSystem.out.println(BooleanUtils.toBooleanDefaultIfNull(aBoolean1, false));\n```\n\n我们无需额外的判空了，而且还可以设置Boolean对象为空时返回的默认值。\n\nBooleanUtils类的方法还有很多，有兴趣的小伙伴可以看看下面的内容：![image_56af129c.png](推荐17个提升开发效率轮子/image_56af129c.png)\n\n## 6. StringUtils \n\n`字符串`（String）在我们的日常工作中，用得非常非常非常多。\n\n在我们的代码中经常需要对字符串判空，截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。\n\n如果只用String类提供的那些方法，我们需要手写大量的额外代码，不然容易出现各种异常。\n\n现在有个好消息是：`org.apache.commons.lang3`包下的`StringUtils`工具类，给我们提供了非常丰富的选择。\n\n### 6.1 字符串判空 \n\n其实空字符串，不只是null一种，还有\"\"，\" \"，\"null\"等等，多种情况。\n\nStringUtils给我们提供了多个判空的静态方法，例如：\n\n```java\n String str1 = null;\nString str2 = \"\";\nString str3 = \" \";\nString str4 = \"abc\";\nSystem.out.println(StringUtils.isEmpty(str1));\nSystem.out.println(StringUtils.isEmpty(str2));\nSystem.out.println(StringUtils.isEmpty(str3));\nSystem.out.println(StringUtils.isEmpty(str4));\nSystem.out.println(\"=====\");\nSystem.out.println(StringUtils.isNotEmpty(str1));\nSystem.out.println(StringUtils.isNotEmpty(str2));\nSystem.out.println(StringUtils.isNotEmpty(str3));\nSystem.out.println(StringUtils.isNotEmpty(str4));\nSystem.out.println(\"=====\");\nSystem.out.println(StringUtils.isBlank(str1));\nSystem.out.println(StringUtils.isBlank(str2));\nSystem.out.println(StringUtils.isBlank(str3));\nSystem.out.println(StringUtils.isBlank(str4));\nSystem.out.println(\"=====\");\nSystem.out.println(StringUtils.isNotBlank(str1));\nSystem.out.println(StringUtils.isNotBlank(str2));\nSystem.out.println(StringUtils.isNotBlank(str3));\nSystem.out.println(StringUtils.isNotBlank(str4));\n```\n\n执行结果：\n\n```java\ntrue\ntrue\nfalse\nfalse\n=====\nfalse\nfalse\ntrue\ntrue\n=====\ntrue\ntrue\ntrue\nfalse\n=====\nfalse\nfalse\nfalse\ntrue\n```\n\n示例中的：`isEmpty`、`isNotEmpty`、`isBlank`和`isNotBlank`，这4个判空方法你们可以根据实际情况使用。\n\n> 优先推荐使用`isBlank`和`isNotBlank`方法，因为它会把`\" \"`也考虑进去。\n\n### 6.2 分隔字符串 \n\n分隔字符串是常见需求，如果直接使用String类的split方法，就可能会出现空指针异常。\n\n```java\nString str1 = null;\nSystem.out.println(StringUtils.split(str1,\",\"));\nSystem.out.println(str1.split(\",\"));\n```\n\n执行结果：\n\n```java\nnull\nException in thread \"main\" java.lang.NullPointerException\n at com.sue.jump.service.test1.UtilTest.main(UtilTest.java:21)\n```\n\n使用StringUtils的split方法会返回null，而使用String的split方法会报指针异常。\n\n### 6.3 判断是否纯数字 \n\n给定一个字符串，判断它是否为纯数字，可以使用`isNumeric`方法。例如：\n\n```java\nString str1 = \"123\";\nString str2 = \"123q\";\nString str3 = \"0.33\";\nSystem.out.println(StringUtils.isNumeric(str1));\nSystem.out.println(StringUtils.isNumeric(str2));\nSystem.out.println(StringUtils.isNumeric(str3));\n```\n\n执行结果：\n\n```java\ntrue\nfalse\nfalse\n```\n\n### 6.4 将集合拼接成字符串 \n\n有时候，我们需要将某个集合的内容，拼接成一个字符串，然后输出，这时可以使用`join`方法。例如：\n\n```java\nList<String> list = Lists.newArrayList(\"a\", \"b\", \"c\");\nList<Integer> list2 = Lists.newArrayList(1, 2, 3);\nSystem.out.println(StringUtils.join(list, \",\"));\nSystem.out.println(StringUtils.join(list2, \" \"));\n```\n\n执行结果：\n\n```java\na,b,c\n1 2 3\n```\n\n当然还有很多实用的方法，我在这里就不一一介绍了。![image_48270fb5.png](推荐17个提升开发效率轮子/image_48270fb5.png)\n\n![image_77defa60.png](推荐17个提升开发效率轮子/image_77defa60.png)\n\n## 7. Assert \n\n很多时候，我们需要在代码中做判断：如果不满足条件，则抛异常。\n\n有没有统一的封装呢?\n\n其实`spring`给我们提供了`Assert`类，它表示`断言`。\n\n### 7.1 断言参数是否为空 \n\n断言`参数`是否空，如果不满足条件，则直接抛异常。\n\n```java\nString str = null;\nAssert.isNull(str, \"str必须为空\");\nAssert.isNull(str, () -> \"str必须为空\");\nAssert.notNull(str, \"str不能为空\");\n```\n\n如果不满足条件就会抛出`IllegalArgumentException`异常。\n\n### 7.2 断言集合是否为空 \n\n断言`集合`是否空，如果不满足条件，则直接抛异常。\n\n```java\nList<String> list = null;\nMap<String, String> map = null;\nAssert.notEmpty(list, \"list不能为空\");\nAssert.notEmpty(list, () -> \"list不能为空\");\nAssert.notEmpty(map, \"map不能为空\");\n```\n\n如果不满足条件就会抛出`IllegalArgumentException`异常。\n\n### 7.3 断言条件是否为空 \n\n断言是否满足某个`条件`，如果不满足条件，则直接抛异常。\n\n```java\nList<String> list = null;\nAssert.isTrue(CollectionUtils.isNotEmpty(list), \"list不能为空\");\nAssert.isTrue(CollectionUtils.isNotEmpty(list), () -> \"list不能为空\");\n```\n\n当然Assert类还有一些其他的功能，这里就不多介绍了。![image_b1853624.png](推荐17个提升开发效率轮子/image_b1853624.png)\n\n## 8. IOUtils \n\n`IO`流在我们日常工作中也用得比较多，尽管java已经给我们提供了丰富的API。\n\n但我们不得不每次读取文件，或者写入文件之后，写一些重复的的代码。手动在`finally`代码块中关闭流，不然可能会造成`内存溢出`。\n\n有个好消息是：如果你使用`org.apache.commons.io`包下的`IOUtils`类，会节省大量的时间。\n\n### 8.1 读取文件 \n\n如果你想将某个txt文件中的数据，读取到字符串当中，可以使用IOUtils类的`toString`方法。例如：\n\n```java\nString str = IOUtils.toString(new FileInputStream(\"/temp/a.txt\"), StandardCharsets.UTF_8);\nSystem.out.println(str);\n```\n\n### 8.2 写入文件 \n\n如果你想将某个字符串的内容，写入到指定文件当中，可以使用IOUtils类的`write`方法。例如：\n\n```java\nString str = \"abcde\";\nIOUtils.write(str, new FileOutputStream(\"/temp/b.tx\"), StandardCharsets.UTF_8);\n```\n\n### 8.3 文件拷贝 \n\n如果你想将某个文件中的所有内容，都拷贝到另一个文件当中，可以使用IOUtils类的`copy`方法。例如：\n\n```java\nIOUtils.copy(new FileInputStream(\"/temp/a.txt\"), new FileOutputStream(\"/temp/b.txt\"));\n```\n\n### 8.4 读取文件内容到字节数组 \n\n如果你想将某个文件中的内容，读取字节数组中，可以使用IOUtils类的`toByteArray`方法。例如：\n\n```java\nbyte[] bytes = IOUtils.toByteArray(new FileInputStream(\"/temp/a.txt\"));\n```\n\nIOUtils类非常实用，感兴趣的小伙们，可以看看下面内容。![image_fadda8b7.png](推荐17个提升开发效率轮子/image_fadda8b7.png)\n\n## 9. MDC \n\n`MDC`是`org.slf4j`包下的一个类，它的全称是Mapped Diagnostic Context，我们可以认为它是一个线程安全的存放诊断日志的容器。\n\nMDC的底层是用了`ThreadLocal`来保存数据的。\n\n我们可以用它传递参数。\n\n例如现在有这样一种场景：我们使用`RestTemplate`调用远程接口时，有时需要在`header`中传递信息，比如：traceId，source等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。\n\n这种业务场景就能通过`ClientHttpRequestInterceptor`接口实现，具体做法如下：\n\n第一步，定义一个LogFilter拦截所有接口请求，在MDC中设置traceId：\n\n```java\npublic class LogFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        MdcUtil.add(UUID.randomUUID().toString());\n        System.out.println(\"记录请求日志\");\n        chain.doFilter(request, response);\n        System.out.println(\"记录响应日志\");\n    }\n\n    @Override\n    public void destroy() {\n    }\n}\n```\n\n第二步，实现`ClientHttpRequestInterceptor`接口，MDC中获取当前请求的traceId，然后设置到header中：\n\n```java\npublic class RestTemplateInterceptor implements ClientHttpRequestInterceptor {\n\n    @Override\n    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {\n        request.getHeaders().set(\"traceId\", MdcUtil.get());\n        return execution.execute(request, body);\n    }\n}\n```\n\n第三步，定义配置类，配置上面定义的`RestTemplateInterceptor`类：\n\n```java\n@Configuration\npublic class RestTemplateConfiguration {\n\n    @Bean\n    public RestTemplate restTemplate() {\n        RestTemplate restTemplate = new RestTemplate();\n        restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));\n        return restTemplate;\n    }\n\n    @Bean\n    public RestTemplateInterceptor restTemplateInterceptor() {\n        return new RestTemplateInterceptor();\n    }\n}\n```\n\n其中MdcUtil其实是利用MDC工具在ThreadLocal中存储和获取traceId\n\n```java\npublic class MdcUtil {\n\n    private static final String TRACE_ID = \"TRACE_ID\";\n\n    public static String get() {\n        return MDC.get(TRACE_ID);\n    }\n\n    public static void add(String value) {\n        MDC.put(TRACE_ID, value);\n    }\n}\n```\n\n当然，这个例子中没有演示MdcUtil类的add方法具体调的地方，我们可以在filter中执行接口方法之前，生成traceId，调用MdcUtil类的add方法添加到MDC中，然后在同一个请求的其他地方就能通过MdcUtil类的get方法获取到该traceId。\n\n能使用MDC保存traceId等参数的根本原因是，用户请求到应用服务器，Tomcat会从线程池中分配一个线程去处理该请求。\n\n那么该请求的整个过程中，保存到MDC的ThreadLocal中的参数，也是该线程独享的，所以不会有线程安全问题。\n\n## 10. ClassUtils \n\nspring的`org.springframework.util`包下的`ClassUtils`类，它里面有很多让我们惊喜的功能。\n\n它里面包含了类和对象相关的很多非常实用的方法。\n\n### 10.1 获取对象的所有接口 \n\n如果你想获取某个对象的所有接口，可以使用ClassUtils的`getAllInterfaces`方法。例如：\n\n```java\nClass<?>[] allInterfaces = ClassUtils.getAllInterfaces(new User());\n```\n\n### 10.2 获取某个类的包名 \n\n如果你想获取某个类的包名，可以使用ClassUtils的`getPackageName`方法。例如：\n\n```java\nString packageName = ClassUtils.getPackageName(User.class);\nSystem.out.println(packageName);\n```\n\n### 10.3 判断某个类是否内部类 \n\n如果你想判断某个类是否内部类，可以使用ClassUtils的`isInnerClass`方法。例如：\n\n```java\nSystem.out.println(ClassUtils.isInnerClass(User.class));\n```\n\n### 10.4 判断对象是否代理对象 \n\n如果你想判断对象是否代理对象，可以使用ClassUtils的`isCglibProxy`方法。例如：\n\n```java\nSystem.out.println(ClassUtils.isCglibProxy(new User()));\n```\n\nClassUtils还有很多有用的方法，等待着你去发掘。感兴趣的朋友，可以看看下面内容：![image_dec3e504.png](推荐17个提升开发效率轮子/image_dec3e504.png)\n\n## 11. BeanUtils \n\nspring给我们提供了一个`JavaBean`的工具类，它在`org.springframework.beans`包下面，它的名字叫做：`BeanUtils`。\n\n让我们一起看看这个工具可以带给我们哪些惊喜。\n\n### 11.1 拷贝对象的属性 \n\n曾几何时，你有没有这样的需求：把某个对象中的所有属性，都拷贝到另外一个对象中。这时就能使用BeanUtils的`copyProperties`方法。例如：\n\n```java\nUser user1 = new User();\nuser1.setId(1L);\nuser1.setName(\"苏三说技术\");\nuser1.setAddress(\"成都\");\n\nUser user2 = new User();\nBeanUtils.copyProperties(user1, user2);\nSystem.out.println(user2);\n```\n\n### 11.2 实例化某个类 \n\n如果你想通过反射实例化一个类的对象，可以使用BeanUtils的`instantiateClass`方法。例如：\n\n```java\nUser user = BeanUtils.instantiateClass(User.class);\nSystem.out.println(user);\n```\n\n### 11.3 获取指定类的指定方法 \n\n如果你想获取某个类的指定方法，可以使用BeanUtils的`findDeclaredMethod`方法。例如：\n\n```java\nMethod declaredMethod = BeanUtils.findDeclaredMethod(User.class, \"getId\");\nSystem.out.println(declaredMethod.getName());\n```\n\n### 11.4 获取指定方法的参数 \n\n如果你想获取某个方法的参数，可以使用BeanUtils的`findPropertyForMethod`方法。例如：\n\n```java\nMethod declaredMethod = BeanUtils.findDeclaredMethod(User.class, \"getId\");\nPropertyDescriptor propertyForMethod = BeanUtils.findPropertyForMethod(declaredMethod);\nSystem.out.println(propertyForMethod.getName());\n```\n\n如果你对BeanUtils比较感兴趣，可以看看下面内容：![image_7eeac46e.png](推荐17个提升开发效率轮子/image_7eeac46e.png)\n\n## 12. ReflectionUtils \n\n有时候，我们需要在项目中使用`反射`功能，如果使用最原始的方法来开发，代码量会非常多，而且很麻烦，它需要处理一大堆异常以及访问权限等问题。\n\n好消息是spring给我们提供了一个`ReflectionUtils`工具，它在`org.springframework.util`包下面。\n\n### 12.1 获取方法 \n\n如果你想获取某个类的某个方法，可以使用ReflectionUtils类的`findMethod`方法。例如：\n\n```java\nMethod method = ReflectionUtils.findMethod(User.class, \"getId\");\n```\n\n### 12.2 获取字段 \n\n如果你想获取某个类的某个字段，可以使用ReflectionUtils类的`findField`方法。例如：\n\n```java\nField field = ReflectionUtils.findField(User.class, \"id\");\n```\n\n### 12.3 执行方法 \n\n如果你想通过反射调用某个方法，传递参数，可以使用ReflectionUtils类的`invokeMethod`方法。例如：\n\n```java\n ReflectionUtils.invokeMethod(method, springContextsUtil.getBean(beanName), param);\n```\n\n### 12.4 判断字段是否常量 \n\n如果你想判断某个字段是否常量，可以使用ReflectionUtils类的`isPublicStaticFinal`方法。例如：\n\n```java\nField field = ReflectionUtils.findField(User.class, \"id\");\nSystem.out.println(ReflectionUtils.isPublicStaticFinal(field));\n```\n\n### 12.5 判断是否equals方法 \n\n如果你想判断某个方法是否equals方法，可以使用ReflectionUtils类的`isEqualsMethod`方法。例如：\n\n```java\nMethod method = ReflectionUtils.findMethod(User.class, \"getId\");\nSystem.out.println(ReflectionUtils.isEqualsMethod(method));\n```\n\n当然这个类还有不少有趣的方法，感兴趣的朋友，可以看看下面内容：![image_ea531c2a.png](推荐17个提升开发效率轮子/image_ea531c2a.png)\n\n## 13. Base64Utils \n\n有时候，为了安全考虑，需要将参数只用`base64`编码。\n\n这时就能直接使用`org.springframework.util`包下的`Base64Utils`工具类。\n\n它里面包含：`encode`和`decode`方法，用于对数据进行加密和解密。例如：\n\n```java\nString str = \"abc\";\nString encode = new String(Base64Utils.encode(str.getBytes()));\nSystem.out.println(\"加密后：\" + encode);\ntry {\n    String decode = new String(Base64Utils.decode(encode.getBytes()), \"utf8\");\n    System.out.println(\"解密后：\" + decode);\n} catch (UnsupportedEncodingException e) {\n    e.printStackTrace();\n}\n```\n\n执行结果：\n\n```java\n加密后：YWJj\n解密后：abc\n```\n\n## 14. StandardCharsets \n\n我们在做字符转换的时候，经常需要指定字符编码，比如：UTF-8、ISO-8859-1等等。\n\n这时就可以直接使用`java.nio.charset`包下的`StandardCharsets`类中静态变量。\n\n例如：\n\n```java\nString str = \"abc\";\nString encode = new String(Base64Utils.encode(str.getBytes()));\nSystem.out.println(\"加密后：\" + encode);\nString decode = new String(Base64Utils.decode(encode.getBytes())\n, StandardCharsets.UTF_8);\nSystem.out.println(\"解密后：\" + decode);\n```\n\n## 15. DigestUtils \n\n有时候，我们需要对数据进行加密处理，比如：md5或sha256。\n\n可以使用apache的`org.apache.commons.codec.digest`包下的`DigestUtils`类。\n\n### 15.1 md5加密 \n\n如果你想对数据进行md5加密，可以使用DigestUtils的`md5Hex`方法。例如：\n\n```java\nString md5Hex = DigestUtils.md5Hex(\"苏三说技术\");\nSystem.out.println(md5Hex);\n```\n\n### 15.2 sha256加密 \n\n如果你想对数据进行sha256加密，可以使用DigestUtils的`sha256Hex`方法。例如：\n\n```java\nString md5Hex = DigestUtils.sha256Hex(\"苏三说技术\");\nSystem.out.println(md5Hex);\n```\n\n当然这个工具还有很多其他的加密方法：![image_fec0346f.png](推荐17个提升开发效率轮子/image_fec0346f.png)\n\n## 16. SerializationUtils \n\n有时候，我们需要把数据进行`序列化`和`反序列化`处理。\n\n传统的做法是某个类实现`Serializable`接口，然后重新它的`writeObject`和`readObject`方法。\n\n但如果使用`org.springframework.util`包下的`SerializationUtils`工具类，能更轻松实现序列化和反序列化功能。例如：\n\n```java\nMap<String, String> map = Maps.newHashMap();\nmap.put(\"a\", \"1\");\nmap.put(\"b\", \"2\");\nmap.put(\"c\", \"3\");\nbyte[] serialize = SerializationUtils.serialize(map);\nObject deserialize = SerializationUtils.deserialize(serialize);\nSystem.out.println(deserialize);\n```\n\n## 17. HttpStatus \n\n很多时候，我们会在代码中定义http的返回码，比如：接口正常返回200，异常返回500，接口找不到返回404，接口不可用返回502等。\n\n```java\nprivate int SUCCESS_CODE = 200;\nprivate int ERROR_CODE = 500;\nprivate int NOT_FOUND_CODE = 404;\n```\n\n其实`org.springframework.http`包下的HttpStatus枚举，或者`org.apache.http`包下的`HttpStatus`接口，已经把常用的http返回码给我们定义好了，直接拿来用就可以了，真的不用再重复定义了。\n\n![image_d1a5a95c.png](推荐17个提升开发效率轮子/image_d1a5a95c.png)","slug":"推荐17个提升开发效率轮子","published":1,"updated":"2022-11-09T03:39:11.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cla93e2ly0000jkld1woodrc6","content":"<h2 id=\"1-Collections\"><a href=\"#1-Collections\" class=\"headerlink\" title=\"1. Collections\"></a>1. Collections</h2><p>首先出场的是<code>java.util</code>包下的<code>Collections</code>类，该类主要用于操作集合或者返回集合，我个人非常喜欢用它。</p>\n<h3 id=\"1-1-排序\"><a href=\"#1-1-排序\" class=\"headerlink\" title=\"1.1 排序\"></a>1.1 排序</h3><p>在工作中经常有对集合排序的需求。</p>\n<p>看看使用<code>Collections</code>工具是如何实现升序和降序的：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//升序</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//降序</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"1-2-获取最大或最小值\"><a href=\"#1-2-获取最大或最小值\" class=\"headerlink\" title=\"1.2 获取最大或最小值\"></a>1.2 获取最大或最小值</h3><p>有时候需要找出集合中的<code>最大值</code>或者<code>最小值</code>，这时可以使用Collections的<code>max</code>和<code>min</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Integer</span> max <span class=\"token operator\">=</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//获取最大值</span>\n<span class=\"token class-name\">Integer</span> min <span class=\"token operator\">=</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//获取最小值</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token number\">3</span>\n<span class=\"token number\">1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"1-3-转换线程安全集合\"><a href=\"#1-3-转换线程安全集合\" class=\"headerlink\" title=\"1.3 转换线程安全集合\"></a>1.3 转换线程安全集合</h3><p>我们都知道，java中的很多集合，比如：ArrayList、LinkedList、HashMap、HashSet等，都是线程不安全的。</p>\n<p>换句话说，这些集合在多线程的环境中，添加数据会出现异常。</p>\n<p>这时，可以用Collections的<code>synchronizedxxx</code>方法，将这些线程不安全的集合，直接转换成线程安全集合。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> integers <span class=\"token operator\">=</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">synchronizedList</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//将ArrayList转换成线程安全集合</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>integers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>它的底层会创建<code>SynchronizedRandomAccessList</code>或者<code>SynchronizedList</code>类，这两个类的很多方法都会用<code>synchronized</code>加锁。</p>\n<h3 id=\"1-4-返回空集合\"><a href=\"#1-4-返回空集合\" class=\"headerlink\" title=\"1.4 返回空集合\"></a>1.4 返回空集合</h3><p>有时，我们在判空之后，需要返回空集合，就可以使用<code>emptyList</code>方法，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>list <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">emptyList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">//业务处理</span>\n    <span class=\"token keyword\">return</span> list<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"1-5-二分查找\"><a href=\"#1-5-二分查找\" class=\"headerlink\" title=\"1.5 二分查找\"></a>1.5 二分查找</h3><p><code>binarySearch</code>方法提供了一个非常好用的<code>二分查找</code>功能，只用传入指定集合和需要找到的key即可。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">binarySearch</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//二分查找</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token number\">2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"1-6-转换成不可修改集合\"><a href=\"#1-6-转换成不可修改集合\" class=\"headerlink\" title=\"1.6 转换成不可修改集合\"></a>1.6 转换成不可修改集合</h3><p>为了防止后续的程序把某个集合的结果修改了，有时候我们需要把某个集合定义成不可修改的，使用Collections的<code>unmodifiablexxx</code>方法就能轻松实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> integers <span class=\"token operator\">=</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">unmodifiableList</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nintegers<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>integers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Exception</span> in thread <span class=\"token string\">\"main\"</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span>UnsupportedOperationException</span>\n at <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span>Collections</span>$<span class=\"token class-name\">UnmodifiableCollection</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">1055</span><span class=\"token punctuation\">)</span>\n at <span class=\"token class-name\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>sue<span class=\"token punctuation\">.</span>jump<span class=\"token punctuation\">.</span>service<span class=\"token punctuation\">.</span>test1<span class=\"token punctuation\">.</span></span>UtilTest</span><span class=\"token punctuation\">.</span><span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UtilTest</span><span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">19</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>当然Collections工具类中还有很多常用的方法，在这里就不一一介绍了，需要你自己去探索。</p>\n<p><img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_22c2f25a.png\" alt=\"image_22c2f25a.png\"> <img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_71d4889f.png\" alt=\"image_71d4889f.png\"></p>\n<h2 id=\"2-CollectionUtils\"><a href=\"#2-CollectionUtils\" class=\"headerlink\" title=\"2. CollectionUtils\"></a>2. CollectionUtils</h2><p>对集合操作，除了前面说的<code>Collections</code>工具类之后，<code>CollectionUtils</code>工具类也非常常用。</p>\n<p>目前比较主流的是<code>spring</code>的<code>org.springframework.util</code>包下的CollectionUtils工具类。<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_f8deb8c1.png\" alt=\"image_f8deb8c1.png\"></p>\n<p>和<code>apache</code>的<code>org.apache.commons.collections</code>包下的CollectionUtils工具类。</p>\n<p><img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_5cf672b2.png\" alt=\"image_5cf672b2.png\"></p>\n<p><img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_98de130d.png\" alt=\"image_98de130d.png\"></p>\n<blockquote>\n<p>我个人更推荐使用apache的包下的CollectionUtils工具类，因为它的工具更多更全面。</p>\n</blockquote>\n<p>举个简单的例子，<code>spring</code>的CollectionUtils工具类没有判断集合不为空的方法。而<code>apache</code>的CollectionUtils工具类却有。</p>\n<p>下面我们以<code>apache</code>的CollectionUtils工具类为例，介绍一下常用方法。</p>\n<h3 id=\"2-1-集合判空\"><a href=\"#2-1-集合判空\" class=\"headerlink\" title=\"2.1 集合判空\"></a>2.1 集合判空</h3><p>通过CollectionUtils工具类的<code>isEmpty</code>方法可以轻松判断集合是否为空，<code>isNotEmpty</code>方法判断集合不为空。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"集合为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"集合不为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"2-2-对两个集合进行操作\"><a href=\"#2-2-对两个集合进行操作\" class=\"headerlink\" title=\"2.2 对两个集合进行操作\"></a>2.2 对两个集合进行操作</h3><p>有时候我们需要对已有的两个集合进行操作，比如取交集或者并集等。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist2<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist2<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//获取并集</span>\n<span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> unionList <span class=\"token operator\">=</span> <span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">union</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> list2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>unionList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//获取交集</span>\n<span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> intersectionList <span class=\"token operator\">=</span> <span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">intersection</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> list2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>intersectionList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//获取交集的补集</span>\n<span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> disjunctionList <span class=\"token operator\">=</span> <span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">disjunction</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> list2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>disjunctionList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//获取差集</span>\n<span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> subtractList <span class=\"token operator\">=</span> <span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">subtract</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> list2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>subtractList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>说句实话，对两个集合的操作，在实际工作中用得挺多的，特别是很多批量的场景中。以前我们需要写一堆代码，但没想到有现成的轮子。</p>\n<h2 id=\"3-Lists\"><a href=\"#3-Lists\" class=\"headerlink\" title=\"3. Lists\"></a>3. Lists</h2><p>如果你引入<code>com.google.guava</code>的pom文件，会获得很多好用的小工具。这里推荐一款<code>com.google.common.collect</code>包下的集合工具：<code>Lists</code>。</p>\n<p>它是在太好用了，让我爱不释手。</p>\n<h3 id=\"3-1-创建空集合\"><a href=\"#3-1-创建空集合\" class=\"headerlink\" title=\"3.1 创建空集合\"></a>3.1 创建空集合</h3><p>有时候，我们想创建一个空集合。这时可以用Lists的<code>newArrayList</code>方法，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-2-快速初始化集合\"><a href=\"#3-2-快速初始化集合\" class=\"headerlink\" title=\"3.2 快速初始化集合\"></a>3.2 快速初始化集合</h3><p>有时候，我们想给一个集合中初始化一些元素。这时可以用Lists的newArrayList方法，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-3-笛卡尔积\"><a href=\"#3-3-笛卡尔积\" class=\"headerlink\" title=\"3.3 笛卡尔积\"></a>3.3 笛卡尔积</h3><p>如果你想将两个集合做<code>笛卡尔积</code>，Lists的<code>cartesianProduct</code>方法可以帮你实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list1 <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list2 <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> productList <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">cartesianProduct</span><span class=\"token punctuation\">(</span>list1<span class=\"token punctuation\">,</span>list2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>productList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-4-分页\"><a href=\"#3-4-分页\" class=\"headerlink\" title=\"3.4 分页\"></a>3.4 分页</h3><p>如果你想将一个<code>大集合</code>分成若干个<code>小集合</code>，可以使用Lists的<code>partition</code>方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> partitionList <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>partitionList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。</p>\n<p>这个是我最喜欢的方法之一，经常在项目中使用。</p>\n<p>比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。</p>\n<h3 id=\"3-5-流处理\"><a href=\"#3-5-流处理\" class=\"headerlink\" title=\"3.5 流处理\"></a>3.5 流处理</h3><p>如果我们想把某个集合转换成另外一个接口，可以使用Lists的<code>transform</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> transformList <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">transform</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> x <span class=\"token operator\">-></span> x<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>transformList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>将小写字母转换成了大写字母。</p>\n<h3 id=\"3-6-颠倒顺序\"><a href=\"#3-6-颠倒顺序\" class=\"headerlink\" title=\"3.6 颠倒顺序\"></a>3.6 颠倒顺序</h3><p>Lists的有颠倒顺序的方法<code>reverse</code>。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> reverseList <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>reverseList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>list的原始顺序是312，使用<code>reverse</code>方法颠倒顺序之后，变成了213。</p>\n<p>Lists还有其他的好用的工具，我在这里只是抛砖引玉，有兴趣的朋友，可以仔细研究一下。<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_040afd70.png\" alt=\"image_040afd70.png\"></p>\n<h2 id=\"4-Objects\"><a href=\"#4-Objects\" class=\"headerlink\" title=\"4. Objects\"></a>4. Objects</h2><p>在<code>jdk7</code>之后，提供了<code>Objects</code>工具类，我们可以通过它操作对象。</p>\n<h3 id=\"4-1-对象判空\"><a href=\"#4-1-对象判空\" class=\"headerlink\" title=\"4.1 对象判空\"></a>4.1 对象判空</h3><p>在java中万事万物皆对象，对象的判空可以说无处不在。Objects的<code>isNull</code>方法判断对象是否为空，而<code>nonNull</code>方法判断对象是否不为空。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> integer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNull</span><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"对象为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">nonNull</span><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"对象不为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"4-2-对象为空抛异常\"><a href=\"#4-2-对象为空抛异常\" class=\"headerlink\" title=\"4.2 对象为空抛异常\"></a>4.2 对象为空抛异常</h3><p>如果我们想在对象为空时，抛出空指针异常，可以使用Objects的<code>requireNonNull</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> integer1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">128</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">requireNonNull</span><span class=\"token punctuation\">(</span>integer1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">requireNonNull</span><span class=\"token punctuation\">(</span>integer1<span class=\"token punctuation\">,</span> <span class=\"token string\">\"参数不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">requireNonNull</span><span class=\"token punctuation\">(</span>integer1<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token string\">\"参数不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"4-3-判断两个对象是否相等\"><a href=\"#4-3-判断两个对象是否相等\" class=\"headerlink\" title=\"4.3 判断两个对象是否相等\"></a>4.3 判断两个对象是否相等</h3><p>我们经常需要判断两个对象是否相等，Objects给我们提供了<code>equals</code>方法，能非常方便的实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> integer1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Integer</span> integer2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>integer1<span class=\"token punctuation\">,</span> integer2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token boolean\">true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>但使用这个方法有坑，比如例子改成：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> integer1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Long</span> integer2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Long</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>integer1<span class=\"token punctuation\">,</span> integer2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token boolean\">false</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>具体原因不细说了，有兴趣的小伙们可以看看我的另一篇文章《[Objects.equals有坑][Objects.equals]》，里面有非常详细的讲解。</p>\n<h3 id=\"4-4-获取对象的hashCode\"><a href=\"#4-4-获取对象的hashCode\" class=\"headerlink\" title=\"4.4 获取对象的hashCode\"></a>4.4 获取对象的hashCode</h3><p>如果你想获取某个对象的hashCode，可以使用Objects的<code>hashCode</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token number\">96354</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>Objects的内容先介绍到这里，有兴趣的小伙们，可以看看下面更多的方法：<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_d64a89cc.png\" alt=\"image_d64a89cc.png\"></p>\n<h2 id=\"5-BooleanUtils\"><a href=\"#5-BooleanUtils\" class=\"headerlink\" title=\"5. BooleanUtils\"></a>5. BooleanUtils</h2><p>在java中布尔值，随处可见。</p>\n<p>如果你使用了布尔的包装类：<code>Boolean</code>，总感觉有点麻烦，因为它有三种值：<code>null</code>、<code>true</code>、<code>false</code>。我们在处理Boolean对象时，需要经常判空。</p>\n<p>头疼！！！</p>\n<p>但如果使用<code>BooleanUtils</code>类处理布尔值，心情一下子就愉悦起来了。</p>\n<h3 id=\"5-1-判断true或false\"><a href=\"#5-1-判断true或false\" class=\"headerlink\" title=\"5.1 判断true或false\"></a>5.1 判断true或false</h3><p>如果你想判断某个参数的值是true或false，可以直接使用<code>isTrue</code>或<code>isFalse</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Boolean</span> aBoolean <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>aBoolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isFalse</span><span class=\"token punctuation\">(</span>aBoolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"5-2-判断不为true或不为false\"><a href=\"#5-2-判断不为true或不为false\" class=\"headerlink\" title=\"5.2 判断不为true或不为false\"></a>5.2 判断不为true或不为false</h3><p>有时候，需要判断某个参数不为true，即是null或者false。或者判断不为false，即是null或者true。</p>\n<p>可以使用<code>isNotTrue</code>或<code>isNotFalse</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Boolean</span> aBoolean <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Boolean</span> aBoolean1 <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotTrue</span><span class=\"token punctuation\">(</span>aBoolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotTrue</span><span class=\"token punctuation\">(</span>aBoolean1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotFalse</span><span class=\"token punctuation\">(</span>aBoolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotFalse</span><span class=\"token punctuation\">(</span>aBoolean1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token boolean\">false</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token boolean\">true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"5-3-转换成数字\"><a href=\"#5-3-转换成数字\" class=\"headerlink\" title=\"5.3 转换成数字\"></a>5.3 转换成数字</h3><p>如果你想将true转换成数字1，false转换成数字0，可以使用<code>toInteger</code>方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Boolean</span> aBoolean <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Boolean</span> aBoolean1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">toInteger</span><span class=\"token punctuation\">(</span>aBoolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">toInteger</span><span class=\"token punctuation\">(</span>aBoolean1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token number\">1</span>\n<span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"5-4-Boolean转换成布尔值\"><a href=\"#5-4-Boolean转换成布尔值\" class=\"headerlink\" title=\"5.4 Boolean转换成布尔值\"></a>5.4 Boolean转换成布尔值</h3><p>我们有时候需要将包装类<code>Boolean</code>对象，转换成原始的<code>boolean</code>对象，可以使用<code>toBoolean</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Boolean</span> aBoolean <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Boolean</span> aBoolean1 <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBoolean</span><span class=\"token punctuation\">(</span>aBoolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBoolean</span><span class=\"token punctuation\">(</span>aBoolean1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBooleanDefaultIfNull</span><span class=\"token punctuation\">(</span>aBoolean1<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们无需额外的判空了，而且还可以设置Boolean对象为空时返回的默认值。</p>\n<p>BooleanUtils类的方法还有很多，有兴趣的小伙伴可以看看下面的内容：<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_56af129c.png\" alt=\"image_56af129c.png\"></p>\n<h2 id=\"6-StringUtils\"><a href=\"#6-StringUtils\" class=\"headerlink\" title=\"6. StringUtils\"></a>6. StringUtils</h2><p><code>字符串</code>（String）在我们的日常工作中，用得非常非常非常多。</p>\n<p>在我们的代码中经常需要对字符串判空，截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。</p>\n<p>如果只用String类提供的那些方法，我们需要手写大量的额外代码，不然容易出现各种异常。</p>\n<p>现在有个好消息是：<code>org.apache.commons.lang3</code>包下的<code>StringUtils</code>工具类，给我们提供了非常丰富的选择。</p>\n<h3 id=\"6-1-字符串判空\"><a href=\"#6-1-字符串判空\" class=\"headerlink\" title=\"6.1 字符串判空\"></a>6.1 字符串判空</h3><p>其实空字符串，不只是null一种，还有””，” “，”null”等等，多种情况。</p>\n<p>StringUtils给我们提供了多个判空的静态方法，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> <span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str2 <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str3 <span class=\"token operator\">=</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str4 <span class=\"token operator\">=</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>str3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>str4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=====\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span>str3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span>str4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=====\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isBlank</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isBlank</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isBlank</span><span class=\"token punctuation\">(</span>str3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isBlank</span><span class=\"token punctuation\">(</span>str4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=====\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotBlank</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotBlank</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotBlank</span><span class=\"token punctuation\">(</span>str3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotBlank</span><span class=\"token punctuation\">(</span>str4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token boolean\">true</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token boolean\">true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例中的：<code>isEmpty</code>、<code>isNotEmpty</code>、<code>isBlank</code>和<code>isNotBlank</code>，这4个判空方法你们可以根据实际情况使用。</p>\n<blockquote>\n<p>优先推荐使用<code>isBlank</code>和<code>isNotBlank</code>方法，因为它会把<code>&quot; &quot;</code>也考虑进去。</p>\n</blockquote>\n<h3 id=\"6-2-分隔字符串\"><a href=\"#6-2-分隔字符串\" class=\"headerlink\" title=\"6.2 分隔字符串\"></a>6.2 分隔字符串</h3><p>分隔字符串是常见需求，如果直接使用String类的split方法，就可能会出现空指针异常。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">,</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">null</span>\n<span class=\"token class-name\">Exception</span> in thread <span class=\"token string\">\"main\"</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span>NullPointerException</span>\n at <span class=\"token class-name\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>sue<span class=\"token punctuation\">.</span>jump<span class=\"token punctuation\">.</span>service<span class=\"token punctuation\">.</span>test1<span class=\"token punctuation\">.</span></span>UtilTest</span><span class=\"token punctuation\">.</span><span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UtilTest</span><span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">21</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>使用StringUtils的split方法会返回null，而使用String的split方法会报指针异常。</p>\n<h3 id=\"6-3-判断是否纯数字\"><a href=\"#6-3-判断是否纯数字\" class=\"headerlink\" title=\"6.3 判断是否纯数字\"></a>6.3 判断是否纯数字</h3><p>给定一个字符串，判断它是否为纯数字，可以使用<code>isNumeric</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token string\">\"123\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str2 <span class=\"token operator\">=</span> <span class=\"token string\">\"123q\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str3 <span class=\"token operator\">=</span> <span class=\"token string\">\"0.33\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNumeric</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNumeric</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNumeric</span><span class=\"token punctuation\">(</span>str3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token boolean\">true</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token boolean\">false</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"6-4-将集合拼接成字符串\"><a href=\"#6-4-将集合拼接成字符串\" class=\"headerlink\" title=\"6.4 将集合拼接成字符串\"></a>6.4 将集合拼接成字符串</h3><p>有时候，我们需要将某个集合的内容，拼接成一个字符串，然后输出，这时可以使用<code>join</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list2 <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> <span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>list2<span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c\n<span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>当然还有很多实用的方法，我在这里就不一一介绍了。<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_48270fb5.png\" alt=\"image_48270fb5.png\"></p>\n<p><img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_77defa60.png\" alt=\"image_77defa60.png\"></p>\n<h2 id=\"7-Assert\"><a href=\"#7-Assert\" class=\"headerlink\" title=\"7. Assert\"></a>7. Assert</h2><p>很多时候，我们需要在代码中做判断：如果不满足条件，则抛异常。</p>\n<p>有没有统一的封装呢?</p>\n<p>其实<code>spring</code>给我们提供了<code>Assert</code>类，它表示<code>断言</code>。</p>\n<h3 id=\"7-1-断言参数是否为空\"><a href=\"#7-1-断言参数是否为空\" class=\"headerlink\" title=\"7.1 断言参数是否为空\"></a>7.1 断言参数是否为空</h3><p>断言<code>参数</code>是否空，如果不满足条件，则直接抛异常。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNull</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> <span class=\"token string\">\"str必须为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNull</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token string\">\"str必须为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">notNull</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> <span class=\"token string\">\"str不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果不满足条件就会抛出<code>IllegalArgumentException</code>异常。</p>\n<h3 id=\"7-2-断言集合是否为空\"><a href=\"#7-2-断言集合是否为空\" class=\"headerlink\" title=\"7.2 断言集合是否为空\"></a>7.2 断言集合是否为空</h3><p>断言<code>集合</code>是否空，如果不满足条件，则直接抛异常。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">notEmpty</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> <span class=\"token string\">\"list不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">notEmpty</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token string\">\"list不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">notEmpty</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">,</span> <span class=\"token string\">\"map不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果不满足条件就会抛出<code>IllegalArgumentException</code>异常。</p>\n<h3 id=\"7-3-断言条件是否为空\"><a href=\"#7-3-断言条件是否为空\" class=\"headerlink\" title=\"7.3 断言条件是否为空\"></a>7.3 断言条件是否为空</h3><p>断言是否满足某个<code>条件</code>，如果不满足条件，则直接抛异常。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"list不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token string\">\"list不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>当然Assert类还有一些其他的功能，这里就不多介绍了。<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_b1853624.png\" alt=\"image_b1853624.png\"></p>\n<h2 id=\"8-IOUtils\"><a href=\"#8-IOUtils\" class=\"headerlink\" title=\"8. IOUtils\"></a>8. IOUtils</h2><p><code>IO</code>流在我们日常工作中也用得比较多，尽管java已经给我们提供了丰富的API。</p>\n<p>但我们不得不每次读取文件，或者写入文件之后，写一些重复的的代码。手动在<code>finally</code>代码块中关闭流，不然可能会造成<code>内存溢出</code>。</p>\n<p>有个好消息是：如果你使用<code>org.apache.commons.io</code>包下的<code>IOUtils</code>类，会节省大量的时间。</p>\n<h3 id=\"8-1-读取文件\"><a href=\"#8-1-读取文件\" class=\"headerlink\" title=\"8.1 读取文件\"></a>8.1 读取文件</h3><p>如果你想将某个txt文件中的数据，读取到字符串当中，可以使用IOUtils类的<code>toString</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token class-name\">IOUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/temp/a.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span>UTF_8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"8-2-写入文件\"><a href=\"#8-2-写入文件\" class=\"headerlink\" title=\"8.2 写入文件\"></a>8.2 写入文件</h3><p>如果你想将某个字符串的内容，写入到指定文件当中，可以使用IOUtils类的<code>write</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"abcde\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">IOUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/temp/b.tx\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span>UTF_8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"8-3-文件拷贝\"><a href=\"#8-3-文件拷贝\" class=\"headerlink\" title=\"8.3 文件拷贝\"></a>8.3 文件拷贝</h3><p>如果你想将某个文件中的所有内容，都拷贝到另一个文件当中，可以使用IOUtils类的<code>copy</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">IOUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/temp/a.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/temp/b.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"8-4-读取文件内容到字节数组\"><a href=\"#8-4-读取文件内容到字节数组\" class=\"headerlink\" title=\"8.4 读取文件内容到字节数组\"></a>8.4 读取文件内容到字节数组</h3><p>如果你想将某个文件中的内容，读取字节数组中，可以使用IOUtils类的<code>toByteArray</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bytes <span class=\"token operator\">=</span> <span class=\"token class-name\">IOUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">toByteArray</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/temp/a.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>IOUtils类非常实用，感兴趣的小伙们，可以看看下面内容。<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_fadda8b7.png\" alt=\"image_fadda8b7.png\"></p>\n<h2 id=\"9-MDC\"><a href=\"#9-MDC\" class=\"headerlink\" title=\"9. MDC\"></a>9. MDC</h2><p><code>MDC</code>是<code>org.slf4j</code>包下的一个类，它的全称是Mapped Diagnostic Context，我们可以认为它是一个线程安全的存放诊断日志的容器。</p>\n<p>MDC的底层是用了<code>ThreadLocal</code>来保存数据的。</p>\n<p>我们可以用它传递参数。</p>\n<p>例如现在有这样一种场景：我们使用<code>RestTemplate</code>调用远程接口时，有时需要在<code>header</code>中传递信息，比如：traceId，source等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。</p>\n<p>这种业务场景就能通过<code>ClientHttpRequestInterceptor</code>接口实现，具体做法如下：</p>\n<p>第一步，定义一个LogFilter拦截所有接口请求，在MDC中设置traceId：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LogFilter</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Filter</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">FilterConfig</span> filterConfig<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ServletException</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doFilter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ServletRequest</span> request<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ServletResponse</span> response<span class=\"token punctuation\">,</span> <span class=\"token class-name\">FilterChain</span> chain<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ServletException</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">MdcUtil</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>UUID<span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"记录请求日志\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        chain<span class=\"token punctuation\">.</span><span class=\"token function\">doFilter</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"记录响应日志\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">destroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>第二步，实现<code>ClientHttpRequestInterceptor</code>接口，MDC中获取当前请求的traceId，然后设置到header中：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RestTemplateInterceptor</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ClientHttpRequestInterceptor</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ClientHttpResponse</span> <span class=\"token function\">intercept</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpRequest</span> request<span class=\"token punctuation\">,</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> body<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ClientHttpRequestExecution</span> execution<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span>\n        request<span class=\"token punctuation\">.</span><span class=\"token function\">getHeaders</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"traceId\"</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">MdcUtil</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> execution<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>第三步，定义配置类，配置上面定义的<code>RestTemplateInterceptor</code>类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RestTemplateConfiguration</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">RestTemplate</span> <span class=\"token function\">restTemplate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">RestTemplate</span> restTemplate <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RestTemplate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        restTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">setInterceptors</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">singletonList</span><span class=\"token punctuation\">(</span><span class=\"token function\">restTemplateInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> restTemplate<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">RestTemplateInterceptor</span> <span class=\"token function\">restTemplateInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RestTemplateInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中MdcUtil其实是利用MDC工具在ThreadLocal中存储和获取traceId</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MdcUtil</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> TRACE_ID <span class=\"token operator\">=</span> <span class=\"token string\">\"TRACE_ID\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">String</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> MDC<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>TRACE_ID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        MDC<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>TRACE_ID<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当然，这个例子中没有演示MdcUtil类的add方法具体调的地方，我们可以在filter中执行接口方法之前，生成traceId，调用MdcUtil类的add方法添加到MDC中，然后在同一个请求的其他地方就能通过MdcUtil类的get方法获取到该traceId。</p>\n<p>能使用MDC保存traceId等参数的根本原因是，用户请求到应用服务器，Tomcat会从线程池中分配一个线程去处理该请求。</p>\n<p>那么该请求的整个过程中，保存到MDC的ThreadLocal中的参数，也是该线程独享的，所以不会有线程安全问题。</p>\n<h2 id=\"10-ClassUtils\"><a href=\"#10-ClassUtils\" class=\"headerlink\" title=\"10. ClassUtils\"></a>10. ClassUtils</h2><p>spring的<code>org.springframework.util</code>包下的<code>ClassUtils</code>类，它里面有很多让我们惊喜的功能。</p>\n<p>它里面包含了类和对象相关的很多非常实用的方法。</p>\n<h3 id=\"10-1-获取对象的所有接口\"><a href=\"#10-1-获取对象的所有接口\" class=\"headerlink\" title=\"10.1 获取对象的所有接口\"></a>10.1 获取对象的所有接口</h3><p>如果你想获取某个对象的所有接口，可以使用ClassUtils的<code>getAllInterfaces</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> allInterfaces <span class=\"token operator\">=</span> <span class=\"token class-name\">ClassUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">getAllInterfaces</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"10-2-获取某个类的包名\"><a href=\"#10-2-获取某个类的包名\" class=\"headerlink\" title=\"10.2 获取某个类的包名\"></a>10.2 获取某个类的包名</h3><p>如果你想获取某个类的包名，可以使用ClassUtils的<code>getPackageName</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> packageName <span class=\"token operator\">=</span> <span class=\"token class-name\">ClassUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">getPackageName</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>packageName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"10-3-判断某个类是否内部类\"><a href=\"#10-3-判断某个类是否内部类\" class=\"headerlink\" title=\"10.3 判断某个类是否内部类\"></a>10.3 判断某个类是否内部类</h3><p>如果你想判断某个类是否内部类，可以使用ClassUtils的<code>isInnerClass</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isInnerClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"10-4-判断对象是否代理对象\"><a href=\"#10-4-判断对象是否代理对象\" class=\"headerlink\" title=\"10.4 判断对象是否代理对象\"></a>10.4 判断对象是否代理对象</h3><p>如果你想判断对象是否代理对象，可以使用ClassUtils的<code>isCglibProxy</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isCglibProxy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>ClassUtils还有很多有用的方法，等待着你去发掘。感兴趣的朋友，可以看看下面内容：<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_dec3e504.png\" alt=\"image_dec3e504.png\"></p>\n<h2 id=\"11-BeanUtils\"><a href=\"#11-BeanUtils\" class=\"headerlink\" title=\"11. BeanUtils\"></a>11. BeanUtils</h2><p>spring给我们提供了一个<code>JavaBean</code>的工具类，它在<code>org.springframework.beans</code>包下面，它的名字叫做：<code>BeanUtils</code>。</p>\n<p>让我们一起看看这个工具可以带给我们哪些惊喜。</p>\n<h3 id=\"11-1-拷贝对象的属性\"><a href=\"#11-1-拷贝对象的属性\" class=\"headerlink\" title=\"11.1 拷贝对象的属性\"></a>11.1 拷贝对象的属性</h3><p>曾几何时，你有没有这样的需求：把某个对象中的所有属性，都拷贝到另外一个对象中。这时就能使用BeanUtils的<code>copyProperties</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nuser1<span class=\"token punctuation\">.</span><span class=\"token function\">setId</span><span class=\"token punctuation\">(</span><span class=\"token number\">1L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nuser1<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"苏三说技术\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nuser1<span class=\"token punctuation\">.</span><span class=\"token function\">setAddress</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"成都\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">User</span> user2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>user1<span class=\"token punctuation\">,</span> user2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>user2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"11-2-实例化某个类\"><a href=\"#11-2-实例化某个类\" class=\"headerlink\" title=\"11.2 实例化某个类\"></a>11.2 实例化某个类</h3><p>如果你想通过反射实例化一个类的对象，可以使用BeanUtils的<code>instantiateClass</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">instantiateClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"11-3-获取指定类的指定方法\"><a href=\"#11-3-获取指定类的指定方法\" class=\"headerlink\" title=\"11.3 获取指定类的指定方法\"></a>11.3 获取指定类的指定方法</h3><p>如果你想获取某个类的指定方法，可以使用BeanUtils的<code>findDeclaredMethod</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Method</span> declaredMethod <span class=\"token operator\">=</span> <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">findDeclaredMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"getId\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>declaredMethod<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"11-4-获取指定方法的参数\"><a href=\"#11-4-获取指定方法的参数\" class=\"headerlink\" title=\"11.4 获取指定方法的参数\"></a>11.4 获取指定方法的参数</h3><p>如果你想获取某个方法的参数，可以使用BeanUtils的<code>findPropertyForMethod</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Method</span> declaredMethod <span class=\"token operator\">=</span> <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">findDeclaredMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"getId\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">PropertyDescriptor</span> propertyForMethod <span class=\"token operator\">=</span> <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">findPropertyForMethod</span><span class=\"token punctuation\">(</span>declaredMethod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>propertyForMethod<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>如果你对BeanUtils比较感兴趣，可以看看下面内容：<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_7eeac46e.png\" alt=\"image_7eeac46e.png\"></p>\n<h2 id=\"12-ReflectionUtils\"><a href=\"#12-ReflectionUtils\" class=\"headerlink\" title=\"12. ReflectionUtils\"></a>12. ReflectionUtils</h2><p>有时候，我们需要在项目中使用<code>反射</code>功能，如果使用最原始的方法来开发，代码量会非常多，而且很麻烦，它需要处理一大堆异常以及访问权限等问题。</p>\n<p>好消息是spring给我们提供了一个<code>ReflectionUtils</code>工具，它在<code>org.springframework.util</code>包下面。</p>\n<h3 id=\"12-1-获取方法\"><a href=\"#12-1-获取方法\" class=\"headerlink\" title=\"12.1 获取方法\"></a>12.1 获取方法</h3><p>如果你想获取某个类的某个方法，可以使用ReflectionUtils类的<code>findMethod</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Method</span> method <span class=\"token operator\">=</span> <span class=\"token class-name\">ReflectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">findMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"getId\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"12-2-获取字段\"><a href=\"#12-2-获取字段\" class=\"headerlink\" title=\"12.2 获取字段\"></a>12.2 获取字段</h3><p>如果你想获取某个类的某个字段，可以使用ReflectionUtils类的<code>findField</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Field</span> field <span class=\"token operator\">=</span> <span class=\"token class-name\">ReflectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">findField</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"12-3-执行方法\"><a href=\"#12-3-执行方法\" class=\"headerlink\" title=\"12.3 执行方法\"></a>12.3 执行方法</h3><p>如果你想通过反射调用某个方法，传递参数，可以使用ReflectionUtils类的<code>invokeMethod</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">ReflectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">invokeMethod</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">,</span> springContextsUtil<span class=\"token punctuation\">.</span><span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"12-4-判断字段是否常量\"><a href=\"#12-4-判断字段是否常量\" class=\"headerlink\" title=\"12.4 判断字段是否常量\"></a>12.4 判断字段是否常量</h3><p>如果你想判断某个字段是否常量，可以使用ReflectionUtils类的<code>isPublicStaticFinal</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Field</span> field <span class=\"token operator\">=</span> <span class=\"token class-name\">ReflectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">findField</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ReflectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isPublicStaticFinal</span><span class=\"token punctuation\">(</span>field<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"12-5-判断是否equals方法\"><a href=\"#12-5-判断是否equals方法\" class=\"headerlink\" title=\"12.5 判断是否equals方法\"></a>12.5 判断是否equals方法</h3><p>如果你想判断某个方法是否equals方法，可以使用ReflectionUtils类的<code>isEqualsMethod</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Method</span> method <span class=\"token operator\">=</span> <span class=\"token class-name\">ReflectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">findMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"getId\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ReflectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEqualsMethod</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>当然这个类还有不少有趣的方法，感兴趣的朋友，可以看看下面内容：<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_ea531c2a.png\" alt=\"image_ea531c2a.png\"></p>\n<h2 id=\"13-Base64Utils\"><a href=\"#13-Base64Utils\" class=\"headerlink\" title=\"13. Base64Utils\"></a>13. Base64Utils</h2><p>有时候，为了安全考虑，需要将参数只用<code>base64</code>编码。</p>\n<p>这时就能直接使用<code>org.springframework.util</code>包下的<code>Base64Utils</code>工具类。</p>\n<p>它里面包含：<code>encode</code>和<code>decode</code>方法，用于对数据进行加密和解密。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> encode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Base64Utils</span><span class=\"token punctuation\">.</span><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"加密后：\"</span> <span class=\"token operator\">+</span> encode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">String</span> decode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Base64Utils</span><span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>encode<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"utf8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"解密后：\"</span> <span class=\"token operator\">+</span> decode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">UnsupportedEncodingException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">加密后：<span class=\"token class-name\">YWJj</span>\n解密后：abc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"14-StandardCharsets\"><a href=\"#14-StandardCharsets\" class=\"headerlink\" title=\"14. StandardCharsets\"></a>14. StandardCharsets</h2><p>我们在做字符转换的时候，经常需要指定字符编码，比如：UTF-8、ISO-8859-1等等。</p>\n<p>这时就可以直接使用<code>java.nio.charset</code>包下的<code>StandardCharsets</code>类中静态变量。</p>\n<p>例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> encode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Base64Utils</span><span class=\"token punctuation\">.</span><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"加密后：\"</span> <span class=\"token operator\">+</span> encode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> decode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Base64Utils</span><span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>encode<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">,</span> <span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span>UTF_8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"解密后：\"</span> <span class=\"token operator\">+</span> decode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"15-DigestUtils\"><a href=\"#15-DigestUtils\" class=\"headerlink\" title=\"15. DigestUtils\"></a>15. DigestUtils</h2><p>有时候，我们需要对数据进行加密处理，比如：md5或sha256。</p>\n<p>可以使用apache的<code>org.apache.commons.codec.digest</code>包下的<code>DigestUtils</code>类。</p>\n<h3 id=\"15-1-md5加密\"><a href=\"#15-1-md5加密\" class=\"headerlink\" title=\"15.1 md5加密\"></a>15.1 md5加密</h3><p>如果你想对数据进行md5加密，可以使用DigestUtils的<code>md5Hex</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> md5Hex <span class=\"token operator\">=</span> <span class=\"token class-name\">DigestUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">md5Hex</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"苏三说技术\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>md5Hex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"15-2-sha256加密\"><a href=\"#15-2-sha256加密\" class=\"headerlink\" title=\"15.2 sha256加密\"></a>15.2 sha256加密</h3><p>如果你想对数据进行sha256加密，可以使用DigestUtils的<code>sha256Hex</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> md5Hex <span class=\"token operator\">=</span> <span class=\"token class-name\">DigestUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">sha256Hex</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"苏三说技术\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>md5Hex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>当然这个工具还有很多其他的加密方法：<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_fec0346f.png\" alt=\"image_fec0346f.png\"></p>\n<h2 id=\"16-SerializationUtils\"><a href=\"#16-SerializationUtils\" class=\"headerlink\" title=\"16. SerializationUtils\"></a>16. SerializationUtils</h2><p>有时候，我们需要把数据进行<code>序列化</code>和<code>反序列化</code>处理。</p>\n<p>传统的做法是某个类实现<code>Serializable</code>接口，然后重新它的<code>writeObject</code>和<code>readObject</code>方法。</p>\n<p>但如果使用<code>org.springframework.util</code>包下的<code>SerializationUtils</code>工具类，能更轻松实现序列化和反序列化功能。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token class-name\">Maps</span><span class=\"token punctuation\">.</span><span class=\"token function\">newHashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> serialize <span class=\"token operator\">=</span> <span class=\"token class-name\">SerializationUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">serialize</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Object</span> deserialize <span class=\"token operator\">=</span> <span class=\"token class-name\">SerializationUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">deserialize</span><span class=\"token punctuation\">(</span>serialize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>deserialize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"17-HttpStatus\"><a href=\"#17-HttpStatus\" class=\"headerlink\" title=\"17. HttpStatus\"></a>17. HttpStatus</h2><p>很多时候，我们会在代码中定义http的返回码，比如：接口正常返回200，异常返回500，接口找不到返回404，接口不可用返回502等。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> SUCCESS_CODE <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> ERROR_CODE <span class=\"token operator\">=</span> <span class=\"token number\">500</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> NOT_FOUND_CODE <span class=\"token operator\">=</span> <span class=\"token number\">404</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>其实<code>org.springframework.http</code>包下的HttpStatus枚举，或者<code>org.apache.http</code>包下的<code>HttpStatus</code>接口，已经把常用的http返回码给我们定义好了，直接拿来用就可以了，真的不用再重复定义了。</p>\n<p><img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_d1a5a95c.png\" alt=\"image_d1a5a95c.png\"></p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<h2 id=\"1-Collections\"><a href=\"#1-Collections\" class=\"headerlink\" title=\"1. Collections\"></a>1. Collections</h2><p>首先出场的是<code>java.util</code>包下的<code>Collections</code>类，该类主要用于操作集合或者返回集合，我个人非常喜欢用它。</p>\n<h3 id=\"1-1-排序\"><a href=\"#1-1-排序\" class=\"headerlink\" title=\"1.1 排序\"></a>1.1 排序</h3><p>在工作中经常有对集合排序的需求。</p>\n<p>看看使用<code>Collections</code>工具是如何实现升序和降序的：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//升序</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//降序</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"1-2-获取最大或最小值\"><a href=\"#1-2-获取最大或最小值\" class=\"headerlink\" title=\"1.2 获取最大或最小值\"></a>1.2 获取最大或最小值</h3><p>有时候需要找出集合中的<code>最大值</code>或者<code>最小值</code>，这时可以使用Collections的<code>max</code>和<code>min</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Integer</span> max <span class=\"token operator\">=</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//获取最大值</span>\n<span class=\"token class-name\">Integer</span> min <span class=\"token operator\">=</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//获取最小值</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token number\">3</span>\n<span class=\"token number\">1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"1-3-转换线程安全集合\"><a href=\"#1-3-转换线程安全集合\" class=\"headerlink\" title=\"1.3 转换线程安全集合\"></a>1.3 转换线程安全集合</h3><p>我们都知道，java中的很多集合，比如：ArrayList、LinkedList、HashMap、HashSet等，都是线程不安全的。</p>\n<p>换句话说，这些集合在多线程的环境中，添加数据会出现异常。</p>\n<p>这时，可以用Collections的<code>synchronizedxxx</code>方法，将这些线程不安全的集合，直接转换成线程安全集合。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> integers <span class=\"token operator\">=</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">synchronizedList</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//将ArrayList转换成线程安全集合</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>integers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>它的底层会创建<code>SynchronizedRandomAccessList</code>或者<code>SynchronizedList</code>类，这两个类的很多方法都会用<code>synchronized</code>加锁。</p>\n<h3 id=\"1-4-返回空集合\"><a href=\"#1-4-返回空集合\" class=\"headerlink\" title=\"1.4 返回空集合\"></a>1.4 返回空集合</h3><p>有时，我们在判空之后，需要返回空集合，就可以使用<code>emptyList</code>方法，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>list <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">emptyList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">//业务处理</span>\n    <span class=\"token keyword\">return</span> list<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"1-5-二分查找\"><a href=\"#1-5-二分查找\" class=\"headerlink\" title=\"1.5 二分查找\"></a>1.5 二分查找</h3><p><code>binarySearch</code>方法提供了一个非常好用的<code>二分查找</code>功能，只用传入指定集合和需要找到的key即可。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">binarySearch</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//二分查找</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token number\">2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"1-6-转换成不可修改集合\"><a href=\"#1-6-转换成不可修改集合\" class=\"headerlink\" title=\"1.6 转换成不可修改集合\"></a>1.6 转换成不可修改集合</h3><p>为了防止后续的程序把某个集合的结果修改了，有时候我们需要把某个集合定义成不可修改的，使用Collections的<code>unmodifiablexxx</code>方法就能轻松实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> integers <span class=\"token operator\">=</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">unmodifiableList</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nintegers<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>integers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Exception</span> in thread <span class=\"token string\">\"main\"</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span>UnsupportedOperationException</span>\n at <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span>Collections</span>$<span class=\"token class-name\">UnmodifiableCollection</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">1055</span><span class=\"token punctuation\">)</span>\n at <span class=\"token class-name\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>sue<span class=\"token punctuation\">.</span>jump<span class=\"token punctuation\">.</span>service<span class=\"token punctuation\">.</span>test1<span class=\"token punctuation\">.</span></span>UtilTest</span><span class=\"token punctuation\">.</span><span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UtilTest</span><span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">19</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>当然Collections工具类中还有很多常用的方法，在这里就不一一介绍了，需要你自己去探索。</p>\n<p><img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_22c2f25a.png\" alt=\"image_22c2f25a.png\"> <img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_71d4889f.png\" alt=\"image_71d4889f.png\"></p>\n<h2 id=\"2-CollectionUtils\"><a href=\"#2-CollectionUtils\" class=\"headerlink\" title=\"2. CollectionUtils\"></a>2. CollectionUtils</h2><p>对集合操作，除了前面说的<code>Collections</code>工具类之后，<code>CollectionUtils</code>工具类也非常常用。</p>\n<p>目前比较主流的是<code>spring</code>的<code>org.springframework.util</code>包下的CollectionUtils工具类。<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_f8deb8c1.png\" alt=\"image_f8deb8c1.png\"></p>\n<p>和<code>apache</code>的<code>org.apache.commons.collections</code>包下的CollectionUtils工具类。</p>\n<p><img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_5cf672b2.png\" alt=\"image_5cf672b2.png\"></p>\n<p><img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_98de130d.png\" alt=\"image_98de130d.png\"></p>\n<blockquote>\n<p>我个人更推荐使用apache的包下的CollectionUtils工具类，因为它的工具更多更全面。</p>\n</blockquote>\n<p>举个简单的例子，<code>spring</code>的CollectionUtils工具类没有判断集合不为空的方法。而<code>apache</code>的CollectionUtils工具类却有。</p>\n<p>下面我们以<code>apache</code>的CollectionUtils工具类为例，介绍一下常用方法。</p>\n<h3 id=\"2-1-集合判空\"><a href=\"#2-1-集合判空\" class=\"headerlink\" title=\"2.1 集合判空\"></a>2.1 集合判空</h3><p>通过CollectionUtils工具类的<code>isEmpty</code>方法可以轻松判断集合是否为空，<code>isNotEmpty</code>方法判断集合不为空。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"集合为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"集合不为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"2-2-对两个集合进行操作\"><a href=\"#2-2-对两个集合进行操作\" class=\"headerlink\" title=\"2.2 对两个集合进行操作\"></a>2.2 对两个集合进行操作</h3><p>有时候我们需要对已有的两个集合进行操作，比如取交集或者并集等。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist2<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist2<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//获取并集</span>\n<span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> unionList <span class=\"token operator\">=</span> <span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">union</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> list2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>unionList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//获取交集</span>\n<span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> intersectionList <span class=\"token operator\">=</span> <span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">intersection</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> list2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>intersectionList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//获取交集的补集</span>\n<span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> disjunctionList <span class=\"token operator\">=</span> <span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">disjunction</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> list2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>disjunctionList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//获取差集</span>\n<span class=\"token class-name\">Collection</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> subtractList <span class=\"token operator\">=</span> <span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">subtract</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> list2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>subtractList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>说句实话，对两个集合的操作，在实际工作中用得挺多的，特别是很多批量的场景中。以前我们需要写一堆代码，但没想到有现成的轮子。</p>\n<h2 id=\"3-Lists\"><a href=\"#3-Lists\" class=\"headerlink\" title=\"3. Lists\"></a>3. Lists</h2><p>如果你引入<code>com.google.guava</code>的pom文件，会获得很多好用的小工具。这里推荐一款<code>com.google.common.collect</code>包下的集合工具：<code>Lists</code>。</p>\n<p>它是在太好用了，让我爱不释手。</p>\n<h3 id=\"3-1-创建空集合\"><a href=\"#3-1-创建空集合\" class=\"headerlink\" title=\"3.1 创建空集合\"></a>3.1 创建空集合</h3><p>有时候，我们想创建一个空集合。这时可以用Lists的<code>newArrayList</code>方法，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-2-快速初始化集合\"><a href=\"#3-2-快速初始化集合\" class=\"headerlink\" title=\"3.2 快速初始化集合\"></a>3.2 快速初始化集合</h3><p>有时候，我们想给一个集合中初始化一些元素。这时可以用Lists的newArrayList方法，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-3-笛卡尔积\"><a href=\"#3-3-笛卡尔积\" class=\"headerlink\" title=\"3.3 笛卡尔积\"></a>3.3 笛卡尔积</h3><p>如果你想将两个集合做<code>笛卡尔积</code>，Lists的<code>cartesianProduct</code>方法可以帮你实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list1 <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list2 <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> productList <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">cartesianProduct</span><span class=\"token punctuation\">(</span>list1<span class=\"token punctuation\">,</span>list2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>productList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-4-分页\"><a href=\"#3-4-分页\" class=\"headerlink\" title=\"3.4 分页\"></a>3.4 分页</h3><p>如果你想将一个<code>大集合</code>分成若干个<code>小集合</code>，可以使用Lists的<code>partition</code>方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> partitionList <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>partitionList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。</p>\n<p>这个是我最喜欢的方法之一，经常在项目中使用。</p>\n<p>比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。</p>\n<h3 id=\"3-5-流处理\"><a href=\"#3-5-流处理\" class=\"headerlink\" title=\"3.5 流处理\"></a>3.5 流处理</h3><p>如果我们想把某个集合转换成另外一个接口，可以使用Lists的<code>transform</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> transformList <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">transform</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> x <span class=\"token operator\">-></span> x<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>transformList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>将小写字母转换成了大写字母。</p>\n<h3 id=\"3-6-颠倒顺序\"><a href=\"#3-6-颠倒顺序\" class=\"headerlink\" title=\"3.6 颠倒顺序\"></a>3.6 颠倒顺序</h3><p>Lists的有颠倒顺序的方法<code>reverse</code>。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> reverseList <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>reverseList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>list的原始顺序是312，使用<code>reverse</code>方法颠倒顺序之后，变成了213。</p>\n<p>Lists还有其他的好用的工具，我在这里只是抛砖引玉，有兴趣的朋友，可以仔细研究一下。<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_040afd70.png\" alt=\"image_040afd70.png\"></p>\n<h2 id=\"4-Objects\"><a href=\"#4-Objects\" class=\"headerlink\" title=\"4. Objects\"></a>4. Objects</h2><p>在<code>jdk7</code>之后，提供了<code>Objects</code>工具类，我们可以通过它操作对象。</p>\n<h3 id=\"4-1-对象判空\"><a href=\"#4-1-对象判空\" class=\"headerlink\" title=\"4.1 对象判空\"></a>4.1 对象判空</h3><p>在java中万事万物皆对象，对象的判空可以说无处不在。Objects的<code>isNull</code>方法判断对象是否为空，而<code>nonNull</code>方法判断对象是否不为空。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> integer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNull</span><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"对象为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">nonNull</span><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"对象不为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"4-2-对象为空抛异常\"><a href=\"#4-2-对象为空抛异常\" class=\"headerlink\" title=\"4.2 对象为空抛异常\"></a>4.2 对象为空抛异常</h3><p>如果我们想在对象为空时，抛出空指针异常，可以使用Objects的<code>requireNonNull</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> integer1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">128</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">requireNonNull</span><span class=\"token punctuation\">(</span>integer1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">requireNonNull</span><span class=\"token punctuation\">(</span>integer1<span class=\"token punctuation\">,</span> <span class=\"token string\">\"参数不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">requireNonNull</span><span class=\"token punctuation\">(</span>integer1<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token string\">\"参数不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"4-3-判断两个对象是否相等\"><a href=\"#4-3-判断两个对象是否相等\" class=\"headerlink\" title=\"4.3 判断两个对象是否相等\"></a>4.3 判断两个对象是否相等</h3><p>我们经常需要判断两个对象是否相等，Objects给我们提供了<code>equals</code>方法，能非常方便的实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> integer1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Integer</span> integer2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>integer1<span class=\"token punctuation\">,</span> integer2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token boolean\">true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>但使用这个方法有坑，比如例子改成：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> integer1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Long</span> integer2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Long</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>integer1<span class=\"token punctuation\">,</span> integer2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token boolean\">false</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>具体原因不细说了，有兴趣的小伙们可以看看我的另一篇文章《[Objects.equals有坑][Objects.equals]》，里面有非常详细的讲解。</p>\n<h3 id=\"4-4-获取对象的hashCode\"><a href=\"#4-4-获取对象的hashCode\" class=\"headerlink\" title=\"4.4 获取对象的hashCode\"></a>4.4 获取对象的hashCode</h3><p>如果你想获取某个对象的hashCode，可以使用Objects的<code>hashCode</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token number\">96354</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>Objects的内容先介绍到这里，有兴趣的小伙们，可以看看下面更多的方法：<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_d64a89cc.png\" alt=\"image_d64a89cc.png\"></p>\n<h2 id=\"5-BooleanUtils\"><a href=\"#5-BooleanUtils\" class=\"headerlink\" title=\"5. BooleanUtils\"></a>5. BooleanUtils</h2><p>在java中布尔值，随处可见。</p>\n<p>如果你使用了布尔的包装类：<code>Boolean</code>，总感觉有点麻烦，因为它有三种值：<code>null</code>、<code>true</code>、<code>false</code>。我们在处理Boolean对象时，需要经常判空。</p>\n<p>头疼！！！</p>\n<p>但如果使用<code>BooleanUtils</code>类处理布尔值，心情一下子就愉悦起来了。</p>\n<h3 id=\"5-1-判断true或false\"><a href=\"#5-1-判断true或false\" class=\"headerlink\" title=\"5.1 判断true或false\"></a>5.1 判断true或false</h3><p>如果你想判断某个参数的值是true或false，可以直接使用<code>isTrue</code>或<code>isFalse</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Boolean</span> aBoolean <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>aBoolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isFalse</span><span class=\"token punctuation\">(</span>aBoolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"5-2-判断不为true或不为false\"><a href=\"#5-2-判断不为true或不为false\" class=\"headerlink\" title=\"5.2 判断不为true或不为false\"></a>5.2 判断不为true或不为false</h3><p>有时候，需要判断某个参数不为true，即是null或者false。或者判断不为false，即是null或者true。</p>\n<p>可以使用<code>isNotTrue</code>或<code>isNotFalse</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Boolean</span> aBoolean <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Boolean</span> aBoolean1 <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotTrue</span><span class=\"token punctuation\">(</span>aBoolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotTrue</span><span class=\"token punctuation\">(</span>aBoolean1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotFalse</span><span class=\"token punctuation\">(</span>aBoolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotFalse</span><span class=\"token punctuation\">(</span>aBoolean1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token boolean\">false</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token boolean\">true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"5-3-转换成数字\"><a href=\"#5-3-转换成数字\" class=\"headerlink\" title=\"5.3 转换成数字\"></a>5.3 转换成数字</h3><p>如果你想将true转换成数字1，false转换成数字0，可以使用<code>toInteger</code>方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Boolean</span> aBoolean <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Boolean</span> aBoolean1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">toInteger</span><span class=\"token punctuation\">(</span>aBoolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">toInteger</span><span class=\"token punctuation\">(</span>aBoolean1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token number\">1</span>\n<span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"5-4-Boolean转换成布尔值\"><a href=\"#5-4-Boolean转换成布尔值\" class=\"headerlink\" title=\"5.4 Boolean转换成布尔值\"></a>5.4 Boolean转换成布尔值</h3><p>我们有时候需要将包装类<code>Boolean</code>对象，转换成原始的<code>boolean</code>对象，可以使用<code>toBoolean</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Boolean</span> aBoolean <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Boolean</span> aBoolean1 <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBoolean</span><span class=\"token punctuation\">(</span>aBoolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBoolean</span><span class=\"token punctuation\">(</span>aBoolean1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BooleanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBooleanDefaultIfNull</span><span class=\"token punctuation\">(</span>aBoolean1<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们无需额外的判空了，而且还可以设置Boolean对象为空时返回的默认值。</p>\n<p>BooleanUtils类的方法还有很多，有兴趣的小伙伴可以看看下面的内容：<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_56af129c.png\" alt=\"image_56af129c.png\"></p>\n<h2 id=\"6-StringUtils\"><a href=\"#6-StringUtils\" class=\"headerlink\" title=\"6. StringUtils\"></a>6. StringUtils</h2><p><code>字符串</code>（String）在我们的日常工作中，用得非常非常非常多。</p>\n<p>在我们的代码中经常需要对字符串判空，截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。</p>\n<p>如果只用String类提供的那些方法，我们需要手写大量的额外代码，不然容易出现各种异常。</p>\n<p>现在有个好消息是：<code>org.apache.commons.lang3</code>包下的<code>StringUtils</code>工具类，给我们提供了非常丰富的选择。</p>\n<h3 id=\"6-1-字符串判空\"><a href=\"#6-1-字符串判空\" class=\"headerlink\" title=\"6.1 字符串判空\"></a>6.1 字符串判空</h3><p>其实空字符串，不只是null一种，还有””，” “，”null”等等，多种情况。</p>\n<p>StringUtils给我们提供了多个判空的静态方法，例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> <span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str2 <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str3 <span class=\"token operator\">=</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str4 <span class=\"token operator\">=</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>str3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>str4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=====\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span>str3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span>str4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=====\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isBlank</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isBlank</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isBlank</span><span class=\"token punctuation\">(</span>str3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isBlank</span><span class=\"token punctuation\">(</span>str4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=====\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotBlank</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotBlank</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotBlank</span><span class=\"token punctuation\">(</span>str3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotBlank</span><span class=\"token punctuation\">(</span>str4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token boolean\">true</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token boolean\">true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>示例中的：<code>isEmpty</code>、<code>isNotEmpty</code>、<code>isBlank</code>和<code>isNotBlank</code>，这4个判空方法你们可以根据实际情况使用。</p>\n<blockquote>\n<p>优先推荐使用<code>isBlank</code>和<code>isNotBlank</code>方法，因为它会把<code>&quot; &quot;</code>也考虑进去。</p>\n</blockquote>\n<h3 id=\"6-2-分隔字符串\"><a href=\"#6-2-分隔字符串\" class=\"headerlink\" title=\"6.2 分隔字符串\"></a>6.2 分隔字符串</h3><p>分隔字符串是常见需求，如果直接使用String类的split方法，就可能会出现空指针异常。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">,</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">null</span>\n<span class=\"token class-name\">Exception</span> in thread <span class=\"token string\">\"main\"</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span></span>NullPointerException</span>\n at <span class=\"token class-name\"><span class=\"token namespace\">com<span class=\"token punctuation\">.</span>sue<span class=\"token punctuation\">.</span>jump<span class=\"token punctuation\">.</span>service<span class=\"token punctuation\">.</span>test1<span class=\"token punctuation\">.</span></span>UtilTest</span><span class=\"token punctuation\">.</span><span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UtilTest</span><span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">21</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>使用StringUtils的split方法会返回null，而使用String的split方法会报指针异常。</p>\n<h3 id=\"6-3-判断是否纯数字\"><a href=\"#6-3-判断是否纯数字\" class=\"headerlink\" title=\"6.3 判断是否纯数字\"></a>6.3 判断是否纯数字</h3><p>给定一个字符串，判断它是否为纯数字，可以使用<code>isNumeric</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str1 <span class=\"token operator\">=</span> <span class=\"token string\">\"123\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str2 <span class=\"token operator\">=</span> <span class=\"token string\">\"123q\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> str3 <span class=\"token operator\">=</span> <span class=\"token string\">\"0.33\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNumeric</span><span class=\"token punctuation\">(</span>str1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNumeric</span><span class=\"token punctuation\">(</span>str2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNumeric</span><span class=\"token punctuation\">(</span>str3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token boolean\">true</span>\n<span class=\"token boolean\">false</span>\n<span class=\"token boolean\">false</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"6-4-将集合拼接成字符串\"><a href=\"#6-4-将集合拼接成字符串\" class=\"headerlink\" title=\"6.4 将集合拼接成字符串\"></a>6.4 将集合拼接成字符串</h3><p>有时候，我们需要将某个集合的内容，拼接成一个字符串，然后输出，这时可以使用<code>join</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list2 <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> <span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StringUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>list2<span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c\n<span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>当然还有很多实用的方法，我在这里就不一一介绍了。<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_48270fb5.png\" alt=\"image_48270fb5.png\"></p>\n<p><img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_77defa60.png\" alt=\"image_77defa60.png\"></p>\n<h2 id=\"7-Assert\"><a href=\"#7-Assert\" class=\"headerlink\" title=\"7. Assert\"></a>7. Assert</h2><p>很多时候，我们需要在代码中做判断：如果不满足条件，则抛异常。</p>\n<p>有没有统一的封装呢?</p>\n<p>其实<code>spring</code>给我们提供了<code>Assert</code>类，它表示<code>断言</code>。</p>\n<h3 id=\"7-1-断言参数是否为空\"><a href=\"#7-1-断言参数是否为空\" class=\"headerlink\" title=\"7.1 断言参数是否为空\"></a>7.1 断言参数是否为空</h3><p>断言<code>参数</code>是否空，如果不满足条件，则直接抛异常。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNull</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> <span class=\"token string\">\"str必须为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNull</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token string\">\"str必须为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">notNull</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> <span class=\"token string\">\"str不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果不满足条件就会抛出<code>IllegalArgumentException</code>异常。</p>\n<h3 id=\"7-2-断言集合是否为空\"><a href=\"#7-2-断言集合是否为空\" class=\"headerlink\" title=\"7.2 断言集合是否为空\"></a>7.2 断言集合是否为空</h3><p>断言<code>集合</code>是否空，如果不满足条件，则直接抛异常。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">notEmpty</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> <span class=\"token string\">\"list不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">notEmpty</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token string\">\"list不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">notEmpty</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">,</span> <span class=\"token string\">\"map不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果不满足条件就会抛出<code>IllegalArgumentException</code>异常。</p>\n<h3 id=\"7-3-断言条件是否为空\"><a href=\"#7-3-断言条件是否为空\" class=\"headerlink\" title=\"7.3 断言条件是否为空\"></a>7.3 断言条件是否为空</h3><p>断言是否满足某个<code>条件</code>，如果不满足条件，则直接抛异常。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"list不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Assert</span><span class=\"token punctuation\">.</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CollectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEmpty</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token string\">\"list不能为空\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>当然Assert类还有一些其他的功能，这里就不多介绍了。<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_b1853624.png\" alt=\"image_b1853624.png\"></p>\n<h2 id=\"8-IOUtils\"><a href=\"#8-IOUtils\" class=\"headerlink\" title=\"8. IOUtils\"></a>8. IOUtils</h2><p><code>IO</code>流在我们日常工作中也用得比较多，尽管java已经给我们提供了丰富的API。</p>\n<p>但我们不得不每次读取文件，或者写入文件之后，写一些重复的的代码。手动在<code>finally</code>代码块中关闭流，不然可能会造成<code>内存溢出</code>。</p>\n<p>有个好消息是：如果你使用<code>org.apache.commons.io</code>包下的<code>IOUtils</code>类，会节省大量的时间。</p>\n<h3 id=\"8-1-读取文件\"><a href=\"#8-1-读取文件\" class=\"headerlink\" title=\"8.1 读取文件\"></a>8.1 读取文件</h3><p>如果你想将某个txt文件中的数据，读取到字符串当中，可以使用IOUtils类的<code>toString</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token class-name\">IOUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/temp/a.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span>UTF_8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"8-2-写入文件\"><a href=\"#8-2-写入文件\" class=\"headerlink\" title=\"8.2 写入文件\"></a>8.2 写入文件</h3><p>如果你想将某个字符串的内容，写入到指定文件当中，可以使用IOUtils类的<code>write</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"abcde\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">IOUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/temp/b.tx\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span>UTF_8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"8-3-文件拷贝\"><a href=\"#8-3-文件拷贝\" class=\"headerlink\" title=\"8.3 文件拷贝\"></a>8.3 文件拷贝</h3><p>如果你想将某个文件中的所有内容，都拷贝到另一个文件当中，可以使用IOUtils类的<code>copy</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">IOUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/temp/a.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/temp/b.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"8-4-读取文件内容到字节数组\"><a href=\"#8-4-读取文件内容到字节数组\" class=\"headerlink\" title=\"8.4 读取文件内容到字节数组\"></a>8.4 读取文件内容到字节数组</h3><p>如果你想将某个文件中的内容，读取字节数组中，可以使用IOUtils类的<code>toByteArray</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bytes <span class=\"token operator\">=</span> <span class=\"token class-name\">IOUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">toByteArray</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/temp/a.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>IOUtils类非常实用，感兴趣的小伙们，可以看看下面内容。<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_fadda8b7.png\" alt=\"image_fadda8b7.png\"></p>\n<h2 id=\"9-MDC\"><a href=\"#9-MDC\" class=\"headerlink\" title=\"9. MDC\"></a>9. MDC</h2><p><code>MDC</code>是<code>org.slf4j</code>包下的一个类，它的全称是Mapped Diagnostic Context，我们可以认为它是一个线程安全的存放诊断日志的容器。</p>\n<p>MDC的底层是用了<code>ThreadLocal</code>来保存数据的。</p>\n<p>我们可以用它传递参数。</p>\n<p>例如现在有这样一种场景：我们使用<code>RestTemplate</code>调用远程接口时，有时需要在<code>header</code>中传递信息，比如：traceId，source等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。</p>\n<p>这种业务场景就能通过<code>ClientHttpRequestInterceptor</code>接口实现，具体做法如下：</p>\n<p>第一步，定义一个LogFilter拦截所有接口请求，在MDC中设置traceId：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LogFilter</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Filter</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">FilterConfig</span> filterConfig<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">ServletException</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doFilter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ServletRequest</span> request<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ServletResponse</span> response<span class=\"token punctuation\">,</span> <span class=\"token class-name\">FilterChain</span> chain<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ServletException</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">MdcUtil</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>UUID<span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"记录请求日志\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        chain<span class=\"token punctuation\">.</span><span class=\"token function\">doFilter</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"记录响应日志\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">destroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>第二步，实现<code>ClientHttpRequestInterceptor</code>接口，MDC中获取当前请求的traceId，然后设置到header中：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RestTemplateInterceptor</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ClientHttpRequestInterceptor</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ClientHttpResponse</span> <span class=\"token function\">intercept</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpRequest</span> request<span class=\"token punctuation\">,</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> body<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ClientHttpRequestExecution</span> execution<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span>\n        request<span class=\"token punctuation\">.</span><span class=\"token function\">getHeaders</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"traceId\"</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">MdcUtil</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> execution<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>第三步，定义配置类，配置上面定义的<code>RestTemplateInterceptor</code>类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RestTemplateConfiguration</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">RestTemplate</span> <span class=\"token function\">restTemplate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">RestTemplate</span> restTemplate <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RestTemplate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        restTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">setInterceptors</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">singletonList</span><span class=\"token punctuation\">(</span><span class=\"token function\">restTemplateInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> restTemplate<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">RestTemplateInterceptor</span> <span class=\"token function\">restTemplateInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RestTemplateInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中MdcUtil其实是利用MDC工具在ThreadLocal中存储和获取traceId</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MdcUtil</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> TRACE_ID <span class=\"token operator\">=</span> <span class=\"token string\">\"TRACE_ID\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">String</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> MDC<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>TRACE_ID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        MDC<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>TRACE_ID<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当然，这个例子中没有演示MdcUtil类的add方法具体调的地方，我们可以在filter中执行接口方法之前，生成traceId，调用MdcUtil类的add方法添加到MDC中，然后在同一个请求的其他地方就能通过MdcUtil类的get方法获取到该traceId。</p>\n<p>能使用MDC保存traceId等参数的根本原因是，用户请求到应用服务器，Tomcat会从线程池中分配一个线程去处理该请求。</p>\n<p>那么该请求的整个过程中，保存到MDC的ThreadLocal中的参数，也是该线程独享的，所以不会有线程安全问题。</p>\n<h2 id=\"10-ClassUtils\"><a href=\"#10-ClassUtils\" class=\"headerlink\" title=\"10. ClassUtils\"></a>10. ClassUtils</h2><p>spring的<code>org.springframework.util</code>包下的<code>ClassUtils</code>类，它里面有很多让我们惊喜的功能。</p>\n<p>它里面包含了类和对象相关的很多非常实用的方法。</p>\n<h3 id=\"10-1-获取对象的所有接口\"><a href=\"#10-1-获取对象的所有接口\" class=\"headerlink\" title=\"10.1 获取对象的所有接口\"></a>10.1 获取对象的所有接口</h3><p>如果你想获取某个对象的所有接口，可以使用ClassUtils的<code>getAllInterfaces</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> allInterfaces <span class=\"token operator\">=</span> <span class=\"token class-name\">ClassUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">getAllInterfaces</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"10-2-获取某个类的包名\"><a href=\"#10-2-获取某个类的包名\" class=\"headerlink\" title=\"10.2 获取某个类的包名\"></a>10.2 获取某个类的包名</h3><p>如果你想获取某个类的包名，可以使用ClassUtils的<code>getPackageName</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> packageName <span class=\"token operator\">=</span> <span class=\"token class-name\">ClassUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">getPackageName</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>packageName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"10-3-判断某个类是否内部类\"><a href=\"#10-3-判断某个类是否内部类\" class=\"headerlink\" title=\"10.3 判断某个类是否内部类\"></a>10.3 判断某个类是否内部类</h3><p>如果你想判断某个类是否内部类，可以使用ClassUtils的<code>isInnerClass</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isInnerClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"10-4-判断对象是否代理对象\"><a href=\"#10-4-判断对象是否代理对象\" class=\"headerlink\" title=\"10.4 判断对象是否代理对象\"></a>10.4 判断对象是否代理对象</h3><p>如果你想判断对象是否代理对象，可以使用ClassUtils的<code>isCglibProxy</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isCglibProxy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>ClassUtils还有很多有用的方法，等待着你去发掘。感兴趣的朋友，可以看看下面内容：<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_dec3e504.png\" alt=\"image_dec3e504.png\"></p>\n<h2 id=\"11-BeanUtils\"><a href=\"#11-BeanUtils\" class=\"headerlink\" title=\"11. BeanUtils\"></a>11. BeanUtils</h2><p>spring给我们提供了一个<code>JavaBean</code>的工具类，它在<code>org.springframework.beans</code>包下面，它的名字叫做：<code>BeanUtils</code>。</p>\n<p>让我们一起看看这个工具可以带给我们哪些惊喜。</p>\n<h3 id=\"11-1-拷贝对象的属性\"><a href=\"#11-1-拷贝对象的属性\" class=\"headerlink\" title=\"11.1 拷贝对象的属性\"></a>11.1 拷贝对象的属性</h3><p>曾几何时，你有没有这样的需求：把某个对象中的所有属性，都拷贝到另外一个对象中。这时就能使用BeanUtils的<code>copyProperties</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nuser1<span class=\"token punctuation\">.</span><span class=\"token function\">setId</span><span class=\"token punctuation\">(</span><span class=\"token number\">1L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nuser1<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"苏三说技术\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nuser1<span class=\"token punctuation\">.</span><span class=\"token function\">setAddress</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"成都\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">User</span> user2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>user1<span class=\"token punctuation\">,</span> user2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>user2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"11-2-实例化某个类\"><a href=\"#11-2-实例化某个类\" class=\"headerlink\" title=\"11.2 实例化某个类\"></a>11.2 实例化某个类</h3><p>如果你想通过反射实例化一个类的对象，可以使用BeanUtils的<code>instantiateClass</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">instantiateClass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"11-3-获取指定类的指定方法\"><a href=\"#11-3-获取指定类的指定方法\" class=\"headerlink\" title=\"11.3 获取指定类的指定方法\"></a>11.3 获取指定类的指定方法</h3><p>如果你想获取某个类的指定方法，可以使用BeanUtils的<code>findDeclaredMethod</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Method</span> declaredMethod <span class=\"token operator\">=</span> <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">findDeclaredMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"getId\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>declaredMethod<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"11-4-获取指定方法的参数\"><a href=\"#11-4-获取指定方法的参数\" class=\"headerlink\" title=\"11.4 获取指定方法的参数\"></a>11.4 获取指定方法的参数</h3><p>如果你想获取某个方法的参数，可以使用BeanUtils的<code>findPropertyForMethod</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Method</span> declaredMethod <span class=\"token operator\">=</span> <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">findDeclaredMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"getId\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">PropertyDescriptor</span> propertyForMethod <span class=\"token operator\">=</span> <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">findPropertyForMethod</span><span class=\"token punctuation\">(</span>declaredMethod<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>propertyForMethod<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>如果你对BeanUtils比较感兴趣，可以看看下面内容：<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_7eeac46e.png\" alt=\"image_7eeac46e.png\"></p>\n<h2 id=\"12-ReflectionUtils\"><a href=\"#12-ReflectionUtils\" class=\"headerlink\" title=\"12. ReflectionUtils\"></a>12. ReflectionUtils</h2><p>有时候，我们需要在项目中使用<code>反射</code>功能，如果使用最原始的方法来开发，代码量会非常多，而且很麻烦，它需要处理一大堆异常以及访问权限等问题。</p>\n<p>好消息是spring给我们提供了一个<code>ReflectionUtils</code>工具，它在<code>org.springframework.util</code>包下面。</p>\n<h3 id=\"12-1-获取方法\"><a href=\"#12-1-获取方法\" class=\"headerlink\" title=\"12.1 获取方法\"></a>12.1 获取方法</h3><p>如果你想获取某个类的某个方法，可以使用ReflectionUtils类的<code>findMethod</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Method</span> method <span class=\"token operator\">=</span> <span class=\"token class-name\">ReflectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">findMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"getId\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"12-2-获取字段\"><a href=\"#12-2-获取字段\" class=\"headerlink\" title=\"12.2 获取字段\"></a>12.2 获取字段</h3><p>如果你想获取某个类的某个字段，可以使用ReflectionUtils类的<code>findField</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Field</span> field <span class=\"token operator\">=</span> <span class=\"token class-name\">ReflectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">findField</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"12-3-执行方法\"><a href=\"#12-3-执行方法\" class=\"headerlink\" title=\"12.3 执行方法\"></a>12.3 执行方法</h3><p>如果你想通过反射调用某个方法，传递参数，可以使用ReflectionUtils类的<code>invokeMethod</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">ReflectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">invokeMethod</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">,</span> springContextsUtil<span class=\"token punctuation\">.</span><span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"12-4-判断字段是否常量\"><a href=\"#12-4-判断字段是否常量\" class=\"headerlink\" title=\"12.4 判断字段是否常量\"></a>12.4 判断字段是否常量</h3><p>如果你想判断某个字段是否常量，可以使用ReflectionUtils类的<code>isPublicStaticFinal</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Field</span> field <span class=\"token operator\">=</span> <span class=\"token class-name\">ReflectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">findField</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ReflectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isPublicStaticFinal</span><span class=\"token punctuation\">(</span>field<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"12-5-判断是否equals方法\"><a href=\"#12-5-判断是否equals方法\" class=\"headerlink\" title=\"12.5 判断是否equals方法\"></a>12.5 判断是否equals方法</h3><p>如果你想判断某个方法是否equals方法，可以使用ReflectionUtils类的<code>isEqualsMethod</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Method</span> method <span class=\"token operator\">=</span> <span class=\"token class-name\">ReflectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">findMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"getId\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ReflectionUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEqualsMethod</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>当然这个类还有不少有趣的方法，感兴趣的朋友，可以看看下面内容：<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_ea531c2a.png\" alt=\"image_ea531c2a.png\"></p>\n<h2 id=\"13-Base64Utils\"><a href=\"#13-Base64Utils\" class=\"headerlink\" title=\"13. Base64Utils\"></a>13. Base64Utils</h2><p>有时候，为了安全考虑，需要将参数只用<code>base64</code>编码。</p>\n<p>这时就能直接使用<code>org.springframework.util</code>包下的<code>Base64Utils</code>工具类。</p>\n<p>它里面包含：<code>encode</code>和<code>decode</code>方法，用于对数据进行加密和解密。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> encode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Base64Utils</span><span class=\"token punctuation\">.</span><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"加密后：\"</span> <span class=\"token operator\">+</span> encode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">String</span> decode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Base64Utils</span><span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>encode<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"utf8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"解密后：\"</span> <span class=\"token operator\">+</span> decode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">UnsupportedEncodingException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>执行结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">加密后：<span class=\"token class-name\">YWJj</span>\n解密后：abc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"14-StandardCharsets\"><a href=\"#14-StandardCharsets\" class=\"headerlink\" title=\"14. StandardCharsets\"></a>14. StandardCharsets</h2><p>我们在做字符转换的时候，经常需要指定字符编码，比如：UTF-8、ISO-8859-1等等。</p>\n<p>这时就可以直接使用<code>java.nio.charset</code>包下的<code>StandardCharsets</code>类中静态变量。</p>\n<p>例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> encode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Base64Utils</span><span class=\"token punctuation\">.</span><span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"加密后：\"</span> <span class=\"token operator\">+</span> encode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> decode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Base64Utils</span><span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>encode<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">,</span> <span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span>UTF_8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"解密后：\"</span> <span class=\"token operator\">+</span> decode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"15-DigestUtils\"><a href=\"#15-DigestUtils\" class=\"headerlink\" title=\"15. DigestUtils\"></a>15. DigestUtils</h2><p>有时候，我们需要对数据进行加密处理，比如：md5或sha256。</p>\n<p>可以使用apache的<code>org.apache.commons.codec.digest</code>包下的<code>DigestUtils</code>类。</p>\n<h3 id=\"15-1-md5加密\"><a href=\"#15-1-md5加密\" class=\"headerlink\" title=\"15.1 md5加密\"></a>15.1 md5加密</h3><p>如果你想对数据进行md5加密，可以使用DigestUtils的<code>md5Hex</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> md5Hex <span class=\"token operator\">=</span> <span class=\"token class-name\">DigestUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">md5Hex</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"苏三说技术\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>md5Hex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"15-2-sha256加密\"><a href=\"#15-2-sha256加密\" class=\"headerlink\" title=\"15.2 sha256加密\"></a>15.2 sha256加密</h3><p>如果你想对数据进行sha256加密，可以使用DigestUtils的<code>sha256Hex</code>方法。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> md5Hex <span class=\"token operator\">=</span> <span class=\"token class-name\">DigestUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">sha256Hex</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"苏三说技术\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>md5Hex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>当然这个工具还有很多其他的加密方法：<img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_fec0346f.png\" alt=\"image_fec0346f.png\"></p>\n<h2 id=\"16-SerializationUtils\"><a href=\"#16-SerializationUtils\" class=\"headerlink\" title=\"16. SerializationUtils\"></a>16. SerializationUtils</h2><p>有时候，我们需要把数据进行<code>序列化</code>和<code>反序列化</code>处理。</p>\n<p>传统的做法是某个类实现<code>Serializable</code>接口，然后重新它的<code>writeObject</code>和<code>readObject</code>方法。</p>\n<p>但如果使用<code>org.springframework.util</code>包下的<code>SerializationUtils</code>工具类，能更轻松实现序列化和反序列化功能。例如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token class-name\">Maps</span><span class=\"token punctuation\">.</span><span class=\"token function\">newHashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> serialize <span class=\"token operator\">=</span> <span class=\"token class-name\">SerializationUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">serialize</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Object</span> deserialize <span class=\"token operator\">=</span> <span class=\"token class-name\">SerializationUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">deserialize</span><span class=\"token punctuation\">(</span>serialize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>deserialize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"17-HttpStatus\"><a href=\"#17-HttpStatus\" class=\"headerlink\" title=\"17. HttpStatus\"></a>17. HttpStatus</h2><p>很多时候，我们会在代码中定义http的返回码，比如：接口正常返回200，异常返回500，接口找不到返回404，接口不可用返回502等。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> SUCCESS_CODE <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> ERROR_CODE <span class=\"token operator\">=</span> <span class=\"token number\">500</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> NOT_FOUND_CODE <span class=\"token operator\">=</span> <span class=\"token number\">404</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>其实<code>org.springframework.http</code>包下的HttpStatus枚举，或者<code>org.apache.http</code>包下的<code>HttpStatus</code>接口，已经把常用的http返回码给我们定义好了，直接拿来用就可以了，真的不用再重复定义了。</p>\n<p><img src=\"/2022/11/09/tui-jian-17-ge-ti-sheng-kai-fa-xiao-lu-lun-zi/image_d1a5a95c.png\" alt=\"image_d1a5a95c.png\"></p>\n"},{"title":"目瞪口呆的Java代码技巧","top":false,"cover":false,"toc":true,"mathjax":true,"summary":"目瞪口呆的Java代码技巧","date":"2022-11-09T04:12:37.000Z","password":null,"_content":"开发工具\n\n  \n\n\n\n\n\n不知道有多少“老”程序员还在使用 Eclipse，这些程序员们要不就是因循守旧，要不就是根本就不知道其他好的开发工具的存在，Eclipse 吃内存卡顿的现象以及各种偶然莫名异常的出现，都告知我们是时候寻找新的开发工具了。\n\n  \n\n\n#### | 更换 IDE \n\n根本就不想多解释要换什么样的 IDE，如果你想成为一个优秀的 Java 程序员，请更换 IntelliJ IDEA。使用 IDEA 的好处，请搜索谷歌。\n\n  \n\n\n#### | 别告诉我快捷键不好用 \n\n更换 IDE 不在我本文的重点内容中，所以不想用太多的篇幅去写为什么更换IDE。在这里，我只能告诉你，更换 IDE 只为了更好、更快的写好 Java 代码。原因略。\n\n  \n\n\n别告诉我快捷键不好用，请尝试新事物。\n\n  \n\n\n#### | bean \n\nbean 使我们使用最多的模型之一，我将以大篇幅去讲解 bean，希望读者好好体会。\n\n  \n\n\n#### | domain 包名 \n\n根据很多 Java 程序员的“经验”来看，一个数据库表则对应着一个 domain 对象，所以很多程序员在写代码时，包名则使用：com.xxx.domain ，这样写好像已经成为了行业的一种约束，数据库映射对象就应该是 domain。\n\n  \n\n\n但是你错了，domain 是一个领域对象，往往我们再做传统 Java 软件 Web 开发中，这些 domain 都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的。\n\n  \n\n\n所以，以这个理论来讲，这些 domain 都应该是一个普通的 entity 对象，并非领域对象，所以请把包名改为：com.xxx.entity。\n\n  \n\n\n如果你还不理解我说的话，请看一下 Vaughn Vernon 出的一本叫做《IMPLEMENTING DOMAIN-DRIVEN DESIGN》（实现领域驱动设计）这本书，书中讲解了贫血模型与领域模型的区别，相信你会受益匪浅。\n\n  \n\n\n#### | DTO \n\n数据传输我们应该使用 DTO 对象作为传输对象，这是我们所约定的，因为很长时间我一直都在做移动端 API 设计的工作，有很多人告诉我，他们认为只有给手机端传输数据的时候（input or output），这些对象成为 DTO 对象。\n\n  \n\n\n请注意！这种理解是错误的，只要是用于网络传输的对象，我们都认为他们可以当做是 DTO 对象，比如电商平台中，用户进行下单，下单后的数据，订单会发到 OMS 或者 ERP 系统，这些对接的返回值以及入参也叫 DTO 对象。\n\n  \n\n\n我们约定某对象如果是 DTO 对象，就将名称改为 XXDTO，比如订单下发 OMS：OMSOrderInputDTO。\n\n  \n\n\n#### | DTO 转化 \n\n正如我们所知，DTO 为系统与外界交互的模型对象，那么肯定会有一个步骤是将 DTO 对象转化为 BO 对象或者是普通的 entity 对象，让 service 层去处理。\n\n  \n\n\n#### | 场景 \n\n  \n\n\n比如添加会员操作，由于用于演示，我只考虑用户的一些简单数据，当后台管理员点击添加用户时，只需要传过来用户的姓名和年龄就可以了，后端接受到数据后，将添加创建时间和更新时间和默认密码三个字段，然后保存数据库。\n\n```java\n@RequestMapping(\"/v1/api/user\")\n@RestController\npublic class UserApi {\n\n    @Autowired\n    private UserService userService;\n\n    @PostMapping\n    public User addUser(UserInputDTO userInputDTO){\n        User user = new User();\n        user.setUsername(userInputDTO.getUsername());\n        user.setAge(userInputDTO.getAge());\n\n        return userService.addUser(user);\n    }\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n我们只关注一下上述代码中的转化代码，其他内容请忽略：\n\n```java\nUser user = new User();\nuser.setUsername(userInputDTO.getUsername());\nuser.setAge(userInputDTO.getAge());\n```\n\n  \n\n\n\n\n\n#### | 请使用工具 \n\n上边的代码，从逻辑上讲，是没有问题的，只是这种写法让我很厌烦，例子中只有两个字段，如果有 20 个字段，我们要如何做呢？一个一个进行 set 数据吗？\n\n  \n\n\n当然，如果你这么做了，肯定不会有什么问题，但是，这肯定不是一个最优的做法。网上有很多工具，支持浅拷贝或深拷贝的 Utils。\n\n  \n\n\n\n\n\n举个例子，我们可以使用 org.springframework.beans.BeanUtils\\#copyProperties 对代码进行重构和优化：\n\n```java\n@PostMapping\npublic User addUser(UserInputDTO userInputDTO){\n    User user = new User();\n    BeanUtils.copyProperties(userInputDTO,user);\n\n    return userService.addUser(user);\n}\n```\n\n  \n\n\n\n\n\nBeanUtils.copyProperties 是一个浅拷贝方法，复制属性时，我们只需要把 DTO 对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。\n\n  \n\n\n如果你在做 DTO 转化的时候一直使用 set 进行属性赋值，那么请尝试这种方式简化代码，让代码更加清晰！\n\n  \n\n\n#### | 转化的语义 \n\n  \n\n\n上边的转化过程，读者看后肯定觉得优雅很多，但是我们再写 Java 代码时，更多的需要考虑语义的操作，再看上边的代码：\n\n```java\nUser user = new User();\nBeanUtils.copyProperties(userInputDTO,user);\n```\n\n  \n\n\n\n\n\n  \n\n\n虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好，所以代码改成如下：\n\n```java\n@PostMapping\n public User addUser(UserInputDTO userInputDTO){\n         User user = convertFor(userInputDTO);\n\n         return userService.addUser(user);\n }\n\n private User convertFor(UserInputDTO userInputDTO){\n\n         User user = new User();\n         BeanUtils.copyProperties(userInputDTO,user);\n         return user;\n }\n```\n\n  \n\n\n\n\n\n  \n\n\n这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中，比如：\n\n```java\nUser user = convertFor(userInputDTO);\nreturn userService.addUser(user);\n```\n\n  \n\n\n\n\n\n这两段代码都没有暴露实现，都是在讲如何在同一个方法中，做一组相同层次的语义操作，而不是暴露具体的实现。\n\n  \n\n\n如上所述，是一种重构方式，读者可以参考 Martin Fowler 的《Refactoring Imporving the Design of Existing Code》（重构改善既有代码的设计）这本书中的 Extract Method 重构方式。\n\n  \n\n\n#### | 抽象接口定义 \n\n当实际工作中，完成了几个 API 的 DTO 转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。\n\n  \n\n\n如果接口被定义以后，那么 convertFor 这个方法的语义将产生变化，它将是一个实现类。\n\n  \n\n\n\n\n\n看一下抽象后的接口：\n\n```java\npublic interface DTOConvert<S,T> {\n    T convert(S s);\n}\n```\n\n  \n\n\n\n\n\n虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的 Java 程序员，请为你想做的抽象接口，做好泛型吧。\n\n  \n\n\n\n\n\n我们再来看接口实现：\n\n```java\npublic class UserInputDTOConvert implements DTOConvert {\n@Override\npublic User convert(UserInputDTO userInputDTO) {\nUser user = new User();\nBeanUtils.copyProperties(userInputDTO,user);\nreturn user;\n}\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范：\n\n```java\n@RequestMapping(\"/v1/api/user\")\n@RestController\npublic class UserApi {\n\n    @Autowired\n    private UserService userService;\n\n    @PostMapping\n    public User addUser(UserInputDTO userInputDTO){\n        User user = new UserInputDTOConvert().convert(userInputDTO);\n\n        return userService.addUser(user);\n    }\n}\n```\n\n  \n\n\n\n\n\n#### | review code \n\n如果你是一个优秀的 Java 程序员，我相信你应该和我一样，已经数次重复 review 过自己的代码很多次了。\n\n  \n\n\n我们再看这个保存用户的例子，你将发现，API 中返回值是有些问题的，问题就在于不应该直接返回 User 实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的。\n\n  \n\n\n\n\n\n所以我们更应该返回一个 DTO 对象，我们可称它为 UserOutputDTO：\n\n```java\n@PostMapping\npublic UserOutputDTO addUser(UserInputDTO userInputDTO){\n        User user = new UserInputDTOConvert().convert(userInputDTO);\n        User saveUserResult = userService.addUser(user);\n        UserOutputDTO result = new UserOutDTOConvert().convertToUser(saveUserResult);\n        return result;\n}\n```\n\n  \n\n\n\n\n\n这样你的 API 才更健全。\n\n  \n\n\n\n\n\n不知道在看完这段代码之后，读者有是否发现还有其他问题的存在，作为一个优秀的 Java 程序员，请看一下这段我们刚刚抽象完的代码：\n\n```java\nUser user = new UserInputDTOConvert().convert(userInputDTO);\n```\n\n  \n\n\n\n\n\n你会发现，new 这样一个 DTO 转化对象是没有必要的，而且每一个转化对象都是由在遇到 DTO 转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和 DTO 进行聚合呢？\n\n  \n\n\n\n\n\n看一下我的聚合结果：\n\n```java\npublic class UserInputDTO {\nprivate String username;\nprivate int age;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n\n    public User convertToUser(){\n        UserInputDTOConvert userInputDTOConvert = new UserInputDTOConvert();\n        User convert = userInputDTOConvert.convert(this);\n        return convert;\n    }\n\n    private static class UserInputDTOConvert implements DTOConvert<UserInputDTO,User> {\n        @Override\n        public User convert(UserInputDTO userInputDTO) {\n            User user = new User();\n            BeanUtils.copyProperties(userInputDTO,user);\n            return user;\n        }\n    }\n\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n然后 API 中的转化则由：\n\n```java\nUser user = new UserInputDTOConvert().convert(userInputDTO);\nUser saveUserResult = userService.addUser(user);\n```\n\n  \n\n\n\n\n\n  \n\n\n变成了：\n\n```java\nUser user = userInputDTO.convertToUser();\nUser saveUserResult = userService.addUser(user);\n```\n\n  \n\n\n\n\n\n我们再 DTO 对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。\n\n  \n\n\n#### | 再查工具类 \n\n再来看 DTO 内部转化的代码，它实现了我们自己定义的 DTOConvert 接口，但是这样真的就没有问题，不需要再思考了吗？\n\n  \n\n\n我觉得并不是，对于 Convert 这种转化语义来讲，很多工具类中都有这样的定义，这中 Convert 并不是业务级别上的接口定义，它只是用于普通 bean 之间转化属性值的普通意义上的接口定义，所以我们应该更多的去读其他含有 Convert 转化语义的代码。\n\n  \n\n\n\n\n\n我仔细阅读了一下 GUAVA 的源码，发现了 com.google.common.base.Convert 这样的定义：\n\n```java\npublic abstract class Converter<A, B> implements Function<A, B> {\n    protected abstract B doForward(A a);\n    protected abstract A doBackward(B b);\n    //其他略\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n从源码可以了解到，GUAVA 中的 Convert 可以完成正向转化和逆向转化，继续修改我们 DTO 中转化的这段代码：\n\n```java\nprivate static class UserInputDTOConvert implements DTOConvert<UserInputDTO,User> {\n        @Override\n        public User convert(UserInputDTO userInputDTO) {\n                User user = new User();\n                BeanUtils.copyProperties(userInputDTO,user);\n                return user;\n        }\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n修改后：\n\n```java\nprivate static class UserInputDTOConvert extends Converter<UserInputDTO, User> {\n         @Override\n         protected User doForward(UserInputDTO userInputDTO) {\n                 User user = new User();\n                 BeanUtils.copyProperties(userInputDTO,user);\n                 return user;\n         }\n\n         @Override\n         protected UserInputDTO doBackward(User user) {\n                 UserInputDTO userInputDTO = new UserInputDTO();\n                 BeanUtils.copyProperties(user,userInputDTO);\n                 return userInputDTO;\n         }\n }\n```\n\n  \n\n\n\n\n\n看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的 UserInputDTO 和 UserOutputDTO 都转成 UserDTO 展示给大家。\n\n  \n\n\n\n\n\nDTO：\n\n```java\npublic class UserDTO {\n    private String username;\n    private int age;\n\n    public String getUsername() {\n            return username;\n    }\n\n    public void setUsername(String username) {\n            this.username = username;\n    }\n\n    public int getAge() {\n            return age;\n    }\n\n    public void setAge(int age) {\n            this.age = age;\n    }\n\n\n    public User convertToUser(){\n            UserDTOConvert userDTOConvert = new UserDTOConvert();\n            User convert = userDTOConvert.convert(this);\n            return convert;\n    }\n\n    public UserDTO convertFor(User user){\n            UserDTOConvert userDTOConvert = new UserDTOConvert();\n            UserDTO convert = userDTOConvert.reverse().convert(user);\n            return convert;\n    }\n\n    private static class UserDTOConvert extends Converter<UserDTO, User> {\n            @Override\n            protected User doForward(UserDTO userDTO) {\n                    User user = new User();\n                    BeanUtils.copyProperties(userDTO,user);\n                    return user;\n            }\n\n            @Override\n            protected UserDTO doBackward(User user) {\n                    UserDTO userDTO = new UserDTO();\n                    BeanUtils.copyProperties(user,userDTO);\n                    return userDTO;\n            }\n    }\n\n}\n```\n\n  \n\n\n\n\n\n  \n\n\nAPI：\n\n```java\n@PostMapping\n public UserDTO addUser(UserDTO userDTO){\n         User user =  userDTO.convertToUser();\n         User saveResultUser = userService.addUser(user);\n         UserDTO result = userDTO.convertFor(saveResultUser);\n         return result;\n }\n```\n\n  \n\n\n\n\n\n  \n\n\n当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的 DTO 对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的。\n\n```java\nprivate static class UserDTOConvert extends Converter<UserDTO, User> {\n         @Override\n         protected User doForward(UserDTO userDTO) {\n                 User user = new User();\n                 BeanUtils.copyProperties(userDTO,user);\n                 return user;\n         }\n\n         @Override\n         protected UserDTO doBackward(User user) {\n                 throw new AssertionError(\"不支持逆向转化方法!\");\n         }\n }\n```\n\n  \n\n\n\n\n\n看一下 doBackward 方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就“断言”你调用错误了。\n\n  \n\n\n\n\n\n关于异常处理的更详细介绍，可以参考这篇文章：如何优雅的设计 Java 异常 ，应该可以帮你更好的理解异常。\n\n```java\nhttp://lrwinx.github.io/2016/04/28/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%AE%BE%E8%AE%A1java%E5%BC%82%E5%B8%B8/\n```\n\n  \n\n\n\n\n\n#### | bean 的验证 \n\n如果你认为我上边写的那个添加用户 API 写的已经非常完美了，那只能说明你还不是一个优秀的程序员。我们应该保证任何数据的入参到方法体内都是合法的。\n\n  \n\n\n#### | 为什么要验证 \n\n很多人会告诉我，如果这些 API 是提供给前端进行调用的，前端都会进行验证啊，你为什还要验证？\n\n  \n\n\n其实答案是这样的，我从不相信任何调用我 API 或者方法的人，比如前端验证失败了，或者某些人通过一些特殊的渠道(比如 Charles 进行抓包)，直接将数据传入到我的 API，那我仍然进行正常的业务逻辑处理，那么就有可能产生脏数据！\n\n  \n\n\n“对于脏数据的产生一定是致命”，这句话希望大家牢记在心，再小的脏数据也有可能让你找几个通宵！\n\n  \n\n\n#### | jsr 303 验证 \n\nhibernate 提供的 jsr 303 实现，我觉得目前仍然是很优秀的，具体如何使用，我不想讲，因为谷歌上你可以搜索出很多答案！\n\n  \n\n\n\n\n\n再以上班的 API 实例进行说明，我们现在对 DTO 数据进行检查：\n\n```java\npublic class UserDTO {\n    @NotNull\n    private String username;\n    @NotNull\n    private int age;\n        //其他代码略\n}\n```\n\n  \n\n\n\n\n\n  \n\n\nAPI 验证：\n\n```java\n@PostMapping\n    public UserDTO addUser(@Valid UserDTO userDTO){\n            User user =  userDTO.convertToUser();\n            User saveResultUser = userService.addUser(user);\n            UserDTO result = userDTO.convertFor(saveResultUser);\n            return result;\n    }\n```\n\n  \n\n\n\n\n\n  \n\n\n我们需要将验证结果传给前端，这种异常应该转化为一个 api 异常（带有错误码的异常）。\n\n```java\n@PostMapping\npublic UserDTO addUser(@Valid UserDTO userDTO, BindingResult bindingResult){\n     checkDTOParams(bindingResult);\n\n     User user =  userDTO.convertToUser();\n     User saveResultUser = userService.addUser(user);\n     UserDTO result = userDTO.convertFor(saveResultUser);\n     return result;\n}\nprivate void checkDTOParams(BindingResult bindingResult){\n     if(bindingResult.hasErrors()){\n             //throw new 带验证码的验证错误异常\n     }\n}\n```\n\n  \n\n\n\n\n\n  \n\n\nBindingResult 是 Spring MVC 验证 DTO 后的一个结果集，可以参考 spring 官方文档：\n\n```java\nhttps://spring.io/\n```\n\n  \n\n\n\n\n\n检查参数后，可以抛出一个“带验证码的验证错误异常”。\n\n  \n\n\n拥抱 lombok\n\n  \n\n\n上边的 DTO 代码，已经让我看的很累了，我相信读者也是一样，看到那么多的 Getter 和 Setter 方法，太烦躁了，那时候有什么方法可以简化这些呢。\n\n  \n\n\n请拥抱 lombok，它会帮助我们解决一些让我们很烦躁的问题。\n\n  \n\n\n去掉 Setter 和 Getter\n\n  \n\n\n\n\n\n其实这个标题，我不太想说，因为网上太多，但是因为很多人告诉我，他们根本就不知道 lombok 的存在，所以为了让读者更好的学习，我愿意写这样一个例子：\n\n```java\n@Setter\n@Getter\npublic class UserDTO {\n    @NotNull\n    private String username;\n    @NotNull\n    private int age;\n\n    public User convertToUser(){\n        UserDTOConvert userDTOConvert = new UserDTOConvert();\n        User convert = userDTOConvert.convert(this);\n        return convert;\n    }\n\n    public UserDTO convertFor(User user){\n        UserDTOConvert userDTOConvert = new UserDTOConvert();\n        UserDTO convert = userDTOConvert.reverse().convert(user);\n        return convert;\n    }\n\n    private static class UserDTOConvert extends Converter<UserDTO, User> {\n        @Override\n        protected User doForward(UserDTO userDTO) {\n            User user = new User();\n            BeanUtils.copyProperties(userDTO,user);\n            return user;\n        }\n\n        @Override\n        protected UserDTO doBackward(User user) {\n            throw new AssertionError(\"不支持逆向转化方法!\");\n        }\n    }\n\n}\n```\n\n  \n\n\n\n\n\n看到了吧，烦人的 Getter 和 Setter 方法已经去掉了。\n\n  \n\n\n但是上边的例子根本不足以体现 lombok 的强大。我希望写一些网上很难查到，或者很少人进行说明的 lombok 的使用以及在使用时程序语义上的说明。\n\n  \n\n\n比如：@Data，@AllArgsConstructor，@NoArgsConstructor..这些我就不进行一一说明了，请大家自行查询资料。\n\n  \n\n\nbean 中的链式风格\n\n  \n\n\n\n\n\n什么是链式风格？我来举个例子，看下面这个 Student 的 bean：\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n\n    public String getName() {\n        return name;\n    }\n\n    public Student setName(String name) {\n        this.name = name;\n        return this;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public Student setAge(int age) {\n        return this;\n    }\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n仔细看一下 set 方法，这样的设置便是 chain 的 style，调用的时候，可以这样使用：\n\n```java\nStudent student = new Student()\n        .setAge(24)\n        .setName(\"zs\");\n```\n\n  \n\n\n\n\n\n  \n\n\n相信合理使用这样的链式代码，会更多的程序带来很好的可读性，那看一下如果使用 lombok 进行改善呢，请使用 @Accessors(chain = true)，看如下代码：\n\n```java\n@Accessors(chain = true)\n@Setter\n@Getter\npublic class Student {\n    private String name;\n    private int age;\n}\n```\n\n  \n\n\n\n\n\n这样就完成了一个对于 bean 来讲很友好的链式操作。\n\n  \n\n\n#### | 静态构造方法 \n\n  \n\n\n静态构造方法的语义和简化程度真的高于直接去 new 一个对象。比如 new 一个 List 对象，过去的使用是这样的：\n\n```java\nList<String> list = new ArrayList<>();\n```\n\n  \n\n\n\n\n\n  \n\n\n看一下 guava 中的创建方式：\n\n```java\nList<String> list = Lists.newArrayList();\n```\n\n  \n\n\n\n\n\nLists 命名是一种约定（俗话说：约定优于配置），它是指 Lists 是 List 这个类的一个工具类，那么使用 List 的工具类去产生 List，这样的语义是不是要比直接 new 一个子类来的更直接一些呢，答案是肯定的。\n\n  \n\n\n\n\n\n再比如如果有一个工具类叫做 Maps，那你是否想到了创建 Map 的方法呢：\n\n```java\nHashMap<String, String> objectObjectHashMap = Maps.newHashMap();\n```\n\n  \n\n\n\n\n\n好了，如果你理解了我说的语义，那么，你已经向成为 Java 程序员更近了一步了。\n\n  \n\n\n再回过头来看刚刚的 Student，很多时候，我们去写 Student 这个 bean 的时候，他会有一些必输字段。\n\n  \n\n\n比如 Student 中的 name 字段，一般处理的方式是将 name 字段包装成一个构造方法，只有传入 name 这样的构造方法，才能创建一个 Student 对象。\n\n  \n\n\n\n\n\n接上上边的静态构造方法和必传参数的构造方法，使用 lombok 将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）：\n\n```java\n@Accessors(chain = true)\n@Setter\n@Getter\n@RequiredArgsConstructor(staticName = \"ofName\")\npublic class Student {\n    @NonNull private String name;\n    private int age;\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n测试代码：\n\n```java\nStudent student = Student.ofName(\"zs\");\n```\n\n  \n\n\n\n\n\n这样构建出的 bean 语义是否要比直接 new 一个含参的构造方法（包含 name 的构造方法）要好很多。\n\n  \n\n\n\n\n\n当然，看过很多源码以后，我想相信将静态构造方法 ofName 换成 of 会先的更加简洁：\n\n```java\n@Accessors(chain = true)\n@Setter\n@Getter\n@RequiredArgsConstructor(staticName = \"of\")\npublic class Student {\n        @NonNull private String name;\n        private int age;\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n测试代码：\n\n```java\nStudent student = Student.of(\"zs\");\n```\n\n  \n\n\n\n\n\n  \n\n\n当然他仍然是支持链式调用的：\n\n```java\nStudent student = Student.of(\"zs\").setAge(24);\n```\n\n  \n\n\n\n\n\n这样来写代码，真的很简洁，并且可读性很强。\n\n  \n\n\n#### | 使用 builder \n\nBuilder 模式我不想再多解释了，读者可以看一下《Head First》(设计模式) 的建造者模式。\n\n  \n\n\n今天其实要说的是一种变种的 builder 模式，那就是构建 bean 的 builder 模式，其实主要的思想是带着大家一起看一下 lombok 给我们带来了什么。\n\n  \n\n\n\n\n\n看一下 Student 这个类的原始 builder 状态：\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n\n    public String getName() {\n            return name;\n    }\n\n    public void setName(String name) {\n            this.name = name;\n    }\n\n    public int getAge() {\n            return age;\n    }\n\n    public void setAge(int age) {\n            this.age = age;\n    }\n\n    public static Builder builder(){\n            return new Builder();\n    }\n    public static class Builder{\n            private String name;\n            private int age;\n            public Builder name(String name){\n                    this.name = name;\n                    return this;\n            }\n\n            public Builder age(int age){\n                    this.age = age;\n                    return this;\n            }\n\n            public Student build(){\n                    Student student = new Student();\n                    student.setAge(age);\n                    student.setName(name);\n                    return student;\n            }\n    }\n\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n调用方式：\n\n```java\nStudent student = Student.builder().name(\"zs\").age(24).build();\n```\n\n  \n\n\n\n\n\n  \n\n\n这样的 builder 代码，让我是在恶心难受，于是我打算用 lombok 重构这段代码：\n\n```java\n@Builder\npublic class Student {\n    private String name;\n    private int age;\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n调用方式：\n\n```java\nStudent student = Student.builder().name(\"zs\").age(24).build();\n```\n\n  \n\n\n\n\n\n代理模式\n\n  \n\n\n正如我们所知的，在程序中调用 rest 接口是一个常见的行为动作，如果你和我一样使用过 spring 的 RestTemplate，我相信你会我和一样，对他抛出的非 http 状态码异常深恶痛绝。\n\n  \n\n\n\n\n\n所以我们考虑将 RestTemplate 最为底层包装器进行包装器模式的设计：\n\n```java\npublic abstract class FilterRestTemplate implements RestOperations {\n        protected volatile RestTemplate restTemplate;\n\n        protected FilterRestTemplate(RestTemplate restTemplate){\n                this.restTemplate = restTemplate;\n        }\n\n        //实现RestOperations所有的接口\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n然后再由扩展类对 FilterRestTemplate 进行包装扩展：\n\n```java\npublic class ExtractRestTemplate extends FilterRestTemplate {\n    private RestTemplate restTemplate;\n    public ExtractRestTemplate(RestTemplate restTemplate) {\n            super(restTemplate);\n            this.restTemplate = restTemplate;\n    }\n\n    public <T> RestResponseDTO<T> postForEntityWithNoException(String url, Object request, Class<T> responseType, Object... uriVariables)\n                    throws RestClientException {\n            RestResponseDTO<T> restResponseDTO = new RestResponseDTO<T>();\n            ResponseEntity<T> tResponseEntity;\n            try {\n                    tResponseEntity = restTemplate.postForEntity(url, request, responseType, uriVariables);\n                    restResponseDTO.setData(tResponseEntity.getBody());\n                    restResponseDTO.setMessage(tResponseEntity.getStatusCode().name());\n                    restResponseDTO.setStatusCode(tResponseEntity.getStatusCodeValue());\n            }catch (Exception e){\n                    restResponseDTO.setStatusCode(RestResponseDTO.UNKNOWN_ERROR);\n                    restResponseDTO.setMessage(e.getMessage());\n                    restResponseDTO.setData(null);\n            }\n            return restResponseDTO;\n    }\n}\n```\n\n  \n\n\n\n\n\n包装器 ExtractRestTemplate 很完美的更改了异常抛出的行为，让程序更具有容错性。\n\n  \n\n\n在这里我们不考虑 ExtractRestTemplate 完成的功能，让我们把焦点放在 FilterRestTemplate 上，“实现 RestOperations 所有的接口”。\n\n  \n\n\n\n\n\n这个操作绝对不是一时半会可以写完的，当时在重构之前我几乎写了半个小时，如下：\n\n```java\npublic abstract class FilterRestTemplate implements RestOperations {\n\n    protected volatile RestTemplate restTemplate;\n\n    protected FilterRestTemplate(RestTemplate restTemplate) {\n            this.restTemplate = restTemplate;\n    }\n\n    @Override\n    public <T> T getForObject(String url, Class<T> responseType, Object... uriVariables) throws RestClientException {\n            return restTemplate.getForObject(url,responseType,uriVariables);\n    }\n\n    @Override\n    public <T> T getForObject(String url, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {\n            return restTemplate.getForObject(url,responseType,uriVariables);\n    }\n\n    @Override\n    public <T> T getForObject(URI url, Class<T> responseType) throws RestClientException {\n            return restTemplate.getForObject(url,responseType);\n    }\n\n    @Override\n    public <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... uriVariables) throws RestClientException {\n            return restTemplate.getForEntity(url,responseType,uriVariables);\n    }\n    //其他实现代码略。。。\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n我相信你看了以上代码，你会和我一样觉得恶心反胃，后来我用 lombok 提供的代理注解优化了我的代码（@Delegate）：\n\n```java\n@AllArgsConstructor\npublic abstract class FilterRestTemplate implements RestOperations {\n    @Delegate\n    protected volatile RestTemplate restTemplate;\n}\n```\n\n  \n\n\n\n\n\n这几行代码完全替代上述那些冗长的代码。是不是很简洁，做一个拥抱 lombok 的程序员吧。\n\n  \n\n\n\n\n\n重构\n\n  \n\n\n\n\n\n需求案例\n\n  \n\n\n#### | 项目需求 \n\n项目开发阶段，有一个关于下单发货的需求：如果今天下午 3 点前进行下单，那么发货时间是明天，如果今天下午 3 点后进行下单，那么发货时间是后天，如果被确定的时间是周日，那么在此时间上再加 1 天为发货时间。\n\n  \n\n\n#### | 思考与重构 \n\n我相信这个需求看似很简单，无论怎么写都可以完成。\n\n  \n\n\n很多人可能看到这个需求，就动手开始写 Calendar 或 Date 进行计算，从而完成需求。\n\n  \n\n\n而我给的建议是，仔细考虑如何写代码，然后再去写，不是说所有的时间操作都用 Calendar 或 Date 去解决，一定要看场景。\n\n  \n\n\n对于时间的计算我们要考虑 joda-time 这种类似的成熟时间计算框架来写代码，它会让代码更加简洁和易读。\n\n  \n\n\n\n\n\n请读者先考虑这个需求如何用 Java 代码完成，或先写一个你觉得完成这个代码的思路，再来看我下边的代码，这样，你的收获会更多一些：\n\n```java\nfinal DateTime DISTRIBUTION_TIME_SPLIT_TIME = new DateTime().withTime(15,0,0,0);\nprivate Date calculateDistributionTimeByOrderCreateTime(Date orderCreateTime){\n    DateTime orderCreateDateTime = new DateTime(orderCreateTime);\n    Date tomorrow = orderCreateDateTime.plusDays(1).toDate();\n    Date theDayAfterTomorrow = orderCreateDateTime.plusDays(2).toDate();\n    return orderCreateDateTime.isAfter(DISTRIBUTION_TIME_SPLIT_TIME) ? wrapDistributionTime(theDayAfterTomorrow) : wrapDistributionTime(tomorrow);\n}\nprivate Date wrapDistributionTime(Date distributionTime){\n    DateTime currentDistributionDateTime = new DateTime(distributionTime);\n    DateTime plusOneDay = currentDistributionDateTime.plusDays(1);\n    boolean isSunday = (DateTimeConstants.SUNDAY == currentDistributionDateTime.getDayOfWeek());\n    return isSunday ? plusOneDay.toDate() : currentDistributionDateTime.toDate() ;\n}\n```\n\n  \n\n\n\n\n\n读这段代码的时候，你会发现，我将判断和有可能出现的不同结果都当做一个变量，最终做一个三目运算符的方式进行返回。\n\n  \n\n\n这样的优雅和可读性显而易见，当然这样的代码不是一蹴而就的，我优化了 3 遍产生的以上代码。读者可根据自己的代码和我写的代码进行对比。\n\n  \n\n\n#### | 提高方法 \n\n如果你做了 3 年+的程序员，我相信像如上这样的需求，你很轻松就能完成，但是如果你想做一个会写 Java 的程序员，就好好的思考和重构代码吧。\n\n  \n\n\n写代码就如同写字一样，同样的字，大家都会写，但是写出来是否好看就不一定了。如果想把程序写好，就要不断的思考和重构，敢于尝试，敢于创新，不要因循守旧，一定要做一个优秀的 Java 程序员。\n\n  \n\n\n提高代码水平最好的方法就是有条理的重构！（注意：是有条理的重构）\n\n  \n\n\n#### | 设计模式 \n\n设计模式就是工具，而不是提现你是否是高水平程序员的一个指标。\n\n  \n\n\n我经常会看到某一个程序员兴奋的大喊，哪个程序哪个点我用到了设计模式，写的多么多么优秀，多么多么好。我仔细去翻阅的时候，却发现有很多是过度设计的。\n\n  \n\n\n#### | 业务驱动技术 or 技术驱动业务 \n\n业务驱动技术 or 技术驱动业务 ？其实这是一个一直在争论的话题，但是很多人不这么认为，我觉得就是大家不愿意承认罢了。我来和大家大概分析一下作为一个 Java 程序员，我们应该如何判断自己所处于的位置。\n\n  \n\n\n业务驱动技术：如果你所在的项目是一个收益很小或者甚至没有收益的项目，请不要搞其他创新的东西，不要驱动业务要如何如何做，而是要熟知业务现在的痛点是什么？如何才能帮助业务盈利或者让项目更好，更顺利的进行。\n\n  \n\n\n技术驱动业务：如果你所在的项目是一个很牛的项目，比如淘宝这类的项目，我可以在满足业务需求的情况下，和业务沟通，使用什么样的技术能更好的帮助业务创造收益。\n\n  \n\n\n比如说下单的时候要进队列，可能几分钟之后订单状态才能处理完成，但是会让用户有更流畅的体验，赚取更多的访问流量，那么我相信业务愿意被技术驱动，会同意订单的延迟问题，这样便是技术驱动业务。\n\n  \n\n\n我相信大部分人还都处于业务驱动技术的方向吧。所以你既然不能驱动业务，那就请拥抱业务变化吧。\n\n  \n\n\n#### | 代码设计 \n\n一直在做 Java 后端的项目，经常会有一些变动，我相信大家也都遇到过。\n\n  \n\n\n比如当我们写一段代码的时候，我们考虑将需求映射成代码的状态模式，突然有一天，状态模式里边又添加了很多行为变化的东西，这时候你就挠头了，你硬生生的将状态模式中添加过多行为和变化。\n\n  \n\n\n慢慢的你会发现这些状态模式，其实更像是一簇算法，应该使用策略模式，这时你应该已经晕头转向了。\n\n  \n\n\n说了这么多，我的意思是，只要你觉得合理，就请将状态模式改为策略模式吧，所有的模式并不是凭空想象出来的，都是基于重构。\n\n  \n\n\nJava 编程中没有银弹，请拥抱业务变化，一直思考重构，你就有一个更好的代码设计！\n\n  \n\n\n#### | 你真的优秀吗？ \n\n真不好意思，我取了一个这么无聊的标题。\n\n  \n\n\n国外流行一种编程方式，叫做结对编程，我相信国内很多公司都没有这么做，我就不在讲述结对编程带来的好处了，其实就是一边 code review，一边互相提高的一个过程。既然做不到这个，那如何让自己活在自己的世界中不断提高呢？\n\n  \n\n\n“平时开发的时候，做出的代码总认为是正确的，而且写法是完美的。”，我相信这是大部分人的心声，还回到刚刚的问题，如何在自己的世界中不断提高呢？\n\n  \n\n\n### 答案就是： \n\n *  多看成熟框架的源码\n *  多回头看自己的代码\n *  勤于重构\n\n  \n\n\n你真的优秀吗？如果你每周都完成了学习源码，回头看自己代码，然后勤于重构，我认为你就真的很优秀了。\n\n  \n\n\n即使也许你只是刚刚入门，但是一直坚持，你就是一个真的会写 Java 代码的程序员了。\n\n  \n\n\n\n\n\n技能\n\n  \n\n\n\n\n\n#### | UML \n\n不想多讨论 UML 相关的知识，但是我觉得你如果真的会写 Java，请先学会表达自己，UML 就是你说话的语言。\n\n  \n\n\n做一名优秀的 Java 程序员，请至少学会这两种 UML 图：\n\n *  类图\n *  时序图\n\n  \n\n\n#### | clean code \n\n我认为保持代码的简洁和可读性是代码的最基本保证，如果有一天为了程序的效率而降低了这两点，我认为是可以谅解的，除此之外，没有任何理由可以让你任意挥霍你的代码。\n\n  \n\n\n无论如何，请保持你的代码的整洁。\n\n  \n\n\n#### | Linux 基础命令 \n\n这点其实和会写 Java 没有关系，但是 Linux 很多时候确实承载运行 Java 的容器，请学好 Linux 的基础命令。\n\n  \n\n\n\n\n\n总结\n\n  \n\n\n\n\n\nJava 是一个大体系，今天讨论并未涉及框架和架构相关知识，只是讨论如何写好代码。\n\n  \n\n\n本文从写 Java 程序的小方面一直写到大方面，来阐述了如何才能写好 Java 程序，并告诉读者们如何才能提高自身的编码水平。\n\n  \n\n\n我希望看到这篇文章的各位都能做一个优秀的 Java 程序员","source":"_posts/目瞪口呆的Java代码技巧.md","raw":"---\ntitle: 目瞪口呆的Java代码技巧\ntop: false\ncover: false\ntoc: true\nmathjax: true\nsummary: 目瞪口呆的Java代码技巧\ndate: 2022-11-09 12:12:37\npassword:\ntags:\n    - 技巧\n    - 重构\ncategories:\n    - java\n---\n开发工具\n\n  \n\n\n\n\n\n不知道有多少“老”程序员还在使用 Eclipse，这些程序员们要不就是因循守旧，要不就是根本就不知道其他好的开发工具的存在，Eclipse 吃内存卡顿的现象以及各种偶然莫名异常的出现，都告知我们是时候寻找新的开发工具了。\n\n  \n\n\n#### | 更换 IDE \n\n根本就不想多解释要换什么样的 IDE，如果你想成为一个优秀的 Java 程序员，请更换 IntelliJ IDEA。使用 IDEA 的好处，请搜索谷歌。\n\n  \n\n\n#### | 别告诉我快捷键不好用 \n\n更换 IDE 不在我本文的重点内容中，所以不想用太多的篇幅去写为什么更换IDE。在这里，我只能告诉你，更换 IDE 只为了更好、更快的写好 Java 代码。原因略。\n\n  \n\n\n别告诉我快捷键不好用，请尝试新事物。\n\n  \n\n\n#### | bean \n\nbean 使我们使用最多的模型之一，我将以大篇幅去讲解 bean，希望读者好好体会。\n\n  \n\n\n#### | domain 包名 \n\n根据很多 Java 程序员的“经验”来看，一个数据库表则对应着一个 domain 对象，所以很多程序员在写代码时，包名则使用：com.xxx.domain ，这样写好像已经成为了行业的一种约束，数据库映射对象就应该是 domain。\n\n  \n\n\n但是你错了，domain 是一个领域对象，往往我们再做传统 Java 软件 Web 开发中，这些 domain 都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的。\n\n  \n\n\n所以，以这个理论来讲，这些 domain 都应该是一个普通的 entity 对象，并非领域对象，所以请把包名改为：com.xxx.entity。\n\n  \n\n\n如果你还不理解我说的话，请看一下 Vaughn Vernon 出的一本叫做《IMPLEMENTING DOMAIN-DRIVEN DESIGN》（实现领域驱动设计）这本书，书中讲解了贫血模型与领域模型的区别，相信你会受益匪浅。\n\n  \n\n\n#### | DTO \n\n数据传输我们应该使用 DTO 对象作为传输对象，这是我们所约定的，因为很长时间我一直都在做移动端 API 设计的工作，有很多人告诉我，他们认为只有给手机端传输数据的时候（input or output），这些对象成为 DTO 对象。\n\n  \n\n\n请注意！这种理解是错误的，只要是用于网络传输的对象，我们都认为他们可以当做是 DTO 对象，比如电商平台中，用户进行下单，下单后的数据，订单会发到 OMS 或者 ERP 系统，这些对接的返回值以及入参也叫 DTO 对象。\n\n  \n\n\n我们约定某对象如果是 DTO 对象，就将名称改为 XXDTO，比如订单下发 OMS：OMSOrderInputDTO。\n\n  \n\n\n#### | DTO 转化 \n\n正如我们所知，DTO 为系统与外界交互的模型对象，那么肯定会有一个步骤是将 DTO 对象转化为 BO 对象或者是普通的 entity 对象，让 service 层去处理。\n\n  \n\n\n#### | 场景 \n\n  \n\n\n比如添加会员操作，由于用于演示，我只考虑用户的一些简单数据，当后台管理员点击添加用户时，只需要传过来用户的姓名和年龄就可以了，后端接受到数据后，将添加创建时间和更新时间和默认密码三个字段，然后保存数据库。\n\n```java\n@RequestMapping(\"/v1/api/user\")\n@RestController\npublic class UserApi {\n\n    @Autowired\n    private UserService userService;\n\n    @PostMapping\n    public User addUser(UserInputDTO userInputDTO){\n        User user = new User();\n        user.setUsername(userInputDTO.getUsername());\n        user.setAge(userInputDTO.getAge());\n\n        return userService.addUser(user);\n    }\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n我们只关注一下上述代码中的转化代码，其他内容请忽略：\n\n```java\nUser user = new User();\nuser.setUsername(userInputDTO.getUsername());\nuser.setAge(userInputDTO.getAge());\n```\n\n  \n\n\n\n\n\n#### | 请使用工具 \n\n上边的代码，从逻辑上讲，是没有问题的，只是这种写法让我很厌烦，例子中只有两个字段，如果有 20 个字段，我们要如何做呢？一个一个进行 set 数据吗？\n\n  \n\n\n当然，如果你这么做了，肯定不会有什么问题，但是，这肯定不是一个最优的做法。网上有很多工具，支持浅拷贝或深拷贝的 Utils。\n\n  \n\n\n\n\n\n举个例子，我们可以使用 org.springframework.beans.BeanUtils\\#copyProperties 对代码进行重构和优化：\n\n```java\n@PostMapping\npublic User addUser(UserInputDTO userInputDTO){\n    User user = new User();\n    BeanUtils.copyProperties(userInputDTO,user);\n\n    return userService.addUser(user);\n}\n```\n\n  \n\n\n\n\n\nBeanUtils.copyProperties 是一个浅拷贝方法，复制属性时，我们只需要把 DTO 对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。\n\n  \n\n\n如果你在做 DTO 转化的时候一直使用 set 进行属性赋值，那么请尝试这种方式简化代码，让代码更加清晰！\n\n  \n\n\n#### | 转化的语义 \n\n  \n\n\n上边的转化过程，读者看后肯定觉得优雅很多，但是我们再写 Java 代码时，更多的需要考虑语义的操作，再看上边的代码：\n\n```java\nUser user = new User();\nBeanUtils.copyProperties(userInputDTO,user);\n```\n\n  \n\n\n\n\n\n  \n\n\n虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好，所以代码改成如下：\n\n```java\n@PostMapping\n public User addUser(UserInputDTO userInputDTO){\n         User user = convertFor(userInputDTO);\n\n         return userService.addUser(user);\n }\n\n private User convertFor(UserInputDTO userInputDTO){\n\n         User user = new User();\n         BeanUtils.copyProperties(userInputDTO,user);\n         return user;\n }\n```\n\n  \n\n\n\n\n\n  \n\n\n这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中，比如：\n\n```java\nUser user = convertFor(userInputDTO);\nreturn userService.addUser(user);\n```\n\n  \n\n\n\n\n\n这两段代码都没有暴露实现，都是在讲如何在同一个方法中，做一组相同层次的语义操作，而不是暴露具体的实现。\n\n  \n\n\n如上所述，是一种重构方式，读者可以参考 Martin Fowler 的《Refactoring Imporving the Design of Existing Code》（重构改善既有代码的设计）这本书中的 Extract Method 重构方式。\n\n  \n\n\n#### | 抽象接口定义 \n\n当实际工作中，完成了几个 API 的 DTO 转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。\n\n  \n\n\n如果接口被定义以后，那么 convertFor 这个方法的语义将产生变化，它将是一个实现类。\n\n  \n\n\n\n\n\n看一下抽象后的接口：\n\n```java\npublic interface DTOConvert<S,T> {\n    T convert(S s);\n}\n```\n\n  \n\n\n\n\n\n虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的 Java 程序员，请为你想做的抽象接口，做好泛型吧。\n\n  \n\n\n\n\n\n我们再来看接口实现：\n\n```java\npublic class UserInputDTOConvert implements DTOConvert {\n@Override\npublic User convert(UserInputDTO userInputDTO) {\nUser user = new User();\nBeanUtils.copyProperties(userInputDTO,user);\nreturn user;\n}\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范：\n\n```java\n@RequestMapping(\"/v1/api/user\")\n@RestController\npublic class UserApi {\n\n    @Autowired\n    private UserService userService;\n\n    @PostMapping\n    public User addUser(UserInputDTO userInputDTO){\n        User user = new UserInputDTOConvert().convert(userInputDTO);\n\n        return userService.addUser(user);\n    }\n}\n```\n\n  \n\n\n\n\n\n#### | review code \n\n如果你是一个优秀的 Java 程序员，我相信你应该和我一样，已经数次重复 review 过自己的代码很多次了。\n\n  \n\n\n我们再看这个保存用户的例子，你将发现，API 中返回值是有些问题的，问题就在于不应该直接返回 User 实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的。\n\n  \n\n\n\n\n\n所以我们更应该返回一个 DTO 对象，我们可称它为 UserOutputDTO：\n\n```java\n@PostMapping\npublic UserOutputDTO addUser(UserInputDTO userInputDTO){\n        User user = new UserInputDTOConvert().convert(userInputDTO);\n        User saveUserResult = userService.addUser(user);\n        UserOutputDTO result = new UserOutDTOConvert().convertToUser(saveUserResult);\n        return result;\n}\n```\n\n  \n\n\n\n\n\n这样你的 API 才更健全。\n\n  \n\n\n\n\n\n不知道在看完这段代码之后，读者有是否发现还有其他问题的存在，作为一个优秀的 Java 程序员，请看一下这段我们刚刚抽象完的代码：\n\n```java\nUser user = new UserInputDTOConvert().convert(userInputDTO);\n```\n\n  \n\n\n\n\n\n你会发现，new 这样一个 DTO 转化对象是没有必要的，而且每一个转化对象都是由在遇到 DTO 转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和 DTO 进行聚合呢？\n\n  \n\n\n\n\n\n看一下我的聚合结果：\n\n```java\npublic class UserInputDTO {\nprivate String username;\nprivate int age;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n\n    public User convertToUser(){\n        UserInputDTOConvert userInputDTOConvert = new UserInputDTOConvert();\n        User convert = userInputDTOConvert.convert(this);\n        return convert;\n    }\n\n    private static class UserInputDTOConvert implements DTOConvert<UserInputDTO,User> {\n        @Override\n        public User convert(UserInputDTO userInputDTO) {\n            User user = new User();\n            BeanUtils.copyProperties(userInputDTO,user);\n            return user;\n        }\n    }\n\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n然后 API 中的转化则由：\n\n```java\nUser user = new UserInputDTOConvert().convert(userInputDTO);\nUser saveUserResult = userService.addUser(user);\n```\n\n  \n\n\n\n\n\n  \n\n\n变成了：\n\n```java\nUser user = userInputDTO.convertToUser();\nUser saveUserResult = userService.addUser(user);\n```\n\n  \n\n\n\n\n\n我们再 DTO 对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。\n\n  \n\n\n#### | 再查工具类 \n\n再来看 DTO 内部转化的代码，它实现了我们自己定义的 DTOConvert 接口，但是这样真的就没有问题，不需要再思考了吗？\n\n  \n\n\n我觉得并不是，对于 Convert 这种转化语义来讲，很多工具类中都有这样的定义，这中 Convert 并不是业务级别上的接口定义，它只是用于普通 bean 之间转化属性值的普通意义上的接口定义，所以我们应该更多的去读其他含有 Convert 转化语义的代码。\n\n  \n\n\n\n\n\n我仔细阅读了一下 GUAVA 的源码，发现了 com.google.common.base.Convert 这样的定义：\n\n```java\npublic abstract class Converter<A, B> implements Function<A, B> {\n    protected abstract B doForward(A a);\n    protected abstract A doBackward(B b);\n    //其他略\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n从源码可以了解到，GUAVA 中的 Convert 可以完成正向转化和逆向转化，继续修改我们 DTO 中转化的这段代码：\n\n```java\nprivate static class UserInputDTOConvert implements DTOConvert<UserInputDTO,User> {\n        @Override\n        public User convert(UserInputDTO userInputDTO) {\n                User user = new User();\n                BeanUtils.copyProperties(userInputDTO,user);\n                return user;\n        }\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n修改后：\n\n```java\nprivate static class UserInputDTOConvert extends Converter<UserInputDTO, User> {\n         @Override\n         protected User doForward(UserInputDTO userInputDTO) {\n                 User user = new User();\n                 BeanUtils.copyProperties(userInputDTO,user);\n                 return user;\n         }\n\n         @Override\n         protected UserInputDTO doBackward(User user) {\n                 UserInputDTO userInputDTO = new UserInputDTO();\n                 BeanUtils.copyProperties(user,userInputDTO);\n                 return userInputDTO;\n         }\n }\n```\n\n  \n\n\n\n\n\n看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的 UserInputDTO 和 UserOutputDTO 都转成 UserDTO 展示给大家。\n\n  \n\n\n\n\n\nDTO：\n\n```java\npublic class UserDTO {\n    private String username;\n    private int age;\n\n    public String getUsername() {\n            return username;\n    }\n\n    public void setUsername(String username) {\n            this.username = username;\n    }\n\n    public int getAge() {\n            return age;\n    }\n\n    public void setAge(int age) {\n            this.age = age;\n    }\n\n\n    public User convertToUser(){\n            UserDTOConvert userDTOConvert = new UserDTOConvert();\n            User convert = userDTOConvert.convert(this);\n            return convert;\n    }\n\n    public UserDTO convertFor(User user){\n            UserDTOConvert userDTOConvert = new UserDTOConvert();\n            UserDTO convert = userDTOConvert.reverse().convert(user);\n            return convert;\n    }\n\n    private static class UserDTOConvert extends Converter<UserDTO, User> {\n            @Override\n            protected User doForward(UserDTO userDTO) {\n                    User user = new User();\n                    BeanUtils.copyProperties(userDTO,user);\n                    return user;\n            }\n\n            @Override\n            protected UserDTO doBackward(User user) {\n                    UserDTO userDTO = new UserDTO();\n                    BeanUtils.copyProperties(user,userDTO);\n                    return userDTO;\n            }\n    }\n\n}\n```\n\n  \n\n\n\n\n\n  \n\n\nAPI：\n\n```java\n@PostMapping\n public UserDTO addUser(UserDTO userDTO){\n         User user =  userDTO.convertToUser();\n         User saveResultUser = userService.addUser(user);\n         UserDTO result = userDTO.convertFor(saveResultUser);\n         return result;\n }\n```\n\n  \n\n\n\n\n\n  \n\n\n当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的 DTO 对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的。\n\n```java\nprivate static class UserDTOConvert extends Converter<UserDTO, User> {\n         @Override\n         protected User doForward(UserDTO userDTO) {\n                 User user = new User();\n                 BeanUtils.copyProperties(userDTO,user);\n                 return user;\n         }\n\n         @Override\n         protected UserDTO doBackward(User user) {\n                 throw new AssertionError(\"不支持逆向转化方法!\");\n         }\n }\n```\n\n  \n\n\n\n\n\n看一下 doBackward 方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就“断言”你调用错误了。\n\n  \n\n\n\n\n\n关于异常处理的更详细介绍，可以参考这篇文章：如何优雅的设计 Java 异常 ，应该可以帮你更好的理解异常。\n\n```java\nhttp://lrwinx.github.io/2016/04/28/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%AE%BE%E8%AE%A1java%E5%BC%82%E5%B8%B8/\n```\n\n  \n\n\n\n\n\n#### | bean 的验证 \n\n如果你认为我上边写的那个添加用户 API 写的已经非常完美了，那只能说明你还不是一个优秀的程序员。我们应该保证任何数据的入参到方法体内都是合法的。\n\n  \n\n\n#### | 为什么要验证 \n\n很多人会告诉我，如果这些 API 是提供给前端进行调用的，前端都会进行验证啊，你为什还要验证？\n\n  \n\n\n其实答案是这样的，我从不相信任何调用我 API 或者方法的人，比如前端验证失败了，或者某些人通过一些特殊的渠道(比如 Charles 进行抓包)，直接将数据传入到我的 API，那我仍然进行正常的业务逻辑处理，那么就有可能产生脏数据！\n\n  \n\n\n“对于脏数据的产生一定是致命”，这句话希望大家牢记在心，再小的脏数据也有可能让你找几个通宵！\n\n  \n\n\n#### | jsr 303 验证 \n\nhibernate 提供的 jsr 303 实现，我觉得目前仍然是很优秀的，具体如何使用，我不想讲，因为谷歌上你可以搜索出很多答案！\n\n  \n\n\n\n\n\n再以上班的 API 实例进行说明，我们现在对 DTO 数据进行检查：\n\n```java\npublic class UserDTO {\n    @NotNull\n    private String username;\n    @NotNull\n    private int age;\n        //其他代码略\n}\n```\n\n  \n\n\n\n\n\n  \n\n\nAPI 验证：\n\n```java\n@PostMapping\n    public UserDTO addUser(@Valid UserDTO userDTO){\n            User user =  userDTO.convertToUser();\n            User saveResultUser = userService.addUser(user);\n            UserDTO result = userDTO.convertFor(saveResultUser);\n            return result;\n    }\n```\n\n  \n\n\n\n\n\n  \n\n\n我们需要将验证结果传给前端，这种异常应该转化为一个 api 异常（带有错误码的异常）。\n\n```java\n@PostMapping\npublic UserDTO addUser(@Valid UserDTO userDTO, BindingResult bindingResult){\n     checkDTOParams(bindingResult);\n\n     User user =  userDTO.convertToUser();\n     User saveResultUser = userService.addUser(user);\n     UserDTO result = userDTO.convertFor(saveResultUser);\n     return result;\n}\nprivate void checkDTOParams(BindingResult bindingResult){\n     if(bindingResult.hasErrors()){\n             //throw new 带验证码的验证错误异常\n     }\n}\n```\n\n  \n\n\n\n\n\n  \n\n\nBindingResult 是 Spring MVC 验证 DTO 后的一个结果集，可以参考 spring 官方文档：\n\n```java\nhttps://spring.io/\n```\n\n  \n\n\n\n\n\n检查参数后，可以抛出一个“带验证码的验证错误异常”。\n\n  \n\n\n拥抱 lombok\n\n  \n\n\n上边的 DTO 代码，已经让我看的很累了，我相信读者也是一样，看到那么多的 Getter 和 Setter 方法，太烦躁了，那时候有什么方法可以简化这些呢。\n\n  \n\n\n请拥抱 lombok，它会帮助我们解决一些让我们很烦躁的问题。\n\n  \n\n\n去掉 Setter 和 Getter\n\n  \n\n\n\n\n\n其实这个标题，我不太想说，因为网上太多，但是因为很多人告诉我，他们根本就不知道 lombok 的存在，所以为了让读者更好的学习，我愿意写这样一个例子：\n\n```java\n@Setter\n@Getter\npublic class UserDTO {\n    @NotNull\n    private String username;\n    @NotNull\n    private int age;\n\n    public User convertToUser(){\n        UserDTOConvert userDTOConvert = new UserDTOConvert();\n        User convert = userDTOConvert.convert(this);\n        return convert;\n    }\n\n    public UserDTO convertFor(User user){\n        UserDTOConvert userDTOConvert = new UserDTOConvert();\n        UserDTO convert = userDTOConvert.reverse().convert(user);\n        return convert;\n    }\n\n    private static class UserDTOConvert extends Converter<UserDTO, User> {\n        @Override\n        protected User doForward(UserDTO userDTO) {\n            User user = new User();\n            BeanUtils.copyProperties(userDTO,user);\n            return user;\n        }\n\n        @Override\n        protected UserDTO doBackward(User user) {\n            throw new AssertionError(\"不支持逆向转化方法!\");\n        }\n    }\n\n}\n```\n\n  \n\n\n\n\n\n看到了吧，烦人的 Getter 和 Setter 方法已经去掉了。\n\n  \n\n\n但是上边的例子根本不足以体现 lombok 的强大。我希望写一些网上很难查到，或者很少人进行说明的 lombok 的使用以及在使用时程序语义上的说明。\n\n  \n\n\n比如：@Data，@AllArgsConstructor，@NoArgsConstructor..这些我就不进行一一说明了，请大家自行查询资料。\n\n  \n\n\nbean 中的链式风格\n\n  \n\n\n\n\n\n什么是链式风格？我来举个例子，看下面这个 Student 的 bean：\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n\n    public String getName() {\n        return name;\n    }\n\n    public Student setName(String name) {\n        this.name = name;\n        return this;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public Student setAge(int age) {\n        return this;\n    }\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n仔细看一下 set 方法，这样的设置便是 chain 的 style，调用的时候，可以这样使用：\n\n```java\nStudent student = new Student()\n        .setAge(24)\n        .setName(\"zs\");\n```\n\n  \n\n\n\n\n\n  \n\n\n相信合理使用这样的链式代码，会更多的程序带来很好的可读性，那看一下如果使用 lombok 进行改善呢，请使用 @Accessors(chain = true)，看如下代码：\n\n```java\n@Accessors(chain = true)\n@Setter\n@Getter\npublic class Student {\n    private String name;\n    private int age;\n}\n```\n\n  \n\n\n\n\n\n这样就完成了一个对于 bean 来讲很友好的链式操作。\n\n  \n\n\n#### | 静态构造方法 \n\n  \n\n\n静态构造方法的语义和简化程度真的高于直接去 new 一个对象。比如 new 一个 List 对象，过去的使用是这样的：\n\n```java\nList<String> list = new ArrayList<>();\n```\n\n  \n\n\n\n\n\n  \n\n\n看一下 guava 中的创建方式：\n\n```java\nList<String> list = Lists.newArrayList();\n```\n\n  \n\n\n\n\n\nLists 命名是一种约定（俗话说：约定优于配置），它是指 Lists 是 List 这个类的一个工具类，那么使用 List 的工具类去产生 List，这样的语义是不是要比直接 new 一个子类来的更直接一些呢，答案是肯定的。\n\n  \n\n\n\n\n\n再比如如果有一个工具类叫做 Maps，那你是否想到了创建 Map 的方法呢：\n\n```java\nHashMap<String, String> objectObjectHashMap = Maps.newHashMap();\n```\n\n  \n\n\n\n\n\n好了，如果你理解了我说的语义，那么，你已经向成为 Java 程序员更近了一步了。\n\n  \n\n\n再回过头来看刚刚的 Student，很多时候，我们去写 Student 这个 bean 的时候，他会有一些必输字段。\n\n  \n\n\n比如 Student 中的 name 字段，一般处理的方式是将 name 字段包装成一个构造方法，只有传入 name 这样的构造方法，才能创建一个 Student 对象。\n\n  \n\n\n\n\n\n接上上边的静态构造方法和必传参数的构造方法，使用 lombok 将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）：\n\n```java\n@Accessors(chain = true)\n@Setter\n@Getter\n@RequiredArgsConstructor(staticName = \"ofName\")\npublic class Student {\n    @NonNull private String name;\n    private int age;\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n测试代码：\n\n```java\nStudent student = Student.ofName(\"zs\");\n```\n\n  \n\n\n\n\n\n这样构建出的 bean 语义是否要比直接 new 一个含参的构造方法（包含 name 的构造方法）要好很多。\n\n  \n\n\n\n\n\n当然，看过很多源码以后，我想相信将静态构造方法 ofName 换成 of 会先的更加简洁：\n\n```java\n@Accessors(chain = true)\n@Setter\n@Getter\n@RequiredArgsConstructor(staticName = \"of\")\npublic class Student {\n        @NonNull private String name;\n        private int age;\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n测试代码：\n\n```java\nStudent student = Student.of(\"zs\");\n```\n\n  \n\n\n\n\n\n  \n\n\n当然他仍然是支持链式调用的：\n\n```java\nStudent student = Student.of(\"zs\").setAge(24);\n```\n\n  \n\n\n\n\n\n这样来写代码，真的很简洁，并且可读性很强。\n\n  \n\n\n#### | 使用 builder \n\nBuilder 模式我不想再多解释了，读者可以看一下《Head First》(设计模式) 的建造者模式。\n\n  \n\n\n今天其实要说的是一种变种的 builder 模式，那就是构建 bean 的 builder 模式，其实主要的思想是带着大家一起看一下 lombok 给我们带来了什么。\n\n  \n\n\n\n\n\n看一下 Student 这个类的原始 builder 状态：\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n\n    public String getName() {\n            return name;\n    }\n\n    public void setName(String name) {\n            this.name = name;\n    }\n\n    public int getAge() {\n            return age;\n    }\n\n    public void setAge(int age) {\n            this.age = age;\n    }\n\n    public static Builder builder(){\n            return new Builder();\n    }\n    public static class Builder{\n            private String name;\n            private int age;\n            public Builder name(String name){\n                    this.name = name;\n                    return this;\n            }\n\n            public Builder age(int age){\n                    this.age = age;\n                    return this;\n            }\n\n            public Student build(){\n                    Student student = new Student();\n                    student.setAge(age);\n                    student.setName(name);\n                    return student;\n            }\n    }\n\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n调用方式：\n\n```java\nStudent student = Student.builder().name(\"zs\").age(24).build();\n```\n\n  \n\n\n\n\n\n  \n\n\n这样的 builder 代码，让我是在恶心难受，于是我打算用 lombok 重构这段代码：\n\n```java\n@Builder\npublic class Student {\n    private String name;\n    private int age;\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n调用方式：\n\n```java\nStudent student = Student.builder().name(\"zs\").age(24).build();\n```\n\n  \n\n\n\n\n\n代理模式\n\n  \n\n\n正如我们所知的，在程序中调用 rest 接口是一个常见的行为动作，如果你和我一样使用过 spring 的 RestTemplate，我相信你会我和一样，对他抛出的非 http 状态码异常深恶痛绝。\n\n  \n\n\n\n\n\n所以我们考虑将 RestTemplate 最为底层包装器进行包装器模式的设计：\n\n```java\npublic abstract class FilterRestTemplate implements RestOperations {\n        protected volatile RestTemplate restTemplate;\n\n        protected FilterRestTemplate(RestTemplate restTemplate){\n                this.restTemplate = restTemplate;\n        }\n\n        //实现RestOperations所有的接口\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n然后再由扩展类对 FilterRestTemplate 进行包装扩展：\n\n```java\npublic class ExtractRestTemplate extends FilterRestTemplate {\n    private RestTemplate restTemplate;\n    public ExtractRestTemplate(RestTemplate restTemplate) {\n            super(restTemplate);\n            this.restTemplate = restTemplate;\n    }\n\n    public <T> RestResponseDTO<T> postForEntityWithNoException(String url, Object request, Class<T> responseType, Object... uriVariables)\n                    throws RestClientException {\n            RestResponseDTO<T> restResponseDTO = new RestResponseDTO<T>();\n            ResponseEntity<T> tResponseEntity;\n            try {\n                    tResponseEntity = restTemplate.postForEntity(url, request, responseType, uriVariables);\n                    restResponseDTO.setData(tResponseEntity.getBody());\n                    restResponseDTO.setMessage(tResponseEntity.getStatusCode().name());\n                    restResponseDTO.setStatusCode(tResponseEntity.getStatusCodeValue());\n            }catch (Exception e){\n                    restResponseDTO.setStatusCode(RestResponseDTO.UNKNOWN_ERROR);\n                    restResponseDTO.setMessage(e.getMessage());\n                    restResponseDTO.setData(null);\n            }\n            return restResponseDTO;\n    }\n}\n```\n\n  \n\n\n\n\n\n包装器 ExtractRestTemplate 很完美的更改了异常抛出的行为，让程序更具有容错性。\n\n  \n\n\n在这里我们不考虑 ExtractRestTemplate 完成的功能，让我们把焦点放在 FilterRestTemplate 上，“实现 RestOperations 所有的接口”。\n\n  \n\n\n\n\n\n这个操作绝对不是一时半会可以写完的，当时在重构之前我几乎写了半个小时，如下：\n\n```java\npublic abstract class FilterRestTemplate implements RestOperations {\n\n    protected volatile RestTemplate restTemplate;\n\n    protected FilterRestTemplate(RestTemplate restTemplate) {\n            this.restTemplate = restTemplate;\n    }\n\n    @Override\n    public <T> T getForObject(String url, Class<T> responseType, Object... uriVariables) throws RestClientException {\n            return restTemplate.getForObject(url,responseType,uriVariables);\n    }\n\n    @Override\n    public <T> T getForObject(String url, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {\n            return restTemplate.getForObject(url,responseType,uriVariables);\n    }\n\n    @Override\n    public <T> T getForObject(URI url, Class<T> responseType) throws RestClientException {\n            return restTemplate.getForObject(url,responseType);\n    }\n\n    @Override\n    public <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... uriVariables) throws RestClientException {\n            return restTemplate.getForEntity(url,responseType,uriVariables);\n    }\n    //其他实现代码略。。。\n}\n```\n\n  \n\n\n\n\n\n  \n\n\n我相信你看了以上代码，你会和我一样觉得恶心反胃，后来我用 lombok 提供的代理注解优化了我的代码（@Delegate）：\n\n```java\n@AllArgsConstructor\npublic abstract class FilterRestTemplate implements RestOperations {\n    @Delegate\n    protected volatile RestTemplate restTemplate;\n}\n```\n\n  \n\n\n\n\n\n这几行代码完全替代上述那些冗长的代码。是不是很简洁，做一个拥抱 lombok 的程序员吧。\n\n  \n\n\n\n\n\n重构\n\n  \n\n\n\n\n\n需求案例\n\n  \n\n\n#### | 项目需求 \n\n项目开发阶段，有一个关于下单发货的需求：如果今天下午 3 点前进行下单，那么发货时间是明天，如果今天下午 3 点后进行下单，那么发货时间是后天，如果被确定的时间是周日，那么在此时间上再加 1 天为发货时间。\n\n  \n\n\n#### | 思考与重构 \n\n我相信这个需求看似很简单，无论怎么写都可以完成。\n\n  \n\n\n很多人可能看到这个需求，就动手开始写 Calendar 或 Date 进行计算，从而完成需求。\n\n  \n\n\n而我给的建议是，仔细考虑如何写代码，然后再去写，不是说所有的时间操作都用 Calendar 或 Date 去解决，一定要看场景。\n\n  \n\n\n对于时间的计算我们要考虑 joda-time 这种类似的成熟时间计算框架来写代码，它会让代码更加简洁和易读。\n\n  \n\n\n\n\n\n请读者先考虑这个需求如何用 Java 代码完成，或先写一个你觉得完成这个代码的思路，再来看我下边的代码，这样，你的收获会更多一些：\n\n```java\nfinal DateTime DISTRIBUTION_TIME_SPLIT_TIME = new DateTime().withTime(15,0,0,0);\nprivate Date calculateDistributionTimeByOrderCreateTime(Date orderCreateTime){\n    DateTime orderCreateDateTime = new DateTime(orderCreateTime);\n    Date tomorrow = orderCreateDateTime.plusDays(1).toDate();\n    Date theDayAfterTomorrow = orderCreateDateTime.plusDays(2).toDate();\n    return orderCreateDateTime.isAfter(DISTRIBUTION_TIME_SPLIT_TIME) ? wrapDistributionTime(theDayAfterTomorrow) : wrapDistributionTime(tomorrow);\n}\nprivate Date wrapDistributionTime(Date distributionTime){\n    DateTime currentDistributionDateTime = new DateTime(distributionTime);\n    DateTime plusOneDay = currentDistributionDateTime.plusDays(1);\n    boolean isSunday = (DateTimeConstants.SUNDAY == currentDistributionDateTime.getDayOfWeek());\n    return isSunday ? plusOneDay.toDate() : currentDistributionDateTime.toDate() ;\n}\n```\n\n  \n\n\n\n\n\n读这段代码的时候，你会发现，我将判断和有可能出现的不同结果都当做一个变量，最终做一个三目运算符的方式进行返回。\n\n  \n\n\n这样的优雅和可读性显而易见，当然这样的代码不是一蹴而就的，我优化了 3 遍产生的以上代码。读者可根据自己的代码和我写的代码进行对比。\n\n  \n\n\n#### | 提高方法 \n\n如果你做了 3 年+的程序员，我相信像如上这样的需求，你很轻松就能完成，但是如果你想做一个会写 Java 的程序员，就好好的思考和重构代码吧。\n\n  \n\n\n写代码就如同写字一样，同样的字，大家都会写，但是写出来是否好看就不一定了。如果想把程序写好，就要不断的思考和重构，敢于尝试，敢于创新，不要因循守旧，一定要做一个优秀的 Java 程序员。\n\n  \n\n\n提高代码水平最好的方法就是有条理的重构！（注意：是有条理的重构）\n\n  \n\n\n#### | 设计模式 \n\n设计模式就是工具，而不是提现你是否是高水平程序员的一个指标。\n\n  \n\n\n我经常会看到某一个程序员兴奋的大喊，哪个程序哪个点我用到了设计模式，写的多么多么优秀，多么多么好。我仔细去翻阅的时候，却发现有很多是过度设计的。\n\n  \n\n\n#### | 业务驱动技术 or 技术驱动业务 \n\n业务驱动技术 or 技术驱动业务 ？其实这是一个一直在争论的话题，但是很多人不这么认为，我觉得就是大家不愿意承认罢了。我来和大家大概分析一下作为一个 Java 程序员，我们应该如何判断自己所处于的位置。\n\n  \n\n\n业务驱动技术：如果你所在的项目是一个收益很小或者甚至没有收益的项目，请不要搞其他创新的东西，不要驱动业务要如何如何做，而是要熟知业务现在的痛点是什么？如何才能帮助业务盈利或者让项目更好，更顺利的进行。\n\n  \n\n\n技术驱动业务：如果你所在的项目是一个很牛的项目，比如淘宝这类的项目，我可以在满足业务需求的情况下，和业务沟通，使用什么样的技术能更好的帮助业务创造收益。\n\n  \n\n\n比如说下单的时候要进队列，可能几分钟之后订单状态才能处理完成，但是会让用户有更流畅的体验，赚取更多的访问流量，那么我相信业务愿意被技术驱动，会同意订单的延迟问题，这样便是技术驱动业务。\n\n  \n\n\n我相信大部分人还都处于业务驱动技术的方向吧。所以你既然不能驱动业务，那就请拥抱业务变化吧。\n\n  \n\n\n#### | 代码设计 \n\n一直在做 Java 后端的项目，经常会有一些变动，我相信大家也都遇到过。\n\n  \n\n\n比如当我们写一段代码的时候，我们考虑将需求映射成代码的状态模式，突然有一天，状态模式里边又添加了很多行为变化的东西，这时候你就挠头了，你硬生生的将状态模式中添加过多行为和变化。\n\n  \n\n\n慢慢的你会发现这些状态模式，其实更像是一簇算法，应该使用策略模式，这时你应该已经晕头转向了。\n\n  \n\n\n说了这么多，我的意思是，只要你觉得合理，就请将状态模式改为策略模式吧，所有的模式并不是凭空想象出来的，都是基于重构。\n\n  \n\n\nJava 编程中没有银弹，请拥抱业务变化，一直思考重构，你就有一个更好的代码设计！\n\n  \n\n\n#### | 你真的优秀吗？ \n\n真不好意思，我取了一个这么无聊的标题。\n\n  \n\n\n国外流行一种编程方式，叫做结对编程，我相信国内很多公司都没有这么做，我就不在讲述结对编程带来的好处了，其实就是一边 code review，一边互相提高的一个过程。既然做不到这个，那如何让自己活在自己的世界中不断提高呢？\n\n  \n\n\n“平时开发的时候，做出的代码总认为是正确的，而且写法是完美的。”，我相信这是大部分人的心声，还回到刚刚的问题，如何在自己的世界中不断提高呢？\n\n  \n\n\n### 答案就是： \n\n *  多看成熟框架的源码\n *  多回头看自己的代码\n *  勤于重构\n\n  \n\n\n你真的优秀吗？如果你每周都完成了学习源码，回头看自己代码，然后勤于重构，我认为你就真的很优秀了。\n\n  \n\n\n即使也许你只是刚刚入门，但是一直坚持，你就是一个真的会写 Java 代码的程序员了。\n\n  \n\n\n\n\n\n技能\n\n  \n\n\n\n\n\n#### | UML \n\n不想多讨论 UML 相关的知识，但是我觉得你如果真的会写 Java，请先学会表达自己，UML 就是你说话的语言。\n\n  \n\n\n做一名优秀的 Java 程序员，请至少学会这两种 UML 图：\n\n *  类图\n *  时序图\n\n  \n\n\n#### | clean code \n\n我认为保持代码的简洁和可读性是代码的最基本保证，如果有一天为了程序的效率而降低了这两点，我认为是可以谅解的，除此之外，没有任何理由可以让你任意挥霍你的代码。\n\n  \n\n\n无论如何，请保持你的代码的整洁。\n\n  \n\n\n#### | Linux 基础命令 \n\n这点其实和会写 Java 没有关系，但是 Linux 很多时候确实承载运行 Java 的容器，请学好 Linux 的基础命令。\n\n  \n\n\n\n\n\n总结\n\n  \n\n\n\n\n\nJava 是一个大体系，今天讨论并未涉及框架和架构相关知识，只是讨论如何写好代码。\n\n  \n\n\n本文从写 Java 程序的小方面一直写到大方面，来阐述了如何才能写好 Java 程序，并告诉读者们如何才能提高自身的编码水平。\n\n  \n\n\n我希望看到这篇文章的各位都能做一个优秀的 Java 程序员","slug":"目瞪口呆的Java代码技巧","published":1,"updated":"2022-11-09T04:13:12.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cla94lqxf00000old2q3s0yv5","content":"<p>开发工具</p>\n<p>不知道有多少“老”程序员还在使用 Eclipse，这些程序员们要不就是因循守旧，要不就是根本就不知道其他好的开发工具的存在，Eclipse 吃内存卡顿的现象以及各种偶然莫名异常的出现，都告知我们是时候寻找新的开发工具了。</p>\n<h4 id=\"更换-IDE\"><a href=\"#更换-IDE\" class=\"headerlink\" title=\"| 更换 IDE\"></a>| 更换 IDE</h4><p>根本就不想多解释要换什么样的 IDE，如果你想成为一个优秀的 Java 程序员，请更换 IntelliJ IDEA。使用 IDEA 的好处，请搜索谷歌。</p>\n<h4 id=\"别告诉我快捷键不好用\"><a href=\"#别告诉我快捷键不好用\" class=\"headerlink\" title=\"| 别告诉我快捷键不好用\"></a>| 别告诉我快捷键不好用</h4><p>更换 IDE 不在我本文的重点内容中，所以不想用太多的篇幅去写为什么更换IDE。在这里，我只能告诉你，更换 IDE 只为了更好、更快的写好 Java 代码。原因略。</p>\n<p>别告诉我快捷键不好用，请尝试新事物。</p>\n<h4 id=\"bean\"><a href=\"#bean\" class=\"headerlink\" title=\"| bean\"></a>| bean</h4><p>bean 使我们使用最多的模型之一，我将以大篇幅去讲解 bean，希望读者好好体会。</p>\n<h4 id=\"domain-包名\"><a href=\"#domain-包名\" class=\"headerlink\" title=\"| domain 包名\"></a>| domain 包名</h4><p>根据很多 Java 程序员的“经验”来看，一个数据库表则对应着一个 domain 对象，所以很多程序员在写代码时，包名则使用：com.xxx.domain ，这样写好像已经成为了行业的一种约束，数据库映射对象就应该是 domain。</p>\n<p>但是你错了，domain 是一个领域对象，往往我们再做传统 Java 软件 Web 开发中，这些 domain 都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的。</p>\n<p>所以，以这个理论来讲，这些 domain 都应该是一个普通的 entity 对象，并非领域对象，所以请把包名改为：com.xxx.entity。</p>\n<p>如果你还不理解我说的话，请看一下 Vaughn Vernon 出的一本叫做《IMPLEMENTING DOMAIN-DRIVEN DESIGN》（实现领域驱动设计）这本书，书中讲解了贫血模型与领域模型的区别，相信你会受益匪浅。</p>\n<h4 id=\"DTO\"><a href=\"#DTO\" class=\"headerlink\" title=\"| DTO\"></a>| DTO</h4><p>数据传输我们应该使用 DTO 对象作为传输对象，这是我们所约定的，因为很长时间我一直都在做移动端 API 设计的工作，有很多人告诉我，他们认为只有给手机端传输数据的时候（input or output），这些对象成为 DTO 对象。</p>\n<p>请注意！这种理解是错误的，只要是用于网络传输的对象，我们都认为他们可以当做是 DTO 对象，比如电商平台中，用户进行下单，下单后的数据，订单会发到 OMS 或者 ERP 系统，这些对接的返回值以及入参也叫 DTO 对象。</p>\n<p>我们约定某对象如果是 DTO 对象，就将名称改为 XXDTO，比如订单下发 OMS：OMSOrderInputDTO。</p>\n<h4 id=\"DTO-转化\"><a href=\"#DTO-转化\" class=\"headerlink\" title=\"| DTO 转化\"></a>| DTO 转化</h4><p>正如我们所知，DTO 为系统与外界交互的模型对象，那么肯定会有一个步骤是将 DTO 对象转化为 BO 对象或者是普通的 entity 对象，让 service 层去处理。</p>\n<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"| 场景\"></a>| 场景</h4><p>比如添加会员操作，由于用于演示，我只考虑用户的一些简单数据，当后台管理员点击添加用户时，只需要传过来用户的姓名和年龄就可以了，后端接受到数据后，将添加创建时间和更新时间和默认密码三个字段，然后保存数据库。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/v1/api/user\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@RestController</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserApi</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserService</span> userService<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@PostMapping</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        user<span class=\"token punctuation\">.</span><span class=\"token function\">setUsername</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">.</span><span class=\"token function\">getUsername</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        user<span class=\"token punctuation\">.</span><span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们只关注一下上述代码中的转化代码，其他内容请忽略：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nuser<span class=\"token punctuation\">.</span><span class=\"token function\">setUsername</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">.</span><span class=\"token function\">getUsername</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nuser<span class=\"token punctuation\">.</span><span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"请使用工具\"><a href=\"#请使用工具\" class=\"headerlink\" title=\"| 请使用工具\"></a>| 请使用工具</h4><p>上边的代码，从逻辑上讲，是没有问题的，只是这种写法让我很厌烦，例子中只有两个字段，如果有 20 个字段，我们要如何做呢？一个一个进行 set 数据吗？</p>\n<p>当然，如果你这么做了，肯定不会有什么问题，但是，这肯定不是一个最优的做法。网上有很多工具，支持浅拷贝或深拷贝的 Utils。</p>\n<p>举个例子，我们可以使用 org.springframework.beans.BeanUtils#copyProperties 对代码进行重构和优化：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>BeanUtils.copyProperties 是一个浅拷贝方法，复制属性时，我们只需要把 DTO 对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。</p>\n<p>如果你在做 DTO 转化的时候一直使用 set 进行属性赋值，那么请尝试这种方式简化代码，让代码更加清晰！</p>\n<h4 id=\"转化的语义\"><a href=\"#转化的语义\" class=\"headerlink\" title=\"| 转化的语义\"></a>| 转化的语义</h4><p>上边的转化过程，读者看后肯定觉得优雅很多，但是我们再写 Java 代码时，更多的需要考虑语义的操作，再看上边的代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好，所以代码改成如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span>\n <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n         <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n         <span class=\"token keyword\">return</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n\n <span class=\"token keyword\">private</span> <span class=\"token class-name\">User</span> <span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\n         <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中，比如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">return</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>这两段代码都没有暴露实现，都是在讲如何在同一个方法中，做一组相同层次的语义操作，而不是暴露具体的实现。</p>\n<p>如上所述，是一种重构方式，读者可以参考 Martin Fowler 的《Refactoring Imporving the Design of Existing Code》（重构改善既有代码的设计）这本书中的 Extract Method 重构方式。</p>\n<h4 id=\"抽象接口定义\"><a href=\"#抽象接口定义\" class=\"headerlink\" title=\"| 抽象接口定义\"></a>| 抽象接口定义</h4><p>当实际工作中，完成了几个 API 的 DTO 转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。</p>\n<p>如果接口被定义以后，那么 convertFor 这个方法的语义将产生变化，它将是一个实现类。</p>\n<p>看一下抽象后的接口：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">DTOConvert</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">S</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">T</span> <span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">S</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的 Java 程序员，请为你想做的抽象接口，做好泛型吧。</p>\n<p>我们再来看接口实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserInputDTOConvert</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">DTOConvert</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/v1/api/user\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@RestController</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserApi</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserService</span> userService<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@PostMapping</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserInputDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"review-code\"><a href=\"#review-code\" class=\"headerlink\" title=\"| review code\"></a>| review code</h4><p>如果你是一个优秀的 Java 程序员，我相信你应该和我一样，已经数次重复 review 过自己的代码很多次了。</p>\n<p>我们再看这个保存用户的例子，你将发现，API 中返回值是有些问题的，问题就在于不应该直接返回 User 实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的。</p>\n<p>所以我们更应该返回一个 DTO 对象，我们可称它为 UserOutputDTO：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">UserOutputDTO</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserInputDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">User</span> saveUserResult <span class=\"token operator\">=</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">UserOutputDTO</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserOutDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span>saveUserResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这样你的 API 才更健全。</p>\n<p>不知道在看完这段代码之后，读者有是否发现还有其他问题的存在，作为一个优秀的 Java 程序员，请看一下这段我们刚刚抽象完的代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserInputDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>你会发现，new 这样一个 DTO 转化对象是没有必要的，而且每一个转化对象都是由在遇到 DTO 转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和 DTO 进行聚合呢？</p>\n<p>看一下我的聚合结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserInputDTO</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getUsername</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> username<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUsername</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> username<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>username <span class=\"token operator\">=</span> username<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">UserInputDTOConvert</span> userInputDTOConvert <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserInputDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">User</span> convert <span class=\"token operator\">=</span> userInputDTOConvert<span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> convert<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserInputDTOConvert</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">DTOConvert</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserInputDTO</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后 API 中的转化则由：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserInputDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">User</span> saveUserResult <span class=\"token operator\">=</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>变成了：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> userInputDTO<span class=\"token punctuation\">.</span><span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">User</span> saveUserResult <span class=\"token operator\">=</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>我们再 DTO 对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。</p>\n<h4 id=\"再查工具类\"><a href=\"#再查工具类\" class=\"headerlink\" title=\"| 再查工具类\"></a>| 再查工具类</h4><p>再来看 DTO 内部转化的代码，它实现了我们自己定义的 DTOConvert 接口，但是这样真的就没有问题，不需要再思考了吗？</p>\n<p>我觉得并不是，对于 Convert 这种转化语义来讲，很多工具类中都有这样的定义，这中 Convert 并不是业务级别上的接口定义，它只是用于普通 bean 之间转化属性值的普通意义上的接口定义，所以我们应该更多的去读其他含有 Convert 转化语义的代码。</p>\n<p>我仔细阅读了一下 GUAVA 的源码，发现了 com.google.common.base.Convert 这样的定义：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Converter</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Function</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">abstract</span> <span class=\"token class-name\">B</span> <span class=\"token function\">doForward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">A</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">abstract</span> <span class=\"token class-name\">A</span> <span class=\"token function\">doBackward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">B</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//其他略</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>从源码可以了解到，GUAVA 中的 Convert 可以完成正向转化和逆向转化，继续修改我们 DTO 中转化的这段代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserInputDTOConvert</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">DTOConvert</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserInputDTO</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>修改后：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserInputDTOConvert</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Converter</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserInputDTO</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n         <span class=\"token annotation punctuation\">@Override</span>\n         <span class=\"token keyword\">protected</span> <span class=\"token class-name\">User</span> <span class=\"token function\">doForward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                 <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n\n         <span class=\"token annotation punctuation\">@Override</span>\n         <span class=\"token keyword\">protected</span> <span class=\"token class-name\">UserInputDTO</span> <span class=\"token function\">doBackward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span> user<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                 <span class=\"token class-name\">UserInputDTO</span> userInputDTO <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserInputDTO</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">,</span>userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token keyword\">return</span> userInputDTO<span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的 UserInputDTO 和 UserOutputDTO 都转成 UserDTO 展示给大家。</p>\n<p>DTO：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getUsername</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> username<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUsername</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> username<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>username <span class=\"token operator\">=</span> username<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">UserDTOConvert</span> userDTOConvert <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">User</span> convert <span class=\"token operator\">=</span> userDTOConvert<span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> convert<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span> user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">UserDTOConvert</span> userDTOConvert <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">UserDTO</span> convert <span class=\"token operator\">=</span> userDTOConvert<span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> convert<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserDTOConvert</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Converter</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserDTO</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">protected</span> <span class=\"token class-name\">User</span> <span class=\"token function\">doForward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDTO</span> userDTO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">protected</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">doBackward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span> user<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token class-name\">UserDTO</span> userDTO <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserDTO</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">,</span>userDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> userDTO<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>API：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span>\n <span class=\"token keyword\">public</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDTO</span> userDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n         <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span>  userDTO<span class=\"token punctuation\">.</span><span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token class-name\">User</span> saveResultUser <span class=\"token operator\">=</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token class-name\">UserDTO</span> result <span class=\"token operator\">=</span> userDTO<span class=\"token punctuation\">.</span><span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span>saveResultUser<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的 DTO 对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserDTOConvert</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Converter</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserDTO</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n         <span class=\"token annotation punctuation\">@Override</span>\n         <span class=\"token keyword\">protected</span> <span class=\"token class-name\">User</span> <span class=\"token function\">doForward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDTO</span> userDTO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                 <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n\n         <span class=\"token annotation punctuation\">@Override</span>\n         <span class=\"token keyword\">protected</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">doBackward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span> user<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                 <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AssertionError</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"不支持逆向转化方法!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看一下 doBackward 方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就“断言”你调用错误了。</p>\n<p>关于异常处理的更详细介绍，可以参考这篇文章：如何优雅的设计 Java 异常 ，应该可以帮你更好的理解异常。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>lrwinx<span class=\"token punctuation\">.</span>github<span class=\"token punctuation\">.</span>io<span class=\"token operator\">/</span><span class=\"token number\">2016</span><span class=\"token operator\">/</span><span class=\"token number\">04</span><span class=\"token operator\">/</span><span class=\"token number\">28</span><span class=\"token operator\">/</span><span class=\"token operator\">%</span>E5<span class=\"token operator\">%</span>A6<span class=\"token operator\">%</span><span class=\"token number\">82</span><span class=\"token operator\">%</span>E4<span class=\"token operator\">%</span>BD<span class=\"token operator\">%</span><span class=\"token number\">95</span><span class=\"token operator\">%</span>E4<span class=\"token operator\">%</span>BC<span class=\"token operator\">%</span><span class=\"token number\">98</span><span class=\"token operator\">%</span>E9<span class=\"token operator\">%</span><span class=\"token number\">9</span>B<span class=\"token operator\">%</span><span class=\"token number\">85</span><span class=\"token operator\">%</span>E7<span class=\"token operator\">%</span><span class=\"token number\">9</span>A<span class=\"token operator\">%</span><span class=\"token number\">84</span><span class=\"token operator\">%</span>E8<span class=\"token operator\">%</span>AE<span class=\"token operator\">%</span>BE<span class=\"token operator\">%</span>E8<span class=\"token operator\">%</span>AE<span class=\"token operator\">%</span><span class=\"token class-name\">A1java</span><span class=\"token operator\">%</span>E5<span class=\"token operator\">%</span>BC<span class=\"token operator\">%</span><span class=\"token number\">82</span><span class=\"token operator\">%</span>E5<span class=\"token operator\">%</span>B8<span class=\"token operator\">%</span>B8<span class=\"token operator\">/</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"bean-的验证\"><a href=\"#bean-的验证\" class=\"headerlink\" title=\"| bean 的验证\"></a>| bean 的验证</h4><p>如果你认为我上边写的那个添加用户 API 写的已经非常完美了，那只能说明你还不是一个优秀的程序员。我们应该保证任何数据的入参到方法体内都是合法的。</p>\n<h4 id=\"为什么要验证\"><a href=\"#为什么要验证\" class=\"headerlink\" title=\"| 为什么要验证\"></a>| 为什么要验证</h4><p>很多人会告诉我，如果这些 API 是提供给前端进行调用的，前端都会进行验证啊，你为什还要验证？</p>\n<p>其实答案是这样的，我从不相信任何调用我 API 或者方法的人，比如前端验证失败了，或者某些人通过一些特殊的渠道(比如 Charles 进行抓包)，直接将数据传入到我的 API，那我仍然进行正常的业务逻辑处理，那么就有可能产生脏数据！</p>\n<p>“对于脏数据的产生一定是致命”，这句话希望大家牢记在心，再小的脏数据也有可能让你找几个通宵！</p>\n<h4 id=\"jsr-303-验证\"><a href=\"#jsr-303-验证\" class=\"headerlink\" title=\"| jsr 303 验证\"></a>| jsr 303 验证</h4><p>hibernate 提供的 jsr 303 实现，我觉得目前仍然是很优秀的，具体如何使用，我不想讲，因为谷歌上你可以搜索出很多答案！</p>\n<p>再以上班的 API 实例进行说明，我们现在对 DTO 数据进行检查：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token annotation punctuation\">@NotNull</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@NotNull</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//其他代码略</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>API 验证：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Valid</span> <span class=\"token class-name\">UserDTO</span> userDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span>  userDTO<span class=\"token punctuation\">.</span><span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">User</span> saveResultUser <span class=\"token operator\">=</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">UserDTO</span> result <span class=\"token operator\">=</span> userDTO<span class=\"token punctuation\">.</span><span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span>saveResultUser<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们需要将验证结果传给前端，这种异常应该转化为一个 api 异常（带有错误码的异常）。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Valid</span> <span class=\"token class-name\">UserDTO</span> userDTO<span class=\"token punctuation\">,</span> <span class=\"token class-name\">BindingResult</span> bindingResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token function\">checkDTOParams</span><span class=\"token punctuation\">(</span>bindingResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n     <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span>  userDTO<span class=\"token punctuation\">.</span><span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token class-name\">User</span> saveResultUser <span class=\"token operator\">=</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token class-name\">UserDTO</span> result <span class=\"token operator\">=</span> userDTO<span class=\"token punctuation\">.</span><span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span>saveResultUser<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">checkDTOParams</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BindingResult</span> bindingResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>bindingResult<span class=\"token punctuation\">.</span><span class=\"token function\">hasErrors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n             <span class=\"token comment\">//throw new 带验证码的验证错误异常</span>\n     <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>BindingResult 是 Spring MVC 验证 DTO 后的一个结果集，可以参考 spring 官方文档：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">https<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>spring<span class=\"token punctuation\">.</span>io<span class=\"token operator\">/</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>检查参数后，可以抛出一个“带验证码的验证错误异常”。</p>\n<p>拥抱 lombok</p>\n<p>上边的 DTO 代码，已经让我看的很累了，我相信读者也是一样，看到那么多的 Getter 和 Setter 方法，太烦躁了，那时候有什么方法可以简化这些呢。</p>\n<p>请拥抱 lombok，它会帮助我们解决一些让我们很烦躁的问题。</p>\n<p>去掉 Setter 和 Getter</p>\n<p>其实这个标题，我不太想说，因为网上太多，但是因为很多人告诉我，他们根本就不知道 lombok 的存在，所以为了让读者更好的学习，我愿意写这样一个例子：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Setter</span>\n<span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token annotation punctuation\">@NotNull</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@NotNull</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">UserDTOConvert</span> userDTOConvert <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">User</span> convert <span class=\"token operator\">=</span> userDTOConvert<span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> convert<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span> user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">UserDTOConvert</span> userDTOConvert <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">UserDTO</span> convert <span class=\"token operator\">=</span> userDTOConvert<span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> convert<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserDTOConvert</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Converter</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserDTO</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">protected</span> <span class=\"token class-name\">User</span> <span class=\"token function\">doForward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDTO</span> userDTO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">protected</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">doBackward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span> user<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AssertionError</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"不支持逆向转化方法!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看到了吧，烦人的 Getter 和 Setter 方法已经去掉了。</p>\n<p>但是上边的例子根本不足以体现 lombok 的强大。我希望写一些网上很难查到，或者很少人进行说明的 lombok 的使用以及在使用时程序语义上的说明。</p>\n<p>比如：@Data，@AllArgsConstructor，@NoArgsConstructor..这些我就不进行一一说明了，请大家自行查询资料。</p>\n<p>bean 中的链式风格</p>\n<p>什么是链式风格？我来举个例子，看下面这个 Student 的 bean：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Student</span> <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Student</span> <span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>仔细看一下 set 方法，这样的设置便是 chain 的 style，调用的时候，可以这样使用：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token number\">24</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>相信合理使用这样的链式代码，会更多的程序带来很好的可读性，那看一下如果使用 lombok 进行改善呢，请使用 @Accessors(chain = true)，看如下代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Accessors</span><span class=\"token punctuation\">(</span>chain <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Setter</span>\n<span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这样就完成了一个对于 bean 来讲很友好的链式操作。</p>\n<h4 id=\"静态构造方法\"><a href=\"#静态构造方法\" class=\"headerlink\" title=\"| 静态构造方法\"></a>| 静态构造方法</h4><p>静态构造方法的语义和简化程度真的高于直接去 new 一个对象。比如 new 一个 List 对象，过去的使用是这样的：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>看一下 guava 中的创建方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>Lists 命名是一种约定（俗话说：约定优于配置），它是指 Lists 是 List 这个类的一个工具类，那么使用 List 的工具类去产生 List，这样的语义是不是要比直接 new 一个子类来的更直接一些呢，答案是肯定的。</p>\n<p>再比如如果有一个工具类叫做 Maps，那你是否想到了创建 Map 的方法呢：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> objectObjectHashMap <span class=\"token operator\">=</span> <span class=\"token class-name\">Maps</span><span class=\"token punctuation\">.</span><span class=\"token function\">newHashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>好了，如果你理解了我说的语义，那么，你已经向成为 Java 程序员更近了一步了。</p>\n<p>再回过头来看刚刚的 Student，很多时候，我们去写 Student 这个 bean 的时候，他会有一些必输字段。</p>\n<p>比如 Student 中的 name 字段，一般处理的方式是将 name 字段包装成一个构造方法，只有传入 name 这样的构造方法，才能创建一个 Student 对象。</p>\n<p>接上上边的静态构造方法和必传参数的构造方法，使用 lombok 将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Accessors</span><span class=\"token punctuation\">(</span>chain <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Setter</span>\n<span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token annotation punctuation\">@RequiredArgsConstructor</span><span class=\"token punctuation\">(</span>staticName <span class=\"token operator\">=</span> <span class=\"token string\">\"ofName\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token annotation punctuation\">@NonNull</span> <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>测试代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">.</span><span class=\"token function\">ofName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这样构建出的 bean 语义是否要比直接 new 一个含参的构造方法（包含 name 的构造方法）要好很多。</p>\n<p>当然，看过很多源码以后，我想相信将静态构造方法 ofName 换成 of 会先的更加简洁：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Accessors</span><span class=\"token punctuation\">(</span>chain <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Setter</span>\n<span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token annotation punctuation\">@RequiredArgsConstructor</span><span class=\"token punctuation\">(</span>staticName <span class=\"token operator\">=</span> <span class=\"token string\">\"of\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token annotation punctuation\">@NonNull</span> <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>测试代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>当然他仍然是支持链式调用的：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token number\">24</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这样来写代码，真的很简洁，并且可读性很强。</p>\n<h4 id=\"使用-builder\"><a href=\"#使用-builder\" class=\"headerlink\" title=\"| 使用 builder\"></a>| 使用 builder</h4><p>Builder 模式我不想再多解释了，读者可以看一下《Head First》(设计模式) 的建造者模式。</p>\n<p>今天其实要说的是一种变种的 builder 模式，那就是构建 bean 的 builder 模式，其实主要的思想是带着大家一起看一下 lombok 给我们带来了什么。</p>\n<p>看一下 Student 这个类的原始 builder 状态：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Builder</span> <span class=\"token function\">builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Builder</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">public</span> <span class=\"token class-name\">Builder</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n\n            <span class=\"token keyword\">public</span> <span class=\"token class-name\">Builder</span> <span class=\"token function\">age</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n\n            <span class=\"token keyword\">public</span> <span class=\"token class-name\">Student</span> <span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    student<span class=\"token punctuation\">.</span><span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    student<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> student<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>调用方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">.</span><span class=\"token function\">builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">age</span><span class=\"token punctuation\">(</span><span class=\"token number\">24</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这样的 builder 代码，让我是在恶心难受，于是我打算用 lombok 重构这段代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Builder</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>调用方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">.</span><span class=\"token function\">builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">age</span><span class=\"token punctuation\">(</span><span class=\"token number\">24</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>代理模式</p>\n<p>正如我们所知的，在程序中调用 rest 接口是一个常见的行为动作，如果你和我一样使用过 spring 的 RestTemplate，我相信你会我和一样，对他抛出的非 http 状态码异常深恶痛绝。</p>\n<p>所以我们考虑将 RestTemplate 最为底层包装器进行包装器模式的设计：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FilterRestTemplate</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">RestOperations</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">protected</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">RestTemplate</span> restTemplate<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">protected</span> <span class=\"token class-name\">FilterRestTemplate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RestTemplate</span> restTemplate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>restTemplate <span class=\"token operator\">=</span> restTemplate<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token comment\">//实现RestOperations所有的接口</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后再由扩展类对 FilterRestTemplate 进行包装扩展：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ExtractRestTemplate</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">FilterRestTemplate</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">RestTemplate</span> restTemplate<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ExtractRestTemplate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RestTemplate</span> restTemplate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>restTemplate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>restTemplate <span class=\"token operator\">=</span> restTemplate<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">RestResponseDTO</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">postForEntityWithNoException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> request<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> responseType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> uriVariables<span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">throws</span> <span class=\"token class-name\">RestClientException</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">RestResponseDTO</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> restResponseDTO <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RestResponseDTO</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">ResponseEntity</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> tResponseEntity<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n                    tResponseEntity <span class=\"token operator\">=</span> restTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">postForEntity</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">,</span> responseType<span class=\"token punctuation\">,</span> uriVariables<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    restResponseDTO<span class=\"token punctuation\">.</span><span class=\"token function\">setData</span><span class=\"token punctuation\">(</span>tResponseEntity<span class=\"token punctuation\">.</span><span class=\"token function\">getBody</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    restResponseDTO<span class=\"token punctuation\">.</span><span class=\"token function\">setMessage</span><span class=\"token punctuation\">(</span>tResponseEntity<span class=\"token punctuation\">.</span><span class=\"token function\">getStatusCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    restResponseDTO<span class=\"token punctuation\">.</span><span class=\"token function\">setStatusCode</span><span class=\"token punctuation\">(</span>tResponseEntity<span class=\"token punctuation\">.</span><span class=\"token function\">getStatusCodeValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                    restResponseDTO<span class=\"token punctuation\">.</span><span class=\"token function\">setStatusCode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RestResponseDTO</span><span class=\"token punctuation\">.</span>UNKNOWN_ERROR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    restResponseDTO<span class=\"token punctuation\">.</span><span class=\"token function\">setMessage</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    restResponseDTO<span class=\"token punctuation\">.</span><span class=\"token function\">setData</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token keyword\">return</span> restResponseDTO<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>包装器 ExtractRestTemplate 很完美的更改了异常抛出的行为，让程序更具有容错性。</p>\n<p>在这里我们不考虑 ExtractRestTemplate 完成的功能，让我们把焦点放在 FilterRestTemplate 上，“实现 RestOperations 所有的接口”。</p>\n<p>这个操作绝对不是一时半会可以写完的，当时在重构之前我几乎写了半个小时，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FilterRestTemplate</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">RestOperations</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">RestTemplate</span> restTemplate<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token class-name\">FilterRestTemplate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RestTemplate</span> restTemplate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>restTemplate <span class=\"token operator\">=</span> restTemplate<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">getForObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> responseType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> uriVariables<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">RestClientException</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> restTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">getForObject</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span>responseType<span class=\"token punctuation\">,</span>uriVariables<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">getForObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> responseType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> uriVariables<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">RestClientException</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> restTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">getForObject</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span>responseType<span class=\"token punctuation\">,</span>uriVariables<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">getForObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">URI</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> responseType<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">RestClientException</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> restTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">getForObject</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span>responseType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">ResponseEntity</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">getForEntity</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> responseType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> uriVariables<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">RestClientException</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> restTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">getForEntity</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span>responseType<span class=\"token punctuation\">,</span>uriVariables<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">//其他实现代码略。。。</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我相信你看了以上代码，你会和我一样觉得恶心反胃，后来我用 lombok 提供的代理注解优化了我的代码（@Delegate）：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@AllArgsConstructor</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FilterRestTemplate</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">RestOperations</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token annotation punctuation\">@Delegate</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">RestTemplate</span> restTemplate<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这几行代码完全替代上述那些冗长的代码。是不是很简洁，做一个拥抱 lombok 的程序员吧。</p>\n<p>重构</p>\n<p>需求案例</p>\n<h4 id=\"项目需求\"><a href=\"#项目需求\" class=\"headerlink\" title=\"| 项目需求\"></a>| 项目需求</h4><p>项目开发阶段，有一个关于下单发货的需求：如果今天下午 3 点前进行下单，那么发货时间是明天，如果今天下午 3 点后进行下单，那么发货时间是后天，如果被确定的时间是周日，那么在此时间上再加 1 天为发货时间。</p>\n<h4 id=\"思考与重构\"><a href=\"#思考与重构\" class=\"headerlink\" title=\"| 思考与重构\"></a>| 思考与重构</h4><p>我相信这个需求看似很简单，无论怎么写都可以完成。</p>\n<p>很多人可能看到这个需求，就动手开始写 Calendar 或 Date 进行计算，从而完成需求。</p>\n<p>而我给的建议是，仔细考虑如何写代码，然后再去写，不是说所有的时间操作都用 Calendar 或 Date 去解决，一定要看场景。</p>\n<p>对于时间的计算我们要考虑 joda-time 这种类似的成熟时间计算框架来写代码，它会让代码更加简洁和易读。</p>\n<p>请读者先考虑这个需求如何用 Java 代码完成，或先写一个你觉得完成这个代码的思路，再来看我下边的代码，这样，你的收获会更多一些：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> <span class=\"token class-name\">DateTime</span> DISTRIBUTION_TIME_SPLIT_TIME <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DateTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">withTime</span><span class=\"token punctuation\">(</span><span class=\"token number\">15</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> <span class=\"token function\">calculateDistributionTimeByOrderCreateTime</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Date</span> orderCreateTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">DateTime</span> orderCreateDateTime <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DateTime</span><span class=\"token punctuation\">(</span>orderCreateTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Date</span> tomorrow <span class=\"token operator\">=</span> orderCreateDateTime<span class=\"token punctuation\">.</span><span class=\"token function\">plusDays</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Date</span> theDayAfterTomorrow <span class=\"token operator\">=</span> orderCreateDateTime<span class=\"token punctuation\">.</span><span class=\"token function\">plusDays</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> orderCreateDateTime<span class=\"token punctuation\">.</span><span class=\"token function\">isAfter</span><span class=\"token punctuation\">(</span>DISTRIBUTION_TIME_SPLIT_TIME<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token function\">wrapDistributionTime</span><span class=\"token punctuation\">(</span>theDayAfterTomorrow<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">wrapDistributionTime</span><span class=\"token punctuation\">(</span>tomorrow<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> <span class=\"token function\">wrapDistributionTime</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Date</span> distributionTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">DateTime</span> currentDistributionDateTime <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DateTime</span><span class=\"token punctuation\">(</span>distributionTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">DateTime</span> plusOneDay <span class=\"token operator\">=</span> currentDistributionDateTime<span class=\"token punctuation\">.</span><span class=\"token function\">plusDays</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">boolean</span> isSunday <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">DateTimeConstants</span><span class=\"token punctuation\">.</span>SUNDAY <span class=\"token operator\">==</span> currentDistributionDateTime<span class=\"token punctuation\">.</span><span class=\"token function\">getDayOfWeek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> isSunday <span class=\"token operator\">?</span> plusOneDay<span class=\"token punctuation\">.</span><span class=\"token function\">toDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> currentDistributionDateTime<span class=\"token punctuation\">.</span><span class=\"token function\">toDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>读这段代码的时候，你会发现，我将判断和有可能出现的不同结果都当做一个变量，最终做一个三目运算符的方式进行返回。</p>\n<p>这样的优雅和可读性显而易见，当然这样的代码不是一蹴而就的，我优化了 3 遍产生的以上代码。读者可根据自己的代码和我写的代码进行对比。</p>\n<h4 id=\"提高方法\"><a href=\"#提高方法\" class=\"headerlink\" title=\"| 提高方法\"></a>| 提高方法</h4><p>如果你做了 3 年+的程序员，我相信像如上这样的需求，你很轻松就能完成，但是如果你想做一个会写 Java 的程序员，就好好的思考和重构代码吧。</p>\n<p>写代码就如同写字一样，同样的字，大家都会写，但是写出来是否好看就不一定了。如果想把程序写好，就要不断的思考和重构，敢于尝试，敢于创新，不要因循守旧，一定要做一个优秀的 Java 程序员。</p>\n<p>提高代码水平最好的方法就是有条理的重构！（注意：是有条理的重构）</p>\n<h4 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"| 设计模式\"></a>| 设计模式</h4><p>设计模式就是工具，而不是提现你是否是高水平程序员的一个指标。</p>\n<p>我经常会看到某一个程序员兴奋的大喊，哪个程序哪个点我用到了设计模式，写的多么多么优秀，多么多么好。我仔细去翻阅的时候，却发现有很多是过度设计的。</p>\n<h4 id=\"业务驱动技术-or-技术驱动业务\"><a href=\"#业务驱动技术-or-技术驱动业务\" class=\"headerlink\" title=\"| 业务驱动技术 or 技术驱动业务\"></a>| 业务驱动技术 or 技术驱动业务</h4><p>业务驱动技术 or 技术驱动业务 ？其实这是一个一直在争论的话题，但是很多人不这么认为，我觉得就是大家不愿意承认罢了。我来和大家大概分析一下作为一个 Java 程序员，我们应该如何判断自己所处于的位置。</p>\n<p>业务驱动技术：如果你所在的项目是一个收益很小或者甚至没有收益的项目，请不要搞其他创新的东西，不要驱动业务要如何如何做，而是要熟知业务现在的痛点是什么？如何才能帮助业务盈利或者让项目更好，更顺利的进行。</p>\n<p>技术驱动业务：如果你所在的项目是一个很牛的项目，比如淘宝这类的项目，我可以在满足业务需求的情况下，和业务沟通，使用什么样的技术能更好的帮助业务创造收益。</p>\n<p>比如说下单的时候要进队列，可能几分钟之后订单状态才能处理完成，但是会让用户有更流畅的体验，赚取更多的访问流量，那么我相信业务愿意被技术驱动，会同意订单的延迟问题，这样便是技术驱动业务。</p>\n<p>我相信大部分人还都处于业务驱动技术的方向吧。所以你既然不能驱动业务，那就请拥抱业务变化吧。</p>\n<h4 id=\"代码设计\"><a href=\"#代码设计\" class=\"headerlink\" title=\"| 代码设计\"></a>| 代码设计</h4><p>一直在做 Java 后端的项目，经常会有一些变动，我相信大家也都遇到过。</p>\n<p>比如当我们写一段代码的时候，我们考虑将需求映射成代码的状态模式，突然有一天，状态模式里边又添加了很多行为变化的东西，这时候你就挠头了，你硬生生的将状态模式中添加过多行为和变化。</p>\n<p>慢慢的你会发现这些状态模式，其实更像是一簇算法，应该使用策略模式，这时你应该已经晕头转向了。</p>\n<p>说了这么多，我的意思是，只要你觉得合理，就请将状态模式改为策略模式吧，所有的模式并不是凭空想象出来的，都是基于重构。</p>\n<p>Java 编程中没有银弹，请拥抱业务变化，一直思考重构，你就有一个更好的代码设计！</p>\n<h4 id=\"你真的优秀吗？\"><a href=\"#你真的优秀吗？\" class=\"headerlink\" title=\"| 你真的优秀吗？\"></a>| 你真的优秀吗？</h4><p>真不好意思，我取了一个这么无聊的标题。</p>\n<p>国外流行一种编程方式，叫做结对编程，我相信国内很多公司都没有这么做，我就不在讲述结对编程带来的好处了，其实就是一边 code review，一边互相提高的一个过程。既然做不到这个，那如何让自己活在自己的世界中不断提高呢？</p>\n<p>“平时开发的时候，做出的代码总认为是正确的，而且写法是完美的。”，我相信这是大部分人的心声，还回到刚刚的问题，如何在自己的世界中不断提高呢？</p>\n<h3 id=\"答案就是：\"><a href=\"#答案就是：\" class=\"headerlink\" title=\"答案就是：\"></a>答案就是：</h3><ul>\n<li> 多看成熟框架的源码</li>\n<li> 多回头看自己的代码</li>\n<li>勤于重构</li>\n</ul>\n<p>你真的优秀吗？如果你每周都完成了学习源码，回头看自己代码，然后勤于重构，我认为你就真的很优秀了。</p>\n<p>即使也许你只是刚刚入门，但是一直坚持，你就是一个真的会写 Java 代码的程序员了。</p>\n<p>技能</p>\n<h4 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"| UML\"></a>| UML</h4><p>不想多讨论 UML 相关的知识，但是我觉得你如果真的会写 Java，请先学会表达自己，UML 就是你说话的语言。</p>\n<p>做一名优秀的 Java 程序员，请至少学会这两种 UML 图：</p>\n<ul>\n<li> 类图</li>\n<li>时序图</li>\n</ul>\n<h4 id=\"clean-code\"><a href=\"#clean-code\" class=\"headerlink\" title=\"| clean code\"></a>| clean code</h4><p>我认为保持代码的简洁和可读性是代码的最基本保证，如果有一天为了程序的效率而降低了这两点，我认为是可以谅解的，除此之外，没有任何理由可以让你任意挥霍你的代码。</p>\n<p>无论如何，请保持你的代码的整洁。</p>\n<h4 id=\"Linux-基础命令\"><a href=\"#Linux-基础命令\" class=\"headerlink\" title=\"| Linux 基础命令\"></a>| Linux 基础命令</h4><p>这点其实和会写 Java 没有关系，但是 Linux 很多时候确实承载运行 Java 的容器，请学好 Linux 的基础命令。</p>\n<p>总结</p>\n<p>Java 是一个大体系，今天讨论并未涉及框架和架构相关知识，只是讨论如何写好代码。</p>\n<p>本文从写 Java 程序的小方面一直写到大方面，来阐述了如何才能写好 Java 程序，并告诉读者们如何才能提高自身的编码水平。</p>\n<p>我希望看到这篇文章的各位都能做一个优秀的 Java 程序员</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<p>开发工具</p>\n<p>不知道有多少“老”程序员还在使用 Eclipse，这些程序员们要不就是因循守旧，要不就是根本就不知道其他好的开发工具的存在，Eclipse 吃内存卡顿的现象以及各种偶然莫名异常的出现，都告知我们是时候寻找新的开发工具了。</p>\n<h4 id=\"更换-IDE\"><a href=\"#更换-IDE\" class=\"headerlink\" title=\"| 更换 IDE\"></a>| 更换 IDE</h4><p>根本就不想多解释要换什么样的 IDE，如果你想成为一个优秀的 Java 程序员，请更换 IntelliJ IDEA。使用 IDEA 的好处，请搜索谷歌。</p>\n<h4 id=\"别告诉我快捷键不好用\"><a href=\"#别告诉我快捷键不好用\" class=\"headerlink\" title=\"| 别告诉我快捷键不好用\"></a>| 别告诉我快捷键不好用</h4><p>更换 IDE 不在我本文的重点内容中，所以不想用太多的篇幅去写为什么更换IDE。在这里，我只能告诉你，更换 IDE 只为了更好、更快的写好 Java 代码。原因略。</p>\n<p>别告诉我快捷键不好用，请尝试新事物。</p>\n<h4 id=\"bean\"><a href=\"#bean\" class=\"headerlink\" title=\"| bean\"></a>| bean</h4><p>bean 使我们使用最多的模型之一，我将以大篇幅去讲解 bean，希望读者好好体会。</p>\n<h4 id=\"domain-包名\"><a href=\"#domain-包名\" class=\"headerlink\" title=\"| domain 包名\"></a>| domain 包名</h4><p>根据很多 Java 程序员的“经验”来看，一个数据库表则对应着一个 domain 对象，所以很多程序员在写代码时，包名则使用：com.xxx.domain ，这样写好像已经成为了行业的一种约束，数据库映射对象就应该是 domain。</p>\n<p>但是你错了，domain 是一个领域对象，往往我们再做传统 Java 软件 Web 开发中，这些 domain 都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的。</p>\n<p>所以，以这个理论来讲，这些 domain 都应该是一个普通的 entity 对象，并非领域对象，所以请把包名改为：com.xxx.entity。</p>\n<p>如果你还不理解我说的话，请看一下 Vaughn Vernon 出的一本叫做《IMPLEMENTING DOMAIN-DRIVEN DESIGN》（实现领域驱动设计）这本书，书中讲解了贫血模型与领域模型的区别，相信你会受益匪浅。</p>\n<h4 id=\"DTO\"><a href=\"#DTO\" class=\"headerlink\" title=\"| DTO\"></a>| DTO</h4><p>数据传输我们应该使用 DTO 对象作为传输对象，这是我们所约定的，因为很长时间我一直都在做移动端 API 设计的工作，有很多人告诉我，他们认为只有给手机端传输数据的时候（input or output），这些对象成为 DTO 对象。</p>\n<p>请注意！这种理解是错误的，只要是用于网络传输的对象，我们都认为他们可以当做是 DTO 对象，比如电商平台中，用户进行下单，下单后的数据，订单会发到 OMS 或者 ERP 系统，这些对接的返回值以及入参也叫 DTO 对象。</p>\n<p>我们约定某对象如果是 DTO 对象，就将名称改为 XXDTO，比如订单下发 OMS：OMSOrderInputDTO。</p>\n<h4 id=\"DTO-转化\"><a href=\"#DTO-转化\" class=\"headerlink\" title=\"| DTO 转化\"></a>| DTO 转化</h4><p>正如我们所知，DTO 为系统与外界交互的模型对象，那么肯定会有一个步骤是将 DTO 对象转化为 BO 对象或者是普通的 entity 对象，让 service 层去处理。</p>\n<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"| 场景\"></a>| 场景</h4><p>比如添加会员操作，由于用于演示，我只考虑用户的一些简单数据，当后台管理员点击添加用户时，只需要传过来用户的姓名和年龄就可以了，后端接受到数据后，将添加创建时间和更新时间和默认密码三个字段，然后保存数据库。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/v1/api/user\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@RestController</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserApi</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserService</span> userService<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@PostMapping</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        user<span class=\"token punctuation\">.</span><span class=\"token function\">setUsername</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">.</span><span class=\"token function\">getUsername</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        user<span class=\"token punctuation\">.</span><span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们只关注一下上述代码中的转化代码，其他内容请忽略：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nuser<span class=\"token punctuation\">.</span><span class=\"token function\">setUsername</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">.</span><span class=\"token function\">getUsername</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nuser<span class=\"token punctuation\">.</span><span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">.</span><span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"请使用工具\"><a href=\"#请使用工具\" class=\"headerlink\" title=\"| 请使用工具\"></a>| 请使用工具</h4><p>上边的代码，从逻辑上讲，是没有问题的，只是这种写法让我很厌烦，例子中只有两个字段，如果有 20 个字段，我们要如何做呢？一个一个进行 set 数据吗？</p>\n<p>当然，如果你这么做了，肯定不会有什么问题，但是，这肯定不是一个最优的做法。网上有很多工具，支持浅拷贝或深拷贝的 Utils。</p>\n<p>举个例子，我们可以使用 org.springframework.beans.BeanUtils#copyProperties 对代码进行重构和优化：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>BeanUtils.copyProperties 是一个浅拷贝方法，复制属性时，我们只需要把 DTO 对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。</p>\n<p>如果你在做 DTO 转化的时候一直使用 set 进行属性赋值，那么请尝试这种方式简化代码，让代码更加清晰！</p>\n<h4 id=\"转化的语义\"><a href=\"#转化的语义\" class=\"headerlink\" title=\"| 转化的语义\"></a>| 转化的语义</h4><p>上边的转化过程，读者看后肯定觉得优雅很多，但是我们再写 Java 代码时，更多的需要考虑语义的操作，再看上边的代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好，所以代码改成如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span>\n <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n         <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n         <span class=\"token keyword\">return</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n\n <span class=\"token keyword\">private</span> <span class=\"token class-name\">User</span> <span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\n         <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中，比如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">return</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>这两段代码都没有暴露实现，都是在讲如何在同一个方法中，做一组相同层次的语义操作，而不是暴露具体的实现。</p>\n<p>如上所述，是一种重构方式，读者可以参考 Martin Fowler 的《Refactoring Imporving the Design of Existing Code》（重构改善既有代码的设计）这本书中的 Extract Method 重构方式。</p>\n<h4 id=\"抽象接口定义\"><a href=\"#抽象接口定义\" class=\"headerlink\" title=\"| 抽象接口定义\"></a>| 抽象接口定义</h4><p>当实际工作中，完成了几个 API 的 DTO 转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。</p>\n<p>如果接口被定义以后，那么 convertFor 这个方法的语义将产生变化，它将是一个实现类。</p>\n<p>看一下抽象后的接口：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">DTOConvert</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">S</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">T</span> <span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">S</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的 Java 程序员，请为你想做的抽象接口，做好泛型吧。</p>\n<p>我们再来看接口实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserInputDTOConvert</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">DTOConvert</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/v1/api/user\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@RestController</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserApi</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserService</span> userService<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@PostMapping</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserInputDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"review-code\"><a href=\"#review-code\" class=\"headerlink\" title=\"| review code\"></a>| review code</h4><p>如果你是一个优秀的 Java 程序员，我相信你应该和我一样，已经数次重复 review 过自己的代码很多次了。</p>\n<p>我们再看这个保存用户的例子，你将发现，API 中返回值是有些问题的，问题就在于不应该直接返回 User 实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的。</p>\n<p>所以我们更应该返回一个 DTO 对象，我们可称它为 UserOutputDTO：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">UserOutputDTO</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserInputDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">User</span> saveUserResult <span class=\"token operator\">=</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">UserOutputDTO</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserOutDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span>saveUserResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这样你的 API 才更健全。</p>\n<p>不知道在看完这段代码之后，读者有是否发现还有其他问题的存在，作为一个优秀的 Java 程序员，请看一下这段我们刚刚抽象完的代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserInputDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>你会发现，new 这样一个 DTO 转化对象是没有必要的，而且每一个转化对象都是由在遇到 DTO 转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和 DTO 进行聚合呢？</p>\n<p>看一下我的聚合结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserInputDTO</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getUsername</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> username<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUsername</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> username<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>username <span class=\"token operator\">=</span> username<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">UserInputDTOConvert</span> userInputDTOConvert <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserInputDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">User</span> convert <span class=\"token operator\">=</span> userInputDTOConvert<span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> convert<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserInputDTOConvert</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">DTOConvert</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserInputDTO</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后 API 中的转化则由：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserInputDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">User</span> saveUserResult <span class=\"token operator\">=</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>变成了：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> userInputDTO<span class=\"token punctuation\">.</span><span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">User</span> saveUserResult <span class=\"token operator\">=</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>我们再 DTO 对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。</p>\n<h4 id=\"再查工具类\"><a href=\"#再查工具类\" class=\"headerlink\" title=\"| 再查工具类\"></a>| 再查工具类</h4><p>再来看 DTO 内部转化的代码，它实现了我们自己定义的 DTOConvert 接口，但是这样真的就没有问题，不需要再思考了吗？</p>\n<p>我觉得并不是，对于 Convert 这种转化语义来讲，很多工具类中都有这样的定义，这中 Convert 并不是业务级别上的接口定义，它只是用于普通 bean 之间转化属性值的普通意义上的接口定义，所以我们应该更多的去读其他含有 Convert 转化语义的代码。</p>\n<p>我仔细阅读了一下 GUAVA 的源码，发现了 com.google.common.base.Convert 这样的定义：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Converter</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Function</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">A</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">abstract</span> <span class=\"token class-name\">B</span> <span class=\"token function\">doForward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">A</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">abstract</span> <span class=\"token class-name\">A</span> <span class=\"token function\">doBackward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">B</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//其他略</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>从源码可以了解到，GUAVA 中的 Convert 可以完成正向转化和逆向转化，继续修改我们 DTO 中转化的这段代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserInputDTOConvert</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">DTOConvert</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserInputDTO</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">User</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>修改后：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserInputDTOConvert</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Converter</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserInputDTO</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n         <span class=\"token annotation punctuation\">@Override</span>\n         <span class=\"token keyword\">protected</span> <span class=\"token class-name\">User</span> <span class=\"token function\">doForward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserInputDTO</span> userInputDTO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                 <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userInputDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n\n         <span class=\"token annotation punctuation\">@Override</span>\n         <span class=\"token keyword\">protected</span> <span class=\"token class-name\">UserInputDTO</span> <span class=\"token function\">doBackward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span> user<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                 <span class=\"token class-name\">UserInputDTO</span> userInputDTO <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserInputDTO</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">,</span>userInputDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token keyword\">return</span> userInputDTO<span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的 UserInputDTO 和 UserOutputDTO 都转成 UserDTO 展示给大家。</p>\n<p>DTO：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getUsername</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> username<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUsername</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> username<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>username <span class=\"token operator\">=</span> username<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">UserDTOConvert</span> userDTOConvert <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">User</span> convert <span class=\"token operator\">=</span> userDTOConvert<span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> convert<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span> user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">UserDTOConvert</span> userDTOConvert <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">UserDTO</span> convert <span class=\"token operator\">=</span> userDTOConvert<span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> convert<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserDTOConvert</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Converter</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserDTO</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">protected</span> <span class=\"token class-name\">User</span> <span class=\"token function\">doForward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDTO</span> userDTO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">protected</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">doBackward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span> user<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token class-name\">UserDTO</span> userDTO <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserDTO</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">,</span>userDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> userDTO<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>API：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span>\n <span class=\"token keyword\">public</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDTO</span> userDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n         <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span>  userDTO<span class=\"token punctuation\">.</span><span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token class-name\">User</span> saveResultUser <span class=\"token operator\">=</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token class-name\">UserDTO</span> result <span class=\"token operator\">=</span> userDTO<span class=\"token punctuation\">.</span><span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span>saveResultUser<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的 DTO 对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserDTOConvert</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Converter</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserDTO</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n         <span class=\"token annotation punctuation\">@Override</span>\n         <span class=\"token keyword\">protected</span> <span class=\"token class-name\">User</span> <span class=\"token function\">doForward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDTO</span> userDTO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                 <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n\n         <span class=\"token annotation punctuation\">@Override</span>\n         <span class=\"token keyword\">protected</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">doBackward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span> user<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                 <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AssertionError</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"不支持逆向转化方法!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看一下 doBackward 方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就“断言”你调用错误了。</p>\n<p>关于异常处理的更详细介绍，可以参考这篇文章：如何优雅的设计 Java 异常 ，应该可以帮你更好的理解异常。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>lrwinx<span class=\"token punctuation\">.</span>github<span class=\"token punctuation\">.</span>io<span class=\"token operator\">/</span><span class=\"token number\">2016</span><span class=\"token operator\">/</span><span class=\"token number\">04</span><span class=\"token operator\">/</span><span class=\"token number\">28</span><span class=\"token operator\">/</span><span class=\"token operator\">%</span>E5<span class=\"token operator\">%</span>A6<span class=\"token operator\">%</span><span class=\"token number\">82</span><span class=\"token operator\">%</span>E4<span class=\"token operator\">%</span>BD<span class=\"token operator\">%</span><span class=\"token number\">95</span><span class=\"token operator\">%</span>E4<span class=\"token operator\">%</span>BC<span class=\"token operator\">%</span><span class=\"token number\">98</span><span class=\"token operator\">%</span>E9<span class=\"token operator\">%</span><span class=\"token number\">9</span>B<span class=\"token operator\">%</span><span class=\"token number\">85</span><span class=\"token operator\">%</span>E7<span class=\"token operator\">%</span><span class=\"token number\">9</span>A<span class=\"token operator\">%</span><span class=\"token number\">84</span><span class=\"token operator\">%</span>E8<span class=\"token operator\">%</span>AE<span class=\"token operator\">%</span>BE<span class=\"token operator\">%</span>E8<span class=\"token operator\">%</span>AE<span class=\"token operator\">%</span><span class=\"token class-name\">A1java</span><span class=\"token operator\">%</span>E5<span class=\"token operator\">%</span>BC<span class=\"token operator\">%</span><span class=\"token number\">82</span><span class=\"token operator\">%</span>E5<span class=\"token operator\">%</span>B8<span class=\"token operator\">%</span>B8<span class=\"token operator\">/</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"bean-的验证\"><a href=\"#bean-的验证\" class=\"headerlink\" title=\"| bean 的验证\"></a>| bean 的验证</h4><p>如果你认为我上边写的那个添加用户 API 写的已经非常完美了，那只能说明你还不是一个优秀的程序员。我们应该保证任何数据的入参到方法体内都是合法的。</p>\n<h4 id=\"为什么要验证\"><a href=\"#为什么要验证\" class=\"headerlink\" title=\"| 为什么要验证\"></a>| 为什么要验证</h4><p>很多人会告诉我，如果这些 API 是提供给前端进行调用的，前端都会进行验证啊，你为什还要验证？</p>\n<p>其实答案是这样的，我从不相信任何调用我 API 或者方法的人，比如前端验证失败了，或者某些人通过一些特殊的渠道(比如 Charles 进行抓包)，直接将数据传入到我的 API，那我仍然进行正常的业务逻辑处理，那么就有可能产生脏数据！</p>\n<p>“对于脏数据的产生一定是致命”，这句话希望大家牢记在心，再小的脏数据也有可能让你找几个通宵！</p>\n<h4 id=\"jsr-303-验证\"><a href=\"#jsr-303-验证\" class=\"headerlink\" title=\"| jsr 303 验证\"></a>| jsr 303 验证</h4><p>hibernate 提供的 jsr 303 实现，我觉得目前仍然是很优秀的，具体如何使用，我不想讲，因为谷歌上你可以搜索出很多答案！</p>\n<p>再以上班的 API 实例进行说明，我们现在对 DTO 数据进行检查：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token annotation punctuation\">@NotNull</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@NotNull</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//其他代码略</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>API 验证：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Valid</span> <span class=\"token class-name\">UserDTO</span> userDTO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span>  userDTO<span class=\"token punctuation\">.</span><span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">User</span> saveResultUser <span class=\"token operator\">=</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">UserDTO</span> result <span class=\"token operator\">=</span> userDTO<span class=\"token punctuation\">.</span><span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span>saveResultUser<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们需要将验证结果传给前端，这种异常应该转化为一个 api 异常（带有错误码的异常）。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Valid</span> <span class=\"token class-name\">UserDTO</span> userDTO<span class=\"token punctuation\">,</span> <span class=\"token class-name\">BindingResult</span> bindingResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token function\">checkDTOParams</span><span class=\"token punctuation\">(</span>bindingResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n     <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span>  userDTO<span class=\"token punctuation\">.</span><span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token class-name\">User</span> saveResultUser <span class=\"token operator\">=</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">addUser</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token class-name\">UserDTO</span> result <span class=\"token operator\">=</span> userDTO<span class=\"token punctuation\">.</span><span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span>saveResultUser<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">checkDTOParams</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BindingResult</span> bindingResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>bindingResult<span class=\"token punctuation\">.</span><span class=\"token function\">hasErrors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n             <span class=\"token comment\">//throw new 带验证码的验证错误异常</span>\n     <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>BindingResult 是 Spring MVC 验证 DTO 后的一个结果集，可以参考 spring 官方文档：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">https<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>spring<span class=\"token punctuation\">.</span>io<span class=\"token operator\">/</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>检查参数后，可以抛出一个“带验证码的验证错误异常”。</p>\n<p>拥抱 lombok</p>\n<p>上边的 DTO 代码，已经让我看的很累了，我相信读者也是一样，看到那么多的 Getter 和 Setter 方法，太烦躁了，那时候有什么方法可以简化这些呢。</p>\n<p>请拥抱 lombok，它会帮助我们解决一些让我们很烦躁的问题。</p>\n<p>去掉 Setter 和 Getter</p>\n<p>其实这个标题，我不太想说，因为网上太多，但是因为很多人告诉我，他们根本就不知道 lombok 的存在，所以为了让读者更好的学习，我愿意写这样一个例子：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Setter</span>\n<span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token annotation punctuation\">@NotNull</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@NotNull</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">User</span> <span class=\"token function\">convertToUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">UserDTOConvert</span> userDTOConvert <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">User</span> convert <span class=\"token operator\">=</span> userDTOConvert<span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> convert<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">convertFor</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span> user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">UserDTOConvert</span> userDTOConvert <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserDTOConvert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">UserDTO</span> convert <span class=\"token operator\">=</span> userDTOConvert<span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> convert<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserDTOConvert</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Converter</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">UserDTO</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">protected</span> <span class=\"token class-name\">User</span> <span class=\"token function\">doForward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">UserDTO</span> userDTO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">BeanUtils</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyProperties</span><span class=\"token punctuation\">(</span>userDTO<span class=\"token punctuation\">,</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> user<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">protected</span> <span class=\"token class-name\">UserDTO</span> <span class=\"token function\">doBackward</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">User</span> user<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AssertionError</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"不支持逆向转化方法!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>看到了吧，烦人的 Getter 和 Setter 方法已经去掉了。</p>\n<p>但是上边的例子根本不足以体现 lombok 的强大。我希望写一些网上很难查到，或者很少人进行说明的 lombok 的使用以及在使用时程序语义上的说明。</p>\n<p>比如：@Data，@AllArgsConstructor，@NoArgsConstructor..这些我就不进行一一说明了，请大家自行查询资料。</p>\n<p>bean 中的链式风格</p>\n<p>什么是链式风格？我来举个例子，看下面这个 Student 的 bean：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Student</span> <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Student</span> <span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>仔细看一下 set 方法，这样的设置便是 chain 的 style，调用的时候，可以这样使用：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token number\">24</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>相信合理使用这样的链式代码，会更多的程序带来很好的可读性，那看一下如果使用 lombok 进行改善呢，请使用 @Accessors(chain = true)，看如下代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Accessors</span><span class=\"token punctuation\">(</span>chain <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Setter</span>\n<span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这样就完成了一个对于 bean 来讲很友好的链式操作。</p>\n<h4 id=\"静态构造方法\"><a href=\"#静态构造方法\" class=\"headerlink\" title=\"| 静态构造方法\"></a>| 静态构造方法</h4><p>静态构造方法的语义和简化程度真的高于直接去 new 一个对象。比如 new 一个 List 对象，过去的使用是这样的：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>看一下 guava 中的创建方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">Lists</span><span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>Lists 命名是一种约定（俗话说：约定优于配置），它是指 Lists 是 List 这个类的一个工具类，那么使用 List 的工具类去产生 List，这样的语义是不是要比直接 new 一个子类来的更直接一些呢，答案是肯定的。</p>\n<p>再比如如果有一个工具类叫做 Maps，那你是否想到了创建 Map 的方法呢：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> objectObjectHashMap <span class=\"token operator\">=</span> <span class=\"token class-name\">Maps</span><span class=\"token punctuation\">.</span><span class=\"token function\">newHashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>好了，如果你理解了我说的语义，那么，你已经向成为 Java 程序员更近了一步了。</p>\n<p>再回过头来看刚刚的 Student，很多时候，我们去写 Student 这个 bean 的时候，他会有一些必输字段。</p>\n<p>比如 Student 中的 name 字段，一般处理的方式是将 name 字段包装成一个构造方法，只有传入 name 这样的构造方法，才能创建一个 Student 对象。</p>\n<p>接上上边的静态构造方法和必传参数的构造方法，使用 lombok 将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Accessors</span><span class=\"token punctuation\">(</span>chain <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Setter</span>\n<span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token annotation punctuation\">@RequiredArgsConstructor</span><span class=\"token punctuation\">(</span>staticName <span class=\"token operator\">=</span> <span class=\"token string\">\"ofName\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token annotation punctuation\">@NonNull</span> <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>测试代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">.</span><span class=\"token function\">ofName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这样构建出的 bean 语义是否要比直接 new 一个含参的构造方法（包含 name 的构造方法）要好很多。</p>\n<p>当然，看过很多源码以后，我想相信将静态构造方法 ofName 换成 of 会先的更加简洁：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Accessors</span><span class=\"token punctuation\">(</span>chain <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Setter</span>\n<span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token annotation punctuation\">@RequiredArgsConstructor</span><span class=\"token punctuation\">(</span>staticName <span class=\"token operator\">=</span> <span class=\"token string\">\"of\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token annotation punctuation\">@NonNull</span> <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>测试代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>当然他仍然是支持链式调用的：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token number\">24</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这样来写代码，真的很简洁，并且可读性很强。</p>\n<h4 id=\"使用-builder\"><a href=\"#使用-builder\" class=\"headerlink\" title=\"| 使用 builder\"></a>| 使用 builder</h4><p>Builder 模式我不想再多解释了，读者可以看一下《Head First》(设计模式) 的建造者模式。</p>\n<p>今天其实要说的是一种变种的 builder 模式，那就是构建 bean 的 builder 模式，其实主要的思想是带着大家一起看一下 lombok 给我们带来了什么。</p>\n<p>看一下 Student 这个类的原始 builder 状态：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Builder</span> <span class=\"token function\">builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Builder</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">public</span> <span class=\"token class-name\">Builder</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n\n            <span class=\"token keyword\">public</span> <span class=\"token class-name\">Builder</span> <span class=\"token function\">age</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n\n            <span class=\"token keyword\">public</span> <span class=\"token class-name\">Student</span> <span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    student<span class=\"token punctuation\">.</span><span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    student<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> student<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>调用方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">.</span><span class=\"token function\">builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">age</span><span class=\"token punctuation\">(</span><span class=\"token number\">24</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这样的 builder 代码，让我是在恶心难受，于是我打算用 lombok 重构这段代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Builder</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>调用方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Student</span> student <span class=\"token operator\">=</span> <span class=\"token class-name\">Student</span><span class=\"token punctuation\">.</span><span class=\"token function\">builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">age</span><span class=\"token punctuation\">(</span><span class=\"token number\">24</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>代理模式</p>\n<p>正如我们所知的，在程序中调用 rest 接口是一个常见的行为动作，如果你和我一样使用过 spring 的 RestTemplate，我相信你会我和一样，对他抛出的非 http 状态码异常深恶痛绝。</p>\n<p>所以我们考虑将 RestTemplate 最为底层包装器进行包装器模式的设计：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FilterRestTemplate</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">RestOperations</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">protected</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">RestTemplate</span> restTemplate<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">protected</span> <span class=\"token class-name\">FilterRestTemplate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RestTemplate</span> restTemplate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>restTemplate <span class=\"token operator\">=</span> restTemplate<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n\n        <span class=\"token comment\">//实现RestOperations所有的接口</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>然后再由扩展类对 FilterRestTemplate 进行包装扩展：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ExtractRestTemplate</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">FilterRestTemplate</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">RestTemplate</span> restTemplate<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">ExtractRestTemplate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RestTemplate</span> restTemplate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>restTemplate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>restTemplate <span class=\"token operator\">=</span> restTemplate<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">RestResponseDTO</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">postForEntityWithNoException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> request<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> responseType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> uriVariables<span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">throws</span> <span class=\"token class-name\">RestClientException</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">RestResponseDTO</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> restResponseDTO <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RestResponseDTO</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">ResponseEntity</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> tResponseEntity<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n                    tResponseEntity <span class=\"token operator\">=</span> restTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">postForEntity</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">,</span> responseType<span class=\"token punctuation\">,</span> uriVariables<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    restResponseDTO<span class=\"token punctuation\">.</span><span class=\"token function\">setData</span><span class=\"token punctuation\">(</span>tResponseEntity<span class=\"token punctuation\">.</span><span class=\"token function\">getBody</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    restResponseDTO<span class=\"token punctuation\">.</span><span class=\"token function\">setMessage</span><span class=\"token punctuation\">(</span>tResponseEntity<span class=\"token punctuation\">.</span><span class=\"token function\">getStatusCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    restResponseDTO<span class=\"token punctuation\">.</span><span class=\"token function\">setStatusCode</span><span class=\"token punctuation\">(</span>tResponseEntity<span class=\"token punctuation\">.</span><span class=\"token function\">getStatusCodeValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n                    restResponseDTO<span class=\"token punctuation\">.</span><span class=\"token function\">setStatusCode</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RestResponseDTO</span><span class=\"token punctuation\">.</span>UNKNOWN_ERROR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    restResponseDTO<span class=\"token punctuation\">.</span><span class=\"token function\">setMessage</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    restResponseDTO<span class=\"token punctuation\">.</span><span class=\"token function\">setData</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token keyword\">return</span> restResponseDTO<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>包装器 ExtractRestTemplate 很完美的更改了异常抛出的行为，让程序更具有容错性。</p>\n<p>在这里我们不考虑 ExtractRestTemplate 完成的功能，让我们把焦点放在 FilterRestTemplate 上，“实现 RestOperations 所有的接口”。</p>\n<p>这个操作绝对不是一时半会可以写完的，当时在重构之前我几乎写了半个小时，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FilterRestTemplate</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">RestOperations</span> <span class=\"token punctuation\">&#123;</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">RestTemplate</span> restTemplate<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token class-name\">FilterRestTemplate</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RestTemplate</span> restTemplate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>restTemplate <span class=\"token operator\">=</span> restTemplate<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">getForObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> responseType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> uriVariables<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">RestClientException</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> restTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">getForObject</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span>responseType<span class=\"token punctuation\">,</span>uriVariables<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">getForObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> responseType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> uriVariables<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">RestClientException</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> restTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">getForObject</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span>responseType<span class=\"token punctuation\">,</span>uriVariables<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">T</span> <span class=\"token function\">getForObject</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">URI</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> responseType<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">RestClientException</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> restTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">getForObject</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span>responseType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token class-name\">ResponseEntity</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">getForEntity</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> url<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">></span></span> responseType<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> uriVariables<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">RestClientException</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">return</span> restTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">getForEntity</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span>responseType<span class=\"token punctuation\">,</span>uriVariables<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">//其他实现代码略。。。</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我相信你看了以上代码，你会和我一样觉得恶心反胃，后来我用 lombok 提供的代理注解优化了我的代码（@Delegate）：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@AllArgsConstructor</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FilterRestTemplate</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">RestOperations</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token annotation punctuation\">@Delegate</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">volatile</span> <span class=\"token class-name\">RestTemplate</span> restTemplate<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这几行代码完全替代上述那些冗长的代码。是不是很简洁，做一个拥抱 lombok 的程序员吧。</p>\n<p>重构</p>\n<p>需求案例</p>\n<h4 id=\"项目需求\"><a href=\"#项目需求\" class=\"headerlink\" title=\"| 项目需求\"></a>| 项目需求</h4><p>项目开发阶段，有一个关于下单发货的需求：如果今天下午 3 点前进行下单，那么发货时间是明天，如果今天下午 3 点后进行下单，那么发货时间是后天，如果被确定的时间是周日，那么在此时间上再加 1 天为发货时间。</p>\n<h4 id=\"思考与重构\"><a href=\"#思考与重构\" class=\"headerlink\" title=\"| 思考与重构\"></a>| 思考与重构</h4><p>我相信这个需求看似很简单，无论怎么写都可以完成。</p>\n<p>很多人可能看到这个需求，就动手开始写 Calendar 或 Date 进行计算，从而完成需求。</p>\n<p>而我给的建议是，仔细考虑如何写代码，然后再去写，不是说所有的时间操作都用 Calendar 或 Date 去解决，一定要看场景。</p>\n<p>对于时间的计算我们要考虑 joda-time 这种类似的成熟时间计算框架来写代码，它会让代码更加简洁和易读。</p>\n<p>请读者先考虑这个需求如何用 Java 代码完成，或先写一个你觉得完成这个代码的思路，再来看我下边的代码，这样，你的收获会更多一些：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> <span class=\"token class-name\">DateTime</span> DISTRIBUTION_TIME_SPLIT_TIME <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DateTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">withTime</span><span class=\"token punctuation\">(</span><span class=\"token number\">15</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> <span class=\"token function\">calculateDistributionTimeByOrderCreateTime</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Date</span> orderCreateTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">DateTime</span> orderCreateDateTime <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DateTime</span><span class=\"token punctuation\">(</span>orderCreateTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Date</span> tomorrow <span class=\"token operator\">=</span> orderCreateDateTime<span class=\"token punctuation\">.</span><span class=\"token function\">plusDays</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Date</span> theDayAfterTomorrow <span class=\"token operator\">=</span> orderCreateDateTime<span class=\"token punctuation\">.</span><span class=\"token function\">plusDays</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> orderCreateDateTime<span class=\"token punctuation\">.</span><span class=\"token function\">isAfter</span><span class=\"token punctuation\">(</span>DISTRIBUTION_TIME_SPLIT_TIME<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token function\">wrapDistributionTime</span><span class=\"token punctuation\">(</span>theDayAfterTomorrow<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">wrapDistributionTime</span><span class=\"token punctuation\">(</span>tomorrow<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">Date</span> <span class=\"token function\">wrapDistributionTime</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Date</span> distributionTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">DateTime</span> currentDistributionDateTime <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DateTime</span><span class=\"token punctuation\">(</span>distributionTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">DateTime</span> plusOneDay <span class=\"token operator\">=</span> currentDistributionDateTime<span class=\"token punctuation\">.</span><span class=\"token function\">plusDays</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">boolean</span> isSunday <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">DateTimeConstants</span><span class=\"token punctuation\">.</span>SUNDAY <span class=\"token operator\">==</span> currentDistributionDateTime<span class=\"token punctuation\">.</span><span class=\"token function\">getDayOfWeek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> isSunday <span class=\"token operator\">?</span> plusOneDay<span class=\"token punctuation\">.</span><span class=\"token function\">toDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> currentDistributionDateTime<span class=\"token punctuation\">.</span><span class=\"token function\">toDate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>读这段代码的时候，你会发现，我将判断和有可能出现的不同结果都当做一个变量，最终做一个三目运算符的方式进行返回。</p>\n<p>这样的优雅和可读性显而易见，当然这样的代码不是一蹴而就的，我优化了 3 遍产生的以上代码。读者可根据自己的代码和我写的代码进行对比。</p>\n<h4 id=\"提高方法\"><a href=\"#提高方法\" class=\"headerlink\" title=\"| 提高方法\"></a>| 提高方法</h4><p>如果你做了 3 年+的程序员，我相信像如上这样的需求，你很轻松就能完成，但是如果你想做一个会写 Java 的程序员，就好好的思考和重构代码吧。</p>\n<p>写代码就如同写字一样，同样的字，大家都会写，但是写出来是否好看就不一定了。如果想把程序写好，就要不断的思考和重构，敢于尝试，敢于创新，不要因循守旧，一定要做一个优秀的 Java 程序员。</p>\n<p>提高代码水平最好的方法就是有条理的重构！（注意：是有条理的重构）</p>\n<h4 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"| 设计模式\"></a>| 设计模式</h4><p>设计模式就是工具，而不是提现你是否是高水平程序员的一个指标。</p>\n<p>我经常会看到某一个程序员兴奋的大喊，哪个程序哪个点我用到了设计模式，写的多么多么优秀，多么多么好。我仔细去翻阅的时候，却发现有很多是过度设计的。</p>\n<h4 id=\"业务驱动技术-or-技术驱动业务\"><a href=\"#业务驱动技术-or-技术驱动业务\" class=\"headerlink\" title=\"| 业务驱动技术 or 技术驱动业务\"></a>| 业务驱动技术 or 技术驱动业务</h4><p>业务驱动技术 or 技术驱动业务 ？其实这是一个一直在争论的话题，但是很多人不这么认为，我觉得就是大家不愿意承认罢了。我来和大家大概分析一下作为一个 Java 程序员，我们应该如何判断自己所处于的位置。</p>\n<p>业务驱动技术：如果你所在的项目是一个收益很小或者甚至没有收益的项目，请不要搞其他创新的东西，不要驱动业务要如何如何做，而是要熟知业务现在的痛点是什么？如何才能帮助业务盈利或者让项目更好，更顺利的进行。</p>\n<p>技术驱动业务：如果你所在的项目是一个很牛的项目，比如淘宝这类的项目，我可以在满足业务需求的情况下，和业务沟通，使用什么样的技术能更好的帮助业务创造收益。</p>\n<p>比如说下单的时候要进队列，可能几分钟之后订单状态才能处理完成，但是会让用户有更流畅的体验，赚取更多的访问流量，那么我相信业务愿意被技术驱动，会同意订单的延迟问题，这样便是技术驱动业务。</p>\n<p>我相信大部分人还都处于业务驱动技术的方向吧。所以你既然不能驱动业务，那就请拥抱业务变化吧。</p>\n<h4 id=\"代码设计\"><a href=\"#代码设计\" class=\"headerlink\" title=\"| 代码设计\"></a>| 代码设计</h4><p>一直在做 Java 后端的项目，经常会有一些变动，我相信大家也都遇到过。</p>\n<p>比如当我们写一段代码的时候，我们考虑将需求映射成代码的状态模式，突然有一天，状态模式里边又添加了很多行为变化的东西，这时候你就挠头了，你硬生生的将状态模式中添加过多行为和变化。</p>\n<p>慢慢的你会发现这些状态模式，其实更像是一簇算法，应该使用策略模式，这时你应该已经晕头转向了。</p>\n<p>说了这么多，我的意思是，只要你觉得合理，就请将状态模式改为策略模式吧，所有的模式并不是凭空想象出来的，都是基于重构。</p>\n<p>Java 编程中没有银弹，请拥抱业务变化，一直思考重构，你就有一个更好的代码设计！</p>\n<h4 id=\"你真的优秀吗？\"><a href=\"#你真的优秀吗？\" class=\"headerlink\" title=\"| 你真的优秀吗？\"></a>| 你真的优秀吗？</h4><p>真不好意思，我取了一个这么无聊的标题。</p>\n<p>国外流行一种编程方式，叫做结对编程，我相信国内很多公司都没有这么做，我就不在讲述结对编程带来的好处了，其实就是一边 code review，一边互相提高的一个过程。既然做不到这个，那如何让自己活在自己的世界中不断提高呢？</p>\n<p>“平时开发的时候，做出的代码总认为是正确的，而且写法是完美的。”，我相信这是大部分人的心声，还回到刚刚的问题，如何在自己的世界中不断提高呢？</p>\n<h3 id=\"答案就是：\"><a href=\"#答案就是：\" class=\"headerlink\" title=\"答案就是：\"></a>答案就是：</h3><ul>\n<li> 多看成熟框架的源码</li>\n<li> 多回头看自己的代码</li>\n<li>勤于重构</li>\n</ul>\n<p>你真的优秀吗？如果你每周都完成了学习源码，回头看自己代码，然后勤于重构，我认为你就真的很优秀了。</p>\n<p>即使也许你只是刚刚入门，但是一直坚持，你就是一个真的会写 Java 代码的程序员了。</p>\n<p>技能</p>\n<h4 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"| UML\"></a>| UML</h4><p>不想多讨论 UML 相关的知识，但是我觉得你如果真的会写 Java，请先学会表达自己，UML 就是你说话的语言。</p>\n<p>做一名优秀的 Java 程序员，请至少学会这两种 UML 图：</p>\n<ul>\n<li> 类图</li>\n<li>时序图</li>\n</ul>\n<h4 id=\"clean-code\"><a href=\"#clean-code\" class=\"headerlink\" title=\"| clean code\"></a>| clean code</h4><p>我认为保持代码的简洁和可读性是代码的最基本保证，如果有一天为了程序的效率而降低了这两点，我认为是可以谅解的，除此之外，没有任何理由可以让你任意挥霍你的代码。</p>\n<p>无论如何，请保持你的代码的整洁。</p>\n<h4 id=\"Linux-基础命令\"><a href=\"#Linux-基础命令\" class=\"headerlink\" title=\"| Linux 基础命令\"></a>| Linux 基础命令</h4><p>这点其实和会写 Java 没有关系，但是 Linux 很多时候确实承载运行 Java 的容器，请学好 Linux 的基础命令。</p>\n<p>总结</p>\n<p>Java 是一个大体系，今天讨论并未涉及框架和架构相关知识，只是讨论如何写好代码。</p>\n<p>本文从写 Java 程序的小方面一直写到大方面，来阐述了如何才能写好 Java 程序，并告诉读者们如何才能提高自身的编码水平。</p>\n<p>我希望看到这篇文章的各位都能做一个优秀的 Java 程序员</p>\n"},{"title":"Mysql中join的那些事","top":false,"cover":false,"toc":true,"mathjax":true,"summary":"Mysql中的join原理","date":"2022-11-14T08:36:02.000Z","password":null,"_content":"Mysql中的join原理。\n\njoin用法基本工作过的都会用，不管是left join、right join、inner join语法都是比较简单的。\n\n但是，join的原理确实博大精深，对于一些传统it企业，几乎是一句sql走天下，join了五六个表，当数据量上来的时候，就会变得非常慢，索引对于掌握join的优化还是非常有必要的。\n\n阿里的开发手册中规定join不能查过三个，有些互联网是明确规定不能使用join的的明文规定，那么在实际的场景中，我们真的不能使用join吗？我们就来详细的聊一聊。\n\nMysql的join主要涉及到三种算法，分别是Simple Nested-Loop Join、Block Nested-Loop Join、Index Nested-Loop Join，下面我们就来深入的了解这三种算法的原理、区别、效率。\n\n首先，为了测试先准备两个表作为测试表，并且使用存储过程初始化一些测试数据，初始化的表结构sql如下所示：\n\n```java\nCREATE TABLE `testa` (\n  `id` int(20) NOT NULL AUTO_INCREMENT COMMENT '活动主键',\n  `col1` int(20) NOT NULL DEFAULT '0' COMMENT '测试字段1',\n  `col2` int(20) NOT NULL DEFAULT '0' COMMENT '测试字段2',\n  PRIMARY KEY (`id`),\n  KEY `col1` (`idx_col1`)\n)ENGINE=InnoDB AUTO_INCREMENT=782 DEFAULT CHARSET=utf8mb4 COMMENT='测试表1';\n\n\nCREATE TABLE `testb` (\n  `id` int(20) NOT NULL AUTO_INCREMENT COMMENT '活动主键',\n  `col1` int(20) NOT NULL DEFAULT '0' COMMENT '测试字段1',\n  `col2` int(20) NOT NULL DEFAULT '0' COMMENT '测试字段2',\n  PRIMARY KEY (`id`),\n  KEY `col1` (`idx_col1`)\n) ENGINE=InnoDB AUTO_INCREMENT=782 DEFAULT CHARSET=utf8mb4 COMMENT='测试表2';\n```\n\n初始化数据：\n\n```java\nCREATE DEFINER = `root` @`localhost` PROCEDURE `init_data` () \n\nBEGIN\n DECLARE i INT;\n \n SET i = 1;\n WHILE ( i <= 100 ) DO\n   INSERT INTO testa VALUES ( i, i, i );\n  SET i = i + 1;\n END WHILE;\n \n SET i = 1;\n WHILE ( i <= 2000) DO\n   INSERT INTO test2 VALUES ( i, i, i );\n  SET i = i + 1;\n END WHILE;\n\nEND\n```\n\n分别初始化testa表为100条数据，testb为2000条数据\n\n## Simple Nested-Loop Join \n\n首先，我们执行如下sql：\n\n```java\nselect * from testa ta left join testb tb on (ta.col1=tb.col2);\n```\n\nSimple Nested-Loop Join是最简单也是最粗暴的join方法，上面的sql在testb 的col2字段是没有加索引的，所以当testa为驱动表，testb为被驱动表时，就会拿着testa的每一行，然后去testb的全表扫描，执行流程如下：\n\n1.  从表testa中取出一行数据，记为ta。\n2.  从ta中取出col1字段去testb中全表扫描查询。\n3.  找到testb中满足情况的数据与ta组成结果集返回。\n4.  重复执行1-3步骤，直到把testa表的所有数据都取完。\n\n因此扫描的时间复杂度就是100\\*2000=20W的行数，所以在被驱动表关联字段没有添加索引的时候效率就非常的低下。\n\n假如testb是百万数据以上，那么扫描的时间复杂度就更恐怖了，但是在Mysql中没有使用这个算法，而是使用了另一种算法Block Nested-Loop Join，目的就是为了优化驱动表没有索引时的查询。\n\n## Block Nested-Loop Join \n\n还是上面的sql，不过通过加explain关键字来查看这条sql的执行计划：\n\n```java\nexplain select * from testa ta left join testb tb on (ta.col1=tb.col2);\n```\n\n![image_58fd8737.png](Mysql中join的那些事/image_58fd8737.png)\n\n可以看到testb依旧是全表扫描，并且在Extra字段中可以看到testb的Using join buffer（hash join）的字样，在rows中可以看到总扫描的行数是驱动表行数+被驱动表行数，那么这个算法与Simple Nested-Loop Join有什么区别呢？\n\nBlock Nested-Loop Join算法中引入了join buffer区域，而join buffer是一块内存区域，它的大小由join\\_buffer\\_size参数大小控制，默认大小是256k：\n\n![image_9f6ce7ed.png](Mysql中join的那些事/image_9f6ce7ed.png)\n\n在执行上面的sql的时候，它会把testa表的数据全部加载到join buffer区域，因为join buffer是内存操作，因此相对于比上面的simple算法要高效，具体的执行流程如下：\n\n1.  首先把testa表的所有数据都加在到join buffer里面，这里的所有数据是select后面的testa的字段，因为这里是select \\*，所以就是加载所有的testa字段。\n2.  然后遍历的取testb表中的每一行数据，并且与join buffer里面的数据济宁对比，符合条件的，就作为结果集返回。\n\n具体的流程图如下所示：\n\n![image_65df1467.png](Mysql中join的那些事/image_65df1467.png)\n\n所以，从上面的执行的步骤来看（假设驱动表的行数为N，被驱动表的行数据为M），Block Nested-Loop Join的扫描的行数还是驱动表+被驱动表行数（N+M），在内存中总的比较次数还是驱动表\\*被驱动表行数（N\\*M）\n\n上面我们提到join buffer是一块内存区域，并且有自己的大小，要是join buffer的大小不足够容纳驱动表的数量级怎么办呢？\n\n答案就是分段，你要是join buffer没办法容纳驱动表的所有数据，那么就不把所有的数据加载到join buffer里面，先加载一部分，后面再加载另一部分，比如：先加载testa中的80条数据，与testb比较完数据后，清空再加载testa后20条数据，再与testb进行比较。具体执行流程如下：\n\n1.  先加载testa中的80条数据到join buffer\n2.  然后一次遍历testb的所有数据，与join buffer里面的数据进行比较，符合条件的组成结果集。\n3.  清空join buffer，再加载testa后面的20条数据。\n4.  然后一次遍历testb的所有数据，与join buffer里面的数据进行比较，符合条件的组成结果集并返回。\n\n执行流程图如下所示：\n\n![image_ec6b3fe7.png](Mysql中join的那些事/image_ec6b3fe7.png)\n\n从上面的结果来看相对于比内存足够的join buffer来说，分段的join buffer多了一遍全表全表遍历testb，并且分的段数越多，多扫描驱动表的次数就越多。，性能就越差，所以在某一些场景下，适当的增大join buffer的值，是能够提高join的效率。\n\n假如驱动表的行数是N，分段参数为K，被驱动表的行数是M，那么总的扫描行数还是N+K\\*M，而内存比较的次数还是N\\*M，没有变。\n\n其中K段数与N的数据量有关，若是N的数据量越大，那么可能K被分成段数就越多，这样多次重复扫描的被驱动表的次数就越多。\n\n所以在join buffer不够的情况小，驱动表是越小越好，能够减少K值，减少重复扫描被驱动表的次数。这也就是为什么提倡小表要作为驱动表的原因。\n\n那么这里提到小表的概念，是不是就是数据量少的就是认为是小表呢？其实不然，小表的真正的还是是实际参与join的数据量，比如以下的两条sql：\n\n```java\nselect * from testa ta left join testb tb on (ta.col1=tb.col2) where tb.id<=20;\nselect * from testb tb left join testa ta on (ta.col1=tb.col2) where tb.id<=20;\n```\n\n在第二条sql中，虽然testb驱动表数据量比较大，但是在where条件中实际参与join的行数也就是id小于等于20的数据，完全小于testa的数据量，所以这里选择以testb作为驱动表是更加的合适。\n\n在实际的开发中Block Nested-Loop Join也是严禁被禁止出现的，严格要求关联条件建索引，所以性能最好的就是Index Nested-Loop Join算法。\n\n## Index Nested-Loop Join \n\n当我们执行如下sql时：\n\n```java\nselect * from testa ta left join testb tb on (ta.col1=tb.col1);\n```\n\n![image_942c82dc.png](Mysql中join的那些事/image_942c82dc.png)\n\n它的执行流程如下：\n\n1.  首先取testa表的一行数据。\n2.  使用上面的行数据的col1字段去testb表进行查询。\n3.  在testb找到符合条件的数据行，并与testa的数据行组合作为结果集。\n4.  重复执行1-3步骤，直到取完testa表的所有数据。\n\n因为testb的col1字段是建立了索引，所以，当使用testa表的字段col1去testb查找的时候，testb走的是col1索引的b+树的搜索，时间复杂度近似log2M，并且因为是select\\*，也就是要查找testb的所有字段，所以这里也涉及到回表查询，因此就变成了2\\*log2M.\n\n在这个过程中，testa表的扫描行数是全部，所以需要扫描100行，然后testa的每一行都与testb也是一一对应的，所以col1索引查询扫描的行数也是100行，所以总的扫描行数就是200行。\n\n我们假设驱动表的数据行位N，被驱动表的数据行为M，那么近似的复杂度为：N+N\\*2\\*log M，因为驱动表的扫描行数就是N，然后被驱动表因为每一次都对应驱动表的一次，并且一次的时间复杂度就是近似2\\*log M，所以被驱动表就是N\\*2\\*log M。\n\n明显N的值对于N+N\\*2\\*log M的结果值影响更大，所以N越小越好，所以选择小表作为驱动表是最优选择。\n\n在一些情况下的优化，假如join的驱动表所需要的字段很少（两个），可以建立联合索引来优化join查询，并且如果业务允许的话，可以通过冗余字段，减少join的个数提高查询的效率。 ","source":"_posts/Mysql中join的那些事.md","raw":"---\ntitle: Mysql中join的那些事\ntop: false\ncover: false\ntoc: true\nmathjax: true\nsummary: Mysql中的join原理\ndate: 2022-11-14 16:36:02\npassword:\ntags:\n    - join\n    - sql\ncategories:\n    - mysql\n---\nMysql中的join原理。\n\njoin用法基本工作过的都会用，不管是left join、right join、inner join语法都是比较简单的。\n\n但是，join的原理确实博大精深，对于一些传统it企业，几乎是一句sql走天下，join了五六个表，当数据量上来的时候，就会变得非常慢，索引对于掌握join的优化还是非常有必要的。\n\n阿里的开发手册中规定join不能查过三个，有些互联网是明确规定不能使用join的的明文规定，那么在实际的场景中，我们真的不能使用join吗？我们就来详细的聊一聊。\n\nMysql的join主要涉及到三种算法，分别是Simple Nested-Loop Join、Block Nested-Loop Join、Index Nested-Loop Join，下面我们就来深入的了解这三种算法的原理、区别、效率。\n\n首先，为了测试先准备两个表作为测试表，并且使用存储过程初始化一些测试数据，初始化的表结构sql如下所示：\n\n```java\nCREATE TABLE `testa` (\n  `id` int(20) NOT NULL AUTO_INCREMENT COMMENT '活动主键',\n  `col1` int(20) NOT NULL DEFAULT '0' COMMENT '测试字段1',\n  `col2` int(20) NOT NULL DEFAULT '0' COMMENT '测试字段2',\n  PRIMARY KEY (`id`),\n  KEY `col1` (`idx_col1`)\n)ENGINE=InnoDB AUTO_INCREMENT=782 DEFAULT CHARSET=utf8mb4 COMMENT='测试表1';\n\n\nCREATE TABLE `testb` (\n  `id` int(20) NOT NULL AUTO_INCREMENT COMMENT '活动主键',\n  `col1` int(20) NOT NULL DEFAULT '0' COMMENT '测试字段1',\n  `col2` int(20) NOT NULL DEFAULT '0' COMMENT '测试字段2',\n  PRIMARY KEY (`id`),\n  KEY `col1` (`idx_col1`)\n) ENGINE=InnoDB AUTO_INCREMENT=782 DEFAULT CHARSET=utf8mb4 COMMENT='测试表2';\n```\n\n初始化数据：\n\n```java\nCREATE DEFINER = `root` @`localhost` PROCEDURE `init_data` () \n\nBEGIN\n DECLARE i INT;\n \n SET i = 1;\n WHILE ( i <= 100 ) DO\n   INSERT INTO testa VALUES ( i, i, i );\n  SET i = i + 1;\n END WHILE;\n \n SET i = 1;\n WHILE ( i <= 2000) DO\n   INSERT INTO test2 VALUES ( i, i, i );\n  SET i = i + 1;\n END WHILE;\n\nEND\n```\n\n分别初始化testa表为100条数据，testb为2000条数据\n\n## Simple Nested-Loop Join \n\n首先，我们执行如下sql：\n\n```java\nselect * from testa ta left join testb tb on (ta.col1=tb.col2);\n```\n\nSimple Nested-Loop Join是最简单也是最粗暴的join方法，上面的sql在testb 的col2字段是没有加索引的，所以当testa为驱动表，testb为被驱动表时，就会拿着testa的每一行，然后去testb的全表扫描，执行流程如下：\n\n1.  从表testa中取出一行数据，记为ta。\n2.  从ta中取出col1字段去testb中全表扫描查询。\n3.  找到testb中满足情况的数据与ta组成结果集返回。\n4.  重复执行1-3步骤，直到把testa表的所有数据都取完。\n\n因此扫描的时间复杂度就是100\\*2000=20W的行数，所以在被驱动表关联字段没有添加索引的时候效率就非常的低下。\n\n假如testb是百万数据以上，那么扫描的时间复杂度就更恐怖了，但是在Mysql中没有使用这个算法，而是使用了另一种算法Block Nested-Loop Join，目的就是为了优化驱动表没有索引时的查询。\n\n## Block Nested-Loop Join \n\n还是上面的sql，不过通过加explain关键字来查看这条sql的执行计划：\n\n```java\nexplain select * from testa ta left join testb tb on (ta.col1=tb.col2);\n```\n\n![image_58fd8737.png](Mysql中join的那些事/image_58fd8737.png)\n\n可以看到testb依旧是全表扫描，并且在Extra字段中可以看到testb的Using join buffer（hash join）的字样，在rows中可以看到总扫描的行数是驱动表行数+被驱动表行数，那么这个算法与Simple Nested-Loop Join有什么区别呢？\n\nBlock Nested-Loop Join算法中引入了join buffer区域，而join buffer是一块内存区域，它的大小由join\\_buffer\\_size参数大小控制，默认大小是256k：\n\n![image_9f6ce7ed.png](Mysql中join的那些事/image_9f6ce7ed.png)\n\n在执行上面的sql的时候，它会把testa表的数据全部加载到join buffer区域，因为join buffer是内存操作，因此相对于比上面的simple算法要高效，具体的执行流程如下：\n\n1.  首先把testa表的所有数据都加在到join buffer里面，这里的所有数据是select后面的testa的字段，因为这里是select \\*，所以就是加载所有的testa字段。\n2.  然后遍历的取testb表中的每一行数据，并且与join buffer里面的数据济宁对比，符合条件的，就作为结果集返回。\n\n具体的流程图如下所示：\n\n![image_65df1467.png](Mysql中join的那些事/image_65df1467.png)\n\n所以，从上面的执行的步骤来看（假设驱动表的行数为N，被驱动表的行数据为M），Block Nested-Loop Join的扫描的行数还是驱动表+被驱动表行数（N+M），在内存中总的比较次数还是驱动表\\*被驱动表行数（N\\*M）\n\n上面我们提到join buffer是一块内存区域，并且有自己的大小，要是join buffer的大小不足够容纳驱动表的数量级怎么办呢？\n\n答案就是分段，你要是join buffer没办法容纳驱动表的所有数据，那么就不把所有的数据加载到join buffer里面，先加载一部分，后面再加载另一部分，比如：先加载testa中的80条数据，与testb比较完数据后，清空再加载testa后20条数据，再与testb进行比较。具体执行流程如下：\n\n1.  先加载testa中的80条数据到join buffer\n2.  然后一次遍历testb的所有数据，与join buffer里面的数据进行比较，符合条件的组成结果集。\n3.  清空join buffer，再加载testa后面的20条数据。\n4.  然后一次遍历testb的所有数据，与join buffer里面的数据进行比较，符合条件的组成结果集并返回。\n\n执行流程图如下所示：\n\n![image_ec6b3fe7.png](Mysql中join的那些事/image_ec6b3fe7.png)\n\n从上面的结果来看相对于比内存足够的join buffer来说，分段的join buffer多了一遍全表全表遍历testb，并且分的段数越多，多扫描驱动表的次数就越多。，性能就越差，所以在某一些场景下，适当的增大join buffer的值，是能够提高join的效率。\n\n假如驱动表的行数是N，分段参数为K，被驱动表的行数是M，那么总的扫描行数还是N+K\\*M，而内存比较的次数还是N\\*M，没有变。\n\n其中K段数与N的数据量有关，若是N的数据量越大，那么可能K被分成段数就越多，这样多次重复扫描的被驱动表的次数就越多。\n\n所以在join buffer不够的情况小，驱动表是越小越好，能够减少K值，减少重复扫描被驱动表的次数。这也就是为什么提倡小表要作为驱动表的原因。\n\n那么这里提到小表的概念，是不是就是数据量少的就是认为是小表呢？其实不然，小表的真正的还是是实际参与join的数据量，比如以下的两条sql：\n\n```java\nselect * from testa ta left join testb tb on (ta.col1=tb.col2) where tb.id<=20;\nselect * from testb tb left join testa ta on (ta.col1=tb.col2) where tb.id<=20;\n```\n\n在第二条sql中，虽然testb驱动表数据量比较大，但是在where条件中实际参与join的行数也就是id小于等于20的数据，完全小于testa的数据量，所以这里选择以testb作为驱动表是更加的合适。\n\n在实际的开发中Block Nested-Loop Join也是严禁被禁止出现的，严格要求关联条件建索引，所以性能最好的就是Index Nested-Loop Join算法。\n\n## Index Nested-Loop Join \n\n当我们执行如下sql时：\n\n```java\nselect * from testa ta left join testb tb on (ta.col1=tb.col1);\n```\n\n![image_942c82dc.png](Mysql中join的那些事/image_942c82dc.png)\n\n它的执行流程如下：\n\n1.  首先取testa表的一行数据。\n2.  使用上面的行数据的col1字段去testb表进行查询。\n3.  在testb找到符合条件的数据行，并与testa的数据行组合作为结果集。\n4.  重复执行1-3步骤，直到取完testa表的所有数据。\n\n因为testb的col1字段是建立了索引，所以，当使用testa表的字段col1去testb查找的时候，testb走的是col1索引的b+树的搜索，时间复杂度近似log2M，并且因为是select\\*，也就是要查找testb的所有字段，所以这里也涉及到回表查询，因此就变成了2\\*log2M.\n\n在这个过程中，testa表的扫描行数是全部，所以需要扫描100行，然后testa的每一行都与testb也是一一对应的，所以col1索引查询扫描的行数也是100行，所以总的扫描行数就是200行。\n\n我们假设驱动表的数据行位N，被驱动表的数据行为M，那么近似的复杂度为：N+N\\*2\\*log M，因为驱动表的扫描行数就是N，然后被驱动表因为每一次都对应驱动表的一次，并且一次的时间复杂度就是近似2\\*log M，所以被驱动表就是N\\*2\\*log M。\n\n明显N的值对于N+N\\*2\\*log M的结果值影响更大，所以N越小越好，所以选择小表作为驱动表是最优选择。\n\n在一些情况下的优化，假如join的驱动表所需要的字段很少（两个），可以建立联合索引来优化join查询，并且如果业务允许的话，可以通过冗余字段，减少join的个数提高查询的效率。 ","slug":"Mysql中join的那些事","published":1,"updated":"2022-11-14T08:38:38.174Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagje6cl0000v6ldhohb421b","content":"<p>Mysql中的join原理。</p>\n<p>join用法基本工作过的都会用，不管是left join、right join、inner join语法都是比较简单的。</p>\n<p>但是，join的原理确实博大精深，对于一些传统it企业，几乎是一句sql走天下，join了五六个表，当数据量上来的时候，就会变得非常慢，索引对于掌握join的优化还是非常有必要的。</p>\n<p>阿里的开发手册中规定join不能查过三个，有些互联网是明确规定不能使用join的的明文规定，那么在实际的场景中，我们真的不能使用join吗？我们就来详细的聊一聊。</p>\n<p>Mysql的join主要涉及到三种算法，分别是Simple Nested-Loop Join、Block Nested-Loop Join、Index Nested-Loop Join，下面我们就来深入的了解这三种算法的原理、区别、效率。</p>\n<p>首先，为了测试先准备两个表作为测试表，并且使用存储过程初始化一些测试数据，初始化的表结构sql如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">CREATE TABLE `testa` <span class=\"token punctuation\">(</span>\n  `id` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> NOT NULL AUTO_INCREMENT COMMENT <span class=\"token string\">'活动主键'</span><span class=\"token punctuation\">,</span>\n  `col1` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> NOT NULL DEFAULT <span class=\"token string\">'0'</span> COMMENT <span class=\"token string\">'测试字段1'</span><span class=\"token punctuation\">,</span>\n  `col2` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> NOT NULL DEFAULT <span class=\"token string\">'0'</span> COMMENT <span class=\"token string\">'测试字段2'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\">PRIMARY</span> KEY <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  KEY `col1` <span class=\"token punctuation\">(</span>`idx_col1`<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span>ENGINE<span class=\"token operator\">=</span><span class=\"token class-name\">InnoDB</span> AUTO_INCREMENT<span class=\"token operator\">=</span><span class=\"token number\">782</span> <span class=\"token class-name\">DEFAULT</span> CHARSET<span class=\"token operator\">=</span>utf8mb4 COMMENT<span class=\"token operator\">=</span><span class=\"token string\">'测试表1'</span><span class=\"token punctuation\">;</span>\n\n\nCREATE TABLE `testb` <span class=\"token punctuation\">(</span>\n  `id` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> NOT NULL AUTO_INCREMENT COMMENT <span class=\"token string\">'活动主键'</span><span class=\"token punctuation\">,</span>\n  `col1` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> NOT NULL DEFAULT <span class=\"token string\">'0'</span> COMMENT <span class=\"token string\">'测试字段1'</span><span class=\"token punctuation\">,</span>\n  `col2` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> NOT NULL DEFAULT <span class=\"token string\">'0'</span> COMMENT <span class=\"token string\">'测试字段2'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\">PRIMARY</span> KEY <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  KEY `col1` <span class=\"token punctuation\">(</span>`idx_col1`<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> ENGINE<span class=\"token operator\">=</span><span class=\"token class-name\">InnoDB</span> AUTO_INCREMENT<span class=\"token operator\">=</span><span class=\"token number\">782</span> <span class=\"token class-name\">DEFAULT</span> CHARSET<span class=\"token operator\">=</span>utf8mb4 COMMENT<span class=\"token operator\">=</span><span class=\"token string\">'测试表2'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>初始化数据：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">CREATE</span> DEFINER <span class=\"token operator\">=</span> `root` @`localhost` PROCEDURE `init_data` <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n\nBEGIN\n DECLARE i INT<span class=\"token punctuation\">;</span>\n \n <span class=\"token class-name\">SET</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n WHILE <span class=\"token punctuation\">(</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">)</span> DO\n   INSERT INTO testa VALUES <span class=\"token punctuation\">(</span> i<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> i <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">SET</span> i <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n <span class=\"token class-name\">END</span> WHILE<span class=\"token punctuation\">;</span>\n \n <span class=\"token class-name\">SET</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n WHILE <span class=\"token punctuation\">(</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span> DO\n   INSERT INTO test2 VALUES <span class=\"token punctuation\">(</span> i<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> i <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">SET</span> i <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n <span class=\"token class-name\">END</span> WHILE<span class=\"token punctuation\">;</span>\n\nEND<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>分别初始化testa表为100条数据，testb为2000条数据</p>\n<h2 id=\"Simple-Nested-Loop-Join\"><a href=\"#Simple-Nested-Loop-Join\" class=\"headerlink\" title=\"Simple Nested-Loop Join\"></a>Simple Nested-Loop Join</h2><p>首先，我们执行如下sql：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">select <span class=\"token operator\">*</span> from testa ta left join testb tb on <span class=\"token punctuation\">(</span>ta<span class=\"token punctuation\">.</span>col1<span class=\"token operator\">=</span>tb<span class=\"token punctuation\">.</span>col2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>Simple Nested-Loop Join是最简单也是最粗暴的join方法，上面的sql在testb 的col2字段是没有加索引的，所以当testa为驱动表，testb为被驱动表时，就会拿着testa的每一行，然后去testb的全表扫描，执行流程如下：</p>\n<ol>\n<li> 从表testa中取出一行数据，记为ta。</li>\n<li> 从ta中取出col1字段去testb中全表扫描查询。</li>\n<li> 找到testb中满足情况的数据与ta组成结果集返回。</li>\n<li> 重复执行1-3步骤，直到把testa表的所有数据都取完。</li>\n</ol>\n<p>因此扫描的时间复杂度就是100*2000=20W的行数，所以在被驱动表关联字段没有添加索引的时候效率就非常的低下。</p>\n<p>假如testb是百万数据以上，那么扫描的时间复杂度就更恐怖了，但是在Mysql中没有使用这个算法，而是使用了另一种算法Block Nested-Loop Join，目的就是为了优化驱动表没有索引时的查询。</p>\n<h2 id=\"Block-Nested-Loop-Join\"><a href=\"#Block-Nested-Loop-Join\" class=\"headerlink\" title=\"Block Nested-Loop Join\"></a>Block Nested-Loop Join</h2><p>还是上面的sql，不过通过加explain关键字来查看这条sql的执行计划：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">explain select <span class=\"token operator\">*</span> from testa ta left join testb tb on <span class=\"token punctuation\">(</span>ta<span class=\"token punctuation\">.</span>col1<span class=\"token operator\">=</span>tb<span class=\"token punctuation\">.</span>col2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_58fd8737.png\" alt=\"image_58fd8737.png\"></p>\n<p>可以看到testb依旧是全表扫描，并且在Extra字段中可以看到testb的Using join buffer（hash join）的字样，在rows中可以看到总扫描的行数是驱动表行数+被驱动表行数，那么这个算法与Simple Nested-Loop Join有什么区别呢？</p>\n<p>Block Nested-Loop Join算法中引入了join buffer区域，而join buffer是一块内存区域，它的大小由join_buffer_size参数大小控制，默认大小是256k：</p>\n<p><img src=\"/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_9f6ce7ed.png\" alt=\"image_9f6ce7ed.png\"></p>\n<p>在执行上面的sql的时候，它会把testa表的数据全部加载到join buffer区域，因为join buffer是内存操作，因此相对于比上面的simple算法要高效，具体的执行流程如下：</p>\n<ol>\n<li> 首先把testa表的所有数据都加在到join buffer里面，这里的所有数据是select后面的testa的字段，因为这里是select *，所以就是加载所有的testa字段。</li>\n<li> 然后遍历的取testb表中的每一行数据，并且与join buffer里面的数据济宁对比，符合条件的，就作为结果集返回。</li>\n</ol>\n<p>具体的流程图如下所示：</p>\n<p><img src=\"/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_65df1467.png\" alt=\"image_65df1467.png\"></p>\n<p>所以，从上面的执行的步骤来看（假设驱动表的行数为N，被驱动表的行数据为M），Block Nested-Loop Join的扫描的行数还是驱动表+被驱动表行数（N+M），在内存中总的比较次数还是驱动表*被驱动表行数（N*M）</p>\n<p>上面我们提到join buffer是一块内存区域，并且有自己的大小，要是join buffer的大小不足够容纳驱动表的数量级怎么办呢？</p>\n<p>答案就是分段，你要是join buffer没办法容纳驱动表的所有数据，那么就不把所有的数据加载到join buffer里面，先加载一部分，后面再加载另一部分，比如：先加载testa中的80条数据，与testb比较完数据后，清空再加载testa后20条数据，再与testb进行比较。具体执行流程如下：</p>\n<ol>\n<li> 先加载testa中的80条数据到join buffer</li>\n<li> 然后一次遍历testb的所有数据，与join buffer里面的数据进行比较，符合条件的组成结果集。</li>\n<li> 清空join buffer，再加载testa后面的20条数据。</li>\n<li> 然后一次遍历testb的所有数据，与join buffer里面的数据进行比较，符合条件的组成结果集并返回。</li>\n</ol>\n<p>执行流程图如下所示：</p>\n<p><img src=\"/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_ec6b3fe7.png\" alt=\"image_ec6b3fe7.png\"></p>\n<p>从上面的结果来看相对于比内存足够的join buffer来说，分段的join buffer多了一遍全表全表遍历testb，并且分的段数越多，多扫描驱动表的次数就越多。，性能就越差，所以在某一些场景下，适当的增大join buffer的值，是能够提高join的效率。</p>\n<p>假如驱动表的行数是N，分段参数为K，被驱动表的行数是M，那么总的扫描行数还是N+K*M，而内存比较的次数还是N*M，没有变。</p>\n<p>其中K段数与N的数据量有关，若是N的数据量越大，那么可能K被分成段数就越多，这样多次重复扫描的被驱动表的次数就越多。</p>\n<p>所以在join buffer不够的情况小，驱动表是越小越好，能够减少K值，减少重复扫描被驱动表的次数。这也就是为什么提倡小表要作为驱动表的原因。</p>\n<p>那么这里提到小表的概念，是不是就是数据量少的就是认为是小表呢？其实不然，小表的真正的还是是实际参与join的数据量，比如以下的两条sql：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">select <span class=\"token operator\">*</span> from testa ta left join testb tb on <span class=\"token punctuation\">(</span>ta<span class=\"token punctuation\">.</span>col1<span class=\"token operator\">=</span>tb<span class=\"token punctuation\">.</span>col2<span class=\"token punctuation\">)</span> where tb<span class=\"token punctuation\">.</span>id<span class=\"token operator\">&lt;=</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\nselect <span class=\"token operator\">*</span> from testb tb left join testa ta on <span class=\"token punctuation\">(</span>ta<span class=\"token punctuation\">.</span>col1<span class=\"token operator\">=</span>tb<span class=\"token punctuation\">.</span>col2<span class=\"token punctuation\">)</span> where tb<span class=\"token punctuation\">.</span>id<span class=\"token operator\">&lt;=</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>在第二条sql中，虽然testb驱动表数据量比较大，但是在where条件中实际参与join的行数也就是id小于等于20的数据，完全小于testa的数据量，所以这里选择以testb作为驱动表是更加的合适。</p>\n<p>在实际的开发中Block Nested-Loop Join也是严禁被禁止出现的，严格要求关联条件建索引，所以性能最好的就是Index Nested-Loop Join算法。</p>\n<h2 id=\"Index-Nested-Loop-Join\"><a href=\"#Index-Nested-Loop-Join\" class=\"headerlink\" title=\"Index Nested-Loop Join\"></a>Index Nested-Loop Join</h2><p>当我们执行如下sql时：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">select <span class=\"token operator\">*</span> from testa ta left join testb tb on <span class=\"token punctuation\">(</span>ta<span class=\"token punctuation\">.</span>col1<span class=\"token operator\">=</span>tb<span class=\"token punctuation\">.</span>col1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_942c82dc.png\" alt=\"image_942c82dc.png\"></p>\n<p>它的执行流程如下：</p>\n<ol>\n<li> 首先取testa表的一行数据。</li>\n<li> 使用上面的行数据的col1字段去testb表进行查询。</li>\n<li> 在testb找到符合条件的数据行，并与testa的数据行组合作为结果集。</li>\n<li> 重复执行1-3步骤，直到取完testa表的所有数据。</li>\n</ol>\n<p>因为testb的col1字段是建立了索引，所以，当使用testa表的字段col1去testb查找的时候，testb走的是col1索引的b+树的搜索，时间复杂度近似log2M，并且因为是select*，也就是要查找testb的所有字段，所以这里也涉及到回表查询，因此就变成了2*log2M.</p>\n<p>在这个过程中，testa表的扫描行数是全部，所以需要扫描100行，然后testa的每一行都与testb也是一一对应的，所以col1索引查询扫描的行数也是100行，所以总的扫描行数就是200行。</p>\n<p>我们假设驱动表的数据行位N，被驱动表的数据行为M，那么近似的复杂度为：N+N*2*log M，因为驱动表的扫描行数就是N，然后被驱动表因为每一次都对应驱动表的一次，并且一次的时间复杂度就是近似2*log M，所以被驱动表就是N*2*log M。</p>\n<p>明显N的值对于N+N*2*log M的结果值影响更大，所以N越小越好，所以选择小表作为驱动表是最优选择。</p>\n<p>在一些情况下的优化，假如join的驱动表所需要的字段很少（两个），可以建立联合索引来优化join查询，并且如果业务允许的话，可以通过冗余字段，减少join的个数提高查询的效率。 </p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<p>Mysql中的join原理。</p>\n<p>join用法基本工作过的都会用，不管是left join、right join、inner join语法都是比较简单的。</p>\n<p>但是，join的原理确实博大精深，对于一些传统it企业，几乎是一句sql走天下，join了五六个表，当数据量上来的时候，就会变得非常慢，索引对于掌握join的优化还是非常有必要的。</p>\n<p>阿里的开发手册中规定join不能查过三个，有些互联网是明确规定不能使用join的的明文规定，那么在实际的场景中，我们真的不能使用join吗？我们就来详细的聊一聊。</p>\n<p>Mysql的join主要涉及到三种算法，分别是Simple Nested-Loop Join、Block Nested-Loop Join、Index Nested-Loop Join，下面我们就来深入的了解这三种算法的原理、区别、效率。</p>\n<p>首先，为了测试先准备两个表作为测试表，并且使用存储过程初始化一些测试数据，初始化的表结构sql如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">CREATE TABLE `testa` <span class=\"token punctuation\">(</span>\n  `id` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> NOT NULL AUTO_INCREMENT COMMENT <span class=\"token string\">'活动主键'</span><span class=\"token punctuation\">,</span>\n  `col1` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> NOT NULL DEFAULT <span class=\"token string\">'0'</span> COMMENT <span class=\"token string\">'测试字段1'</span><span class=\"token punctuation\">,</span>\n  `col2` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> NOT NULL DEFAULT <span class=\"token string\">'0'</span> COMMENT <span class=\"token string\">'测试字段2'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\">PRIMARY</span> KEY <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  KEY `col1` <span class=\"token punctuation\">(</span>`idx_col1`<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span>ENGINE<span class=\"token operator\">=</span><span class=\"token class-name\">InnoDB</span> AUTO_INCREMENT<span class=\"token operator\">=</span><span class=\"token number\">782</span> <span class=\"token class-name\">DEFAULT</span> CHARSET<span class=\"token operator\">=</span>utf8mb4 COMMENT<span class=\"token operator\">=</span><span class=\"token string\">'测试表1'</span><span class=\"token punctuation\">;</span>\n\n\nCREATE TABLE `testb` <span class=\"token punctuation\">(</span>\n  `id` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> NOT NULL AUTO_INCREMENT COMMENT <span class=\"token string\">'活动主键'</span><span class=\"token punctuation\">,</span>\n  `col1` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> NOT NULL DEFAULT <span class=\"token string\">'0'</span> COMMENT <span class=\"token string\">'测试字段1'</span><span class=\"token punctuation\">,</span>\n  `col2` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> NOT NULL DEFAULT <span class=\"token string\">'0'</span> COMMENT <span class=\"token string\">'测试字段2'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\">PRIMARY</span> KEY <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  KEY `col1` <span class=\"token punctuation\">(</span>`idx_col1`<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> ENGINE<span class=\"token operator\">=</span><span class=\"token class-name\">InnoDB</span> AUTO_INCREMENT<span class=\"token operator\">=</span><span class=\"token number\">782</span> <span class=\"token class-name\">DEFAULT</span> CHARSET<span class=\"token operator\">=</span>utf8mb4 COMMENT<span class=\"token operator\">=</span><span class=\"token string\">'测试表2'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>初始化数据：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">CREATE</span> DEFINER <span class=\"token operator\">=</span> `root` @`localhost` PROCEDURE `init_data` <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n\nBEGIN\n DECLARE i INT<span class=\"token punctuation\">;</span>\n \n <span class=\"token class-name\">SET</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n WHILE <span class=\"token punctuation\">(</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">)</span> DO\n   INSERT INTO testa VALUES <span class=\"token punctuation\">(</span> i<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> i <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">SET</span> i <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n <span class=\"token class-name\">END</span> WHILE<span class=\"token punctuation\">;</span>\n \n <span class=\"token class-name\">SET</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n WHILE <span class=\"token punctuation\">(</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span> DO\n   INSERT INTO test2 VALUES <span class=\"token punctuation\">(</span> i<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> i <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">SET</span> i <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n <span class=\"token class-name\">END</span> WHILE<span class=\"token punctuation\">;</span>\n\nEND<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>分别初始化testa表为100条数据，testb为2000条数据</p>\n<h2 id=\"Simple-Nested-Loop-Join\"><a href=\"#Simple-Nested-Loop-Join\" class=\"headerlink\" title=\"Simple Nested-Loop Join\"></a>Simple Nested-Loop Join</h2><p>首先，我们执行如下sql：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">select <span class=\"token operator\">*</span> from testa ta left join testb tb on <span class=\"token punctuation\">(</span>ta<span class=\"token punctuation\">.</span>col1<span class=\"token operator\">=</span>tb<span class=\"token punctuation\">.</span>col2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>Simple Nested-Loop Join是最简单也是最粗暴的join方法，上面的sql在testb 的col2字段是没有加索引的，所以当testa为驱动表，testb为被驱动表时，就会拿着testa的每一行，然后去testb的全表扫描，执行流程如下：</p>\n<ol>\n<li> 从表testa中取出一行数据，记为ta。</li>\n<li> 从ta中取出col1字段去testb中全表扫描查询。</li>\n<li> 找到testb中满足情况的数据与ta组成结果集返回。</li>\n<li> 重复执行1-3步骤，直到把testa表的所有数据都取完。</li>\n</ol>\n<p>因此扫描的时间复杂度就是100*2000=20W的行数，所以在被驱动表关联字段没有添加索引的时候效率就非常的低下。</p>\n<p>假如testb是百万数据以上，那么扫描的时间复杂度就更恐怖了，但是在Mysql中没有使用这个算法，而是使用了另一种算法Block Nested-Loop Join，目的就是为了优化驱动表没有索引时的查询。</p>\n<h2 id=\"Block-Nested-Loop-Join\"><a href=\"#Block-Nested-Loop-Join\" class=\"headerlink\" title=\"Block Nested-Loop Join\"></a>Block Nested-Loop Join</h2><p>还是上面的sql，不过通过加explain关键字来查看这条sql的执行计划：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">explain select <span class=\"token operator\">*</span> from testa ta left join testb tb on <span class=\"token punctuation\">(</span>ta<span class=\"token punctuation\">.</span>col1<span class=\"token operator\">=</span>tb<span class=\"token punctuation\">.</span>col2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_58fd8737.png\" alt=\"image_58fd8737.png\"></p>\n<p>可以看到testb依旧是全表扫描，并且在Extra字段中可以看到testb的Using join buffer（hash join）的字样，在rows中可以看到总扫描的行数是驱动表行数+被驱动表行数，那么这个算法与Simple Nested-Loop Join有什么区别呢？</p>\n<p>Block Nested-Loop Join算法中引入了join buffer区域，而join buffer是一块内存区域，它的大小由join_buffer_size参数大小控制，默认大小是256k：</p>\n<p><img src=\"/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_9f6ce7ed.png\" alt=\"image_9f6ce7ed.png\"></p>\n<p>在执行上面的sql的时候，它会把testa表的数据全部加载到join buffer区域，因为join buffer是内存操作，因此相对于比上面的simple算法要高效，具体的执行流程如下：</p>\n<ol>\n<li> 首先把testa表的所有数据都加在到join buffer里面，这里的所有数据是select后面的testa的字段，因为这里是select *，所以就是加载所有的testa字段。</li>\n<li> 然后遍历的取testb表中的每一行数据，并且与join buffer里面的数据济宁对比，符合条件的，就作为结果集返回。</li>\n</ol>\n<p>具体的流程图如下所示：</p>\n<p><img src=\"/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_65df1467.png\" alt=\"image_65df1467.png\"></p>\n<p>所以，从上面的执行的步骤来看（假设驱动表的行数为N，被驱动表的行数据为M），Block Nested-Loop Join的扫描的行数还是驱动表+被驱动表行数（N+M），在内存中总的比较次数还是驱动表*被驱动表行数（N*M）</p>\n<p>上面我们提到join buffer是一块内存区域，并且有自己的大小，要是join buffer的大小不足够容纳驱动表的数量级怎么办呢？</p>\n<p>答案就是分段，你要是join buffer没办法容纳驱动表的所有数据，那么就不把所有的数据加载到join buffer里面，先加载一部分，后面再加载另一部分，比如：先加载testa中的80条数据，与testb比较完数据后，清空再加载testa后20条数据，再与testb进行比较。具体执行流程如下：</p>\n<ol>\n<li> 先加载testa中的80条数据到join buffer</li>\n<li> 然后一次遍历testb的所有数据，与join buffer里面的数据进行比较，符合条件的组成结果集。</li>\n<li> 清空join buffer，再加载testa后面的20条数据。</li>\n<li> 然后一次遍历testb的所有数据，与join buffer里面的数据进行比较，符合条件的组成结果集并返回。</li>\n</ol>\n<p>执行流程图如下所示：</p>\n<p><img src=\"/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_ec6b3fe7.png\" alt=\"image_ec6b3fe7.png\"></p>\n<p>从上面的结果来看相对于比内存足够的join buffer来说，分段的join buffer多了一遍全表全表遍历testb，并且分的段数越多，多扫描驱动表的次数就越多。，性能就越差，所以在某一些场景下，适当的增大join buffer的值，是能够提高join的效率。</p>\n<p>假如驱动表的行数是N，分段参数为K，被驱动表的行数是M，那么总的扫描行数还是N+K*M，而内存比较的次数还是N*M，没有变。</p>\n<p>其中K段数与N的数据量有关，若是N的数据量越大，那么可能K被分成段数就越多，这样多次重复扫描的被驱动表的次数就越多。</p>\n<p>所以在join buffer不够的情况小，驱动表是越小越好，能够减少K值，减少重复扫描被驱动表的次数。这也就是为什么提倡小表要作为驱动表的原因。</p>\n<p>那么这里提到小表的概念，是不是就是数据量少的就是认为是小表呢？其实不然，小表的真正的还是是实际参与join的数据量，比如以下的两条sql：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">select <span class=\"token operator\">*</span> from testa ta left join testb tb on <span class=\"token punctuation\">(</span>ta<span class=\"token punctuation\">.</span>col1<span class=\"token operator\">=</span>tb<span class=\"token punctuation\">.</span>col2<span class=\"token punctuation\">)</span> where tb<span class=\"token punctuation\">.</span>id<span class=\"token operator\">&lt;=</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\nselect <span class=\"token operator\">*</span> from testb tb left join testa ta on <span class=\"token punctuation\">(</span>ta<span class=\"token punctuation\">.</span>col1<span class=\"token operator\">=</span>tb<span class=\"token punctuation\">.</span>col2<span class=\"token punctuation\">)</span> where tb<span class=\"token punctuation\">.</span>id<span class=\"token operator\">&lt;=</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>在第二条sql中，虽然testb驱动表数据量比较大，但是在where条件中实际参与join的行数也就是id小于等于20的数据，完全小于testa的数据量，所以这里选择以testb作为驱动表是更加的合适。</p>\n<p>在实际的开发中Block Nested-Loop Join也是严禁被禁止出现的，严格要求关联条件建索引，所以性能最好的就是Index Nested-Loop Join算法。</p>\n<h2 id=\"Index-Nested-Loop-Join\"><a href=\"#Index-Nested-Loop-Join\" class=\"headerlink\" title=\"Index Nested-Loop Join\"></a>Index Nested-Loop Join</h2><p>当我们执行如下sql时：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">select <span class=\"token operator\">*</span> from testa ta left join testb tb on <span class=\"token punctuation\">(</span>ta<span class=\"token punctuation\">.</span>col1<span class=\"token operator\">=</span>tb<span class=\"token punctuation\">.</span>col1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"/2022/11/14/mysql-zhong-join-de-na-xie-shi/image_942c82dc.png\" alt=\"image_942c82dc.png\"></p>\n<p>它的执行流程如下：</p>\n<ol>\n<li> 首先取testa表的一行数据。</li>\n<li> 使用上面的行数据的col1字段去testb表进行查询。</li>\n<li> 在testb找到符合条件的数据行，并与testa的数据行组合作为结果集。</li>\n<li> 重复执行1-3步骤，直到取完testa表的所有数据。</li>\n</ol>\n<p>因为testb的col1字段是建立了索引，所以，当使用testa表的字段col1去testb查找的时候，testb走的是col1索引的b+树的搜索，时间复杂度近似log2M，并且因为是select*，也就是要查找testb的所有字段，所以这里也涉及到回表查询，因此就变成了2*log2M.</p>\n<p>在这个过程中，testa表的扫描行数是全部，所以需要扫描100行，然后testa的每一行都与testb也是一一对应的，所以col1索引查询扫描的行数也是100行，所以总的扫描行数就是200行。</p>\n<p>我们假设驱动表的数据行位N，被驱动表的数据行为M，那么近似的复杂度为：N+N*2*log M，因为驱动表的扫描行数就是N，然后被驱动表因为每一次都对应驱动表的一次，并且一次的时间复杂度就是近似2*log M，所以被驱动表就是N*2*log M。</p>\n<p>明显N的值对于N+N*2*log M的结果值影响更大，所以N越小越好，所以选择小表作为驱动表是最优选择。</p>\n<p>在一些情况下的优化，假如join的驱动表所需要的字段很少（两个），可以建立联合索引来优化join查询，并且如果业务允许的话，可以通过冗余字段，减少join的个数提高查询的效率。 </p>\n"},{"title":"精通Mysql索引","top":false,"cover":false,"toc":true,"mathjax":true,"summary":"精通Mysql索引","date":"2022-11-14T08:40:48.000Z","password":null,"_content":"## 索引概念 \n\n概念：索引是提高mysql查询效率的数据结构。总的一句话概括就是索引是一种提高查询效率的数据结构。\n\n数据库查询是数据库的最主要功能之一。设计者们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。\n\n最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如：有顺序查找、折半查找、快速查找等。\n\n但是，每种查找算法都只能应用于特定的数据结构之上，例如顺序查找依赖于顺序结构，折半查找通过二叉查找树或红黑树实现二分搜索。\n\n因此，在数据之外，数据库系统还维护着满足特定查找算法的数据结构。这种数据结构，就是索引。\n\n## 索引性能分析 \n\n目前，大多数数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。B+ 树索引是 B+ 树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。\n\n从最早的平衡二叉树演化而来的。B+ 树是由二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree）逐步优化而来。\n\n那么为什么mysql的索引选择B+数呢？\n\n有序数组、Hash索引、红黑树、二叉查找树、AVL树也可以作为数据结构也可以用来实现索引，但是文件系统以及数据库系统普遍采用B树或者B+树，这里结合各个索引的特点以及计算的组成原理来深入的分析。\n\n但是，对于Mysql来说适合它的才是最好的查询，一方面要实现高效的查询，除了简单的条件查询，还要支持有序的高效索引的范围查询、分组。\n\n有序数组在等值查询和范围查询性能都是非常好的，那为什么又不用有序数组作为索引呢？因为对于数组而言作为索引更新的成本太高，新增数据要把后面的数据都往后移一位，所以也不采用有序数组作为索引的底层实现。\n\nhash是以key-value的形式进行存储，适合于等值查询的场景，查询的时间复杂度为O(1)，因为hash储存并不是有序的，所以对于范围查询就可能要遍历所有数据进行查询，而且不同值的计算还会出现hash冲突，所以hash并不适合于做Mysql的索引。\n\n另一方面就是除了查询的效率要高，还要有高效的读取数据效率（io），我们都知道计算机的随机磁盘io效率是非常低下的。\n\n那么为什么硬盘的存取会如此的慢呢？\n\n这个就要讲硬盘的读写原理，硬盘有很多种，但是都是由盘片、磁头、盘片主轴、控制电机、磁头控制器、数据转换器、接口、缓存等几个部分组成。\n\n所有的盘片都固定在一条轴上，那条轴叫做盘片主轴，所有的盘片都是绝对平行的，也形成一个柱体，每个盘片上都有一个磁头，每个磁头都在同一轴线上，就是从上方往下看，磁头是绝对重叠的。\n\n所有的磁头连在一个磁头控制器上，由磁头控制器负责各个磁头的运动，磁头可沿盘片的半径方向移动，实际上是斜切运动，每个磁头同一时刻必须是同轴的盘片以每分钟数千转到上万转的速度在高速运转，这样磁头就能对盘片上的指定位置进行数据的读写操作：\n\n![image_2c3f6cae.png](精通Mysql索引/image_2c3f6cae.png)\n\n磁盘数据的读写原理\n\n盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。\n\n磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。\n\n当磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。\n\n为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。\n\n即一次磁盘的读写操作完成过程由三个动作组成：\n\n *  寻道（时间）：磁头移动定位到指定磁道。\n *  旋转延迟（时间）：等待指定扇区从磁头下旋转经过。\n *  数据传输（时间）：数据在磁盘与内存之间的实际传输\n\n> 额外知识：\n>\n>  *  盘面：硬盘的每一个盘片都有上下两个盘面，一般每个盘面都会得到利用，都可以存储数据，盘面号又叫磁头号，因为每一个有效盘面都有一个对应的读写磁头。\n>  *  磁道：磁盘在格式化时被划分成许多同心圆，这些同心圆轨迹叫做磁道，磁道从外向内从 0 开始顺序编号，信息以脉冲串的形式记录在这些轨迹中，这些同心圆不是连续记录数据，而是被划分成一段段的圆弧。\n>  *  所有盘面上的同一磁道构成一个圆柱，通常称作柱面。所有盘面上的同一磁道构成一个圆柱，通常称作柱面。数据的读 / 写按柱面进行，而不按盘面进行，当一个磁道写满数据后，就在同一柱面的下一个盘面来写，一个柱面写满后，才移到下一个扇区开始写数据，读数据也按照这种方式进行，这样就提高了硬盘的读 / 写效率。\n\n提高磁盘数据读写原理\n\n局部性原理与磁盘预读。由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。\n\n为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。\n\n这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。\n\n所以，程序运行期间所需要的数据通常应当比较集中。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。\n\n预读的长度一般为页（page）4k的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4k），主存和磁盘以页为单位交换数据。\n\n当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。\n\n> 所以，硬盘中由于涉及到机械运动，所以一次的磁盘IO消耗的时间是非常大的，于内存的读取速度相比，就好比光速与声速的比较。\n\n因此，假如内存条件允许的话，Mysql巴不得把所有的数据一次性加载到内存中进行读写。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。\n\n服务器的内存的大小也是限制的，一个服务器中可能不止跑着Mysql一个进行，多多少少都有可能二三十个进行，每个进行都需要操作系统分配内存。\n\n这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，硬盘I/O存取的消耗要高几个数量级，查找过程中磁盘I/O的存取次数。\n\nMysql中的一些大的数据表，一个表就有可能几个G，索引结构也很大，那服务器内存不得撑爆了。\n\n所以，必须做一个取舍，在内存与磁盘中进行衡量，数据尽量放在内存中，而在少量的数据在磁盘中，读取磁盘的次数控制到最少，也就是对于Mysql的性能影响到最小，加上磁盘数据读写原理来提高数据的读取效率。\n\n那么在众多树的条件下，B+树又是以怎么样的又是脱颖而出呢？下面我们来聊一聊B树、B-树、B+树、红黑树性能。\n\n二叉树、红黑树、AVL树、B树、B+树性能分析\n\nB树性能分析：B树是二叉查找平衡树，但是B树一个节点只存一个关键字，在大量数据的时候，B树树高非常大，性能低下：\n\n![image_f327aac4.png](精通Mysql索引/image_f327aac4.png)\n\n甚至在极端的情况下，因为二叉搜索树不存在平衡算法，所以在某些特殊的情况下，二叉搜索树等同于线性，出现蹩脚的情况，设计者们发现降低树的高度自然就可以提高查找效率：\n\n![image_c1987417.png](精通Mysql索引/image_c1987417.png)\n\n红黑树和AVL树是在二叉树的基础上机上加上平衡算法，红黑树确保没有一条路径会比其它路径长出两倍，它是弱平衡树而AVL是严格的平衡，所以相对于二叉树的蹩脚情况做了很大的改进，加入了平衡算法：\n\n![image_700a6b0b.png](精通Mysql索引/image_700a6b0b.png)\n\n但是，同样还是存在数据量大导致树非常高的问题，所以现在的目标就是压缩树的高度。\n\nB树基于减少树的高度上，B树是一种多路搜索树，每个节点都可以有多于两个子节点，并不是二叉的：\n\n![image_4d67662e.png](精通Mysql索引/image_4d67662e.png)\n\nB树与B+树最大的区别就是B的非叶子节点可以存储数据，而B+树只有叶子结点才可以存储数据，B树是多路搜索树，一个节点可以存储很多数据，所以B树的高度大大减小。\n\n但是B树相对于B+树来说，在查找数据的时候，由于每一个节点都有可能包含目标数据，所以查找总是从根节点进行向下搜索，这个特点会带来大量的随机io。\n\n而在B+树种，因为叶子结点才会存储数据（InnoDB），这样子相比B树一个页大小存储的索引数据就更多了（16K），并且叶子结点通过双向指针指向相邻的节点，依次连接。\n\n并且相邻结点是有序的，所以对于范围查找是非常方便的，获取到第一个符合条件的，然后通过指针，往后获取数据，直到最后一个不满足条件为止。\n\n所以总结来说：B+树是多叉树，一个数据页的大小是16kb，在1-3的树高就能存储10亿级以上的数据，也就是只要访问磁盘1-3次就足够了，并且B+树的叶子结点上一个叶子结点有指针指向下一个叶子结点，便于范围查询：\n\n![image_275a1cfe.png](精通Mysql索引/image_275a1cfe.png)\n\n下面我们来详细的聊一聊Mysql索引B+树查询原理。\n\n## B+树索引原理 \n\n上面也大概说了一下B+树的介绍，在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。\n\n在B+树的结构中，只在叶子节点存储数据，在非叶子节点中只存储的索引，在非叶子节点中可以有更大的空间储存更多的索引，这样B+树的出度d就可以大大的增加，从而降低的B+树的高度h，B树中一个节点的大小为一个page的大小，也就是一次IO的读取，h越小IO的次数就可以减少：\n\ndmax=floor(pagesize/(keysize+datasize+pointsize))\n\nfloor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。\n\n我们来看看B+树的搜索过程，Mysql的InnoDB的索引的结构如下图所示，假设我们要搜索id为15的数据：\n\n![image_5bee3c9f.png](精通Mysql索引/image_5bee3c9f.png)\n\n1.  根据根节点找到磁盘块 1，读入内存，一般根节点也会常驻内存，甚至可以省略一次磁盘IO操作。【磁盘 I/O 操作第 1 次】\n2.  比较id 15在区间28的左边，于是根据p1找到磁盘2。\n3.  将磁盘2读入内存，查找结果15在（10,17）之间。【磁盘 I/O 操作第 2 次】\n4.  然后根据磁盘2的指针p2找到磁盘块5，读入内存。【磁盘 I/O 操作第 3 次】\n5.  最后根据id=15找到对应的数据，返回结果。\n\n所以根据上面的查找只需要至多三次的磁盘IO就可以找到对应的数据。从上面的B+树的原理图中非叶子节点构成了类似于一个一个目录一样，也可以叫做索引页，最后找到叶子结点的数据。\n\n在MySQL中，不同存储引擎对索引的实现方式是不同的，Mysql有MyISAM和InnoDB两个存储引擎的索引实现方式，下面就来分别介绍这两种存储引擎。\n\n### MyISAM \n\n在MyISAM储存引擎中，数据和索引文件是分开储存的，Myisam 的存储文件有三个，后缀名分别是 .frm、.MYD、MYI，其中 .frm 是表的定义文件，.MYD 是数据文件，.MYI 是索引文件。\n\n![image_e6679248.png](精通Mysql索引/image_e6679248.png)\n\nMyisam 只支持表锁，且不支持事务。Myisam 由于有单独的索引文件，在读取数据方面的性能很高 。\n\nMyisam 也是B+树结构，但是MyISAM索引的叶子节点的数据保存的是行数据的地址。因此，MyISAM中索引检索的算法首先在索引树中找到行数据的地址，然后根据地址找到对应的行数据。\n\n![image_f50b3c32.png](精通Mysql索引/image_f50b3c32.png)\n\n可以看出MyISAM的索引文件仅仅保存数据记录的地址。主键索引和辅助索引，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的如下图：\n\n![image_3e3d131e.png](精通Mysql索引/image_3e3d131e.png)\n\nMyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。\n\n### InnoDB \n\n在InnoDB中，数据和索引文件是合起来储存的，如图所示，InnoDB 的存储文件有两个，后缀名分别是 .frm 和 .idb，其中 .frm 是表的定义文件，而 idb 是数据文件。\n\n![image_5eb3208c.png](精通Mysql索引/image_5eb3208c.png)\n\n在InnoDB虽然底层也是B+树实现的方式，当时与MyISAM却有明显的区别，在InnoDB实现的索引结构中，索引文件和数据文件是一起的，InnoDB中索引文件中的key就是数据表中的主键索引，因此InnoDB的索引文件也是主索引文件。如下图所示：\n\n![image_33b5701e.png](精通Mysql索引/image_33b5701e.png)\n\n如果给另一个字段指定为普通索引，则普通索引树的结构如下图所示：\n\n![image_cee886ce.png](精通Mysql索引/image_cee886ce.png)\n\n所以，当查询不是按照主键查询时候就会先在辅助索引树上先找到主键的值，然后再到主索引树找到对应的行数据的值，这叫做回表，回表降低了表的查询效率。\n\n## Mysql索引种类 \n\nMysql中索引的种类也不是很多，不同类型的索引有不同的作用，索引的作用相互之间也存在交叉关系，Mysql中索引主要分为以下几类：\n\n1.  「主键索引」（PRIMARY KEY）：主键索引一般都是在创建表的时候指定，「一个表只有一个主键索引」，特点是「唯一、非空」。\n2.  「唯一索引」（UNIQUE）：唯一索引具有的特点就是唯一性，可以在创建表的时候指定，也可以在创建表后创建。\n3.  「普通索引」（INDEX）：普通索引唯一的作用就是加快查询。\n4.  「组合索引」（ INDEX）：组合索引是创建一个「多个字段的索引」，这个概念是相对于上上面的单列索引而言，组合索引查询遵循「最左前缀原则」。\n5.  「全文索引」（FULLTEXT）：全文索引是针对一些大的「文本字段」创建的索引，也称为「全文检索」。\n6.  「聚簇索引」和「非聚簇索引」：聚簇索引和非聚簇索引的概念比上面的概念要大，属于包含和被包含的关系。例如：InnoDB中主键索引使用的就是聚簇索引。\n\n若是你想查看一个表的所有索引，可以执行下面的sql来查看：\n\n```java\nshow index from 表名\n```\n\n例如，查看我自己的测试表里面的索引，如下图所示，Key\\_name表示索引的名字，Column\\_name表示索引的字段：\n\n![image_4030cc20.png](精通Mysql索引/image_4030cc20.png)\n\n### 主键索引 \n\n主键索引在InnoDB存储引擎中是最常见的索引类型，一个表都会有一个主键索引，它索引的字段不允许为空值，并且唯一。\n\n一般是在创建表的时候，可以通过RIMARY KEY指定主键索引，在InnoDB存储引擎中，若是创建表的时候没有主观创建主键索引，Mysql就会看表中是否有唯一索引，有，就会指定「非空的唯一索引」为主键索引\n\n若是没有唯一索引，就会默认生成一个6byte空间的自动增长主键作为主键索引，可以通过select \\_rowid from 表名查询的是对应的主键值.。\n\nMyISAM储存引擎是可以不存在主键索引，MyISAM和InnoDB储存数据的结构方式还是有明显的区别，这个后面篇章会详细讲解。\n\n### 唯一索引 \n\n唯一索引与主键索引的区别就是，唯一索引允许为空，若是在组合索引中，只要创建的列值是唯一的\n\n唯一索引在实际中更多的是用来保证数据的唯一性，假如你仅仅要数据能够快速查询，你也可以使用普通索引，所以唯一索引重在体现它的唯一性。\n\n实际的业务场景，有些库表字段要求唯一，就可以使用唯一索引，创建唯一索引的方式有三种。\n\n（1）一个是在创建表的时候指定，如下sql：\n\n```java\nCREATE TABLE user( \n id INT PRIMARY KEY NOT NULL, \n name VARCHAR(16) NOT NULL, \n UNIQUE unique_name (name(10)) \n);\n```\n\n（2）也可以在表创建后创建，如下sql：\n\n```java\nCREATE UNIQUE INDEX unique_name ON user(name(10))；\n```\n\n（3）通过修改表结构创建，如下sql：\n\n```java\nALTER user ADD UNIQUE unique_name ON (name(10))\n```\n\n这里有一个细节要注意的是创建的name字段，指定的长度是16字符，而创建的索引的长度制定的是10字符，因为也没有人的名字长度会超过10个字符，所以减少索引长度，能够减少索引所占的空间的大小。\n\n### 普通索引 \n\n普通索引的唯一作用就是加快数据的查询，一般对查询语句WHERE和ORDER BY后面的字段创建普通索引。\n\n创建普通索引的方式也有三种，基本和创建唯一索引的方式一样，只是把关键字UNIQUE换成INDEX，如下所示：\n\n```java\n// 创建表的时候创建\nCREATE TABLE user( \n id INT PRIMARY KEY NOT NULL, \n name VARCHAR(16) NOT NULL, \n INDEX index_name (name(10)) \n);\n// 创建表后创建\nCREATE INDEX INDEX index_name ON user(name(10))；\n// 修改表结构创建\nALTER user ADD INDEX index_name ON (name(10))\n```\n\n若是想删除索引，可以通过执行下面的sql进行删除索引：\n\n```java\nDROP INDEX index_name ON user;\n```\n\n### 组合索引 \n\n组合索引即用多个字段创建一个索引，组合索引能够避免「回表查询」，相对于多字段的单列索引，组合索引的查询效率更高。\n\n创建组合索引(联合索引)的方式和上面创建普通索引的方式一样，只不过字段的数目多了，如下sql创建：\n\n```java\n// 其它方式和上面的一样，这里就只列举修改表结构的方式创建\nALTER TABLE employee ADD INDEX name_age_sex (name(10),age,sex);\n```\n\n#### 回表查询 \n\n什么是回表查询呢？回表查询简单来说「通过二级索引查询数据，得不到完整的数据行，需要再次查询主键索引来获得数据行」。\n\nInnoDB存储引擎中，索引分为 「聚簇索引」和「二级索引」，主键索引就是聚簇索引，其它的索引为二级索引。\n\n聚簇索引中的叶子节点保存着完整的数据行，而二级索引的叶子节点并不是保存完整的数据行。\n\n上面提到InnoDB表是一定要有主键索引的，虽然索引占据空间，但是索引符合二分查找的算法，查找数据非常的快。\n\n假设还是上面的employee表，里面有主键索引id，和普通的索引name，那么在InnoDB中就会存在两棵B+Tree，一棵是主键索引树：\n\n![image_ea5a8c1e.png](精通Mysql索引/image_ea5a8c1e.png)\n\n在主键索引树中的叶子节点存储的是完整的数据行，另外一棵是name字段的二级索引树，如下图所示：\n\n![image_73608ecd.png](精通Mysql索引/image_73608ecd.png)\n\n倘若你执行这条sql：select name, age, sex from employee where name ='as';就会先执行二级索引的查询，当查询name='as'时，得到主键为50，再根据主键查询主键索引树，得到完整的数据行，具体的执行流程如下：\n\n![image_6bcc4698.png](精通Mysql索引/image_6bcc4698.png)\n\n这个就是回表查询，回表查询会查询两次，这样就会降低查询的效率，为了避免回表查询，只查询一次就能得到完整的数据呢？\n\n#### 索引覆盖 \n\n常见的方式就是「建立组合索引（联合索引）「进行」索引覆盖」，什么是索引覆盖呢？索引覆盖就是「索引的叶子节点已经包含了查询的数据，没必要再回表进行查询。」\n\n假如我还是执行如下sql：select name, age, sex from employee where name ='as';因为普通索引只有name字段才建立了索引，这必然会导致回表查询。\n\n为了提高查询效率，就(name)「单列索引升级为联合索引」(name, age, sex)就不同了。\n\n因为建立的联合索引，在二级节点的叶子阶段就会同时存在name, age, sex三个的值，一次性就会获得所需要的数据，这样就避免了回表，但是所有的方案都不是完美的。\n\n若是这个联合索引哪一天某一个数据行的name值改变了或者age改变了，我就需要同时维护主键索引和联合索引两棵树，这样的维护成本就高了，性能开销也大了。\n\n相比之前数据的改变，我只需要维护主键索引即可，联合索引的创建就导致了需要同时维护两棵树，这样就会影响插入、更新数据的操作，所以并没有哪种方案是完美的。\n\n#### 最左前缀原则 \n\n我们知道单列索引是按照索引列有序性的进行组织B+Tree结构的，联合索引又是怎么组织B+Tree呢？\n\n联合索引其实也是按照创建索引的时候，最左边的进行最开始的排序，也就是「最左前缀原则」，比如一个表中有如下数据：\n\n![image_d3894bcc.png](精通Mysql索引/image_d3894bcc.png)\n\n如上图所示，对于联合索引中name字段是放在最前面的，所以name是完全有序的，但是age字段就不是有序的，只有当name相同，例如：name='bc'此时age字段的索引排序才是完全有序的。\n\n所以你会发现，在联合索引中你只有使用以下的规则的方式查询才会使用到索引：\n\n *  name,age,sex\n *  name,age\n *  name\n\n因为Mysql的底层有查询优化器，会判断sql执行的时候若是使用全表扫描的效率比使用索引的效率更高，就会使用全表扫描。\n\n假如，我查询的时候使用age>=23,sex='男';两个字段作为查询条件，但是没有使用name字段，因为在name不知情的条件下，对于age是无序的。\n\n对于age>=23条件可能在很多的name不同中都有符合条件的出现，所以就没有办法使用索引，这也是索引实现的原因，一定要遵循「查找有序，充分的利用索引的有序性」。\n\n假如你是分别在name，age，sex三个字段中分别建立三个单列索引，就相当于建立三颗索引树，那么它的查询效率，比我们使用一棵索引树查询效率就可想而知了。\n\n有一种情况即使使用到了最左边的name字段也不会使用索引，例如：WHERE name like '%d%'；这种like条件的模糊查询是会使索引失效。\n\n我们可以这样理解，「查询字符串也是遵循最左前缀原则的」，字符串的查询是对字符串里面的字符一个一个的匹配，「若是字符串最左边为%表示一个不确定的字符串，那么是没办法利用到索引的有序性」。\n\n但是若是修改为 ：WHERE name like 'd%'；就可以使用索引，因为最左边的字符串是确定的，这种称为「匹配列前缀」。\n\n实际业务场景中联合索引的创建，「我们应该把识别度比较高的字段放在前面，提高索引的命中率，充分的利用索引」。\n\n#### 索引下推 \n\nMysql5.6版本提出了索引下推的原则，「用于查询优化，主要是用于like关键字的查询的优化」，什么是索引下推呢？\n\n下面通过演示来说明一下他的概念，还是利用原来的employee测试表，假如我要执行下面的sql进行查询：SELECT \\* from user where name like '张%' and age=40；\n\n假如没有索引下推，执行的过程如下图所示：\n\n![image_f9e7e1af.png](精通Mysql索引/image_f9e7e1af.png)\n\n查询会直接忽略age字段，将name查询的张开头的id=5、id=7的结果返回给Mysql服务器，再执行两次的回表查询。\n\n若是上面的查询操作使用了索引下推，执行的过程如下：\n\n![image_e986da4f.png](精通Mysql索引/image_e986da4f.png)\n\nMysql会将查询条件age=40的查询条件传递给存储引擎，再次过滤掉age=50的数据行，这样回表的次数就变为了一次，提高了查询效率。\n\n总结起来索引下推就是在执行sql查询的时候，会将一部分的索引列的判断条件传递给存储引擎，由存储引擎通过判断是否符合条件，只有符合条件的数据才会返回给Mysql服务器。\n\n### 全文索引 \n\n全文索引也称为全文检索，可以通过以下sql建立全文索引：ALTER TABLE employee ADD FULLTEXT fulltext\\_name(name);或者CREATE INDEX的方式创建。\n\n全文索引主要是针对CHAR、VARCHAR或TEXT这种文本类的字段有效，有人说不也可以使用like关键字来查询文本吗。\n\n普通索引（单列索引）的查询只能加快字段内容中最前面的字符串的检索，若是对于多个单词组成文本的查询普通索引就无能为力了。\n\n索引一经创建就没有办法修改，若是想要修改索引，必须重建，可以使用以下sql来删除索引：DROP INDEX fulltext\\_name ON employee;\n\n### 聚簇索引和非聚簇索引 \n\n聚簇索引和非聚簇索引是相对于存储引擎的概念，范围比较大，包含上面所提到的索引类型。\n\n「聚簇索引就是叶子节点中存储的就是完整的行数据，索引和数据存储在一起；而非聚簇索引的索引文件和数据文件是分开的，所以查询数据会多一次查询」。\n\n因此聚簇索引的查询速度会快于非聚簇索引的查询速度，在Mysql的存储引擎中，「InnoDB支持聚簇索引，MyISAM不支持聚簇索引，MyISAM支持非聚簇索引」。\n\n#### 聚簇索引 \n\n下面我们来看看InnoDB中的聚簇索引，前面说到InnoDB都会有一个主键，该主键就是用于支持聚簇索引，聚簇索引结构图，大致如下图所示：\n\n![image_5661add7.png](精通Mysql索引/image_5661add7.png)\n\nInnoDB中适用于最好的主键选择就是给出一个AUTO\\_INCREMENT的列作为自增的主键，有的人可能会使用UUID作为随机主键。\n\n因为索引要维持有序性，若是使用随机的主键，主键的插入需要寻找合适的位置进行放置，这样维护主键索引树的成本就会变得更高。\n\n相反的，自增主键，主键都是自增变大，在维护主键索引树的成本就会变得更小，随意应该尽量避免随机主键。\n\n#### 非聚簇索引 \n\nMyISAM使用的是非聚簇索引，新插入数据的时候，会按顺序的写入的磁盘中，并且给每一行数据标记一个行号，从小逐渐增大。\n\n![image_36b4ad4c.png](精通Mysql索引/image_36b4ad4c.png)\n\n当MyISAM创建主键索引的时候，形成的主键索引树的结构图如下图所示：\n\n![image_1f0bbe29.png](精通Mysql索引/image_1f0bbe29.png)\n\n在主键索引中，数据也是非空且唯一，主键索引树中存储的是数据行的行号，当查询数据的时候使用主键索引查询需要查询到行号，然后通过行号获取数据。\n\n非主键索引和主键索引一样叶子节点也是存储着行号，唯一的区别就是非主键索引不要求非空、唯一。\n\n我们可以通对比图来对比一下「InnoDB(聚簇索引)」 和 「MyISAM(非聚簇索引)」 的索引数据布局，如下图所示：\n\n![image_fb64a8df.png](精通Mysql索引/image_fb64a8df.png)\n\n说到这里相信应该大家对于\\*\\*「InnoDB(聚簇索引)」\\*\\* 和 「MyISAM(非聚簇索引)」 有了非常清晰的认识和理解，下面是来说一说索引的优化，这个也是和我们日常开发最密切相关的。\n\n## 索引优化 \n\n以个人多年（实际就两年）优化经验来看，Mysql索引优化无非就是以下三点：\n\n1.  最好的利用索引来进行查询\n2.  避免全表扫描\n3.  复杂查询，避免扫描无效的数据\n\n### 优化前提 \n\nExplain关键字是Mysql中sql优化的常用「关键字」，通常都会使用Explain来「查看sql的执行计划，而不用执行sql」，从而快速的找出sql的问题所在。\n\n在讲解Explain之前首先创建需要的「用户表user、角色表role、以及用户角色关系表role\\_user」作为测试用的表：\n\n```java\n// 用户表\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL,\n  `name` varchar(25) DEFAULT NULL,\n  `age` int(11)  NOT NULL DEFAULT 0,\n  `update_time` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `user` (`id`, `name`, `age`,`update_time`) VALUES (1,'张三',23,'2020-12-22 15:27:18'), (2,'李四',24,'2020-06-21 15:27:18'), (3,'王五',25,'2020-07-20 15:27:18');\n\nDROP TABLE IF EXISTS `role`;\nCREATE TABLE `role` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(10) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `index_name` (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `role` (`id`, `name`) VALUES (1,'产品经理'),(2,'技术经理'),(3,'项目总监');\n\nDROP TABLE IF EXISTS `role_user`;\nCREATE TABLE `role_user` (\n  `id` int(11) NOT NULL,\n  `role_id` int(11) NOT NULL,\n  `user_id` int(11) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `index_role_user_id` (`role_id`,`user_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `role_user` (`id`, `role_id`, `user_id`) VALUES (1,2,1),(2,1,2),(3,3,3); \n```\n\n我们首先执行一条sql：explain select \\* from user where id =2;，执行后可以看到执行的结果如下：\n\n![image_6c304aa6.png](精通Mysql索引/image_6c304aa6.png)可以看到这里有12个字段那个且都有对应的值，这就是explain的执行计划，能看懂这个执行计划，你离精通sql优化就不远了，下面就来详细的介绍这12个字段分别表示什么意思。\n\n#### id字段 \n\nid表示执行select查询语句的序号，它是sql执行的顺序的标识，sql按照id从大到小执行，id相同的为一组，从上到下执行。\n\n什么意思呢？例如执行这条sql：explain select \\* from user where id in (select user\\_id from role\\_user);\n\n```java\n+----+-------------+-----------+------------+-------+---------------+--------------------+---------+------+------+----------+-----------------------------------------------------------------------------------+\n| id | select_type | table     | partitions | type  | possible_keys | key                | key_len | ref  | rows | filtered | Extra                                                                             |\n+----+-------------+-----------+------------+-------+---------------+--------------------+---------+------+------+----------+-----------------------------------------------------------------------------------+\n|  1 | SIMPLE      | user      | NULL       | ALL   | PRIMARY       | NULL               | NULL    | NULL |    3 |   100.00 | NULL                                                                              |\n|  1 | SIMPLE      | role_user | NULL       | index | NULL          | index_role_user_id | 8       | NULL |    3 |    33.33 | Using where; Using index; FirstMatch(user); Using join buffer (Block Nested Loop) |\n+----+-------------+-----------+------------+-------+---------------+--------------------+---------+------+------+----------+-----------------------------------------------------------------------------------+\n```\n\n显示出的两者的id都相同，便表示sql的执行从上往下执行，第一条记录对应的是user表，然后第二条记录对应的是role\\_user表，这种是id相同的情况。\n\n若是id不同，例如执行下面的sql：explain select (select 1 from user limit 1) from role;：\n\n```java\n+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+\n| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+\n|  1 | PRIMARY     | role  | NULL       | index | NULL          | index_name | 33      | NULL |    3 |   100.00 | Using index |\n|  2 | SUBQUERY    | user  | NULL       | index | NULL          | PRIMARY    | 4       | NULL |    3 |   100.00 | Using index |\n+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+\n```\n\n就会看到有两条记录，并且两条记录的id会不一样，id越大的就越先执行，可以看到id=2的执行的是user表，也就是子查询部分，最后执行最外层的部分。\n\n「结论：」 这个就是id标识sql的执行顺序，一般在复杂查询中会有多条记录，简单查询只有一条记录，复杂查询中id相同的为一组，执行的顺序是从上往下，而id越大的越先执行；Mysql 8中会存在对子查询进行优化，所以有时候即使是复杂查询，也只有一条记录。\n\n#### select\\_type字段 \n\nselect\\_type表示查询的类型，也就是对应的是简单查询还是复杂查询，若是复杂查询又包含：「简单的子查询、from子句的子查询、union查询」。下面就分别来看看select\\_type中的所有查询类型。\n\n *  simplesimple表示简单查询，不含有任何的复杂查询。![image_354ee4ca.png](精通Mysql索引/image_354ee4ca.png)\n *  PRIMARY复杂查询中「最外层的select语句的查询类型就是PRIMARY」，例如执行下面的sql：explain select \\* from role where id = (select id from role\\_user where role\\_id = (select id from user where id = 2));![image_33774441.png](精通Mysql索引/image_33774441.png)最外层的select，也就是select \\* from role where id =？会被标记为PRIMARY类型。\n *  SUBQUERY在「select或者where中包含的子查询」会被表示为SUBQUERY类型，例如上一句执行的sql中就有两次的子查询为SUBQUERY。![image_506be7f7.png](精通Mysql索引/image_506be7f7.png)\n *  DERIVED「DERIVED表示的是派生表或者衍生表的意思，在from包含的子查询中会被表示为DERIVED类型」，Mysql会递归执行这些子查询，并且把结果放在临时表中。执行sql：explain select \\* from (select name from user union select name from role) a where a.name = '张三';![image_5f5f8f2e.png](精通Mysql索引/image_5f5f8f2e.png)在Mysql 5.7以上的版本中对其做了优化，新增了derived\\_merge(派生合并)，可以加快查询效率。\n *  UNION在出现「UNION查询语句中，第二个select的查询语句就会被表示为UNION」：![image_41ed6d48.png](精通Mysql索引/image_41ed6d48.png)\n *  UNION RESULT「UNION查询语句的结果被标记为UNION RESULT」，如上面执行的sql：explain select \\* from (select name from user union select name from role) a where a.name = '张三';![image_6b8b2a8d.png](精通Mysql索引/image_6b8b2a8d.png)第四行记录中从table字段中可以看出，第四行的记录来源于第二行和第三行<union2,3>，因此一个UNION查询语句的结果就会被标记为UNION RESULT\n *  DEPENDENT UNION：也表示UNION查询语句中第二个或者后面的语句，但是取决于外面的查询。\n *  DEPENDENT SUBQUERY：子查询中的第一个select语句，也是依赖于外部的查询。\n *  UNCACHEABLE SUBQUERY：子查询的结果不能被缓存，必须重新评估外连接的第一行。\n\n#### table字段 \n\n这个很容易看出「table字段表示的是查询的是哪个表」，一个是已经存在的表，比如上面的user、role都是我们自己创建的表，也可以表示衍生表。\n\n比如：UNION RESULT的table字段表示为<union2,3>，也就是查询的是第二行和第三行的结果记录。\n\n#### type字段 \n\n「type字段表示的sql关联的类型或者说是访问的类型」。从这个字段中我们可以确定这条sql查找数据库表的时候，查找记录的大概范围是怎么样的，直接就能体现sql的效率问题。\n\ntype字段的类型也是有比较多，主要常见掌握的有以下几个：system、const 、eq\\_ref 、ref 、range 、index 、ALL。它的性能体现是从高到低，即system > const > eq\\_ref > ref > range > index > ALL，下面就来详细的说一说这属性。\n\n##### system \n\nsystem是const的特例，「表示表中只有一行记录」，这个几乎不会出现，也作为了解。\n\n##### const \n\nconst表示通过索引一次就查找到了数据，一般const出现在「唯一索引或者主键索引中使用等值查询」，因为表中只有一条数据匹配，所以查找的速度很快。例子：explain select \\* from user where id =2;\n\n![image_0c7be26a.png](精通Mysql索引/image_0c7be26a.png)\n\n##### eq\\_ref \n\neq\\_ref表示使用唯一索引或者主键索引扫描作为表链接匹配条件，对于每一个索引键，表中只有一条记录与之匹配。例如：explain select \\* from user left join role\\_user on user.id = role\\_user.user\\_id left join role on role\\_user.role\\_id=role.id;\n\n![image_19f2ed1c.png](精通Mysql索引/image_19f2ed1c.png)\n\n##### ref \n\nref性能比eq\\_ref差，也表示表的链接匹配条件，也就是使用哪些表字段作为查询索引列上的值，ref与eq\\_ref的区别就是eq\\_ref使用的是唯一索引或者主键索引。\n\nref扫描后的结果可能会找到多条符合条件的行数据，本质上是一种索引访问，返回匹配的行。例如：explain select \\* from user where name = '张三';\n\n![image_471404dc.png](精通Mysql索引/image_471404dc.png)\n\n##### range \n\n「range使用索引来检索给定范围的行数据，一般是在where后面使用between、<>、in等查询语句就会出现range」：explain select \\* from user where id > 2;\n\n![image_00bb0428.png](精通Mysql索引/image_00bb0428.png)\n\n##### index \n\nindex表示会遍历索引树，index回避ALL速度快一些，但是出现index说明需要检查自己的索引是否使用正确：explain select id from user;\n\n![image_a669396a.png](精通Mysql索引/image_a669396a.png)\n\n##### ALL \n\n「ALL与index的区别就是ALL是从硬盘中读取，而index是从索引文件中读取」，ALL全表扫描意味着Mysql会从表的头到尾进行扫描，这时候表示通常需要增加索引来进行优化了，或者说是查询中并没有使用索引作为条件进行查询：explain select \\* from user;\n\n![image_8d791fe4.png](精通Mysql索引/image_8d791fe4.png)\n\n#### possible\\_keys字段 \n\npossible\\_keys表示这一列查询语句可能使用到的索引，仅仅只是可能，列出来的索引并不一定真正的使用到。\n\n当没有使用索引为NULL时，说明需要增加索引来优化查询了，若是表的数据比较少的话，数据库觉得全表扫描更快，也可能为NULL。\n\n#### key字段 \n\nkey字段与possible\\_keys的区别就是，表示的真正使用到的索引，即possible\\_keys中包含key的值。\n\n若是想Mysql使用或者忽视possible\\_keys中的索引，可以使用FORCE INDEX、USE INDEX或者IGNORE INDEX。\n\n#### key\\_len字段 \n\n表示sql查询语句中索引使用到的字节数，这个字节数并不是实际的长度，而是通过计算查询中使用到的索引中的长度得出来的，显示的是索引字段最大的可能长度。\n\n一般来说在不损失精度的前提下，key\\_len是越小越好，比如上面的测试表的id为int类型，int类型由4个字节组成：explain select \\* from user where id =2;\n\n![image_66710eac.png](精通Mysql索引/image_66710eac.png)\n\nkey\\_len对于不同的类型有自己的计算规则，具体的计算规则如下所示：\n\n![image_248c75e6.png](精通Mysql索引/image_248c75e6.png)若是索引为字符串类型的时候，实际存储的字符串非常长，已经超出了字符串类型的存储最大长度（768字节），mysql，就会使用类似左前缀索引来处理。\n\n#### ref字段 \n\nref表示列与索引的比较，表连接的匹配条件，表示哪些列或者常量被用于查询索引列上的值。\n\n#### rows字段 \n\nrows表示估算的要扫描的行数，一般Mysql会根据统计表信息和索引的选用情况，估算出 查找记录所要扫描的行数，注意这个并不是实际结果集的行数。\n\n#### partitions、filtered字段 \n\npartitions表示所匹配的分区；filtered表示的是查询表行所占表的百分比。\n\n#### Extra字段 \n\n该字段显示的是sql查询的额外信息，主要有以下几种情况：\n\n##### Using index \n\n表示查询的列被索引覆盖，这个是查询性能比较高的体现，即所要查询的信息搜在索引里面可以得到，不用回表，索引被正确的使用：explain select id from user where id =2;\n\n![image_af5b5697.png](精通Mysql索引/image_af5b5697.png)\n\n假如同时出现了using where，表示索引用于执行索引键值的查找；若是没有出现using where，则表示索引用于读取数据，而非执行查询的动作。\n\n##### Using where \n\n该属性与Using index相反，查询的列并没有被索引覆盖，where条件后面使用的是非索引的前导列，它仅仅是使用了where条件而已：explain select user.\\* from user,role,role\\_user where user.id = role\\_user.user\\_id and role.id=role\\_user.role\\_id;\n\n![image_4925de1e.png](精通Mysql索引/image_4925de1e.png)\n\n##### Using temporary \n\n「Using temporary表示使用了临时表存储中间的结果，一般在对结果排序的时候会使用临时表」，例如：排序order by 和分组查询group by。例子：explain select \\* from (select name from user union select name from role) a where a.name = '张三';\n\n![image_ccf98553.png](精通Mysql索引/image_ccf98553.png)\n\n##### Using filesort \n\nUsing filesort表示文件排序，说明Mysql对数据使用了外部的索引进行排序，并没有使用表中的索引进行排序：explain select \\* from user order by name;\n\n##### Using join buffer \n\nUsing join buffer表示使用连接缓存：explain select user.\\* from user,role,role\\_user where user.id = role\\_user.user\\_id and role.id=role\\_user.role\\_id;\n\n![image_f552bbb6.png](精通Mysql索引/image_f552bbb6.png)\n\n它强调在获取连接条件时，并没有使用索引，而是使用连接缓冲区来存储中间结果，若是出现该值，一般说明需要添加索引来进行优化了。\n\n##### Impossible where \n\nImpossible where会出现在where后的条件一直为false的情况下，这种可以忽视，比较少出现：explain select \\* from user where name = 'hah' and name = 'sfsd';\n\n![image_3c03677f.png](精通Mysql索引/image_3c03677f.png)\n\n##### Select tables optimized away \n\n表示select语句没有遍历表或者索引就返回数据了，比如：explain select min(id) from user;\n\n![image_417b1a31.png](精通Mysql索引/image_417b1a31.png)\n\n在Extra字段中还有其它的属性，但是几乎都没见过的，不出现，所以哪些就讲解，有兴趣的可以自己去了解，这里只列出这些常见的。\n\n### 总结 \n\n下面我来总结一下要正确的使用索引的一些规则。要正确的创建索引，用索引正确的查询，不要使索引失效，因此索引的设计和优化的原则应该遵循下面的几个原则：\n\n1.  索引列不要在表达式中出现，这样会导致索引失效。如：「SELECT ...... WHERE id+1=5」;\n2.  索引列不要作为函数的参数使用。\n3.  索引列尽量不要使用like关键字。如：「SELECT ...... WHERE name like '%d%'」。可以使用Mysql内置的函数INSTR(str,substr) 来匹配，查询字符串出现的下表的位置；也可以是使用FullText全文索引，用match against 检索;假如数据量非常大的话建议使用es或者solr来替代。\n4.  数字型的索引列不要当作字符串类型进行条件查询。如：「SELECT ...... WHERE id = '35'」;\n5.  尽量不要在条件not in、<>、!= 、or 中使用索引，其中in关键字也要慎重使用，在控制in条件的数量在1000以内，如果in后面的条件太多，会导致全表扫描，这个在阿里巴巴的开发手册也有说明；建议使用between来替代in或者使用子查询exists代替；or关键字建议使用union来替代优化。\n6.  建表规范不建议在表中默认值是null的情况，一般建表都会一个默认值，比如0或者空字符串，防止出现一些空指针的现象。\n7.  在索引列的字段中不要出现NULL值，NULL值会使索引失效，可以用特殊的字符比如空字符串' '或者0来代替NULL值。\n8.  联合索引的查询应该遵循最左前缀原则。\n9.  一般对于区别性比较大的字段建立索引，在联合索引中区别性比较大（识别度比较高）放在最前面，提高索引的命中率，在mybatis的xml文件中多条件where查询时，命中索引的条件放在前面，能使用联合索引就不要使用单列索引。\n10.  where、order by 、 group by后面的条件尽量使用索引进行优化 ，可以使用exlpain对查询进行优化。\n11.  复杂查询中建议使用inner on来做关联，因为在mysql优化器中inner on会有限使用小表关联大表，on后面的条件要建立索引，左关联和右关联应该遵循小表带大表的规则。\n12.  微服务分布式系统下的库表设计原则不要进行跨库的join操作，一个库的数据量若是比较大，应该减少或者尽量不要join操作，要进行join操作应该避免join的无效的数据，保持接口的单一原则，减少join操作的方法可以字段冗余，对于一些很久都不会改变的字段，可以考虑冗余，从而减少join操作，阿里巴巴的手册中也有提到，不允许超过三个join，宁愿分多次查询。\n13.  业务优化考虑原则：读多写少场景或者读少写多场景，一般互联网的都是读多写少场景，对于一些需要进行统计的字段，比如一些首页报表、数据面板，需要大量统计的接口，尽量减少Mysql来进行统计，避免慢sql，优化的方法，可以牺牲部分写的性能来提升读的新能，提前在写入的时候通过异步的方式进行统计（比如统计当前月的积分，一年的绩效等数据），有些数据量涉及的数据本身比较大，如果用Mysql的进行查询的时候统计，那必然导致慢sql。\n14.  查询优化对于多次同步调用服务的接口可以通过异步的的方式进行调用，减少接口的响应时间。\n15.  索引的大小要适度，不易过大，避免索引的冗余。","source":"_posts/精通Mysql索引.md","raw":"---\ntitle: 精通Mysql索引\ntop: false\ncover: false\ntoc: true\nmathjax: true\nsummary: 精通Mysql索引\ndate: 2022-11-14 16:40:48\npassword:\ntags:\n    - 索引\ncategories:\n    - mysql\n---\n## 索引概念 \n\n概念：索引是提高mysql查询效率的数据结构。总的一句话概括就是索引是一种提高查询效率的数据结构。\n\n数据库查询是数据库的最主要功能之一。设计者们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。\n\n最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如：有顺序查找、折半查找、快速查找等。\n\n但是，每种查找算法都只能应用于特定的数据结构之上，例如顺序查找依赖于顺序结构，折半查找通过二叉查找树或红黑树实现二分搜索。\n\n因此，在数据之外，数据库系统还维护着满足特定查找算法的数据结构。这种数据结构，就是索引。\n\n## 索引性能分析 \n\n目前，大多数数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。B+ 树索引是 B+ 树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。\n\n从最早的平衡二叉树演化而来的。B+ 树是由二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree）逐步优化而来。\n\n那么为什么mysql的索引选择B+数呢？\n\n有序数组、Hash索引、红黑树、二叉查找树、AVL树也可以作为数据结构也可以用来实现索引，但是文件系统以及数据库系统普遍采用B树或者B+树，这里结合各个索引的特点以及计算的组成原理来深入的分析。\n\n但是，对于Mysql来说适合它的才是最好的查询，一方面要实现高效的查询，除了简单的条件查询，还要支持有序的高效索引的范围查询、分组。\n\n有序数组在等值查询和范围查询性能都是非常好的，那为什么又不用有序数组作为索引呢？因为对于数组而言作为索引更新的成本太高，新增数据要把后面的数据都往后移一位，所以也不采用有序数组作为索引的底层实现。\n\nhash是以key-value的形式进行存储，适合于等值查询的场景，查询的时间复杂度为O(1)，因为hash储存并不是有序的，所以对于范围查询就可能要遍历所有数据进行查询，而且不同值的计算还会出现hash冲突，所以hash并不适合于做Mysql的索引。\n\n另一方面就是除了查询的效率要高，还要有高效的读取数据效率（io），我们都知道计算机的随机磁盘io效率是非常低下的。\n\n那么为什么硬盘的存取会如此的慢呢？\n\n这个就要讲硬盘的读写原理，硬盘有很多种，但是都是由盘片、磁头、盘片主轴、控制电机、磁头控制器、数据转换器、接口、缓存等几个部分组成。\n\n所有的盘片都固定在一条轴上，那条轴叫做盘片主轴，所有的盘片都是绝对平行的，也形成一个柱体，每个盘片上都有一个磁头，每个磁头都在同一轴线上，就是从上方往下看，磁头是绝对重叠的。\n\n所有的磁头连在一个磁头控制器上，由磁头控制器负责各个磁头的运动，磁头可沿盘片的半径方向移动，实际上是斜切运动，每个磁头同一时刻必须是同轴的盘片以每分钟数千转到上万转的速度在高速运转，这样磁头就能对盘片上的指定位置进行数据的读写操作：\n\n![image_2c3f6cae.png](精通Mysql索引/image_2c3f6cae.png)\n\n磁盘数据的读写原理\n\n盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。\n\n磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。\n\n当磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。\n\n为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。\n\n即一次磁盘的读写操作完成过程由三个动作组成：\n\n *  寻道（时间）：磁头移动定位到指定磁道。\n *  旋转延迟（时间）：等待指定扇区从磁头下旋转经过。\n *  数据传输（时间）：数据在磁盘与内存之间的实际传输\n\n> 额外知识：\n>\n>  *  盘面：硬盘的每一个盘片都有上下两个盘面，一般每个盘面都会得到利用，都可以存储数据，盘面号又叫磁头号，因为每一个有效盘面都有一个对应的读写磁头。\n>  *  磁道：磁盘在格式化时被划分成许多同心圆，这些同心圆轨迹叫做磁道，磁道从外向内从 0 开始顺序编号，信息以脉冲串的形式记录在这些轨迹中，这些同心圆不是连续记录数据，而是被划分成一段段的圆弧。\n>  *  所有盘面上的同一磁道构成一个圆柱，通常称作柱面。所有盘面上的同一磁道构成一个圆柱，通常称作柱面。数据的读 / 写按柱面进行，而不按盘面进行，当一个磁道写满数据后，就在同一柱面的下一个盘面来写，一个柱面写满后，才移到下一个扇区开始写数据，读数据也按照这种方式进行，这样就提高了硬盘的读 / 写效率。\n\n提高磁盘数据读写原理\n\n局部性原理与磁盘预读。由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。\n\n为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。\n\n这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。\n\n所以，程序运行期间所需要的数据通常应当比较集中。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。\n\n预读的长度一般为页（page）4k的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4k），主存和磁盘以页为单位交换数据。\n\n当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。\n\n> 所以，硬盘中由于涉及到机械运动，所以一次的磁盘IO消耗的时间是非常大的，于内存的读取速度相比，就好比光速与声速的比较。\n\n因此，假如内存条件允许的话，Mysql巴不得把所有的数据一次性加载到内存中进行读写。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。\n\n服务器的内存的大小也是限制的，一个服务器中可能不止跑着Mysql一个进行，多多少少都有可能二三十个进行，每个进行都需要操作系统分配内存。\n\n这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，硬盘I/O存取的消耗要高几个数量级，查找过程中磁盘I/O的存取次数。\n\nMysql中的一些大的数据表，一个表就有可能几个G，索引结构也很大，那服务器内存不得撑爆了。\n\n所以，必须做一个取舍，在内存与磁盘中进行衡量，数据尽量放在内存中，而在少量的数据在磁盘中，读取磁盘的次数控制到最少，也就是对于Mysql的性能影响到最小，加上磁盘数据读写原理来提高数据的读取效率。\n\n那么在众多树的条件下，B+树又是以怎么样的又是脱颖而出呢？下面我们来聊一聊B树、B-树、B+树、红黑树性能。\n\n二叉树、红黑树、AVL树、B树、B+树性能分析\n\nB树性能分析：B树是二叉查找平衡树，但是B树一个节点只存一个关键字，在大量数据的时候，B树树高非常大，性能低下：\n\n![image_f327aac4.png](精通Mysql索引/image_f327aac4.png)\n\n甚至在极端的情况下，因为二叉搜索树不存在平衡算法，所以在某些特殊的情况下，二叉搜索树等同于线性，出现蹩脚的情况，设计者们发现降低树的高度自然就可以提高查找效率：\n\n![image_c1987417.png](精通Mysql索引/image_c1987417.png)\n\n红黑树和AVL树是在二叉树的基础上机上加上平衡算法，红黑树确保没有一条路径会比其它路径长出两倍，它是弱平衡树而AVL是严格的平衡，所以相对于二叉树的蹩脚情况做了很大的改进，加入了平衡算法：\n\n![image_700a6b0b.png](精通Mysql索引/image_700a6b0b.png)\n\n但是，同样还是存在数据量大导致树非常高的问题，所以现在的目标就是压缩树的高度。\n\nB树基于减少树的高度上，B树是一种多路搜索树，每个节点都可以有多于两个子节点，并不是二叉的：\n\n![image_4d67662e.png](精通Mysql索引/image_4d67662e.png)\n\nB树与B+树最大的区别就是B的非叶子节点可以存储数据，而B+树只有叶子结点才可以存储数据，B树是多路搜索树，一个节点可以存储很多数据，所以B树的高度大大减小。\n\n但是B树相对于B+树来说，在查找数据的时候，由于每一个节点都有可能包含目标数据，所以查找总是从根节点进行向下搜索，这个特点会带来大量的随机io。\n\n而在B+树种，因为叶子结点才会存储数据（InnoDB），这样子相比B树一个页大小存储的索引数据就更多了（16K），并且叶子结点通过双向指针指向相邻的节点，依次连接。\n\n并且相邻结点是有序的，所以对于范围查找是非常方便的，获取到第一个符合条件的，然后通过指针，往后获取数据，直到最后一个不满足条件为止。\n\n所以总结来说：B+树是多叉树，一个数据页的大小是16kb，在1-3的树高就能存储10亿级以上的数据，也就是只要访问磁盘1-3次就足够了，并且B+树的叶子结点上一个叶子结点有指针指向下一个叶子结点，便于范围查询：\n\n![image_275a1cfe.png](精通Mysql索引/image_275a1cfe.png)\n\n下面我们来详细的聊一聊Mysql索引B+树查询原理。\n\n## B+树索引原理 \n\n上面也大概说了一下B+树的介绍，在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。\n\n在B+树的结构中，只在叶子节点存储数据，在非叶子节点中只存储的索引，在非叶子节点中可以有更大的空间储存更多的索引，这样B+树的出度d就可以大大的增加，从而降低的B+树的高度h，B树中一个节点的大小为一个page的大小，也就是一次IO的读取，h越小IO的次数就可以减少：\n\ndmax=floor(pagesize/(keysize+datasize+pointsize))\n\nfloor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。\n\n我们来看看B+树的搜索过程，Mysql的InnoDB的索引的结构如下图所示，假设我们要搜索id为15的数据：\n\n![image_5bee3c9f.png](精通Mysql索引/image_5bee3c9f.png)\n\n1.  根据根节点找到磁盘块 1，读入内存，一般根节点也会常驻内存，甚至可以省略一次磁盘IO操作。【磁盘 I/O 操作第 1 次】\n2.  比较id 15在区间28的左边，于是根据p1找到磁盘2。\n3.  将磁盘2读入内存，查找结果15在（10,17）之间。【磁盘 I/O 操作第 2 次】\n4.  然后根据磁盘2的指针p2找到磁盘块5，读入内存。【磁盘 I/O 操作第 3 次】\n5.  最后根据id=15找到对应的数据，返回结果。\n\n所以根据上面的查找只需要至多三次的磁盘IO就可以找到对应的数据。从上面的B+树的原理图中非叶子节点构成了类似于一个一个目录一样，也可以叫做索引页，最后找到叶子结点的数据。\n\n在MySQL中，不同存储引擎对索引的实现方式是不同的，Mysql有MyISAM和InnoDB两个存储引擎的索引实现方式，下面就来分别介绍这两种存储引擎。\n\n### MyISAM \n\n在MyISAM储存引擎中，数据和索引文件是分开储存的，Myisam 的存储文件有三个，后缀名分别是 .frm、.MYD、MYI，其中 .frm 是表的定义文件，.MYD 是数据文件，.MYI 是索引文件。\n\n![image_e6679248.png](精通Mysql索引/image_e6679248.png)\n\nMyisam 只支持表锁，且不支持事务。Myisam 由于有单独的索引文件，在读取数据方面的性能很高 。\n\nMyisam 也是B+树结构，但是MyISAM索引的叶子节点的数据保存的是行数据的地址。因此，MyISAM中索引检索的算法首先在索引树中找到行数据的地址，然后根据地址找到对应的行数据。\n\n![image_f50b3c32.png](精通Mysql索引/image_f50b3c32.png)\n\n可以看出MyISAM的索引文件仅仅保存数据记录的地址。主键索引和辅助索引，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的如下图：\n\n![image_3e3d131e.png](精通Mysql索引/image_3e3d131e.png)\n\nMyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。\n\n### InnoDB \n\n在InnoDB中，数据和索引文件是合起来储存的，如图所示，InnoDB 的存储文件有两个，后缀名分别是 .frm 和 .idb，其中 .frm 是表的定义文件，而 idb 是数据文件。\n\n![image_5eb3208c.png](精通Mysql索引/image_5eb3208c.png)\n\n在InnoDB虽然底层也是B+树实现的方式，当时与MyISAM却有明显的区别，在InnoDB实现的索引结构中，索引文件和数据文件是一起的，InnoDB中索引文件中的key就是数据表中的主键索引，因此InnoDB的索引文件也是主索引文件。如下图所示：\n\n![image_33b5701e.png](精通Mysql索引/image_33b5701e.png)\n\n如果给另一个字段指定为普通索引，则普通索引树的结构如下图所示：\n\n![image_cee886ce.png](精通Mysql索引/image_cee886ce.png)\n\n所以，当查询不是按照主键查询时候就会先在辅助索引树上先找到主键的值，然后再到主索引树找到对应的行数据的值，这叫做回表，回表降低了表的查询效率。\n\n## Mysql索引种类 \n\nMysql中索引的种类也不是很多，不同类型的索引有不同的作用，索引的作用相互之间也存在交叉关系，Mysql中索引主要分为以下几类：\n\n1.  「主键索引」（PRIMARY KEY）：主键索引一般都是在创建表的时候指定，「一个表只有一个主键索引」，特点是「唯一、非空」。\n2.  「唯一索引」（UNIQUE）：唯一索引具有的特点就是唯一性，可以在创建表的时候指定，也可以在创建表后创建。\n3.  「普通索引」（INDEX）：普通索引唯一的作用就是加快查询。\n4.  「组合索引」（ INDEX）：组合索引是创建一个「多个字段的索引」，这个概念是相对于上上面的单列索引而言，组合索引查询遵循「最左前缀原则」。\n5.  「全文索引」（FULLTEXT）：全文索引是针对一些大的「文本字段」创建的索引，也称为「全文检索」。\n6.  「聚簇索引」和「非聚簇索引」：聚簇索引和非聚簇索引的概念比上面的概念要大，属于包含和被包含的关系。例如：InnoDB中主键索引使用的就是聚簇索引。\n\n若是你想查看一个表的所有索引，可以执行下面的sql来查看：\n\n```java\nshow index from 表名\n```\n\n例如，查看我自己的测试表里面的索引，如下图所示，Key\\_name表示索引的名字，Column\\_name表示索引的字段：\n\n![image_4030cc20.png](精通Mysql索引/image_4030cc20.png)\n\n### 主键索引 \n\n主键索引在InnoDB存储引擎中是最常见的索引类型，一个表都会有一个主键索引，它索引的字段不允许为空值，并且唯一。\n\n一般是在创建表的时候，可以通过RIMARY KEY指定主键索引，在InnoDB存储引擎中，若是创建表的时候没有主观创建主键索引，Mysql就会看表中是否有唯一索引，有，就会指定「非空的唯一索引」为主键索引\n\n若是没有唯一索引，就会默认生成一个6byte空间的自动增长主键作为主键索引，可以通过select \\_rowid from 表名查询的是对应的主键值.。\n\nMyISAM储存引擎是可以不存在主键索引，MyISAM和InnoDB储存数据的结构方式还是有明显的区别，这个后面篇章会详细讲解。\n\n### 唯一索引 \n\n唯一索引与主键索引的区别就是，唯一索引允许为空，若是在组合索引中，只要创建的列值是唯一的\n\n唯一索引在实际中更多的是用来保证数据的唯一性，假如你仅仅要数据能够快速查询，你也可以使用普通索引，所以唯一索引重在体现它的唯一性。\n\n实际的业务场景，有些库表字段要求唯一，就可以使用唯一索引，创建唯一索引的方式有三种。\n\n（1）一个是在创建表的时候指定，如下sql：\n\n```java\nCREATE TABLE user( \n id INT PRIMARY KEY NOT NULL, \n name VARCHAR(16) NOT NULL, \n UNIQUE unique_name (name(10)) \n);\n```\n\n（2）也可以在表创建后创建，如下sql：\n\n```java\nCREATE UNIQUE INDEX unique_name ON user(name(10))；\n```\n\n（3）通过修改表结构创建，如下sql：\n\n```java\nALTER user ADD UNIQUE unique_name ON (name(10))\n```\n\n这里有一个细节要注意的是创建的name字段，指定的长度是16字符，而创建的索引的长度制定的是10字符，因为也没有人的名字长度会超过10个字符，所以减少索引长度，能够减少索引所占的空间的大小。\n\n### 普通索引 \n\n普通索引的唯一作用就是加快数据的查询，一般对查询语句WHERE和ORDER BY后面的字段创建普通索引。\n\n创建普通索引的方式也有三种，基本和创建唯一索引的方式一样，只是把关键字UNIQUE换成INDEX，如下所示：\n\n```java\n// 创建表的时候创建\nCREATE TABLE user( \n id INT PRIMARY KEY NOT NULL, \n name VARCHAR(16) NOT NULL, \n INDEX index_name (name(10)) \n);\n// 创建表后创建\nCREATE INDEX INDEX index_name ON user(name(10))；\n// 修改表结构创建\nALTER user ADD INDEX index_name ON (name(10))\n```\n\n若是想删除索引，可以通过执行下面的sql进行删除索引：\n\n```java\nDROP INDEX index_name ON user;\n```\n\n### 组合索引 \n\n组合索引即用多个字段创建一个索引，组合索引能够避免「回表查询」，相对于多字段的单列索引，组合索引的查询效率更高。\n\n创建组合索引(联合索引)的方式和上面创建普通索引的方式一样，只不过字段的数目多了，如下sql创建：\n\n```java\n// 其它方式和上面的一样，这里就只列举修改表结构的方式创建\nALTER TABLE employee ADD INDEX name_age_sex (name(10),age,sex);\n```\n\n#### 回表查询 \n\n什么是回表查询呢？回表查询简单来说「通过二级索引查询数据，得不到完整的数据行，需要再次查询主键索引来获得数据行」。\n\nInnoDB存储引擎中，索引分为 「聚簇索引」和「二级索引」，主键索引就是聚簇索引，其它的索引为二级索引。\n\n聚簇索引中的叶子节点保存着完整的数据行，而二级索引的叶子节点并不是保存完整的数据行。\n\n上面提到InnoDB表是一定要有主键索引的，虽然索引占据空间，但是索引符合二分查找的算法，查找数据非常的快。\n\n假设还是上面的employee表，里面有主键索引id，和普通的索引name，那么在InnoDB中就会存在两棵B+Tree，一棵是主键索引树：\n\n![image_ea5a8c1e.png](精通Mysql索引/image_ea5a8c1e.png)\n\n在主键索引树中的叶子节点存储的是完整的数据行，另外一棵是name字段的二级索引树，如下图所示：\n\n![image_73608ecd.png](精通Mysql索引/image_73608ecd.png)\n\n倘若你执行这条sql：select name, age, sex from employee where name ='as';就会先执行二级索引的查询，当查询name='as'时，得到主键为50，再根据主键查询主键索引树，得到完整的数据行，具体的执行流程如下：\n\n![image_6bcc4698.png](精通Mysql索引/image_6bcc4698.png)\n\n这个就是回表查询，回表查询会查询两次，这样就会降低查询的效率，为了避免回表查询，只查询一次就能得到完整的数据呢？\n\n#### 索引覆盖 \n\n常见的方式就是「建立组合索引（联合索引）「进行」索引覆盖」，什么是索引覆盖呢？索引覆盖就是「索引的叶子节点已经包含了查询的数据，没必要再回表进行查询。」\n\n假如我还是执行如下sql：select name, age, sex from employee where name ='as';因为普通索引只有name字段才建立了索引，这必然会导致回表查询。\n\n为了提高查询效率，就(name)「单列索引升级为联合索引」(name, age, sex)就不同了。\n\n因为建立的联合索引，在二级节点的叶子阶段就会同时存在name, age, sex三个的值，一次性就会获得所需要的数据，这样就避免了回表，但是所有的方案都不是完美的。\n\n若是这个联合索引哪一天某一个数据行的name值改变了或者age改变了，我就需要同时维护主键索引和联合索引两棵树，这样的维护成本就高了，性能开销也大了。\n\n相比之前数据的改变，我只需要维护主键索引即可，联合索引的创建就导致了需要同时维护两棵树，这样就会影响插入、更新数据的操作，所以并没有哪种方案是完美的。\n\n#### 最左前缀原则 \n\n我们知道单列索引是按照索引列有序性的进行组织B+Tree结构的，联合索引又是怎么组织B+Tree呢？\n\n联合索引其实也是按照创建索引的时候，最左边的进行最开始的排序，也就是「最左前缀原则」，比如一个表中有如下数据：\n\n![image_d3894bcc.png](精通Mysql索引/image_d3894bcc.png)\n\n如上图所示，对于联合索引中name字段是放在最前面的，所以name是完全有序的，但是age字段就不是有序的，只有当name相同，例如：name='bc'此时age字段的索引排序才是完全有序的。\n\n所以你会发现，在联合索引中你只有使用以下的规则的方式查询才会使用到索引：\n\n *  name,age,sex\n *  name,age\n *  name\n\n因为Mysql的底层有查询优化器，会判断sql执行的时候若是使用全表扫描的效率比使用索引的效率更高，就会使用全表扫描。\n\n假如，我查询的时候使用age>=23,sex='男';两个字段作为查询条件，但是没有使用name字段，因为在name不知情的条件下，对于age是无序的。\n\n对于age>=23条件可能在很多的name不同中都有符合条件的出现，所以就没有办法使用索引，这也是索引实现的原因，一定要遵循「查找有序，充分的利用索引的有序性」。\n\n假如你是分别在name，age，sex三个字段中分别建立三个单列索引，就相当于建立三颗索引树，那么它的查询效率，比我们使用一棵索引树查询效率就可想而知了。\n\n有一种情况即使使用到了最左边的name字段也不会使用索引，例如：WHERE name like '%d%'；这种like条件的模糊查询是会使索引失效。\n\n我们可以这样理解，「查询字符串也是遵循最左前缀原则的」，字符串的查询是对字符串里面的字符一个一个的匹配，「若是字符串最左边为%表示一个不确定的字符串，那么是没办法利用到索引的有序性」。\n\n但是若是修改为 ：WHERE name like 'd%'；就可以使用索引，因为最左边的字符串是确定的，这种称为「匹配列前缀」。\n\n实际业务场景中联合索引的创建，「我们应该把识别度比较高的字段放在前面，提高索引的命中率，充分的利用索引」。\n\n#### 索引下推 \n\nMysql5.6版本提出了索引下推的原则，「用于查询优化，主要是用于like关键字的查询的优化」，什么是索引下推呢？\n\n下面通过演示来说明一下他的概念，还是利用原来的employee测试表，假如我要执行下面的sql进行查询：SELECT \\* from user where name like '张%' and age=40；\n\n假如没有索引下推，执行的过程如下图所示：\n\n![image_f9e7e1af.png](精通Mysql索引/image_f9e7e1af.png)\n\n查询会直接忽略age字段，将name查询的张开头的id=5、id=7的结果返回给Mysql服务器，再执行两次的回表查询。\n\n若是上面的查询操作使用了索引下推，执行的过程如下：\n\n![image_e986da4f.png](精通Mysql索引/image_e986da4f.png)\n\nMysql会将查询条件age=40的查询条件传递给存储引擎，再次过滤掉age=50的数据行，这样回表的次数就变为了一次，提高了查询效率。\n\n总结起来索引下推就是在执行sql查询的时候，会将一部分的索引列的判断条件传递给存储引擎，由存储引擎通过判断是否符合条件，只有符合条件的数据才会返回给Mysql服务器。\n\n### 全文索引 \n\n全文索引也称为全文检索，可以通过以下sql建立全文索引：ALTER TABLE employee ADD FULLTEXT fulltext\\_name(name);或者CREATE INDEX的方式创建。\n\n全文索引主要是针对CHAR、VARCHAR或TEXT这种文本类的字段有效，有人说不也可以使用like关键字来查询文本吗。\n\n普通索引（单列索引）的查询只能加快字段内容中最前面的字符串的检索，若是对于多个单词组成文本的查询普通索引就无能为力了。\n\n索引一经创建就没有办法修改，若是想要修改索引，必须重建，可以使用以下sql来删除索引：DROP INDEX fulltext\\_name ON employee;\n\n### 聚簇索引和非聚簇索引 \n\n聚簇索引和非聚簇索引是相对于存储引擎的概念，范围比较大，包含上面所提到的索引类型。\n\n「聚簇索引就是叶子节点中存储的就是完整的行数据，索引和数据存储在一起；而非聚簇索引的索引文件和数据文件是分开的，所以查询数据会多一次查询」。\n\n因此聚簇索引的查询速度会快于非聚簇索引的查询速度，在Mysql的存储引擎中，「InnoDB支持聚簇索引，MyISAM不支持聚簇索引，MyISAM支持非聚簇索引」。\n\n#### 聚簇索引 \n\n下面我们来看看InnoDB中的聚簇索引，前面说到InnoDB都会有一个主键，该主键就是用于支持聚簇索引，聚簇索引结构图，大致如下图所示：\n\n![image_5661add7.png](精通Mysql索引/image_5661add7.png)\n\nInnoDB中适用于最好的主键选择就是给出一个AUTO\\_INCREMENT的列作为自增的主键，有的人可能会使用UUID作为随机主键。\n\n因为索引要维持有序性，若是使用随机的主键，主键的插入需要寻找合适的位置进行放置，这样维护主键索引树的成本就会变得更高。\n\n相反的，自增主键，主键都是自增变大，在维护主键索引树的成本就会变得更小，随意应该尽量避免随机主键。\n\n#### 非聚簇索引 \n\nMyISAM使用的是非聚簇索引，新插入数据的时候，会按顺序的写入的磁盘中，并且给每一行数据标记一个行号，从小逐渐增大。\n\n![image_36b4ad4c.png](精通Mysql索引/image_36b4ad4c.png)\n\n当MyISAM创建主键索引的时候，形成的主键索引树的结构图如下图所示：\n\n![image_1f0bbe29.png](精通Mysql索引/image_1f0bbe29.png)\n\n在主键索引中，数据也是非空且唯一，主键索引树中存储的是数据行的行号，当查询数据的时候使用主键索引查询需要查询到行号，然后通过行号获取数据。\n\n非主键索引和主键索引一样叶子节点也是存储着行号，唯一的区别就是非主键索引不要求非空、唯一。\n\n我们可以通对比图来对比一下「InnoDB(聚簇索引)」 和 「MyISAM(非聚簇索引)」 的索引数据布局，如下图所示：\n\n![image_fb64a8df.png](精通Mysql索引/image_fb64a8df.png)\n\n说到这里相信应该大家对于\\*\\*「InnoDB(聚簇索引)」\\*\\* 和 「MyISAM(非聚簇索引)」 有了非常清晰的认识和理解，下面是来说一说索引的优化，这个也是和我们日常开发最密切相关的。\n\n## 索引优化 \n\n以个人多年（实际就两年）优化经验来看，Mysql索引优化无非就是以下三点：\n\n1.  最好的利用索引来进行查询\n2.  避免全表扫描\n3.  复杂查询，避免扫描无效的数据\n\n### 优化前提 \n\nExplain关键字是Mysql中sql优化的常用「关键字」，通常都会使用Explain来「查看sql的执行计划，而不用执行sql」，从而快速的找出sql的问题所在。\n\n在讲解Explain之前首先创建需要的「用户表user、角色表role、以及用户角色关系表role\\_user」作为测试用的表：\n\n```java\n// 用户表\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL,\n  `name` varchar(25) DEFAULT NULL,\n  `age` int(11)  NOT NULL DEFAULT 0,\n  `update_time` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `user` (`id`, `name`, `age`,`update_time`) VALUES (1,'张三',23,'2020-12-22 15:27:18'), (2,'李四',24,'2020-06-21 15:27:18'), (3,'王五',25,'2020-07-20 15:27:18');\n\nDROP TABLE IF EXISTS `role`;\nCREATE TABLE `role` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(10) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `index_name` (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `role` (`id`, `name`) VALUES (1,'产品经理'),(2,'技术经理'),(3,'项目总监');\n\nDROP TABLE IF EXISTS `role_user`;\nCREATE TABLE `role_user` (\n  `id` int(11) NOT NULL,\n  `role_id` int(11) NOT NULL,\n  `user_id` int(11) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `index_role_user_id` (`role_id`,`user_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `role_user` (`id`, `role_id`, `user_id`) VALUES (1,2,1),(2,1,2),(3,3,3); \n```\n\n我们首先执行一条sql：explain select \\* from user where id =2;，执行后可以看到执行的结果如下：\n\n![image_6c304aa6.png](精通Mysql索引/image_6c304aa6.png)可以看到这里有12个字段那个且都有对应的值，这就是explain的执行计划，能看懂这个执行计划，你离精通sql优化就不远了，下面就来详细的介绍这12个字段分别表示什么意思。\n\n#### id字段 \n\nid表示执行select查询语句的序号，它是sql执行的顺序的标识，sql按照id从大到小执行，id相同的为一组，从上到下执行。\n\n什么意思呢？例如执行这条sql：explain select \\* from user where id in (select user\\_id from role\\_user);\n\n```java\n+----+-------------+-----------+------------+-------+---------------+--------------------+---------+------+------+----------+-----------------------------------------------------------------------------------+\n| id | select_type | table     | partitions | type  | possible_keys | key                | key_len | ref  | rows | filtered | Extra                                                                             |\n+----+-------------+-----------+------------+-------+---------------+--------------------+---------+------+------+----------+-----------------------------------------------------------------------------------+\n|  1 | SIMPLE      | user      | NULL       | ALL   | PRIMARY       | NULL               | NULL    | NULL |    3 |   100.00 | NULL                                                                              |\n|  1 | SIMPLE      | role_user | NULL       | index | NULL          | index_role_user_id | 8       | NULL |    3 |    33.33 | Using where; Using index; FirstMatch(user); Using join buffer (Block Nested Loop) |\n+----+-------------+-----------+------------+-------+---------------+--------------------+---------+------+------+----------+-----------------------------------------------------------------------------------+\n```\n\n显示出的两者的id都相同，便表示sql的执行从上往下执行，第一条记录对应的是user表，然后第二条记录对应的是role\\_user表，这种是id相同的情况。\n\n若是id不同，例如执行下面的sql：explain select (select 1 from user limit 1) from role;：\n\n```java\n+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+\n| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra       |\n+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+\n|  1 | PRIMARY     | role  | NULL       | index | NULL          | index_name | 33      | NULL |    3 |   100.00 | Using index |\n|  2 | SUBQUERY    | user  | NULL       | index | NULL          | PRIMARY    | 4       | NULL |    3 |   100.00 | Using index |\n+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+\n```\n\n就会看到有两条记录，并且两条记录的id会不一样，id越大的就越先执行，可以看到id=2的执行的是user表，也就是子查询部分，最后执行最外层的部分。\n\n「结论：」 这个就是id标识sql的执行顺序，一般在复杂查询中会有多条记录，简单查询只有一条记录，复杂查询中id相同的为一组，执行的顺序是从上往下，而id越大的越先执行；Mysql 8中会存在对子查询进行优化，所以有时候即使是复杂查询，也只有一条记录。\n\n#### select\\_type字段 \n\nselect\\_type表示查询的类型，也就是对应的是简单查询还是复杂查询，若是复杂查询又包含：「简单的子查询、from子句的子查询、union查询」。下面就分别来看看select\\_type中的所有查询类型。\n\n *  simplesimple表示简单查询，不含有任何的复杂查询。![image_354ee4ca.png](精通Mysql索引/image_354ee4ca.png)\n *  PRIMARY复杂查询中「最外层的select语句的查询类型就是PRIMARY」，例如执行下面的sql：explain select \\* from role where id = (select id from role\\_user where role\\_id = (select id from user where id = 2));![image_33774441.png](精通Mysql索引/image_33774441.png)最外层的select，也就是select \\* from role where id =？会被标记为PRIMARY类型。\n *  SUBQUERY在「select或者where中包含的子查询」会被表示为SUBQUERY类型，例如上一句执行的sql中就有两次的子查询为SUBQUERY。![image_506be7f7.png](精通Mysql索引/image_506be7f7.png)\n *  DERIVED「DERIVED表示的是派生表或者衍生表的意思，在from包含的子查询中会被表示为DERIVED类型」，Mysql会递归执行这些子查询，并且把结果放在临时表中。执行sql：explain select \\* from (select name from user union select name from role) a where a.name = '张三';![image_5f5f8f2e.png](精通Mysql索引/image_5f5f8f2e.png)在Mysql 5.7以上的版本中对其做了优化，新增了derived\\_merge(派生合并)，可以加快查询效率。\n *  UNION在出现「UNION查询语句中，第二个select的查询语句就会被表示为UNION」：![image_41ed6d48.png](精通Mysql索引/image_41ed6d48.png)\n *  UNION RESULT「UNION查询语句的结果被标记为UNION RESULT」，如上面执行的sql：explain select \\* from (select name from user union select name from role) a where a.name = '张三';![image_6b8b2a8d.png](精通Mysql索引/image_6b8b2a8d.png)第四行记录中从table字段中可以看出，第四行的记录来源于第二行和第三行<union2,3>，因此一个UNION查询语句的结果就会被标记为UNION RESULT\n *  DEPENDENT UNION：也表示UNION查询语句中第二个或者后面的语句，但是取决于外面的查询。\n *  DEPENDENT SUBQUERY：子查询中的第一个select语句，也是依赖于外部的查询。\n *  UNCACHEABLE SUBQUERY：子查询的结果不能被缓存，必须重新评估外连接的第一行。\n\n#### table字段 \n\n这个很容易看出「table字段表示的是查询的是哪个表」，一个是已经存在的表，比如上面的user、role都是我们自己创建的表，也可以表示衍生表。\n\n比如：UNION RESULT的table字段表示为<union2,3>，也就是查询的是第二行和第三行的结果记录。\n\n#### type字段 \n\n「type字段表示的sql关联的类型或者说是访问的类型」。从这个字段中我们可以确定这条sql查找数据库表的时候，查找记录的大概范围是怎么样的，直接就能体现sql的效率问题。\n\ntype字段的类型也是有比较多，主要常见掌握的有以下几个：system、const 、eq\\_ref 、ref 、range 、index 、ALL。它的性能体现是从高到低，即system > const > eq\\_ref > ref > range > index > ALL，下面就来详细的说一说这属性。\n\n##### system \n\nsystem是const的特例，「表示表中只有一行记录」，这个几乎不会出现，也作为了解。\n\n##### const \n\nconst表示通过索引一次就查找到了数据，一般const出现在「唯一索引或者主键索引中使用等值查询」，因为表中只有一条数据匹配，所以查找的速度很快。例子：explain select \\* from user where id =2;\n\n![image_0c7be26a.png](精通Mysql索引/image_0c7be26a.png)\n\n##### eq\\_ref \n\neq\\_ref表示使用唯一索引或者主键索引扫描作为表链接匹配条件，对于每一个索引键，表中只有一条记录与之匹配。例如：explain select \\* from user left join role\\_user on user.id = role\\_user.user\\_id left join role on role\\_user.role\\_id=role.id;\n\n![image_19f2ed1c.png](精通Mysql索引/image_19f2ed1c.png)\n\n##### ref \n\nref性能比eq\\_ref差，也表示表的链接匹配条件，也就是使用哪些表字段作为查询索引列上的值，ref与eq\\_ref的区别就是eq\\_ref使用的是唯一索引或者主键索引。\n\nref扫描后的结果可能会找到多条符合条件的行数据，本质上是一种索引访问，返回匹配的行。例如：explain select \\* from user where name = '张三';\n\n![image_471404dc.png](精通Mysql索引/image_471404dc.png)\n\n##### range \n\n「range使用索引来检索给定范围的行数据，一般是在where后面使用between、<>、in等查询语句就会出现range」：explain select \\* from user where id > 2;\n\n![image_00bb0428.png](精通Mysql索引/image_00bb0428.png)\n\n##### index \n\nindex表示会遍历索引树，index回避ALL速度快一些，但是出现index说明需要检查自己的索引是否使用正确：explain select id from user;\n\n![image_a669396a.png](精通Mysql索引/image_a669396a.png)\n\n##### ALL \n\n「ALL与index的区别就是ALL是从硬盘中读取，而index是从索引文件中读取」，ALL全表扫描意味着Mysql会从表的头到尾进行扫描，这时候表示通常需要增加索引来进行优化了，或者说是查询中并没有使用索引作为条件进行查询：explain select \\* from user;\n\n![image_8d791fe4.png](精通Mysql索引/image_8d791fe4.png)\n\n#### possible\\_keys字段 \n\npossible\\_keys表示这一列查询语句可能使用到的索引，仅仅只是可能，列出来的索引并不一定真正的使用到。\n\n当没有使用索引为NULL时，说明需要增加索引来优化查询了，若是表的数据比较少的话，数据库觉得全表扫描更快，也可能为NULL。\n\n#### key字段 \n\nkey字段与possible\\_keys的区别就是，表示的真正使用到的索引，即possible\\_keys中包含key的值。\n\n若是想Mysql使用或者忽视possible\\_keys中的索引，可以使用FORCE INDEX、USE INDEX或者IGNORE INDEX。\n\n#### key\\_len字段 \n\n表示sql查询语句中索引使用到的字节数，这个字节数并不是实际的长度，而是通过计算查询中使用到的索引中的长度得出来的，显示的是索引字段最大的可能长度。\n\n一般来说在不损失精度的前提下，key\\_len是越小越好，比如上面的测试表的id为int类型，int类型由4个字节组成：explain select \\* from user where id =2;\n\n![image_66710eac.png](精通Mysql索引/image_66710eac.png)\n\nkey\\_len对于不同的类型有自己的计算规则，具体的计算规则如下所示：\n\n![image_248c75e6.png](精通Mysql索引/image_248c75e6.png)若是索引为字符串类型的时候，实际存储的字符串非常长，已经超出了字符串类型的存储最大长度（768字节），mysql，就会使用类似左前缀索引来处理。\n\n#### ref字段 \n\nref表示列与索引的比较，表连接的匹配条件，表示哪些列或者常量被用于查询索引列上的值。\n\n#### rows字段 \n\nrows表示估算的要扫描的行数，一般Mysql会根据统计表信息和索引的选用情况，估算出 查找记录所要扫描的行数，注意这个并不是实际结果集的行数。\n\n#### partitions、filtered字段 \n\npartitions表示所匹配的分区；filtered表示的是查询表行所占表的百分比。\n\n#### Extra字段 \n\n该字段显示的是sql查询的额外信息，主要有以下几种情况：\n\n##### Using index \n\n表示查询的列被索引覆盖，这个是查询性能比较高的体现，即所要查询的信息搜在索引里面可以得到，不用回表，索引被正确的使用：explain select id from user where id =2;\n\n![image_af5b5697.png](精通Mysql索引/image_af5b5697.png)\n\n假如同时出现了using where，表示索引用于执行索引键值的查找；若是没有出现using where，则表示索引用于读取数据，而非执行查询的动作。\n\n##### Using where \n\n该属性与Using index相反，查询的列并没有被索引覆盖，where条件后面使用的是非索引的前导列，它仅仅是使用了where条件而已：explain select user.\\* from user,role,role\\_user where user.id = role\\_user.user\\_id and role.id=role\\_user.role\\_id;\n\n![image_4925de1e.png](精通Mysql索引/image_4925de1e.png)\n\n##### Using temporary \n\n「Using temporary表示使用了临时表存储中间的结果，一般在对结果排序的时候会使用临时表」，例如：排序order by 和分组查询group by。例子：explain select \\* from (select name from user union select name from role) a where a.name = '张三';\n\n![image_ccf98553.png](精通Mysql索引/image_ccf98553.png)\n\n##### Using filesort \n\nUsing filesort表示文件排序，说明Mysql对数据使用了外部的索引进行排序，并没有使用表中的索引进行排序：explain select \\* from user order by name;\n\n##### Using join buffer \n\nUsing join buffer表示使用连接缓存：explain select user.\\* from user,role,role\\_user where user.id = role\\_user.user\\_id and role.id=role\\_user.role\\_id;\n\n![image_f552bbb6.png](精通Mysql索引/image_f552bbb6.png)\n\n它强调在获取连接条件时，并没有使用索引，而是使用连接缓冲区来存储中间结果，若是出现该值，一般说明需要添加索引来进行优化了。\n\n##### Impossible where \n\nImpossible where会出现在where后的条件一直为false的情况下，这种可以忽视，比较少出现：explain select \\* from user where name = 'hah' and name = 'sfsd';\n\n![image_3c03677f.png](精通Mysql索引/image_3c03677f.png)\n\n##### Select tables optimized away \n\n表示select语句没有遍历表或者索引就返回数据了，比如：explain select min(id) from user;\n\n![image_417b1a31.png](精通Mysql索引/image_417b1a31.png)\n\n在Extra字段中还有其它的属性，但是几乎都没见过的，不出现，所以哪些就讲解，有兴趣的可以自己去了解，这里只列出这些常见的。\n\n### 总结 \n\n下面我来总结一下要正确的使用索引的一些规则。要正确的创建索引，用索引正确的查询，不要使索引失效，因此索引的设计和优化的原则应该遵循下面的几个原则：\n\n1.  索引列不要在表达式中出现，这样会导致索引失效。如：「SELECT ...... WHERE id+1=5」;\n2.  索引列不要作为函数的参数使用。\n3.  索引列尽量不要使用like关键字。如：「SELECT ...... WHERE name like '%d%'」。可以使用Mysql内置的函数INSTR(str,substr) 来匹配，查询字符串出现的下表的位置；也可以是使用FullText全文索引，用match against 检索;假如数据量非常大的话建议使用es或者solr来替代。\n4.  数字型的索引列不要当作字符串类型进行条件查询。如：「SELECT ...... WHERE id = '35'」;\n5.  尽量不要在条件not in、<>、!= 、or 中使用索引，其中in关键字也要慎重使用，在控制in条件的数量在1000以内，如果in后面的条件太多，会导致全表扫描，这个在阿里巴巴的开发手册也有说明；建议使用between来替代in或者使用子查询exists代替；or关键字建议使用union来替代优化。\n6.  建表规范不建议在表中默认值是null的情况，一般建表都会一个默认值，比如0或者空字符串，防止出现一些空指针的现象。\n7.  在索引列的字段中不要出现NULL值，NULL值会使索引失效，可以用特殊的字符比如空字符串' '或者0来代替NULL值。\n8.  联合索引的查询应该遵循最左前缀原则。\n9.  一般对于区别性比较大的字段建立索引，在联合索引中区别性比较大（识别度比较高）放在最前面，提高索引的命中率，在mybatis的xml文件中多条件where查询时，命中索引的条件放在前面，能使用联合索引就不要使用单列索引。\n10.  where、order by 、 group by后面的条件尽量使用索引进行优化 ，可以使用exlpain对查询进行优化。\n11.  复杂查询中建议使用inner on来做关联，因为在mysql优化器中inner on会有限使用小表关联大表，on后面的条件要建立索引，左关联和右关联应该遵循小表带大表的规则。\n12.  微服务分布式系统下的库表设计原则不要进行跨库的join操作，一个库的数据量若是比较大，应该减少或者尽量不要join操作，要进行join操作应该避免join的无效的数据，保持接口的单一原则，减少join操作的方法可以字段冗余，对于一些很久都不会改变的字段，可以考虑冗余，从而减少join操作，阿里巴巴的手册中也有提到，不允许超过三个join，宁愿分多次查询。\n13.  业务优化考虑原则：读多写少场景或者读少写多场景，一般互联网的都是读多写少场景，对于一些需要进行统计的字段，比如一些首页报表、数据面板，需要大量统计的接口，尽量减少Mysql来进行统计，避免慢sql，优化的方法，可以牺牲部分写的性能来提升读的新能，提前在写入的时候通过异步的方式进行统计（比如统计当前月的积分，一年的绩效等数据），有些数据量涉及的数据本身比较大，如果用Mysql的进行查询的时候统计，那必然导致慢sql。\n14.  查询优化对于多次同步调用服务的接口可以通过异步的的方式进行调用，减少接口的响应时间。\n15.  索引的大小要适度，不易过大，避免索引的冗余。","slug":"精通Mysql索引","published":1,"updated":"2022-11-14T08:41:19.447Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clagje6cy0007v6ldblxadckx","content":"<h2 id=\"索引概念\"><a href=\"#索引概念\" class=\"headerlink\" title=\"索引概念\"></a>索引概念</h2><p>概念：索引是提高mysql查询效率的数据结构。总的一句话概括就是索引是一种提高查询效率的数据结构。</p>\n<p>数据库查询是数据库的最主要功能之一。设计者们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。</p>\n<p>最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如：有顺序查找、折半查找、快速查找等。</p>\n<p>但是，每种查找算法都只能应用于特定的数据结构之上，例如顺序查找依赖于顺序结构，折半查找通过二叉查找树或红黑树实现二分搜索。</p>\n<p>因此，在数据之外，数据库系统还维护着满足特定查找算法的数据结构。这种数据结构，就是索引。</p>\n<h2 id=\"索引性能分析\"><a href=\"#索引性能分析\" class=\"headerlink\" title=\"索引性能分析\"></a>索引性能分析</h2><p>目前，大多数数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。B+ 树索引是 B+ 树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。</p>\n<p>从最早的平衡二叉树演化而来的。B+ 树是由二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree）逐步优化而来。</p>\n<p>那么为什么mysql的索引选择B+数呢？</p>\n<p>有序数组、Hash索引、红黑树、二叉查找树、AVL树也可以作为数据结构也可以用来实现索引，但是文件系统以及数据库系统普遍采用B树或者B+树，这里结合各个索引的特点以及计算的组成原理来深入的分析。</p>\n<p>但是，对于Mysql来说适合它的才是最好的查询，一方面要实现高效的查询，除了简单的条件查询，还要支持有序的高效索引的范围查询、分组。</p>\n<p>有序数组在等值查询和范围查询性能都是非常好的，那为什么又不用有序数组作为索引呢？因为对于数组而言作为索引更新的成本太高，新增数据要把后面的数据都往后移一位，所以也不采用有序数组作为索引的底层实现。</p>\n<p>hash是以key-value的形式进行存储，适合于等值查询的场景，查询的时间复杂度为O(1)，因为hash储存并不是有序的，所以对于范围查询就可能要遍历所有数据进行查询，而且不同值的计算还会出现hash冲突，所以hash并不适合于做Mysql的索引。</p>\n<p>另一方面就是除了查询的效率要高，还要有高效的读取数据效率（io），我们都知道计算机的随机磁盘io效率是非常低下的。</p>\n<p>那么为什么硬盘的存取会如此的慢呢？</p>\n<p>这个就要讲硬盘的读写原理，硬盘有很多种，但是都是由盘片、磁头、盘片主轴、控制电机、磁头控制器、数据转换器、接口、缓存等几个部分组成。</p>\n<p>所有的盘片都固定在一条轴上，那条轴叫做盘片主轴，所有的盘片都是绝对平行的，也形成一个柱体，每个盘片上都有一个磁头，每个磁头都在同一轴线上，就是从上方往下看，磁头是绝对重叠的。</p>\n<p>所有的磁头连在一个磁头控制器上，由磁头控制器负责各个磁头的运动，磁头可沿盘片的半径方向移动，实际上是斜切运动，每个磁头同一时刻必须是同轴的盘片以每分钟数千转到上万转的速度在高速运转，这样磁头就能对盘片上的指定位置进行数据的读写操作：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_2c3f6cae.png\" alt=\"image_2c3f6cae.png\"></p>\n<p>磁盘数据的读写原理</p>\n<p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。</p>\n<p>磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p>\n<p>当磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。</p>\n<p>为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>\n<p>即一次磁盘的读写操作完成过程由三个动作组成：</p>\n<ul>\n<li> 寻道（时间）：磁头移动定位到指定磁道。</li>\n<li> 旋转延迟（时间）：等待指定扇区从磁头下旋转经过。</li>\n<li> 数据传输（时间）：数据在磁盘与内存之间的实际传输</li>\n</ul>\n<blockquote>\n<p>额外知识：</p>\n<ul>\n<li> 盘面：硬盘的每一个盘片都有上下两个盘面，一般每个盘面都会得到利用，都可以存储数据，盘面号又叫磁头号，因为每一个有效盘面都有一个对应的读写磁头。</li>\n<li> 磁道：磁盘在格式化时被划分成许多同心圆，这些同心圆轨迹叫做磁道，磁道从外向内从 0 开始顺序编号，信息以脉冲串的形式记录在这些轨迹中，这些同心圆不是连续记录数据，而是被划分成一段段的圆弧。</li>\n<li> 所有盘面上的同一磁道构成一个圆柱，通常称作柱面。所有盘面上的同一磁道构成一个圆柱，通常称作柱面。数据的读 / 写按柱面进行，而不按盘面进行，当一个磁道写满数据后，就在同一柱面的下一个盘面来写，一个柱面写满后，才移到下一个扇区开始写数据，读数据也按照这种方式进行，这样就提高了硬盘的读 / 写效率。</li>\n</ul>\n</blockquote>\n<p>提高磁盘数据读写原理</p>\n<p>局部性原理与磁盘预读。由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。</p>\n<p>为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。</p>\n<p>这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。</p>\n<p>所以，程序运行期间所需要的数据通常应当比较集中。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>\n<p>预读的长度一般为页（page）4k的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4k），主存和磁盘以页为单位交换数据。</p>\n<p>当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>\n<blockquote>\n<p>所以，硬盘中由于涉及到机械运动，所以一次的磁盘IO消耗的时间是非常大的，于内存的读取速度相比，就好比光速与声速的比较。</p>\n</blockquote>\n<p>因此，假如内存条件允许的话，Mysql巴不得把所有的数据一次性加载到内存中进行读写。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。</p>\n<p>服务器的内存的大小也是限制的，一个服务器中可能不止跑着Mysql一个进行，多多少少都有可能二三十个进行，每个进行都需要操作系统分配内存。</p>\n<p>这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，硬盘I/O存取的消耗要高几个数量级，查找过程中磁盘I/O的存取次数。</p>\n<p>Mysql中的一些大的数据表，一个表就有可能几个G，索引结构也很大，那服务器内存不得撑爆了。</p>\n<p>所以，必须做一个取舍，在内存与磁盘中进行衡量，数据尽量放在内存中，而在少量的数据在磁盘中，读取磁盘的次数控制到最少，也就是对于Mysql的性能影响到最小，加上磁盘数据读写原理来提高数据的读取效率。</p>\n<p>那么在众多树的条件下，B+树又是以怎么样的又是脱颖而出呢？下面我们来聊一聊B树、B-树、B+树、红黑树性能。</p>\n<p>二叉树、红黑树、AVL树、B树、B+树性能分析</p>\n<p>B树性能分析：B树是二叉查找平衡树，但是B树一个节点只存一个关键字，在大量数据的时候，B树树高非常大，性能低下：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_f327aac4.png\" alt=\"image_f327aac4.png\"></p>\n<p>甚至在极端的情况下，因为二叉搜索树不存在平衡算法，所以在某些特殊的情况下，二叉搜索树等同于线性，出现蹩脚的情况，设计者们发现降低树的高度自然就可以提高查找效率：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_c1987417.png\" alt=\"image_c1987417.png\"></p>\n<p>红黑树和AVL树是在二叉树的基础上机上加上平衡算法，红黑树确保没有一条路径会比其它路径长出两倍，它是弱平衡树而AVL是严格的平衡，所以相对于二叉树的蹩脚情况做了很大的改进，加入了平衡算法：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_700a6b0b.png\" alt=\"image_700a6b0b.png\"></p>\n<p>但是，同样还是存在数据量大导致树非常高的问题，所以现在的目标就是压缩树的高度。</p>\n<p>B树基于减少树的高度上，B树是一种多路搜索树，每个节点都可以有多于两个子节点，并不是二叉的：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_4d67662e.png\" alt=\"image_4d67662e.png\"></p>\n<p>B树与B+树最大的区别就是B的非叶子节点可以存储数据，而B+树只有叶子结点才可以存储数据，B树是多路搜索树，一个节点可以存储很多数据，所以B树的高度大大减小。</p>\n<p>但是B树相对于B+树来说，在查找数据的时候，由于每一个节点都有可能包含目标数据，所以查找总是从根节点进行向下搜索，这个特点会带来大量的随机io。</p>\n<p>而在B+树种，因为叶子结点才会存储数据（InnoDB），这样子相比B树一个页大小存储的索引数据就更多了（16K），并且叶子结点通过双向指针指向相邻的节点，依次连接。</p>\n<p>并且相邻结点是有序的，所以对于范围查找是非常方便的，获取到第一个符合条件的，然后通过指针，往后获取数据，直到最后一个不满足条件为止。</p>\n<p>所以总结来说：B+树是多叉树，一个数据页的大小是16kb，在1-3的树高就能存储10亿级以上的数据，也就是只要访问磁盘1-3次就足够了，并且B+树的叶子结点上一个叶子结点有指针指向下一个叶子结点，便于范围查询：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_275a1cfe.png\" alt=\"image_275a1cfe.png\"></p>\n<p>下面我们来详细的聊一聊Mysql索引B+树查询原理。</p>\n<h2 id=\"B-树索引原理\"><a href=\"#B-树索引原理\" class=\"headerlink\" title=\"B+树索引原理\"></a>B+树索引原理</h2><p>上面也大概说了一下B+树的介绍，在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。</p>\n<p>在B+树的结构中，只在叶子节点存储数据，在非叶子节点中只存储的索引，在非叶子节点中可以有更大的空间储存更多的索引，这样B+树的出度d就可以大大的增加，从而降低的B+树的高度h，B树中一个节点的大小为一个page的大小，也就是一次IO的读取，h越小IO的次数就可以减少：</p>\n<p>dmax=floor(pagesize/(keysize+datasize+pointsize))</p>\n<p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>\n<p>我们来看看B+树的搜索过程，Mysql的InnoDB的索引的结构如下图所示，假设我们要搜索id为15的数据：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_5bee3c9f.png\" alt=\"image_5bee3c9f.png\"></p>\n<ol>\n<li> 根据根节点找到磁盘块 1，读入内存，一般根节点也会常驻内存，甚至可以省略一次磁盘IO操作。【磁盘 I/O 操作第 1 次】</li>\n<li> 比较id 15在区间28的左边，于是根据p1找到磁盘2。</li>\n<li> 将磁盘2读入内存，查找结果15在（10,17）之间。【磁盘 I/O 操作第 2 次】</li>\n<li> 然后根据磁盘2的指针p2找到磁盘块5，读入内存。【磁盘 I/O 操作第 3 次】</li>\n<li> 最后根据id=15找到对应的数据，返回结果。</li>\n</ol>\n<p>所以根据上面的查找只需要至多三次的磁盘IO就可以找到对应的数据。从上面的B+树的原理图中非叶子节点构成了类似于一个一个目录一样，也可以叫做索引页，最后找到叶子结点的数据。</p>\n<p>在MySQL中，不同存储引擎对索引的实现方式是不同的，Mysql有MyISAM和InnoDB两个存储引擎的索引实现方式，下面就来分别介绍这两种存储引擎。</p>\n<h3 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h3><p>在MyISAM储存引擎中，数据和索引文件是分开储存的，Myisam 的存储文件有三个，后缀名分别是 .frm、.MYD、MYI，其中 .frm 是表的定义文件，.MYD 是数据文件，.MYI 是索引文件。</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_e6679248.png\" alt=\"image_e6679248.png\"></p>\n<p>Myisam 只支持表锁，且不支持事务。Myisam 由于有单独的索引文件，在读取数据方面的性能很高 。</p>\n<p>Myisam 也是B+树结构，但是MyISAM索引的叶子节点的数据保存的是行数据的地址。因此，MyISAM中索引检索的算法首先在索引树中找到行数据的地址，然后根据地址找到对应的行数据。</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_f50b3c32.png\" alt=\"image_f50b3c32.png\"></p>\n<p>可以看出MyISAM的索引文件仅仅保存数据记录的地址。主键索引和辅助索引，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的如下图：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_3e3d131e.png\" alt=\"image_3e3d131e.png\"></p>\n<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>\n<h3 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h3><p>在InnoDB中，数据和索引文件是合起来储存的，如图所示，InnoDB 的存储文件有两个，后缀名分别是 .frm 和 .idb，其中 .frm 是表的定义文件，而 idb 是数据文件。</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_5eb3208c.png\" alt=\"image_5eb3208c.png\"></p>\n<p>在InnoDB虽然底层也是B+树实现的方式，当时与MyISAM却有明显的区别，在InnoDB实现的索引结构中，索引文件和数据文件是一起的，InnoDB中索引文件中的key就是数据表中的主键索引，因此InnoDB的索引文件也是主索引文件。如下图所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_33b5701e.png\" alt=\"image_33b5701e.png\"></p>\n<p>如果给另一个字段指定为普通索引，则普通索引树的结构如下图所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_cee886ce.png\" alt=\"image_cee886ce.png\"></p>\n<p>所以，当查询不是按照主键查询时候就会先在辅助索引树上先找到主键的值，然后再到主索引树找到对应的行数据的值，这叫做回表，回表降低了表的查询效率。</p>\n<h2 id=\"Mysql索引种类\"><a href=\"#Mysql索引种类\" class=\"headerlink\" title=\"Mysql索引种类\"></a>Mysql索引种类</h2><p>Mysql中索引的种类也不是很多，不同类型的索引有不同的作用，索引的作用相互之间也存在交叉关系，Mysql中索引主要分为以下几类：</p>\n<ol>\n<li> 「主键索引」（PRIMARY KEY）：主键索引一般都是在创建表的时候指定，「一个表只有一个主键索引」，特点是「唯一、非空」。</li>\n<li> 「唯一索引」（UNIQUE）：唯一索引具有的特点就是唯一性，可以在创建表的时候指定，也可以在创建表后创建。</li>\n<li> 「普通索引」（INDEX）：普通索引唯一的作用就是加快查询。</li>\n<li> 「组合索引」（ INDEX）：组合索引是创建一个「多个字段的索引」，这个概念是相对于上上面的单列索引而言，组合索引查询遵循「最左前缀原则」。</li>\n<li> 「全文索引」（FULLTEXT）：全文索引是针对一些大的「文本字段」创建的索引，也称为「全文检索」。</li>\n<li> 「聚簇索引」和「非聚簇索引」：聚簇索引和非聚簇索引的概念比上面的概念要大，属于包含和被包含的关系。例如：InnoDB中主键索引使用的就是聚簇索引。</li>\n</ol>\n<p>若是你想查看一个表的所有索引，可以执行下面的sql来查看：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">show index from 表名<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>例如，查看我自己的测试表里面的索引，如下图所示，Key_name表示索引的名字，Column_name表示索引的字段：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_4030cc20.png\" alt=\"image_4030cc20.png\"></p>\n<h3 id=\"主键索引\"><a href=\"#主键索引\" class=\"headerlink\" title=\"主键索引\"></a>主键索引</h3><p>主键索引在InnoDB存储引擎中是最常见的索引类型，一个表都会有一个主键索引，它索引的字段不允许为空值，并且唯一。</p>\n<p>一般是在创建表的时候，可以通过RIMARY KEY指定主键索引，在InnoDB存储引擎中，若是创建表的时候没有主观创建主键索引，Mysql就会看表中是否有唯一索引，有，就会指定「非空的唯一索引」为主键索引</p>\n<p>若是没有唯一索引，就会默认生成一个6byte空间的自动增长主键作为主键索引，可以通过select _rowid from 表名查询的是对应的主键值.。</p>\n<p>MyISAM储存引擎是可以不存在主键索引，MyISAM和InnoDB储存数据的结构方式还是有明显的区别，这个后面篇章会详细讲解。</p>\n<h3 id=\"唯一索引\"><a href=\"#唯一索引\" class=\"headerlink\" title=\"唯一索引\"></a>唯一索引</h3><p>唯一索引与主键索引的区别就是，唯一索引允许为空，若是在组合索引中，只要创建的列值是唯一的</p>\n<p>唯一索引在实际中更多的是用来保证数据的唯一性，假如你仅仅要数据能够快速查询，你也可以使用普通索引，所以唯一索引重在体现它的唯一性。</p>\n<p>实际的业务场景，有些库表字段要求唯一，就可以使用唯一索引，创建唯一索引的方式有三种。</p>\n<p>（1）一个是在创建表的时候指定，如下sql：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">CREATE <span class=\"token class-name\">TABLE</span> <span class=\"token function\">user</span><span class=\"token punctuation\">(</span> \n id INT PRIMARY KEY <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span> \n name <span class=\"token function\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span> \n <span class=\"token class-name\">UNIQUE</span> unique_name <span class=\"token punctuation\">(</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>（2）也可以在表创建后创建，如下sql：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">CREATE UNIQUE INDEX unique_name <span class=\"token class-name\">ON</span> <span class=\"token function\">user</span><span class=\"token punctuation\">(</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>；<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>（3）通过修改表结构创建，如下sql：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ALTER user ADD UNIQUE unique_name ON <span class=\"token punctuation\">(</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这里有一个细节要注意的是创建的name字段，指定的长度是16字符，而创建的索引的长度制定的是10字符，因为也没有人的名字长度会超过10个字符，所以减少索引长度，能够减少索引所占的空间的大小。</p>\n<h3 id=\"普通索引\"><a href=\"#普通索引\" class=\"headerlink\" title=\"普通索引\"></a>普通索引</h3><p>普通索引的唯一作用就是加快数据的查询，一般对查询语句WHERE和ORDER BY后面的字段创建普通索引。</p>\n<p>创建普通索引的方式也有三种，基本和创建唯一索引的方式一样，只是把关键字UNIQUE换成INDEX，如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 创建表的时候创建</span>\nCREATE <span class=\"token class-name\">TABLE</span> <span class=\"token function\">user</span><span class=\"token punctuation\">(</span> \n id INT PRIMARY KEY <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span> \n name <span class=\"token function\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span> \n <span class=\"token class-name\">INDEX</span> index_name <span class=\"token punctuation\">(</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 创建表后创建</span>\nCREATE INDEX INDEX index_name <span class=\"token class-name\">ON</span> <span class=\"token function\">user</span><span class=\"token punctuation\">(</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>；\n<span class=\"token comment\">// 修改表结构创建</span>\nALTER user ADD INDEX index_name ON <span class=\"token punctuation\">(</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>若是想删除索引，可以通过执行下面的sql进行删除索引：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DROP INDEX index_name <span class=\"token class-name\">ON</span> user<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"组合索引\"><a href=\"#组合索引\" class=\"headerlink\" title=\"组合索引\"></a>组合索引</h3><p>组合索引即用多个字段创建一个索引，组合索引能够避免「回表查询」，相对于多字段的单列索引，组合索引的查询效率更高。</p>\n<p>创建组合索引(联合索引)的方式和上面创建普通索引的方式一样，只不过字段的数目多了，如下sql创建：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 其它方式和上面的一样，这里就只列举修改表结构的方式创建</span>\nALTER TABLE employee ADD <span class=\"token class-name\">INDEX</span> name_age_sex <span class=\"token punctuation\">(</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">,</span>sex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h4 id=\"回表查询\"><a href=\"#回表查询\" class=\"headerlink\" title=\"回表查询\"></a>回表查询</h4><p>什么是回表查询呢？回表查询简单来说「通过二级索引查询数据，得不到完整的数据行，需要再次查询主键索引来获得数据行」。</p>\n<p>InnoDB存储引擎中，索引分为 「聚簇索引」和「二级索引」，主键索引就是聚簇索引，其它的索引为二级索引。</p>\n<p>聚簇索引中的叶子节点保存着完整的数据行，而二级索引的叶子节点并不是保存完整的数据行。</p>\n<p>上面提到InnoDB表是一定要有主键索引的，虽然索引占据空间，但是索引符合二分查找的算法，查找数据非常的快。</p>\n<p>假设还是上面的employee表，里面有主键索引id，和普通的索引name，那么在InnoDB中就会存在两棵B+Tree，一棵是主键索引树：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_ea5a8c1e.png\" alt=\"image_ea5a8c1e.png\"></p>\n<p>在主键索引树中的叶子节点存储的是完整的数据行，另外一棵是name字段的二级索引树，如下图所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_73608ecd.png\" alt=\"image_73608ecd.png\"></p>\n<p>倘若你执行这条sql：select name, age, sex from employee where name =’as’;就会先执行二级索引的查询，当查询name=’as’时，得到主键为50，再根据主键查询主键索引树，得到完整的数据行，具体的执行流程如下：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_6bcc4698.png\" alt=\"image_6bcc4698.png\"></p>\n<p>这个就是回表查询，回表查询会查询两次，这样就会降低查询的效率，为了避免回表查询，只查询一次就能得到完整的数据呢？</p>\n<h4 id=\"索引覆盖\"><a href=\"#索引覆盖\" class=\"headerlink\" title=\"索引覆盖\"></a>索引覆盖</h4><p>常见的方式就是「建立组合索引（联合索引）「进行」索引覆盖」，什么是索引覆盖呢？索引覆盖就是「索引的叶子节点已经包含了查询的数据，没必要再回表进行查询。」</p>\n<p>假如我还是执行如下sql：select name, age, sex from employee where name =’as’;因为普通索引只有name字段才建立了索引，这必然会导致回表查询。</p>\n<p>为了提高查询效率，就(name)「单列索引升级为联合索引」(name, age, sex)就不同了。</p>\n<p>因为建立的联合索引，在二级节点的叶子阶段就会同时存在name, age, sex三个的值，一次性就会获得所需要的数据，这样就避免了回表，但是所有的方案都不是完美的。</p>\n<p>若是这个联合索引哪一天某一个数据行的name值改变了或者age改变了，我就需要同时维护主键索引和联合索引两棵树，这样的维护成本就高了，性能开销也大了。</p>\n<p>相比之前数据的改变，我只需要维护主键索引即可，联合索引的创建就导致了需要同时维护两棵树，这样就会影响插入、更新数据的操作，所以并没有哪种方案是完美的。</p>\n<h4 id=\"最左前缀原则\"><a href=\"#最左前缀原则\" class=\"headerlink\" title=\"最左前缀原则\"></a>最左前缀原则</h4><p>我们知道单列索引是按照索引列有序性的进行组织B+Tree结构的，联合索引又是怎么组织B+Tree呢？</p>\n<p>联合索引其实也是按照创建索引的时候，最左边的进行最开始的排序，也就是「最左前缀原则」，比如一个表中有如下数据：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_d3894bcc.png\" alt=\"image_d3894bcc.png\"></p>\n<p>如上图所示，对于联合索引中name字段是放在最前面的，所以name是完全有序的，但是age字段就不是有序的，只有当name相同，例如：name=’bc’此时age字段的索引排序才是完全有序的。</p>\n<p>所以你会发现，在联合索引中你只有使用以下的规则的方式查询才会使用到索引：</p>\n<ul>\n<li> name,age,sex</li>\n<li> name,age</li>\n<li> name</li>\n</ul>\n<p>因为Mysql的底层有查询优化器，会判断sql执行的时候若是使用全表扫描的效率比使用索引的效率更高，就会使用全表扫描。</p>\n<p>假如，我查询的时候使用age&gt;=23,sex=’男’;两个字段作为查询条件，但是没有使用name字段，因为在name不知情的条件下，对于age是无序的。</p>\n<p>对于age&gt;=23条件可能在很多的name不同中都有符合条件的出现，所以就没有办法使用索引，这也是索引实现的原因，一定要遵循「查找有序，充分的利用索引的有序性」。</p>\n<p>假如你是分别在name，age，sex三个字段中分别建立三个单列索引，就相当于建立三颗索引树，那么它的查询效率，比我们使用一棵索引树查询效率就可想而知了。</p>\n<p>有一种情况即使使用到了最左边的name字段也不会使用索引，例如：WHERE name like ‘%d%’；这种like条件的模糊查询是会使索引失效。</p>\n<p>我们可以这样理解，「查询字符串也是遵循最左前缀原则的」，字符串的查询是对字符串里面的字符一个一个的匹配，「若是字符串最左边为%表示一个不确定的字符串，那么是没办法利用到索引的有序性」。</p>\n<p>但是若是修改为 ：WHERE name like ‘d%’；就可以使用索引，因为最左边的字符串是确定的，这种称为「匹配列前缀」。</p>\n<p>实际业务场景中联合索引的创建，「我们应该把识别度比较高的字段放在前面，提高索引的命中率，充分的利用索引」。</p>\n<h4 id=\"索引下推\"><a href=\"#索引下推\" class=\"headerlink\" title=\"索引下推\"></a>索引下推</h4><p>Mysql5.6版本提出了索引下推的原则，「用于查询优化，主要是用于like关键字的查询的优化」，什么是索引下推呢？</p>\n<p>下面通过演示来说明一下他的概念，还是利用原来的employee测试表，假如我要执行下面的sql进行查询：SELECT * from user where name like ‘张%’ and age=40；</p>\n<p>假如没有索引下推，执行的过程如下图所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_f9e7e1af.png\" alt=\"image_f9e7e1af.png\"></p>\n<p>查询会直接忽略age字段，将name查询的张开头的id=5、id=7的结果返回给Mysql服务器，再执行两次的回表查询。</p>\n<p>若是上面的查询操作使用了索引下推，执行的过程如下：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_e986da4f.png\" alt=\"image_e986da4f.png\"></p>\n<p>Mysql会将查询条件age=40的查询条件传递给存储引擎，再次过滤掉age=50的数据行，这样回表的次数就变为了一次，提高了查询效率。</p>\n<p>总结起来索引下推就是在执行sql查询的时候，会将一部分的索引列的判断条件传递给存储引擎，由存储引擎通过判断是否符合条件，只有符合条件的数据才会返回给Mysql服务器。</p>\n<h3 id=\"全文索引\"><a href=\"#全文索引\" class=\"headerlink\" title=\"全文索引\"></a>全文索引</h3><p>全文索引也称为全文检索，可以通过以下sql建立全文索引：ALTER TABLE employee ADD FULLTEXT fulltext_name(name);或者CREATE INDEX的方式创建。</p>\n<p>全文索引主要是针对CHAR、VARCHAR或TEXT这种文本类的字段有效，有人说不也可以使用like关键字来查询文本吗。</p>\n<p>普通索引（单列索引）的查询只能加快字段内容中最前面的字符串的检索，若是对于多个单词组成文本的查询普通索引就无能为力了。</p>\n<p>索引一经创建就没有办法修改，若是想要修改索引，必须重建，可以使用以下sql来删除索引：DROP INDEX fulltext_name ON employee;</p>\n<h3 id=\"聚簇索引和非聚簇索引\"><a href=\"#聚簇索引和非聚簇索引\" class=\"headerlink\" title=\"聚簇索引和非聚簇索引\"></a>聚簇索引和非聚簇索引</h3><p>聚簇索引和非聚簇索引是相对于存储引擎的概念，范围比较大，包含上面所提到的索引类型。</p>\n<p>「聚簇索引就是叶子节点中存储的就是完整的行数据，索引和数据存储在一起；而非聚簇索引的索引文件和数据文件是分开的，所以查询数据会多一次查询」。</p>\n<p>因此聚簇索引的查询速度会快于非聚簇索引的查询速度，在Mysql的存储引擎中，「InnoDB支持聚簇索引，MyISAM不支持聚簇索引，MyISAM支持非聚簇索引」。</p>\n<h4 id=\"聚簇索引\"><a href=\"#聚簇索引\" class=\"headerlink\" title=\"聚簇索引\"></a>聚簇索引</h4><p>下面我们来看看InnoDB中的聚簇索引，前面说到InnoDB都会有一个主键，该主键就是用于支持聚簇索引，聚簇索引结构图，大致如下图所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_5661add7.png\" alt=\"image_5661add7.png\"></p>\n<p>InnoDB中适用于最好的主键选择就是给出一个AUTO_INCREMENT的列作为自增的主键，有的人可能会使用UUID作为随机主键。</p>\n<p>因为索引要维持有序性，若是使用随机的主键，主键的插入需要寻找合适的位置进行放置，这样维护主键索引树的成本就会变得更高。</p>\n<p>相反的，自增主键，主键都是自增变大，在维护主键索引树的成本就会变得更小，随意应该尽量避免随机主键。</p>\n<h4 id=\"非聚簇索引\"><a href=\"#非聚簇索引\" class=\"headerlink\" title=\"非聚簇索引\"></a>非聚簇索引</h4><p>MyISAM使用的是非聚簇索引，新插入数据的时候，会按顺序的写入的磁盘中，并且给每一行数据标记一个行号，从小逐渐增大。</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_36b4ad4c.png\" alt=\"image_36b4ad4c.png\"></p>\n<p>当MyISAM创建主键索引的时候，形成的主键索引树的结构图如下图所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_1f0bbe29.png\" alt=\"image_1f0bbe29.png\"></p>\n<p>在主键索引中，数据也是非空且唯一，主键索引树中存储的是数据行的行号，当查询数据的时候使用主键索引查询需要查询到行号，然后通过行号获取数据。</p>\n<p>非主键索引和主键索引一样叶子节点也是存储着行号，唯一的区别就是非主键索引不要求非空、唯一。</p>\n<p>我们可以通对比图来对比一下「InnoDB(聚簇索引)」 和 「MyISAM(非聚簇索引)」 的索引数据布局，如下图所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_fb64a8df.png\" alt=\"image_fb64a8df.png\"></p>\n<p>说到这里相信应该大家对于**「InnoDB(聚簇索引)」** 和 「MyISAM(非聚簇索引)」 有了非常清晰的认识和理解，下面是来说一说索引的优化，这个也是和我们日常开发最密切相关的。</p>\n<h2 id=\"索引优化\"><a href=\"#索引优化\" class=\"headerlink\" title=\"索引优化\"></a>索引优化</h2><p>以个人多年（实际就两年）优化经验来看，Mysql索引优化无非就是以下三点：</p>\n<ol>\n<li> 最好的利用索引来进行查询</li>\n<li> 避免全表扫描</li>\n<li> 复杂查询，避免扫描无效的数据</li>\n</ol>\n<h3 id=\"优化前提\"><a href=\"#优化前提\" class=\"headerlink\" title=\"优化前提\"></a>优化前提</h3><p>Explain关键字是Mysql中sql优化的常用「关键字」，通常都会使用Explain来「查看sql的执行计划，而不用执行sql」，从而快速的找出sql的问题所在。</p>\n<p>在讲解Explain之前首先创建需要的「用户表user、角色表role、以及用户角色关系表role_user」作为测试用的表：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 用户表</span>\nDROP TABLE IF EXISTS `user`<span class=\"token punctuation\">;</span>\nCREATE TABLE `user` <span class=\"token punctuation\">(</span>\n  `id` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span>\n  `name` <span class=\"token function\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">25</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">DEFAULT</span> NULL<span class=\"token punctuation\">,</span>\n  `age` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span>  NOT NULL <span class=\"token class-name\">DEFAULT</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  `update_time` datetime <span class=\"token class-name\">DEFAULT</span> NULL<span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\">PRIMARY</span> KEY <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> ENGINE<span class=\"token operator\">=</span><span class=\"token class-name\">InnoDB</span> <span class=\"token class-name\">DEFAULT</span> CHARSET<span class=\"token operator\">=</span>utf8<span class=\"token punctuation\">;</span>\n\nINSERT INTO `user` <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">,</span> `name`<span class=\"token punctuation\">,</span> `age`<span class=\"token punctuation\">,</span>`update_time`<span class=\"token punctuation\">)</span> VALUES <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">'张三'</span><span class=\"token punctuation\">,</span><span class=\"token number\">23</span><span class=\"token punctuation\">,</span><span class=\"token string\">'2020-12-22 15:27:18'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token string\">'李四'</span><span class=\"token punctuation\">,</span><span class=\"token number\">24</span><span class=\"token punctuation\">,</span><span class=\"token string\">'2020-06-21 15:27:18'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token string\">'王五'</span><span class=\"token punctuation\">,</span><span class=\"token number\">25</span><span class=\"token punctuation\">,</span><span class=\"token string\">'2020-07-20 15:27:18'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nDROP TABLE IF EXISTS `role`<span class=\"token punctuation\">;</span>\nCREATE TABLE `role` <span class=\"token punctuation\">(</span>\n  `id` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> NOT <span class=\"token class-name\">NULL</span> AUTO_INCREMENT<span class=\"token punctuation\">,</span>\n  `name` <span class=\"token function\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">DEFAULT</span> NULL<span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\">PRIMARY</span> KEY <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  KEY `index_name` <span class=\"token punctuation\">(</span>`name`<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> ENGINE<span class=\"token operator\">=</span><span class=\"token class-name\">InnoDB</span> <span class=\"token class-name\">DEFAULT</span> CHARSET<span class=\"token operator\">=</span>utf8<span class=\"token punctuation\">;</span>\n\nINSERT INTO `role` <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">,</span> `name`<span class=\"token punctuation\">)</span> VALUES <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">'产品经理'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token string\">'技术经理'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token string\">'项目总监'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nDROP TABLE IF EXISTS `role_user`<span class=\"token punctuation\">;</span>\nCREATE TABLE `role_user` <span class=\"token punctuation\">(</span>\n  `id` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span>\n  `role_id` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span>\n  `user_id` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\">PRIMARY</span> KEY <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  KEY `index_role_user_id` <span class=\"token punctuation\">(</span>`role_id`<span class=\"token punctuation\">,</span>`user_id`<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> ENGINE<span class=\"token operator\">=</span><span class=\"token class-name\">InnoDB</span> <span class=\"token class-name\">DEFAULT</span> CHARSET<span class=\"token operator\">=</span>utf8<span class=\"token punctuation\">;</span>\n\nINSERT INTO `role_user` <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">,</span> `role_id`<span class=\"token punctuation\">,</span> `user_id`<span class=\"token punctuation\">)</span> VALUES <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们首先执行一条sql：explain select * from user where id =2;，执行后可以看到执行的结果如下：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_6c304aa6.png\" alt=\"image_6c304aa6.png\">可以看到这里有12个字段那个且都有对应的值，这就是explain的执行计划，能看懂这个执行计划，你离精通sql优化就不远了，下面就来详细的介绍这12个字段分别表示什么意思。</p>\n<h4 id=\"id字段\"><a href=\"#id字段\" class=\"headerlink\" title=\"id字段\"></a>id字段</h4><p>id表示执行select查询语句的序号，它是sql执行的顺序的标识，sql按照id从大到小执行，id相同的为一组，从上到下执行。</p>\n<p>什么意思呢？例如执行这条sql：explain select * from user where id in (select user_id from role_user);</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span>\n<span class=\"token operator\">|</span> id <span class=\"token operator\">|</span> select_type <span class=\"token operator\">|</span> table     <span class=\"token operator\">|</span> partitions <span class=\"token operator\">|</span> type  <span class=\"token operator\">|</span> possible_keys <span class=\"token operator\">|</span> key                <span class=\"token operator\">|</span> key_len <span class=\"token operator\">|</span> ref  <span class=\"token operator\">|</span> rows <span class=\"token operator\">|</span> filtered <span class=\"token operator\">|</span> <span class=\"token class-name\">Extra</span>                                                                             <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span>\n<span class=\"token operator\">|</span>  <span class=\"token number\">1</span> <span class=\"token operator\">|</span> SIMPLE      <span class=\"token operator\">|</span> user      <span class=\"token operator\">|</span> NULL       <span class=\"token operator\">|</span> ALL   <span class=\"token operator\">|</span> PRIMARY       <span class=\"token operator\">|</span> NULL               <span class=\"token operator\">|</span> NULL    <span class=\"token operator\">|</span> NULL <span class=\"token operator\">|</span>    <span class=\"token number\">3</span> <span class=\"token operator\">|</span>   <span class=\"token number\">100.00</span> <span class=\"token operator\">|</span> NULL                                                                              <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>  <span class=\"token number\">1</span> <span class=\"token operator\">|</span> SIMPLE      <span class=\"token operator\">|</span> role_user <span class=\"token operator\">|</span> NULL       <span class=\"token operator\">|</span> index <span class=\"token operator\">|</span> NULL          <span class=\"token operator\">|</span> index_role_user_id <span class=\"token operator\">|</span> <span class=\"token number\">8</span>       <span class=\"token operator\">|</span> NULL <span class=\"token operator\">|</span>    <span class=\"token number\">3</span> <span class=\"token operator\">|</span>    <span class=\"token number\">33.33</span> <span class=\"token operator\">|</span> <span class=\"token class-name\">Using</span> where<span class=\"token punctuation\">;</span> <span class=\"token class-name\">Using</span> index<span class=\"token punctuation\">;</span> <span class=\"token class-name\">FirstMatch</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token class-name\">Using</span> join buffer <span class=\"token punctuation\">(</span><span class=\"token class-name\">Block</span> <span class=\"token class-name\">Nested</span> <span class=\"token class-name\">Loop</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>显示出的两者的id都相同，便表示sql的执行从上往下执行，第一条记录对应的是user表，然后第二条记录对应的是role_user表，这种是id相同的情况。</p>\n<p>若是id不同，例如执行下面的sql：explain select (select 1 from user limit 1) from role;：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span>\n<span class=\"token operator\">|</span> id <span class=\"token operator\">|</span> select_type <span class=\"token operator\">|</span> table <span class=\"token operator\">|</span> partitions <span class=\"token operator\">|</span> type  <span class=\"token operator\">|</span> possible_keys <span class=\"token operator\">|</span> key        <span class=\"token operator\">|</span> key_len <span class=\"token operator\">|</span> ref  <span class=\"token operator\">|</span> rows <span class=\"token operator\">|</span> filtered <span class=\"token operator\">|</span> <span class=\"token class-name\">Extra</span>       <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span>\n<span class=\"token operator\">|</span>  <span class=\"token number\">1</span> <span class=\"token operator\">|</span> PRIMARY     <span class=\"token operator\">|</span> role  <span class=\"token operator\">|</span> NULL       <span class=\"token operator\">|</span> index <span class=\"token operator\">|</span> NULL          <span class=\"token operator\">|</span> index_name <span class=\"token operator\">|</span> <span class=\"token number\">33</span>      <span class=\"token operator\">|</span> NULL <span class=\"token operator\">|</span>    <span class=\"token number\">3</span> <span class=\"token operator\">|</span>   <span class=\"token number\">100.00</span> <span class=\"token operator\">|</span> <span class=\"token class-name\">Using</span> index <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>  <span class=\"token number\">2</span> <span class=\"token operator\">|</span> SUBQUERY    <span class=\"token operator\">|</span> user  <span class=\"token operator\">|</span> NULL       <span class=\"token operator\">|</span> index <span class=\"token operator\">|</span> NULL          <span class=\"token operator\">|</span> PRIMARY    <span class=\"token operator\">|</span> <span class=\"token number\">4</span>       <span class=\"token operator\">|</span> NULL <span class=\"token operator\">|</span>    <span class=\"token number\">3</span> <span class=\"token operator\">|</span>   <span class=\"token number\">100.00</span> <span class=\"token operator\">|</span> <span class=\"token class-name\">Using</span> index <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>就会看到有两条记录，并且两条记录的id会不一样，id越大的就越先执行，可以看到id=2的执行的是user表，也就是子查询部分，最后执行最外层的部分。</p>\n<p>「结论：」 这个就是id标识sql的执行顺序，一般在复杂查询中会有多条记录，简单查询只有一条记录，复杂查询中id相同的为一组，执行的顺序是从上往下，而id越大的越先执行；Mysql 8中会存在对子查询进行优化，所以有时候即使是复杂查询，也只有一条记录。</p>\n<h4 id=\"select-type字段\"><a href=\"#select-type字段\" class=\"headerlink\" title=\"select_type字段\"></a>select_type字段</h4><p>select_type表示查询的类型，也就是对应的是简单查询还是复杂查询，若是复杂查询又包含：「简单的子查询、from子句的子查询、union查询」。下面就分别来看看select_type中的所有查询类型。</p>\n<ul>\n<li> simplesimple表示简单查询，不含有任何的复杂查询。<img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_354ee4ca.png\" alt=\"image_354ee4ca.png\"></li>\n<li> PRIMARY复杂查询中「最外层的select语句的查询类型就是PRIMARY」，例如执行下面的sql：explain select * from role where id = (select id from role_user where role_id = (select id from user where id = 2));<img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_33774441.png\" alt=\"image_33774441.png\">最外层的select，也就是select * from role where id =？会被标记为PRIMARY类型。</li>\n<li> SUBQUERY在「select或者where中包含的子查询」会被表示为SUBQUERY类型，例如上一句执行的sql中就有两次的子查询为SUBQUERY。<img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_506be7f7.png\" alt=\"image_506be7f7.png\"></li>\n<li> DERIVED「DERIVED表示的是派生表或者衍生表的意思，在from包含的子查询中会被表示为DERIVED类型」，Mysql会递归执行这些子查询，并且把结果放在临时表中。执行sql：explain select * from (select name from user union select name from role) a where a.name = ‘张三’;<img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_5f5f8f2e.png\" alt=\"image_5f5f8f2e.png\">在Mysql 5.7以上的版本中对其做了优化，新增了derived_merge(派生合并)，可以加快查询效率。</li>\n<li> UNION在出现「UNION查询语句中，第二个select的查询语句就会被表示为UNION」：<img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_41ed6d48.png\" alt=\"image_41ed6d48.png\"></li>\n<li> UNION RESULT「UNION查询语句的结果被标记为UNION RESULT」，如上面执行的sql：explain select * from (select name from user union select name from role) a where a.name = ‘张三’;<img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_6b8b2a8d.png\" alt=\"image_6b8b2a8d.png\">第四行记录中从table字段中可以看出，第四行的记录来源于第二行和第三行&lt;union2,3&gt;，因此一个UNION查询语句的结果就会被标记为UNION RESULT</li>\n<li> DEPENDENT UNION：也表示UNION查询语句中第二个或者后面的语句，但是取决于外面的查询。</li>\n<li> DEPENDENT SUBQUERY：子查询中的第一个select语句，也是依赖于外部的查询。</li>\n<li> UNCACHEABLE SUBQUERY：子查询的结果不能被缓存，必须重新评估外连接的第一行。</li>\n</ul>\n<h4 id=\"table字段\"><a href=\"#table字段\" class=\"headerlink\" title=\"table字段\"></a>table字段</h4><p>这个很容易看出「table字段表示的是查询的是哪个表」，一个是已经存在的表，比如上面的user、role都是我们自己创建的表，也可以表示衍生表。</p>\n<p>比如：UNION RESULT的table字段表示为&lt;union2,3&gt;，也就是查询的是第二行和第三行的结果记录。</p>\n<h4 id=\"type字段\"><a href=\"#type字段\" class=\"headerlink\" title=\"type字段\"></a>type字段</h4><p>「type字段表示的sql关联的类型或者说是访问的类型」。从这个字段中我们可以确定这条sql查找数据库表的时候，查找记录的大概范围是怎么样的，直接就能体现sql的效率问题。</p>\n<p>type字段的类型也是有比较多，主要常见掌握的有以下几个：system、const 、eq_ref 、ref 、range 、index 、ALL。它的性能体现是从高到低，即system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL，下面就来详细的说一说这属性。</p>\n<h5 id=\"system\"><a href=\"#system\" class=\"headerlink\" title=\"system\"></a>system</h5><p>system是const的特例，「表示表中只有一行记录」，这个几乎不会出现，也作为了解。</p>\n<h5 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h5><p>const表示通过索引一次就查找到了数据，一般const出现在「唯一索引或者主键索引中使用等值查询」，因为表中只有一条数据匹配，所以查找的速度很快。例子：explain select * from user where id =2;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_0c7be26a.png\" alt=\"image_0c7be26a.png\"></p>\n<h5 id=\"eq-ref\"><a href=\"#eq-ref\" class=\"headerlink\" title=\"eq_ref\"></a>eq_ref</h5><p>eq_ref表示使用唯一索引或者主键索引扫描作为表链接匹配条件，对于每一个索引键，表中只有一条记录与之匹配。例如：explain select * from user left join role_user on user.id = role_user.user_id left join role on role_user.role_id=role.id;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_19f2ed1c.png\" alt=\"image_19f2ed1c.png\"></p>\n<h5 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h5><p>ref性能比eq_ref差，也表示表的链接匹配条件，也就是使用哪些表字段作为查询索引列上的值，ref与eq_ref的区别就是eq_ref使用的是唯一索引或者主键索引。</p>\n<p>ref扫描后的结果可能会找到多条符合条件的行数据，本质上是一种索引访问，返回匹配的行。例如：explain select * from user where name = ‘张三’;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_471404dc.png\" alt=\"image_471404dc.png\"></p>\n<h5 id=\"range\"><a href=\"#range\" class=\"headerlink\" title=\"range\"></a>range</h5><p>「range使用索引来检索给定范围的行数据，一般是在where后面使用between、&lt;&gt;、in等查询语句就会出现range」：explain select * from user where id &gt; 2;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_00bb0428.png\" alt=\"image_00bb0428.png\"></p>\n<h5 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h5><p>index表示会遍历索引树，index回避ALL速度快一些，但是出现index说明需要检查自己的索引是否使用正确：explain select id from user;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_a669396a.png\" alt=\"image_a669396a.png\"></p>\n<h5 id=\"ALL\"><a href=\"#ALL\" class=\"headerlink\" title=\"ALL\"></a>ALL</h5><p>「ALL与index的区别就是ALL是从硬盘中读取，而index是从索引文件中读取」，ALL全表扫描意味着Mysql会从表的头到尾进行扫描，这时候表示通常需要增加索引来进行优化了，或者说是查询中并没有使用索引作为条件进行查询：explain select * from user;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_8d791fe4.png\" alt=\"image_8d791fe4.png\"></p>\n<h4 id=\"possible-keys字段\"><a href=\"#possible-keys字段\" class=\"headerlink\" title=\"possible_keys字段\"></a>possible_keys字段</h4><p>possible_keys表示这一列查询语句可能使用到的索引，仅仅只是可能，列出来的索引并不一定真正的使用到。</p>\n<p>当没有使用索引为NULL时，说明需要增加索引来优化查询了，若是表的数据比较少的话，数据库觉得全表扫描更快，也可能为NULL。</p>\n<h4 id=\"key字段\"><a href=\"#key字段\" class=\"headerlink\" title=\"key字段\"></a>key字段</h4><p>key字段与possible_keys的区别就是，表示的真正使用到的索引，即possible_keys中包含key的值。</p>\n<p>若是想Mysql使用或者忽视possible_keys中的索引，可以使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p>\n<h4 id=\"key-len字段\"><a href=\"#key-len字段\" class=\"headerlink\" title=\"key_len字段\"></a>key_len字段</h4><p>表示sql查询语句中索引使用到的字节数，这个字节数并不是实际的长度，而是通过计算查询中使用到的索引中的长度得出来的，显示的是索引字段最大的可能长度。</p>\n<p>一般来说在不损失精度的前提下，key_len是越小越好，比如上面的测试表的id为int类型，int类型由4个字节组成：explain select * from user where id =2;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_66710eac.png\" alt=\"image_66710eac.png\"></p>\n<p>key_len对于不同的类型有自己的计算规则，具体的计算规则如下所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_248c75e6.png\" alt=\"image_248c75e6.png\">若是索引为字符串类型的时候，实际存储的字符串非常长，已经超出了字符串类型的存储最大长度（768字节），mysql，就会使用类似左前缀索引来处理。</p>\n<h4 id=\"ref字段\"><a href=\"#ref字段\" class=\"headerlink\" title=\"ref字段\"></a>ref字段</h4><p>ref表示列与索引的比较，表连接的匹配条件，表示哪些列或者常量被用于查询索引列上的值。</p>\n<h4 id=\"rows字段\"><a href=\"#rows字段\" class=\"headerlink\" title=\"rows字段\"></a>rows字段</h4><p>rows表示估算的要扫描的行数，一般Mysql会根据统计表信息和索引的选用情况，估算出 查找记录所要扫描的行数，注意这个并不是实际结果集的行数。</p>\n<h4 id=\"partitions、filtered字段\"><a href=\"#partitions、filtered字段\" class=\"headerlink\" title=\"partitions、filtered字段\"></a>partitions、filtered字段</h4><p>partitions表示所匹配的分区；filtered表示的是查询表行所占表的百分比。</p>\n<h4 id=\"Extra字段\"><a href=\"#Extra字段\" class=\"headerlink\" title=\"Extra字段\"></a>Extra字段</h4><p>该字段显示的是sql查询的额外信息，主要有以下几种情况：</p>\n<h5 id=\"Using-index\"><a href=\"#Using-index\" class=\"headerlink\" title=\"Using index\"></a>Using index</h5><p>表示查询的列被索引覆盖，这个是查询性能比较高的体现，即所要查询的信息搜在索引里面可以得到，不用回表，索引被正确的使用：explain select id from user where id =2;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_af5b5697.png\" alt=\"image_af5b5697.png\"></p>\n<p>假如同时出现了using where，表示索引用于执行索引键值的查找；若是没有出现using where，则表示索引用于读取数据，而非执行查询的动作。</p>\n<h5 id=\"Using-where\"><a href=\"#Using-where\" class=\"headerlink\" title=\"Using where\"></a>Using where</h5><p>该属性与Using index相反，查询的列并没有被索引覆盖，where条件后面使用的是非索引的前导列，它仅仅是使用了where条件而已：explain select user.* from user,role,role_user where user.id = role_user.user_id and role.id=role_user.role_id;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_4925de1e.png\" alt=\"image_4925de1e.png\"></p>\n<h5 id=\"Using-temporary\"><a href=\"#Using-temporary\" class=\"headerlink\" title=\"Using temporary\"></a>Using temporary</h5><p>「Using temporary表示使用了临时表存储中间的结果，一般在对结果排序的时候会使用临时表」，例如：排序order by 和分组查询group by。例子：explain select * from (select name from user union select name from role) a where a.name = ‘张三’;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_ccf98553.png\" alt=\"image_ccf98553.png\"></p>\n<h5 id=\"Using-filesort\"><a href=\"#Using-filesort\" class=\"headerlink\" title=\"Using filesort\"></a>Using filesort</h5><p>Using filesort表示文件排序，说明Mysql对数据使用了外部的索引进行排序，并没有使用表中的索引进行排序：explain select * from user order by name;</p>\n<h5 id=\"Using-join-buffer\"><a href=\"#Using-join-buffer\" class=\"headerlink\" title=\"Using join buffer\"></a>Using join buffer</h5><p>Using join buffer表示使用连接缓存：explain select user.* from user,role,role_user where user.id = role_user.user_id and role.id=role_user.role_id;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_f552bbb6.png\" alt=\"image_f552bbb6.png\"></p>\n<p>它强调在获取连接条件时，并没有使用索引，而是使用连接缓冲区来存储中间结果，若是出现该值，一般说明需要添加索引来进行优化了。</p>\n<h5 id=\"Impossible-where\"><a href=\"#Impossible-where\" class=\"headerlink\" title=\"Impossible where\"></a>Impossible where</h5><p>Impossible where会出现在where后的条件一直为false的情况下，这种可以忽视，比较少出现：explain select * from user where name = ‘hah’ and name = ‘sfsd’;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_3c03677f.png\" alt=\"image_3c03677f.png\"></p>\n<h5 id=\"Select-tables-optimized-away\"><a href=\"#Select-tables-optimized-away\" class=\"headerlink\" title=\"Select tables optimized away\"></a>Select tables optimized away</h5><p>表示select语句没有遍历表或者索引就返回数据了，比如：explain select min(id) from user;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_417b1a31.png\" alt=\"image_417b1a31.png\"></p>\n<p>在Extra字段中还有其它的属性，但是几乎都没见过的，不出现，所以哪些就讲解，有兴趣的可以自己去了解，这里只列出这些常见的。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>下面我来总结一下要正确的使用索引的一些规则。要正确的创建索引，用索引正确的查询，不要使索引失效，因此索引的设计和优化的原则应该遵循下面的几个原则：</p>\n<ol>\n<li> 索引列不要在表达式中出现，这样会导致索引失效。如：「SELECT …… WHERE id+1=5」;</li>\n<li> 索引列不要作为函数的参数使用。</li>\n<li> 索引列尽量不要使用like关键字。如：「SELECT …… WHERE name like ‘%d%’」。可以使用Mysql内置的函数INSTR(str,substr) 来匹配，查询字符串出现的下表的位置；也可以是使用FullText全文索引，用match against 检索;假如数据量非常大的话建议使用es或者solr来替代。</li>\n<li> 数字型的索引列不要当作字符串类型进行条件查询。如：「SELECT …… WHERE id = ‘35’」;</li>\n<li> 尽量不要在条件not in、&lt;&gt;、!= 、or 中使用索引，其中in关键字也要慎重使用，在控制in条件的数量在1000以内，如果in后面的条件太多，会导致全表扫描，这个在阿里巴巴的开发手册也有说明；建议使用between来替代in或者使用子查询exists代替；or关键字建议使用union来替代优化。</li>\n<li> 建表规范不建议在表中默认值是null的情况，一般建表都会一个默认值，比如0或者空字符串，防止出现一些空指针的现象。</li>\n<li> 在索引列的字段中不要出现NULL值，NULL值会使索引失效，可以用特殊的字符比如空字符串’ ‘或者0来代替NULL值。</li>\n<li> 联合索引的查询应该遵循最左前缀原则。</li>\n<li> 一般对于区别性比较大的字段建立索引，在联合索引中区别性比较大（识别度比较高）放在最前面，提高索引的命中率，在mybatis的xml文件中多条件where查询时，命中索引的条件放在前面，能使用联合索引就不要使用单列索引。</li>\n<li> where、order by 、 group by后面的条件尽量使用索引进行优化 ，可以使用exlpain对查询进行优化。</li>\n<li> 复杂查询中建议使用inner on来做关联，因为在mysql优化器中inner on会有限使用小表关联大表，on后面的条件要建立索引，左关联和右关联应该遵循小表带大表的规则。</li>\n<li> 微服务分布式系统下的库表设计原则不要进行跨库的join操作，一个库的数据量若是比较大，应该减少或者尽量不要join操作，要进行join操作应该避免join的无效的数据，保持接口的单一原则，减少join操作的方法可以字段冗余，对于一些很久都不会改变的字段，可以考虑冗余，从而减少join操作，阿里巴巴的手册中也有提到，不允许超过三个join，宁愿分多次查询。</li>\n<li> 业务优化考虑原则：读多写少场景或者读少写多场景，一般互联网的都是读多写少场景，对于一些需要进行统计的字段，比如一些首页报表、数据面板，需要大量统计的接口，尽量减少Mysql来进行统计，避免慢sql，优化的方法，可以牺牲部分写的性能来提升读的新能，提前在写入的时候通过异步的方式进行统计（比如统计当前月的积分，一年的绩效等数据），有些数据量涉及的数据本身比较大，如果用Mysql的进行查询的时候统计，那必然导致慢sql。</li>\n<li> 查询优化对于多次同步调用服务的接口可以通过异步的的方式进行调用，减少接口的响应时间。</li>\n<li> 索引的大小要适度，不易过大，避免索引的冗余。</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":"<h2 id=\"索引概念\"><a href=\"#索引概念\" class=\"headerlink\" title=\"索引概念\"></a>索引概念</h2><p>概念：索引是提高mysql查询效率的数据结构。总的一句话概括就是索引是一种提高查询效率的数据结构。</p>\n<p>数据库查询是数据库的最主要功能之一。设计者们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。</p>\n<p>最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如：有顺序查找、折半查找、快速查找等。</p>\n<p>但是，每种查找算法都只能应用于特定的数据结构之上，例如顺序查找依赖于顺序结构，折半查找通过二叉查找树或红黑树实现二分搜索。</p>\n<p>因此，在数据之外，数据库系统还维护着满足特定查找算法的数据结构。这种数据结构，就是索引。</p>\n<h2 id=\"索引性能分析\"><a href=\"#索引性能分析\" class=\"headerlink\" title=\"索引性能分析\"></a>索引性能分析</h2><p>目前，大多数数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。B+ 树索引是 B+ 树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。</p>\n<p>从最早的平衡二叉树演化而来的。B+ 树是由二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree）逐步优化而来。</p>\n<p>那么为什么mysql的索引选择B+数呢？</p>\n<p>有序数组、Hash索引、红黑树、二叉查找树、AVL树也可以作为数据结构也可以用来实现索引，但是文件系统以及数据库系统普遍采用B树或者B+树，这里结合各个索引的特点以及计算的组成原理来深入的分析。</p>\n<p>但是，对于Mysql来说适合它的才是最好的查询，一方面要实现高效的查询，除了简单的条件查询，还要支持有序的高效索引的范围查询、分组。</p>\n<p>有序数组在等值查询和范围查询性能都是非常好的，那为什么又不用有序数组作为索引呢？因为对于数组而言作为索引更新的成本太高，新增数据要把后面的数据都往后移一位，所以也不采用有序数组作为索引的底层实现。</p>\n<p>hash是以key-value的形式进行存储，适合于等值查询的场景，查询的时间复杂度为O(1)，因为hash储存并不是有序的，所以对于范围查询就可能要遍历所有数据进行查询，而且不同值的计算还会出现hash冲突，所以hash并不适合于做Mysql的索引。</p>\n<p>另一方面就是除了查询的效率要高，还要有高效的读取数据效率（io），我们都知道计算机的随机磁盘io效率是非常低下的。</p>\n<p>那么为什么硬盘的存取会如此的慢呢？</p>\n<p>这个就要讲硬盘的读写原理，硬盘有很多种，但是都是由盘片、磁头、盘片主轴、控制电机、磁头控制器、数据转换器、接口、缓存等几个部分组成。</p>\n<p>所有的盘片都固定在一条轴上，那条轴叫做盘片主轴，所有的盘片都是绝对平行的，也形成一个柱体，每个盘片上都有一个磁头，每个磁头都在同一轴线上，就是从上方往下看，磁头是绝对重叠的。</p>\n<p>所有的磁头连在一个磁头控制器上，由磁头控制器负责各个磁头的运动，磁头可沿盘片的半径方向移动，实际上是斜切运动，每个磁头同一时刻必须是同轴的盘片以每分钟数千转到上万转的速度在高速运转，这样磁头就能对盘片上的指定位置进行数据的读写操作：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_2c3f6cae.png\" alt=\"image_2c3f6cae.png\"></p>\n<p>磁盘数据的读写原理</p>\n<p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。</p>\n<p>磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p>\n<p>当磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。</p>\n<p>为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>\n<p>即一次磁盘的读写操作完成过程由三个动作组成：</p>\n<ul>\n<li> 寻道（时间）：磁头移动定位到指定磁道。</li>\n<li> 旋转延迟（时间）：等待指定扇区从磁头下旋转经过。</li>\n<li> 数据传输（时间）：数据在磁盘与内存之间的实际传输</li>\n</ul>\n<blockquote>\n<p>额外知识：</p>\n<ul>\n<li> 盘面：硬盘的每一个盘片都有上下两个盘面，一般每个盘面都会得到利用，都可以存储数据，盘面号又叫磁头号，因为每一个有效盘面都有一个对应的读写磁头。</li>\n<li> 磁道：磁盘在格式化时被划分成许多同心圆，这些同心圆轨迹叫做磁道，磁道从外向内从 0 开始顺序编号，信息以脉冲串的形式记录在这些轨迹中，这些同心圆不是连续记录数据，而是被划分成一段段的圆弧。</li>\n<li> 所有盘面上的同一磁道构成一个圆柱，通常称作柱面。所有盘面上的同一磁道构成一个圆柱，通常称作柱面。数据的读 / 写按柱面进行，而不按盘面进行，当一个磁道写满数据后，就在同一柱面的下一个盘面来写，一个柱面写满后，才移到下一个扇区开始写数据，读数据也按照这种方式进行，这样就提高了硬盘的读 / 写效率。</li>\n</ul>\n</blockquote>\n<p>提高磁盘数据读写原理</p>\n<p>局部性原理与磁盘预读。由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。</p>\n<p>为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。</p>\n<p>这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。</p>\n<p>所以，程序运行期间所需要的数据通常应当比较集中。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>\n<p>预读的长度一般为页（page）4k的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4k），主存和磁盘以页为单位交换数据。</p>\n<p>当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>\n<blockquote>\n<p>所以，硬盘中由于涉及到机械运动，所以一次的磁盘IO消耗的时间是非常大的，于内存的读取速度相比，就好比光速与声速的比较。</p>\n</blockquote>\n<p>因此，假如内存条件允许的话，Mysql巴不得把所有的数据一次性加载到内存中进行读写。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。</p>\n<p>服务器的内存的大小也是限制的，一个服务器中可能不止跑着Mysql一个进行，多多少少都有可能二三十个进行，每个进行都需要操作系统分配内存。</p>\n<p>这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，硬盘I/O存取的消耗要高几个数量级，查找过程中磁盘I/O的存取次数。</p>\n<p>Mysql中的一些大的数据表，一个表就有可能几个G，索引结构也很大，那服务器内存不得撑爆了。</p>\n<p>所以，必须做一个取舍，在内存与磁盘中进行衡量，数据尽量放在内存中，而在少量的数据在磁盘中，读取磁盘的次数控制到最少，也就是对于Mysql的性能影响到最小，加上磁盘数据读写原理来提高数据的读取效率。</p>\n<p>那么在众多树的条件下，B+树又是以怎么样的又是脱颖而出呢？下面我们来聊一聊B树、B-树、B+树、红黑树性能。</p>\n<p>二叉树、红黑树、AVL树、B树、B+树性能分析</p>\n<p>B树性能分析：B树是二叉查找平衡树，但是B树一个节点只存一个关键字，在大量数据的时候，B树树高非常大，性能低下：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_f327aac4.png\" alt=\"image_f327aac4.png\"></p>\n<p>甚至在极端的情况下，因为二叉搜索树不存在平衡算法，所以在某些特殊的情况下，二叉搜索树等同于线性，出现蹩脚的情况，设计者们发现降低树的高度自然就可以提高查找效率：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_c1987417.png\" alt=\"image_c1987417.png\"></p>\n<p>红黑树和AVL树是在二叉树的基础上机上加上平衡算法，红黑树确保没有一条路径会比其它路径长出两倍，它是弱平衡树而AVL是严格的平衡，所以相对于二叉树的蹩脚情况做了很大的改进，加入了平衡算法：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_700a6b0b.png\" alt=\"image_700a6b0b.png\"></p>\n<p>但是，同样还是存在数据量大导致树非常高的问题，所以现在的目标就是压缩树的高度。</p>\n<p>B树基于减少树的高度上，B树是一种多路搜索树，每个节点都可以有多于两个子节点，并不是二叉的：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_4d67662e.png\" alt=\"image_4d67662e.png\"></p>\n<p>B树与B+树最大的区别就是B的非叶子节点可以存储数据，而B+树只有叶子结点才可以存储数据，B树是多路搜索树，一个节点可以存储很多数据，所以B树的高度大大减小。</p>\n<p>但是B树相对于B+树来说，在查找数据的时候，由于每一个节点都有可能包含目标数据，所以查找总是从根节点进行向下搜索，这个特点会带来大量的随机io。</p>\n<p>而在B+树种，因为叶子结点才会存储数据（InnoDB），这样子相比B树一个页大小存储的索引数据就更多了（16K），并且叶子结点通过双向指针指向相邻的节点，依次连接。</p>\n<p>并且相邻结点是有序的，所以对于范围查找是非常方便的，获取到第一个符合条件的，然后通过指针，往后获取数据，直到最后一个不满足条件为止。</p>\n<p>所以总结来说：B+树是多叉树，一个数据页的大小是16kb，在1-3的树高就能存储10亿级以上的数据，也就是只要访问磁盘1-3次就足够了，并且B+树的叶子结点上一个叶子结点有指针指向下一个叶子结点，便于范围查询：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_275a1cfe.png\" alt=\"image_275a1cfe.png\"></p>\n<p>下面我们来详细的聊一聊Mysql索引B+树查询原理。</p>\n<h2 id=\"B-树索引原理\"><a href=\"#B-树索引原理\" class=\"headerlink\" title=\"B+树索引原理\"></a>B+树索引原理</h2><p>上面也大概说了一下B+树的介绍，在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。</p>\n<p>在B+树的结构中，只在叶子节点存储数据，在非叶子节点中只存储的索引，在非叶子节点中可以有更大的空间储存更多的索引，这样B+树的出度d就可以大大的增加，从而降低的B+树的高度h，B树中一个节点的大小为一个page的大小，也就是一次IO的读取，h越小IO的次数就可以减少：</p>\n<p>dmax=floor(pagesize/(keysize+datasize+pointsize))</p>\n<p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>\n<p>我们来看看B+树的搜索过程，Mysql的InnoDB的索引的结构如下图所示，假设我们要搜索id为15的数据：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_5bee3c9f.png\" alt=\"image_5bee3c9f.png\"></p>\n<ol>\n<li> 根据根节点找到磁盘块 1，读入内存，一般根节点也会常驻内存，甚至可以省略一次磁盘IO操作。【磁盘 I/O 操作第 1 次】</li>\n<li> 比较id 15在区间28的左边，于是根据p1找到磁盘2。</li>\n<li> 将磁盘2读入内存，查找结果15在（10,17）之间。【磁盘 I/O 操作第 2 次】</li>\n<li> 然后根据磁盘2的指针p2找到磁盘块5，读入内存。【磁盘 I/O 操作第 3 次】</li>\n<li> 最后根据id=15找到对应的数据，返回结果。</li>\n</ol>\n<p>所以根据上面的查找只需要至多三次的磁盘IO就可以找到对应的数据。从上面的B+树的原理图中非叶子节点构成了类似于一个一个目录一样，也可以叫做索引页，最后找到叶子结点的数据。</p>\n<p>在MySQL中，不同存储引擎对索引的实现方式是不同的，Mysql有MyISAM和InnoDB两个存储引擎的索引实现方式，下面就来分别介绍这两种存储引擎。</p>\n<h3 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h3><p>在MyISAM储存引擎中，数据和索引文件是分开储存的，Myisam 的存储文件有三个，后缀名分别是 .frm、.MYD、MYI，其中 .frm 是表的定义文件，.MYD 是数据文件，.MYI 是索引文件。</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_e6679248.png\" alt=\"image_e6679248.png\"></p>\n<p>Myisam 只支持表锁，且不支持事务。Myisam 由于有单独的索引文件，在读取数据方面的性能很高 。</p>\n<p>Myisam 也是B+树结构，但是MyISAM索引的叶子节点的数据保存的是行数据的地址。因此，MyISAM中索引检索的算法首先在索引树中找到行数据的地址，然后根据地址找到对应的行数据。</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_f50b3c32.png\" alt=\"image_f50b3c32.png\"></p>\n<p>可以看出MyISAM的索引文件仅仅保存数据记录的地址。主键索引和辅助索引，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的如下图：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_3e3d131e.png\" alt=\"image_3e3d131e.png\"></p>\n<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>\n<h3 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h3><p>在InnoDB中，数据和索引文件是合起来储存的，如图所示，InnoDB 的存储文件有两个，后缀名分别是 .frm 和 .idb，其中 .frm 是表的定义文件，而 idb 是数据文件。</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_5eb3208c.png\" alt=\"image_5eb3208c.png\"></p>\n<p>在InnoDB虽然底层也是B+树实现的方式，当时与MyISAM却有明显的区别，在InnoDB实现的索引结构中，索引文件和数据文件是一起的，InnoDB中索引文件中的key就是数据表中的主键索引，因此InnoDB的索引文件也是主索引文件。如下图所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_33b5701e.png\" alt=\"image_33b5701e.png\"></p>\n<p>如果给另一个字段指定为普通索引，则普通索引树的结构如下图所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_cee886ce.png\" alt=\"image_cee886ce.png\"></p>\n<p>所以，当查询不是按照主键查询时候就会先在辅助索引树上先找到主键的值，然后再到主索引树找到对应的行数据的值，这叫做回表，回表降低了表的查询效率。</p>\n<h2 id=\"Mysql索引种类\"><a href=\"#Mysql索引种类\" class=\"headerlink\" title=\"Mysql索引种类\"></a>Mysql索引种类</h2><p>Mysql中索引的种类也不是很多，不同类型的索引有不同的作用，索引的作用相互之间也存在交叉关系，Mysql中索引主要分为以下几类：</p>\n<ol>\n<li> 「主键索引」（PRIMARY KEY）：主键索引一般都是在创建表的时候指定，「一个表只有一个主键索引」，特点是「唯一、非空」。</li>\n<li> 「唯一索引」（UNIQUE）：唯一索引具有的特点就是唯一性，可以在创建表的时候指定，也可以在创建表后创建。</li>\n<li> 「普通索引」（INDEX）：普通索引唯一的作用就是加快查询。</li>\n<li> 「组合索引」（ INDEX）：组合索引是创建一个「多个字段的索引」，这个概念是相对于上上面的单列索引而言，组合索引查询遵循「最左前缀原则」。</li>\n<li> 「全文索引」（FULLTEXT）：全文索引是针对一些大的「文本字段」创建的索引，也称为「全文检索」。</li>\n<li> 「聚簇索引」和「非聚簇索引」：聚簇索引和非聚簇索引的概念比上面的概念要大，属于包含和被包含的关系。例如：InnoDB中主键索引使用的就是聚簇索引。</li>\n</ol>\n<p>若是你想查看一个表的所有索引，可以执行下面的sql来查看：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">show index from 表名<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>例如，查看我自己的测试表里面的索引，如下图所示，Key_name表示索引的名字，Column_name表示索引的字段：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_4030cc20.png\" alt=\"image_4030cc20.png\"></p>\n<h3 id=\"主键索引\"><a href=\"#主键索引\" class=\"headerlink\" title=\"主键索引\"></a>主键索引</h3><p>主键索引在InnoDB存储引擎中是最常见的索引类型，一个表都会有一个主键索引，它索引的字段不允许为空值，并且唯一。</p>\n<p>一般是在创建表的时候，可以通过RIMARY KEY指定主键索引，在InnoDB存储引擎中，若是创建表的时候没有主观创建主键索引，Mysql就会看表中是否有唯一索引，有，就会指定「非空的唯一索引」为主键索引</p>\n<p>若是没有唯一索引，就会默认生成一个6byte空间的自动增长主键作为主键索引，可以通过select _rowid from 表名查询的是对应的主键值.。</p>\n<p>MyISAM储存引擎是可以不存在主键索引，MyISAM和InnoDB储存数据的结构方式还是有明显的区别，这个后面篇章会详细讲解。</p>\n<h3 id=\"唯一索引\"><a href=\"#唯一索引\" class=\"headerlink\" title=\"唯一索引\"></a>唯一索引</h3><p>唯一索引与主键索引的区别就是，唯一索引允许为空，若是在组合索引中，只要创建的列值是唯一的</p>\n<p>唯一索引在实际中更多的是用来保证数据的唯一性，假如你仅仅要数据能够快速查询，你也可以使用普通索引，所以唯一索引重在体现它的唯一性。</p>\n<p>实际的业务场景，有些库表字段要求唯一，就可以使用唯一索引，创建唯一索引的方式有三种。</p>\n<p>（1）一个是在创建表的时候指定，如下sql：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">CREATE <span class=\"token class-name\">TABLE</span> <span class=\"token function\">user</span><span class=\"token punctuation\">(</span> \n id INT PRIMARY KEY <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span> \n name <span class=\"token function\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span> \n <span class=\"token class-name\">UNIQUE</span> unique_name <span class=\"token punctuation\">(</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>（2）也可以在表创建后创建，如下sql：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">CREATE UNIQUE INDEX unique_name <span class=\"token class-name\">ON</span> <span class=\"token function\">user</span><span class=\"token punctuation\">(</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>；<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>（3）通过修改表结构创建，如下sql：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ALTER user ADD UNIQUE unique_name ON <span class=\"token punctuation\">(</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这里有一个细节要注意的是创建的name字段，指定的长度是16字符，而创建的索引的长度制定的是10字符，因为也没有人的名字长度会超过10个字符，所以减少索引长度，能够减少索引所占的空间的大小。</p>\n<h3 id=\"普通索引\"><a href=\"#普通索引\" class=\"headerlink\" title=\"普通索引\"></a>普通索引</h3><p>普通索引的唯一作用就是加快数据的查询，一般对查询语句WHERE和ORDER BY后面的字段创建普通索引。</p>\n<p>创建普通索引的方式也有三种，基本和创建唯一索引的方式一样，只是把关键字UNIQUE换成INDEX，如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 创建表的时候创建</span>\nCREATE <span class=\"token class-name\">TABLE</span> <span class=\"token function\">user</span><span class=\"token punctuation\">(</span> \n id INT PRIMARY KEY <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span> \n name <span class=\"token function\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span> \n <span class=\"token class-name\">INDEX</span> index_name <span class=\"token punctuation\">(</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 创建表后创建</span>\nCREATE INDEX INDEX index_name <span class=\"token class-name\">ON</span> <span class=\"token function\">user</span><span class=\"token punctuation\">(</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>；\n<span class=\"token comment\">// 修改表结构创建</span>\nALTER user ADD INDEX index_name ON <span class=\"token punctuation\">(</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>若是想删除索引，可以通过执行下面的sql进行删除索引：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DROP INDEX index_name <span class=\"token class-name\">ON</span> user<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"组合索引\"><a href=\"#组合索引\" class=\"headerlink\" title=\"组合索引\"></a>组合索引</h3><p>组合索引即用多个字段创建一个索引，组合索引能够避免「回表查询」，相对于多字段的单列索引，组合索引的查询效率更高。</p>\n<p>创建组合索引(联合索引)的方式和上面创建普通索引的方式一样，只不过字段的数目多了，如下sql创建：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 其它方式和上面的一样，这里就只列举修改表结构的方式创建</span>\nALTER TABLE employee ADD <span class=\"token class-name\">INDEX</span> name_age_sex <span class=\"token punctuation\">(</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">,</span>sex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h4 id=\"回表查询\"><a href=\"#回表查询\" class=\"headerlink\" title=\"回表查询\"></a>回表查询</h4><p>什么是回表查询呢？回表查询简单来说「通过二级索引查询数据，得不到完整的数据行，需要再次查询主键索引来获得数据行」。</p>\n<p>InnoDB存储引擎中，索引分为 「聚簇索引」和「二级索引」，主键索引就是聚簇索引，其它的索引为二级索引。</p>\n<p>聚簇索引中的叶子节点保存着完整的数据行，而二级索引的叶子节点并不是保存完整的数据行。</p>\n<p>上面提到InnoDB表是一定要有主键索引的，虽然索引占据空间，但是索引符合二分查找的算法，查找数据非常的快。</p>\n<p>假设还是上面的employee表，里面有主键索引id，和普通的索引name，那么在InnoDB中就会存在两棵B+Tree，一棵是主键索引树：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_ea5a8c1e.png\" alt=\"image_ea5a8c1e.png\"></p>\n<p>在主键索引树中的叶子节点存储的是完整的数据行，另外一棵是name字段的二级索引树，如下图所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_73608ecd.png\" alt=\"image_73608ecd.png\"></p>\n<p>倘若你执行这条sql：select name, age, sex from employee where name =’as’;就会先执行二级索引的查询，当查询name=’as’时，得到主键为50，再根据主键查询主键索引树，得到完整的数据行，具体的执行流程如下：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_6bcc4698.png\" alt=\"image_6bcc4698.png\"></p>\n<p>这个就是回表查询，回表查询会查询两次，这样就会降低查询的效率，为了避免回表查询，只查询一次就能得到完整的数据呢？</p>\n<h4 id=\"索引覆盖\"><a href=\"#索引覆盖\" class=\"headerlink\" title=\"索引覆盖\"></a>索引覆盖</h4><p>常见的方式就是「建立组合索引（联合索引）「进行」索引覆盖」，什么是索引覆盖呢？索引覆盖就是「索引的叶子节点已经包含了查询的数据，没必要再回表进行查询。」</p>\n<p>假如我还是执行如下sql：select name, age, sex from employee where name =’as’;因为普通索引只有name字段才建立了索引，这必然会导致回表查询。</p>\n<p>为了提高查询效率，就(name)「单列索引升级为联合索引」(name, age, sex)就不同了。</p>\n<p>因为建立的联合索引，在二级节点的叶子阶段就会同时存在name, age, sex三个的值，一次性就会获得所需要的数据，这样就避免了回表，但是所有的方案都不是完美的。</p>\n<p>若是这个联合索引哪一天某一个数据行的name值改变了或者age改变了，我就需要同时维护主键索引和联合索引两棵树，这样的维护成本就高了，性能开销也大了。</p>\n<p>相比之前数据的改变，我只需要维护主键索引即可，联合索引的创建就导致了需要同时维护两棵树，这样就会影响插入、更新数据的操作，所以并没有哪种方案是完美的。</p>\n<h4 id=\"最左前缀原则\"><a href=\"#最左前缀原则\" class=\"headerlink\" title=\"最左前缀原则\"></a>最左前缀原则</h4><p>我们知道单列索引是按照索引列有序性的进行组织B+Tree结构的，联合索引又是怎么组织B+Tree呢？</p>\n<p>联合索引其实也是按照创建索引的时候，最左边的进行最开始的排序，也就是「最左前缀原则」，比如一个表中有如下数据：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_d3894bcc.png\" alt=\"image_d3894bcc.png\"></p>\n<p>如上图所示，对于联合索引中name字段是放在最前面的，所以name是完全有序的，但是age字段就不是有序的，只有当name相同，例如：name=’bc’此时age字段的索引排序才是完全有序的。</p>\n<p>所以你会发现，在联合索引中你只有使用以下的规则的方式查询才会使用到索引：</p>\n<ul>\n<li> name,age,sex</li>\n<li> name,age</li>\n<li> name</li>\n</ul>\n<p>因为Mysql的底层有查询优化器，会判断sql执行的时候若是使用全表扫描的效率比使用索引的效率更高，就会使用全表扫描。</p>\n<p>假如，我查询的时候使用age&gt;=23,sex=’男’;两个字段作为查询条件，但是没有使用name字段，因为在name不知情的条件下，对于age是无序的。</p>\n<p>对于age&gt;=23条件可能在很多的name不同中都有符合条件的出现，所以就没有办法使用索引，这也是索引实现的原因，一定要遵循「查找有序，充分的利用索引的有序性」。</p>\n<p>假如你是分别在name，age，sex三个字段中分别建立三个单列索引，就相当于建立三颗索引树，那么它的查询效率，比我们使用一棵索引树查询效率就可想而知了。</p>\n<p>有一种情况即使使用到了最左边的name字段也不会使用索引，例如：WHERE name like ‘%d%’；这种like条件的模糊查询是会使索引失效。</p>\n<p>我们可以这样理解，「查询字符串也是遵循最左前缀原则的」，字符串的查询是对字符串里面的字符一个一个的匹配，「若是字符串最左边为%表示一个不确定的字符串，那么是没办法利用到索引的有序性」。</p>\n<p>但是若是修改为 ：WHERE name like ‘d%’；就可以使用索引，因为最左边的字符串是确定的，这种称为「匹配列前缀」。</p>\n<p>实际业务场景中联合索引的创建，「我们应该把识别度比较高的字段放在前面，提高索引的命中率，充分的利用索引」。</p>\n<h4 id=\"索引下推\"><a href=\"#索引下推\" class=\"headerlink\" title=\"索引下推\"></a>索引下推</h4><p>Mysql5.6版本提出了索引下推的原则，「用于查询优化，主要是用于like关键字的查询的优化」，什么是索引下推呢？</p>\n<p>下面通过演示来说明一下他的概念，还是利用原来的employee测试表，假如我要执行下面的sql进行查询：SELECT * from user where name like ‘张%’ and age=40；</p>\n<p>假如没有索引下推，执行的过程如下图所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_f9e7e1af.png\" alt=\"image_f9e7e1af.png\"></p>\n<p>查询会直接忽略age字段，将name查询的张开头的id=5、id=7的结果返回给Mysql服务器，再执行两次的回表查询。</p>\n<p>若是上面的查询操作使用了索引下推，执行的过程如下：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_e986da4f.png\" alt=\"image_e986da4f.png\"></p>\n<p>Mysql会将查询条件age=40的查询条件传递给存储引擎，再次过滤掉age=50的数据行，这样回表的次数就变为了一次，提高了查询效率。</p>\n<p>总结起来索引下推就是在执行sql查询的时候，会将一部分的索引列的判断条件传递给存储引擎，由存储引擎通过判断是否符合条件，只有符合条件的数据才会返回给Mysql服务器。</p>\n<h3 id=\"全文索引\"><a href=\"#全文索引\" class=\"headerlink\" title=\"全文索引\"></a>全文索引</h3><p>全文索引也称为全文检索，可以通过以下sql建立全文索引：ALTER TABLE employee ADD FULLTEXT fulltext_name(name);或者CREATE INDEX的方式创建。</p>\n<p>全文索引主要是针对CHAR、VARCHAR或TEXT这种文本类的字段有效，有人说不也可以使用like关键字来查询文本吗。</p>\n<p>普通索引（单列索引）的查询只能加快字段内容中最前面的字符串的检索，若是对于多个单词组成文本的查询普通索引就无能为力了。</p>\n<p>索引一经创建就没有办法修改，若是想要修改索引，必须重建，可以使用以下sql来删除索引：DROP INDEX fulltext_name ON employee;</p>\n<h3 id=\"聚簇索引和非聚簇索引\"><a href=\"#聚簇索引和非聚簇索引\" class=\"headerlink\" title=\"聚簇索引和非聚簇索引\"></a>聚簇索引和非聚簇索引</h3><p>聚簇索引和非聚簇索引是相对于存储引擎的概念，范围比较大，包含上面所提到的索引类型。</p>\n<p>「聚簇索引就是叶子节点中存储的就是完整的行数据，索引和数据存储在一起；而非聚簇索引的索引文件和数据文件是分开的，所以查询数据会多一次查询」。</p>\n<p>因此聚簇索引的查询速度会快于非聚簇索引的查询速度，在Mysql的存储引擎中，「InnoDB支持聚簇索引，MyISAM不支持聚簇索引，MyISAM支持非聚簇索引」。</p>\n<h4 id=\"聚簇索引\"><a href=\"#聚簇索引\" class=\"headerlink\" title=\"聚簇索引\"></a>聚簇索引</h4><p>下面我们来看看InnoDB中的聚簇索引，前面说到InnoDB都会有一个主键，该主键就是用于支持聚簇索引，聚簇索引结构图，大致如下图所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_5661add7.png\" alt=\"image_5661add7.png\"></p>\n<p>InnoDB中适用于最好的主键选择就是给出一个AUTO_INCREMENT的列作为自增的主键，有的人可能会使用UUID作为随机主键。</p>\n<p>因为索引要维持有序性，若是使用随机的主键，主键的插入需要寻找合适的位置进行放置，这样维护主键索引树的成本就会变得更高。</p>\n<p>相反的，自增主键，主键都是自增变大，在维护主键索引树的成本就会变得更小，随意应该尽量避免随机主键。</p>\n<h4 id=\"非聚簇索引\"><a href=\"#非聚簇索引\" class=\"headerlink\" title=\"非聚簇索引\"></a>非聚簇索引</h4><p>MyISAM使用的是非聚簇索引，新插入数据的时候，会按顺序的写入的磁盘中，并且给每一行数据标记一个行号，从小逐渐增大。</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_36b4ad4c.png\" alt=\"image_36b4ad4c.png\"></p>\n<p>当MyISAM创建主键索引的时候，形成的主键索引树的结构图如下图所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_1f0bbe29.png\" alt=\"image_1f0bbe29.png\"></p>\n<p>在主键索引中，数据也是非空且唯一，主键索引树中存储的是数据行的行号，当查询数据的时候使用主键索引查询需要查询到行号，然后通过行号获取数据。</p>\n<p>非主键索引和主键索引一样叶子节点也是存储着行号，唯一的区别就是非主键索引不要求非空、唯一。</p>\n<p>我们可以通对比图来对比一下「InnoDB(聚簇索引)」 和 「MyISAM(非聚簇索引)」 的索引数据布局，如下图所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_fb64a8df.png\" alt=\"image_fb64a8df.png\"></p>\n<p>说到这里相信应该大家对于**「InnoDB(聚簇索引)」** 和 「MyISAM(非聚簇索引)」 有了非常清晰的认识和理解，下面是来说一说索引的优化，这个也是和我们日常开发最密切相关的。</p>\n<h2 id=\"索引优化\"><a href=\"#索引优化\" class=\"headerlink\" title=\"索引优化\"></a>索引优化</h2><p>以个人多年（实际就两年）优化经验来看，Mysql索引优化无非就是以下三点：</p>\n<ol>\n<li> 最好的利用索引来进行查询</li>\n<li> 避免全表扫描</li>\n<li> 复杂查询，避免扫描无效的数据</li>\n</ol>\n<h3 id=\"优化前提\"><a href=\"#优化前提\" class=\"headerlink\" title=\"优化前提\"></a>优化前提</h3><p>Explain关键字是Mysql中sql优化的常用「关键字」，通常都会使用Explain来「查看sql的执行计划，而不用执行sql」，从而快速的找出sql的问题所在。</p>\n<p>在讲解Explain之前首先创建需要的「用户表user、角色表role、以及用户角色关系表role_user」作为测试用的表：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 用户表</span>\nDROP TABLE IF EXISTS `user`<span class=\"token punctuation\">;</span>\nCREATE TABLE `user` <span class=\"token punctuation\">(</span>\n  `id` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span>\n  `name` <span class=\"token function\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">25</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">DEFAULT</span> NULL<span class=\"token punctuation\">,</span>\n  `age` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span>  NOT NULL <span class=\"token class-name\">DEFAULT</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  `update_time` datetime <span class=\"token class-name\">DEFAULT</span> NULL<span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\">PRIMARY</span> KEY <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> ENGINE<span class=\"token operator\">=</span><span class=\"token class-name\">InnoDB</span> <span class=\"token class-name\">DEFAULT</span> CHARSET<span class=\"token operator\">=</span>utf8<span class=\"token punctuation\">;</span>\n\nINSERT INTO `user` <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">,</span> `name`<span class=\"token punctuation\">,</span> `age`<span class=\"token punctuation\">,</span>`update_time`<span class=\"token punctuation\">)</span> VALUES <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">'张三'</span><span class=\"token punctuation\">,</span><span class=\"token number\">23</span><span class=\"token punctuation\">,</span><span class=\"token string\">'2020-12-22 15:27:18'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token string\">'李四'</span><span class=\"token punctuation\">,</span><span class=\"token number\">24</span><span class=\"token punctuation\">,</span><span class=\"token string\">'2020-06-21 15:27:18'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token string\">'王五'</span><span class=\"token punctuation\">,</span><span class=\"token number\">25</span><span class=\"token punctuation\">,</span><span class=\"token string\">'2020-07-20 15:27:18'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nDROP TABLE IF EXISTS `role`<span class=\"token punctuation\">;</span>\nCREATE TABLE `role` <span class=\"token punctuation\">(</span>\n  `id` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> NOT <span class=\"token class-name\">NULL</span> AUTO_INCREMENT<span class=\"token punctuation\">,</span>\n  `name` <span class=\"token function\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">DEFAULT</span> NULL<span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\">PRIMARY</span> KEY <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  KEY `index_name` <span class=\"token punctuation\">(</span>`name`<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> ENGINE<span class=\"token operator\">=</span><span class=\"token class-name\">InnoDB</span> <span class=\"token class-name\">DEFAULT</span> CHARSET<span class=\"token operator\">=</span>utf8<span class=\"token punctuation\">;</span>\n\nINSERT INTO `role` <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">,</span> `name`<span class=\"token punctuation\">)</span> VALUES <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">'产品经理'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token string\">'技术经理'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token string\">'项目总监'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nDROP TABLE IF EXISTS `role_user`<span class=\"token punctuation\">;</span>\nCREATE TABLE `role_user` <span class=\"token punctuation\">(</span>\n  `id` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span>\n  `role_id` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span>\n  `user_id` <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">NOT</span> NULL<span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\">PRIMARY</span> KEY <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  KEY `index_role_user_id` <span class=\"token punctuation\">(</span>`role_id`<span class=\"token punctuation\">,</span>`user_id`<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> ENGINE<span class=\"token operator\">=</span><span class=\"token class-name\">InnoDB</span> <span class=\"token class-name\">DEFAULT</span> CHARSET<span class=\"token operator\">=</span>utf8<span class=\"token punctuation\">;</span>\n\nINSERT INTO `role_user` <span class=\"token punctuation\">(</span>`id`<span class=\"token punctuation\">,</span> `role_id`<span class=\"token punctuation\">,</span> `user_id`<span class=\"token punctuation\">)</span> VALUES <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们首先执行一条sql：explain select * from user where id =2;，执行后可以看到执行的结果如下：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_6c304aa6.png\" alt=\"image_6c304aa6.png\">可以看到这里有12个字段那个且都有对应的值，这就是explain的执行计划，能看懂这个执行计划，你离精通sql优化就不远了，下面就来详细的介绍这12个字段分别表示什么意思。</p>\n<h4 id=\"id字段\"><a href=\"#id字段\" class=\"headerlink\" title=\"id字段\"></a>id字段</h4><p>id表示执行select查询语句的序号，它是sql执行的顺序的标识，sql按照id从大到小执行，id相同的为一组，从上到下执行。</p>\n<p>什么意思呢？例如执行这条sql：explain select * from user where id in (select user_id from role_user);</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span>\n<span class=\"token operator\">|</span> id <span class=\"token operator\">|</span> select_type <span class=\"token operator\">|</span> table     <span class=\"token operator\">|</span> partitions <span class=\"token operator\">|</span> type  <span class=\"token operator\">|</span> possible_keys <span class=\"token operator\">|</span> key                <span class=\"token operator\">|</span> key_len <span class=\"token operator\">|</span> ref  <span class=\"token operator\">|</span> rows <span class=\"token operator\">|</span> filtered <span class=\"token operator\">|</span> <span class=\"token class-name\">Extra</span>                                                                             <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span>\n<span class=\"token operator\">|</span>  <span class=\"token number\">1</span> <span class=\"token operator\">|</span> SIMPLE      <span class=\"token operator\">|</span> user      <span class=\"token operator\">|</span> NULL       <span class=\"token operator\">|</span> ALL   <span class=\"token operator\">|</span> PRIMARY       <span class=\"token operator\">|</span> NULL               <span class=\"token operator\">|</span> NULL    <span class=\"token operator\">|</span> NULL <span class=\"token operator\">|</span>    <span class=\"token number\">3</span> <span class=\"token operator\">|</span>   <span class=\"token number\">100.00</span> <span class=\"token operator\">|</span> NULL                                                                              <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>  <span class=\"token number\">1</span> <span class=\"token operator\">|</span> SIMPLE      <span class=\"token operator\">|</span> role_user <span class=\"token operator\">|</span> NULL       <span class=\"token operator\">|</span> index <span class=\"token operator\">|</span> NULL          <span class=\"token operator\">|</span> index_role_user_id <span class=\"token operator\">|</span> <span class=\"token number\">8</span>       <span class=\"token operator\">|</span> NULL <span class=\"token operator\">|</span>    <span class=\"token number\">3</span> <span class=\"token operator\">|</span>    <span class=\"token number\">33.33</span> <span class=\"token operator\">|</span> <span class=\"token class-name\">Using</span> where<span class=\"token punctuation\">;</span> <span class=\"token class-name\">Using</span> index<span class=\"token punctuation\">;</span> <span class=\"token class-name\">FirstMatch</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token class-name\">Using</span> join buffer <span class=\"token punctuation\">(</span><span class=\"token class-name\">Block</span> <span class=\"token class-name\">Nested</span> <span class=\"token class-name\">Loop</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>显示出的两者的id都相同，便表示sql的执行从上往下执行，第一条记录对应的是user表，然后第二条记录对应的是role_user表，这种是id相同的情况。</p>\n<p>若是id不同，例如执行下面的sql：explain select (select 1 from user limit 1) from role;：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span>\n<span class=\"token operator\">|</span> id <span class=\"token operator\">|</span> select_type <span class=\"token operator\">|</span> table <span class=\"token operator\">|</span> partitions <span class=\"token operator\">|</span> type  <span class=\"token operator\">|</span> possible_keys <span class=\"token operator\">|</span> key        <span class=\"token operator\">|</span> key_len <span class=\"token operator\">|</span> ref  <span class=\"token operator\">|</span> rows <span class=\"token operator\">|</span> filtered <span class=\"token operator\">|</span> <span class=\"token class-name\">Extra</span>       <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span>\n<span class=\"token operator\">|</span>  <span class=\"token number\">1</span> <span class=\"token operator\">|</span> PRIMARY     <span class=\"token operator\">|</span> role  <span class=\"token operator\">|</span> NULL       <span class=\"token operator\">|</span> index <span class=\"token operator\">|</span> NULL          <span class=\"token operator\">|</span> index_name <span class=\"token operator\">|</span> <span class=\"token number\">33</span>      <span class=\"token operator\">|</span> NULL <span class=\"token operator\">|</span>    <span class=\"token number\">3</span> <span class=\"token operator\">|</span>   <span class=\"token number\">100.00</span> <span class=\"token operator\">|</span> <span class=\"token class-name\">Using</span> index <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>  <span class=\"token number\">2</span> <span class=\"token operator\">|</span> SUBQUERY    <span class=\"token operator\">|</span> user  <span class=\"token operator\">|</span> NULL       <span class=\"token operator\">|</span> index <span class=\"token operator\">|</span> NULL          <span class=\"token operator\">|</span> PRIMARY    <span class=\"token operator\">|</span> <span class=\"token number\">4</span>       <span class=\"token operator\">|</span> NULL <span class=\"token operator\">|</span>    <span class=\"token number\">3</span> <span class=\"token operator\">|</span>   <span class=\"token number\">100.00</span> <span class=\"token operator\">|</span> <span class=\"token class-name\">Using</span> index <span class=\"token operator\">|</span>\n<span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">+</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">+</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>就会看到有两条记录，并且两条记录的id会不一样，id越大的就越先执行，可以看到id=2的执行的是user表，也就是子查询部分，最后执行最外层的部分。</p>\n<p>「结论：」 这个就是id标识sql的执行顺序，一般在复杂查询中会有多条记录，简单查询只有一条记录，复杂查询中id相同的为一组，执行的顺序是从上往下，而id越大的越先执行；Mysql 8中会存在对子查询进行优化，所以有时候即使是复杂查询，也只有一条记录。</p>\n<h4 id=\"select-type字段\"><a href=\"#select-type字段\" class=\"headerlink\" title=\"select_type字段\"></a>select_type字段</h4><p>select_type表示查询的类型，也就是对应的是简单查询还是复杂查询，若是复杂查询又包含：「简单的子查询、from子句的子查询、union查询」。下面就分别来看看select_type中的所有查询类型。</p>\n<ul>\n<li> simplesimple表示简单查询，不含有任何的复杂查询。<img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_354ee4ca.png\" alt=\"image_354ee4ca.png\"></li>\n<li> PRIMARY复杂查询中「最外层的select语句的查询类型就是PRIMARY」，例如执行下面的sql：explain select * from role where id = (select id from role_user where role_id = (select id from user where id = 2));<img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_33774441.png\" alt=\"image_33774441.png\">最外层的select，也就是select * from role where id =？会被标记为PRIMARY类型。</li>\n<li> SUBQUERY在「select或者where中包含的子查询」会被表示为SUBQUERY类型，例如上一句执行的sql中就有两次的子查询为SUBQUERY。<img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_506be7f7.png\" alt=\"image_506be7f7.png\"></li>\n<li> DERIVED「DERIVED表示的是派生表或者衍生表的意思，在from包含的子查询中会被表示为DERIVED类型」，Mysql会递归执行这些子查询，并且把结果放在临时表中。执行sql：explain select * from (select name from user union select name from role) a where a.name = ‘张三’;<img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_5f5f8f2e.png\" alt=\"image_5f5f8f2e.png\">在Mysql 5.7以上的版本中对其做了优化，新增了derived_merge(派生合并)，可以加快查询效率。</li>\n<li> UNION在出现「UNION查询语句中，第二个select的查询语句就会被表示为UNION」：<img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_41ed6d48.png\" alt=\"image_41ed6d48.png\"></li>\n<li> UNION RESULT「UNION查询语句的结果被标记为UNION RESULT」，如上面执行的sql：explain select * from (select name from user union select name from role) a where a.name = ‘张三’;<img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_6b8b2a8d.png\" alt=\"image_6b8b2a8d.png\">第四行记录中从table字段中可以看出，第四行的记录来源于第二行和第三行&lt;union2,3&gt;，因此一个UNION查询语句的结果就会被标记为UNION RESULT</li>\n<li> DEPENDENT UNION：也表示UNION查询语句中第二个或者后面的语句，但是取决于外面的查询。</li>\n<li> DEPENDENT SUBQUERY：子查询中的第一个select语句，也是依赖于外部的查询。</li>\n<li> UNCACHEABLE SUBQUERY：子查询的结果不能被缓存，必须重新评估外连接的第一行。</li>\n</ul>\n<h4 id=\"table字段\"><a href=\"#table字段\" class=\"headerlink\" title=\"table字段\"></a>table字段</h4><p>这个很容易看出「table字段表示的是查询的是哪个表」，一个是已经存在的表，比如上面的user、role都是我们自己创建的表，也可以表示衍生表。</p>\n<p>比如：UNION RESULT的table字段表示为&lt;union2,3&gt;，也就是查询的是第二行和第三行的结果记录。</p>\n<h4 id=\"type字段\"><a href=\"#type字段\" class=\"headerlink\" title=\"type字段\"></a>type字段</h4><p>「type字段表示的sql关联的类型或者说是访问的类型」。从这个字段中我们可以确定这条sql查找数据库表的时候，查找记录的大概范围是怎么样的，直接就能体现sql的效率问题。</p>\n<p>type字段的类型也是有比较多，主要常见掌握的有以下几个：system、const 、eq_ref 、ref 、range 、index 、ALL。它的性能体现是从高到低，即system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL，下面就来详细的说一说这属性。</p>\n<h5 id=\"system\"><a href=\"#system\" class=\"headerlink\" title=\"system\"></a>system</h5><p>system是const的特例，「表示表中只有一行记录」，这个几乎不会出现，也作为了解。</p>\n<h5 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h5><p>const表示通过索引一次就查找到了数据，一般const出现在「唯一索引或者主键索引中使用等值查询」，因为表中只有一条数据匹配，所以查找的速度很快。例子：explain select * from user where id =2;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_0c7be26a.png\" alt=\"image_0c7be26a.png\"></p>\n<h5 id=\"eq-ref\"><a href=\"#eq-ref\" class=\"headerlink\" title=\"eq_ref\"></a>eq_ref</h5><p>eq_ref表示使用唯一索引或者主键索引扫描作为表链接匹配条件，对于每一个索引键，表中只有一条记录与之匹配。例如：explain select * from user left join role_user on user.id = role_user.user_id left join role on role_user.role_id=role.id;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_19f2ed1c.png\" alt=\"image_19f2ed1c.png\"></p>\n<h5 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h5><p>ref性能比eq_ref差，也表示表的链接匹配条件，也就是使用哪些表字段作为查询索引列上的值，ref与eq_ref的区别就是eq_ref使用的是唯一索引或者主键索引。</p>\n<p>ref扫描后的结果可能会找到多条符合条件的行数据，本质上是一种索引访问，返回匹配的行。例如：explain select * from user where name = ‘张三’;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_471404dc.png\" alt=\"image_471404dc.png\"></p>\n<h5 id=\"range\"><a href=\"#range\" class=\"headerlink\" title=\"range\"></a>range</h5><p>「range使用索引来检索给定范围的行数据，一般是在where后面使用between、&lt;&gt;、in等查询语句就会出现range」：explain select * from user where id &gt; 2;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_00bb0428.png\" alt=\"image_00bb0428.png\"></p>\n<h5 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h5><p>index表示会遍历索引树，index回避ALL速度快一些，但是出现index说明需要检查自己的索引是否使用正确：explain select id from user;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_a669396a.png\" alt=\"image_a669396a.png\"></p>\n<h5 id=\"ALL\"><a href=\"#ALL\" class=\"headerlink\" title=\"ALL\"></a>ALL</h5><p>「ALL与index的区别就是ALL是从硬盘中读取，而index是从索引文件中读取」，ALL全表扫描意味着Mysql会从表的头到尾进行扫描，这时候表示通常需要增加索引来进行优化了，或者说是查询中并没有使用索引作为条件进行查询：explain select * from user;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_8d791fe4.png\" alt=\"image_8d791fe4.png\"></p>\n<h4 id=\"possible-keys字段\"><a href=\"#possible-keys字段\" class=\"headerlink\" title=\"possible_keys字段\"></a>possible_keys字段</h4><p>possible_keys表示这一列查询语句可能使用到的索引，仅仅只是可能，列出来的索引并不一定真正的使用到。</p>\n<p>当没有使用索引为NULL时，说明需要增加索引来优化查询了，若是表的数据比较少的话，数据库觉得全表扫描更快，也可能为NULL。</p>\n<h4 id=\"key字段\"><a href=\"#key字段\" class=\"headerlink\" title=\"key字段\"></a>key字段</h4><p>key字段与possible_keys的区别就是，表示的真正使用到的索引，即possible_keys中包含key的值。</p>\n<p>若是想Mysql使用或者忽视possible_keys中的索引，可以使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p>\n<h4 id=\"key-len字段\"><a href=\"#key-len字段\" class=\"headerlink\" title=\"key_len字段\"></a>key_len字段</h4><p>表示sql查询语句中索引使用到的字节数，这个字节数并不是实际的长度，而是通过计算查询中使用到的索引中的长度得出来的，显示的是索引字段最大的可能长度。</p>\n<p>一般来说在不损失精度的前提下，key_len是越小越好，比如上面的测试表的id为int类型，int类型由4个字节组成：explain select * from user where id =2;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_66710eac.png\" alt=\"image_66710eac.png\"></p>\n<p>key_len对于不同的类型有自己的计算规则，具体的计算规则如下所示：</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_248c75e6.png\" alt=\"image_248c75e6.png\">若是索引为字符串类型的时候，实际存储的字符串非常长，已经超出了字符串类型的存储最大长度（768字节），mysql，就会使用类似左前缀索引来处理。</p>\n<h4 id=\"ref字段\"><a href=\"#ref字段\" class=\"headerlink\" title=\"ref字段\"></a>ref字段</h4><p>ref表示列与索引的比较，表连接的匹配条件，表示哪些列或者常量被用于查询索引列上的值。</p>\n<h4 id=\"rows字段\"><a href=\"#rows字段\" class=\"headerlink\" title=\"rows字段\"></a>rows字段</h4><p>rows表示估算的要扫描的行数，一般Mysql会根据统计表信息和索引的选用情况，估算出 查找记录所要扫描的行数，注意这个并不是实际结果集的行数。</p>\n<h4 id=\"partitions、filtered字段\"><a href=\"#partitions、filtered字段\" class=\"headerlink\" title=\"partitions、filtered字段\"></a>partitions、filtered字段</h4><p>partitions表示所匹配的分区；filtered表示的是查询表行所占表的百分比。</p>\n<h4 id=\"Extra字段\"><a href=\"#Extra字段\" class=\"headerlink\" title=\"Extra字段\"></a>Extra字段</h4><p>该字段显示的是sql查询的额外信息，主要有以下几种情况：</p>\n<h5 id=\"Using-index\"><a href=\"#Using-index\" class=\"headerlink\" title=\"Using index\"></a>Using index</h5><p>表示查询的列被索引覆盖，这个是查询性能比较高的体现，即所要查询的信息搜在索引里面可以得到，不用回表，索引被正确的使用：explain select id from user where id =2;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_af5b5697.png\" alt=\"image_af5b5697.png\"></p>\n<p>假如同时出现了using where，表示索引用于执行索引键值的查找；若是没有出现using where，则表示索引用于读取数据，而非执行查询的动作。</p>\n<h5 id=\"Using-where\"><a href=\"#Using-where\" class=\"headerlink\" title=\"Using where\"></a>Using where</h5><p>该属性与Using index相反，查询的列并没有被索引覆盖，where条件后面使用的是非索引的前导列，它仅仅是使用了where条件而已：explain select user.* from user,role,role_user where user.id = role_user.user_id and role.id=role_user.role_id;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_4925de1e.png\" alt=\"image_4925de1e.png\"></p>\n<h5 id=\"Using-temporary\"><a href=\"#Using-temporary\" class=\"headerlink\" title=\"Using temporary\"></a>Using temporary</h5><p>「Using temporary表示使用了临时表存储中间的结果，一般在对结果排序的时候会使用临时表」，例如：排序order by 和分组查询group by。例子：explain select * from (select name from user union select name from role) a where a.name = ‘张三’;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_ccf98553.png\" alt=\"image_ccf98553.png\"></p>\n<h5 id=\"Using-filesort\"><a href=\"#Using-filesort\" class=\"headerlink\" title=\"Using filesort\"></a>Using filesort</h5><p>Using filesort表示文件排序，说明Mysql对数据使用了外部的索引进行排序，并没有使用表中的索引进行排序：explain select * from user order by name;</p>\n<h5 id=\"Using-join-buffer\"><a href=\"#Using-join-buffer\" class=\"headerlink\" title=\"Using join buffer\"></a>Using join buffer</h5><p>Using join buffer表示使用连接缓存：explain select user.* from user,role,role_user where user.id = role_user.user_id and role.id=role_user.role_id;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_f552bbb6.png\" alt=\"image_f552bbb6.png\"></p>\n<p>它强调在获取连接条件时，并没有使用索引，而是使用连接缓冲区来存储中间结果，若是出现该值，一般说明需要添加索引来进行优化了。</p>\n<h5 id=\"Impossible-where\"><a href=\"#Impossible-where\" class=\"headerlink\" title=\"Impossible where\"></a>Impossible where</h5><p>Impossible where会出现在where后的条件一直为false的情况下，这种可以忽视，比较少出现：explain select * from user where name = ‘hah’ and name = ‘sfsd’;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_3c03677f.png\" alt=\"image_3c03677f.png\"></p>\n<h5 id=\"Select-tables-optimized-away\"><a href=\"#Select-tables-optimized-away\" class=\"headerlink\" title=\"Select tables optimized away\"></a>Select tables optimized away</h5><p>表示select语句没有遍历表或者索引就返回数据了，比如：explain select min(id) from user;</p>\n<p><img src=\"/2022/11/14/jing-tong-mysql-suo-yin/image_417b1a31.png\" alt=\"image_417b1a31.png\"></p>\n<p>在Extra字段中还有其它的属性，但是几乎都没见过的，不出现，所以哪些就讲解，有兴趣的可以自己去了解，这里只列出这些常见的。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>下面我来总结一下要正确的使用索引的一些规则。要正确的创建索引，用索引正确的查询，不要使索引失效，因此索引的设计和优化的原则应该遵循下面的几个原则：</p>\n<ol>\n<li> 索引列不要在表达式中出现，这样会导致索引失效。如：「SELECT …… WHERE id+1=5」;</li>\n<li> 索引列不要作为函数的参数使用。</li>\n<li> 索引列尽量不要使用like关键字。如：「SELECT …… WHERE name like ‘%d%’」。可以使用Mysql内置的函数INSTR(str,substr) 来匹配，查询字符串出现的下表的位置；也可以是使用FullText全文索引，用match against 检索;假如数据量非常大的话建议使用es或者solr来替代。</li>\n<li> 数字型的索引列不要当作字符串类型进行条件查询。如：「SELECT …… WHERE id = ‘35’」;</li>\n<li> 尽量不要在条件not in、&lt;&gt;、!= 、or 中使用索引，其中in关键字也要慎重使用，在控制in条件的数量在1000以内，如果in后面的条件太多，会导致全表扫描，这个在阿里巴巴的开发手册也有说明；建议使用between来替代in或者使用子查询exists代替；or关键字建议使用union来替代优化。</li>\n<li> 建表规范不建议在表中默认值是null的情况，一般建表都会一个默认值，比如0或者空字符串，防止出现一些空指针的现象。</li>\n<li> 在索引列的字段中不要出现NULL值，NULL值会使索引失效，可以用特殊的字符比如空字符串’ ‘或者0来代替NULL值。</li>\n<li> 联合索引的查询应该遵循最左前缀原则。</li>\n<li> 一般对于区别性比较大的字段建立索引，在联合索引中区别性比较大（识别度比较高）放在最前面，提高索引的命中率，在mybatis的xml文件中多条件where查询时，命中索引的条件放在前面，能使用联合索引就不要使用单列索引。</li>\n<li> where、order by 、 group by后面的条件尽量使用索引进行优化 ，可以使用exlpain对查询进行优化。</li>\n<li> 复杂查询中建议使用inner on来做关联，因为在mysql优化器中inner on会有限使用小表关联大表，on后面的条件要建立索引，左关联和右关联应该遵循小表带大表的规则。</li>\n<li> 微服务分布式系统下的库表设计原则不要进行跨库的join操作，一个库的数据量若是比较大，应该减少或者尽量不要join操作，要进行join操作应该避免join的无效的数据，保持接口的单一原则，减少join操作的方法可以字段冗余，对于一些很久都不会改变的字段，可以考虑冗余，从而减少join操作，阿里巴巴的手册中也有提到，不允许超过三个join，宁愿分多次查询。</li>\n<li> 业务优化考虑原则：读多写少场景或者读少写多场景，一般互联网的都是读多写少场景，对于一些需要进行统计的字段，比如一些首页报表、数据面板，需要大量统计的接口，尽量减少Mysql来进行统计，避免慢sql，优化的方法，可以牺牲部分写的性能来提升读的新能，提前在写入的时候通过异步的方式进行统计（比如统计当前月的积分，一年的绩效等数据），有些数据量涉及的数据本身比较大，如果用Mysql的进行查询的时候统计，那必然导致慢sql。</li>\n<li> 查询优化对于多次同步调用服务的接口可以通过异步的的方式进行调用，减少接口的响应时间。</li>\n<li> 索引的大小要适度，不易过大，避免索引的冗余。</li>\n</ol>\n"},{"title":"SpringBoot单元测试","top":false,"cover":false,"toc":true,"mathjax":true,"summary":"SpringBoot单元测试","date":"2022-11-19T09:40:55.000Z","password":null,"_content":"\n","source":"_posts/SpringBoot单元测试.md","raw":"---\ntitle: SpringBoot单元测试\ntop: false\ncover: false\ntoc: true\nmathjax: true\nsummary: SpringBoot单元测试\ndate: 2022-11-19 17:40:55\npassword:\ntags:\n    - 单元测试\n    - junit\ncategories:\n    - junit\n---\n\n","slug":"SpringBoot单元测试","published":1,"updated":"2022-11-19T09:41:35.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clanqrodz0000x6lddqrne0i6","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"MaJang","introduction":"I am not a master, just looking for the master's footsteps.","url":"http://luokangyuan.com/","title":"Read More"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"Blinkfox","introduction":"Hello, I'm blinkfox, I like programming.","url":"https://blinkfox.github.io/","title":"Visit Blog"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"Ordinary steps can also go out of the great journey.","url":"https://me.csdn.net/jlh912008548","title":"Read More"}]}},"excerpt":"","more":""}],"PostAsset":[{"_id":"source/_posts/感受java8后lambda之美/image_16155432.png","slug":"image_16155432.png","post":"cla1u1fni00004sld4m8lg8sb","modified":0,"renderable":0},{"_id":"source/_posts/感受java8后lambda之美/image_23fab375.png","slug":"image_23fab375.png","post":"cla1u1fni00004sld4m8lg8sb","modified":0,"renderable":0},{"_id":"source/_posts/感受java8后lambda之美/image_7771b4fe.png","slug":"image_7771b4fe.png","post":"cla1u1fni00004sld4m8lg8sb","modified":0,"renderable":0},{"_id":"source/_posts/感受java8后lambda之美/image_79d304da.png","slug":"image_79d304da.png","post":"cla1u1fni00004sld4m8lg8sb","modified":0,"renderable":0},{"_id":"source/_posts/感受java8后lambda之美/image_9186bf98.png","slug":"image_9186bf98.png","post":"cla1u1fni00004sld4m8lg8sb","modified":0,"renderable":0},{"_id":"source/_posts/感受java8后lambda之美/image_c1ac2536.png","slug":"image_c1ac2536.png","post":"cla1u1fni00004sld4m8lg8sb","modified":0,"renderable":0},{"_id":"source/_posts/感受java8后lambda之美/image_eba0197b.png","slug":"image_eba0197b.png","post":"cla1u1fni00004sld4m8lg8sb","modified":0,"renderable":0},{"_id":"source/_posts/感受java8后lambda之美/image_ec9c4260.png","slug":"image_ec9c4260.png","post":"cla1u1fni00004sld4m8lg8sb","modified":0,"renderable":0},{"_id":"source/_posts/ConcurrentHashMap是如何保证线程安全/image_256782fc-20221104171702786.png","slug":"image_256782fc-20221104171702786.png","post":"cla2aa3710000vbld679fgjml","modified":0,"renderable":0},{"_id":"source/_posts/ConcurrentHashMap是如何保证线程安全/image_4be279cf-20221104171705595.png","slug":"image_4be279cf-20221104171705595.png","post":"cla2aa3710000vbld679fgjml","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_056a7a91.png","slug":"image_056a7a91.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_09845ad7.png","slug":"image_09845ad7.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_0db7343e.png","slug":"image_0db7343e.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_0f3aa81b.png","slug":"image_0f3aa81b.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_12478821.png","slug":"image_12478821.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_26b58e72.png","slug":"image_26b58e72.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_3135fcc2.png","slug":"image_3135fcc2.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_4cc8d46f.png","slug":"image_4cc8d46f.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_56c75850.png","slug":"image_56c75850.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_6794e25f.png","slug":"image_6794e25f.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_7cbd31c6.png","slug":"image_7cbd31c6.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_7f6ad923.png","slug":"image_7f6ad923.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_80280cd4.png","slug":"image_80280cd4.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_8826e899.png","slug":"image_8826e899.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_a62166f6.png","slug":"image_a62166f6.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_a76314fe.png","slug":"image_a76314fe.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_a7e0d82b.png","slug":"image_a7e0d82b.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_b2dcd320.png","slug":"image_b2dcd320.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_cabc5bfb.png","slug":"image_cabc5bfb.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_da86596b.png","slug":"image_da86596b.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_db731042.png","slug":"image_db731042.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_e9562544.png","slug":"image_e9562544.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_f4c365cb.png","slug":"image_f4c365cb.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/JDK源码中NB的设计模式/image_fbd05a32.png","slug":"image_fbd05a32.png","post":"cla65vzs60000uylddl2n5sz7","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_047389be-20221108095355455.png","slug":"image_047389be-20221108095355455.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_24ceb509.png","slug":"image_24ceb509.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_2c6e506b.png","slug":"image_2c6e506b.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_41c09a5c.png","slug":"image_41c09a5c.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_450be2e5.png","slug":"image_450be2e5.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_4605e609.png","slug":"image_4605e609.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_598a46ba.png","slug":"image_598a46ba.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_83a6a12c.png","slug":"image_83a6a12c.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_83d6de95-20221108095355418.png","slug":"image_83d6de95-20221108095355418.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_8fa858cb.png","slug":"image_8fa858cb.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_9db0426b-20221108095355436.png","slug":"image_9db0426b-20221108095355436.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_d67b805c-20221108095355391.png","slug":"image_d67b805c-20221108095355391.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_e59205e3.png","slug":"image_e59205e3.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_f864e546-20221108095355479.png","slug":"image_f864e546-20221108095355479.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/常见代码重构技巧/image_ff852d0e.png","slug":"image_ff852d0e.png","post":"cla7kcdgu0000tvld43pe9jy5","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_14d8f72e.png","slug":"image_14d8f72e.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_0325f376.png","slug":"image_0325f376.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_0eb903df.png","slug":"image_0eb903df.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_6d065553.png","slug":"image_6d065553.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_8b2ddfc9.png","slug":"image_8b2ddfc9.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_175157f1.png","slug":"image_175157f1.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_743e1430.png","slug":"image_743e1430.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_97d0e8f2.png","slug":"image_97d0e8f2.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_9ea86f58.png","slug":"image_9ea86f58.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_a36c2593.png","slug":"image_a36c2593.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_ae0ce795.png","slug":"image_ae0ce795.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_c57014d0.png","slug":"image_c57014d0.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_d1df2887.png","slug":"image_d1df2887.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_de577e1c.png","slug":"image_de577e1c.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/消息队列原理和选型/image_ea5d47d1.png","slug":"image_ea5d47d1.png","post":"cla7kwx9700004sld281xf8oo","modified":0,"renderable":0},{"_id":"source/_posts/分布式锁的多种实现/image_071b7d88-20221109112215596.png","slug":"image_071b7d88-20221109112215596.png","post":"cla92uluj0000fdld41jbaz3k","modified":0,"renderable":0},{"_id":"source/_posts/分布式锁的多种实现/image_1cec9bce-20221109112215610.png","slug":"image_1cec9bce-20221109112215610.png","post":"cla92uluj0000fdld41jbaz3k","modified":0,"renderable":0},{"_id":"source/_posts/分布式锁的多种实现/image_5b5c8168-20221109112215631.png","slug":"image_5b5c8168-20221109112215631.png","post":"cla92uluj0000fdld41jbaz3k","modified":0,"renderable":0},{"_id":"source/_posts/分布式锁的多种实现/image_669de3e0-20221109112215539.png","slug":"image_669de3e0-20221109112215539.png","post":"cla92uluj0000fdld41jbaz3k","modified":0,"renderable":0},{"_id":"source/_posts/分布式锁的多种实现/image_6ae9d764-20221109112215556.png","slug":"image_6ae9d764-20221109112215556.png","post":"cla92uluj0000fdld41jbaz3k","modified":0,"renderable":0},{"_id":"source/_posts/分布式锁的多种实现/image_92a9dd04-20221109112215540.png","slug":"image_92a9dd04-20221109112215540.png","post":"cla92uluj0000fdld41jbaz3k","modified":0,"renderable":0},{"_id":"source/_posts/分布式锁的多种实现/image_93a8ea85-20221109112215608.png","slug":"image_93a8ea85-20221109112215608.png","post":"cla92uluj0000fdld41jbaz3k","modified":0,"renderable":0},{"_id":"source/_posts/分布式锁的多种实现/image_aa38b5f6-20221109112215600.png","slug":"image_aa38b5f6-20221109112215600.png","post":"cla92uluj0000fdld41jbaz3k","modified":0,"renderable":0},{"_id":"source/_posts/分布式锁的多种实现/image_b489bef9-20221109112215598.png","slug":"image_b489bef9-20221109112215598.png","post":"cla92uluj0000fdld41jbaz3k","modified":0,"renderable":0},{"_id":"source/_posts/分布式锁的多种实现/image_bd68a96a-20221109112215522.png","slug":"image_bd68a96a-20221109112215522.png","post":"cla92uluj0000fdld41jbaz3k","modified":0,"renderable":0},{"_id":"source/_posts/分布式锁的多种实现/image_d2f64ca3-20221109112215527.png","slug":"image_d2f64ca3-20221109112215527.png","post":"cla92uluj0000fdld41jbaz3k","modified":0,"renderable":0},{"_id":"source/_posts/分布式锁的多种实现/image_e929ee6e-20221109112215669.png","slug":"image_e929ee6e-20221109112215669.png","post":"cla92uluj0000fdld41jbaz3k","modified":0,"renderable":0},{"_id":"source/_posts/分布式锁的多种实现/image_f90141b7-20221109112215523.png","slug":"image_f90141b7-20221109112215523.png","post":"cla92uluj0000fdld41jbaz3k","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_ea531c2a.png","slug":"image_ea531c2a.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_d1a5a95c.png","slug":"image_d1a5a95c.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_dec3e504.png","slug":"image_dec3e504.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_fec0346f.png","slug":"image_fec0346f.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_fadda8b7.png","slug":"image_fadda8b7.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_7eeac46e.png","slug":"image_7eeac46e.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_b1853624.png","slug":"image_b1853624.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_48270fb5.png","slug":"image_48270fb5.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_77defa60.png","slug":"image_77defa60.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_22c2f25a.png","slug":"image_22c2f25a.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_56af129c.png","slug":"image_56af129c.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_5cf672b2.png","slug":"image_5cf672b2.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_d64a89cc.png","slug":"image_d64a89cc.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_040afd70.png","slug":"image_040afd70.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_f8deb8c1.png","slug":"image_f8deb8c1.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_71d4889f.png","slug":"image_71d4889f.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/推荐17个提升开发效率轮子/image_98de130d.png","slug":"image_98de130d.png","post":"cla93e2ly0000jkld1woodrc6","modified":0,"renderable":0},{"_id":"source/_posts/Mysql中join的那些事/image_58fd8737.png","slug":"image_58fd8737.png","post":"clagje6cl0000v6ldhohb421b","modified":0,"renderable":0},{"_id":"source/_posts/Mysql中join的那些事/image_65df1467.png","slug":"image_65df1467.png","post":"clagje6cl0000v6ldhohb421b","modified":0,"renderable":0},{"_id":"source/_posts/Mysql中join的那些事/image_942c82dc.png","slug":"image_942c82dc.png","post":"clagje6cl0000v6ldhohb421b","modified":0,"renderable":0},{"_id":"source/_posts/Mysql中join的那些事/image_9f6ce7ed.png","slug":"image_9f6ce7ed.png","post":"clagje6cl0000v6ldhohb421b","modified":0,"renderable":0},{"_id":"source/_posts/Mysql中join的那些事/image_ec6b3fe7.png","slug":"image_ec6b3fe7.png","post":"clagje6cl0000v6ldhohb421b","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_00bb0428.png","slug":"image_00bb0428.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_0c7be26a.png","slug":"image_0c7be26a.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_19f2ed1c.png","slug":"image_19f2ed1c.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_1f0bbe29.png","slug":"image_1f0bbe29.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_248c75e6.png","slug":"image_248c75e6.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_275a1cfe.png","slug":"image_275a1cfe.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_2c3f6cae.png","slug":"image_2c3f6cae.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_33774441.png","slug":"image_33774441.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_33b5701e.png","slug":"image_33b5701e.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_354ee4ca.png","slug":"image_354ee4ca.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_36b4ad4c.png","slug":"image_36b4ad4c.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_3c03677f.png","slug":"image_3c03677f.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_3e3d131e.png","slug":"image_3e3d131e.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_4030cc20.png","slug":"image_4030cc20.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_417b1a31.png","slug":"image_417b1a31.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_41ed6d48.png","slug":"image_41ed6d48.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_471404dc.png","slug":"image_471404dc.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_4925de1e.png","slug":"image_4925de1e.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_4d67662e.png","slug":"image_4d67662e.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_506be7f7.png","slug":"image_506be7f7.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_5661add7.png","slug":"image_5661add7.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_5bee3c9f.png","slug":"image_5bee3c9f.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_5eb3208c.png","slug":"image_5eb3208c.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_5f5f8f2e.png","slug":"image_5f5f8f2e.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_66710eac.png","slug":"image_66710eac.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_6b8b2a8d.png","slug":"image_6b8b2a8d.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_6bcc4698.png","slug":"image_6bcc4698.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_6c304aa6.png","slug":"image_6c304aa6.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_700a6b0b.png","slug":"image_700a6b0b.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_73608ecd.png","slug":"image_73608ecd.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_8d791fe4.png","slug":"image_8d791fe4.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_a669396a.png","slug":"image_a669396a.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_af5b5697.png","slug":"image_af5b5697.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_c1987417.png","slug":"image_c1987417.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_ccf98553.png","slug":"image_ccf98553.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_cee886ce.png","slug":"image_cee886ce.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_d3894bcc.png","slug":"image_d3894bcc.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_e6679248.png","slug":"image_e6679248.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_e986da4f.png","slug":"image_e986da4f.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_ea5a8c1e.png","slug":"image_ea5a8c1e.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_f327aac4.png","slug":"image_f327aac4.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_f50b3c32.png","slug":"image_f50b3c32.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_f552bbb6.png","slug":"image_f552bbb6.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_f9e7e1af.png","slug":"image_f9e7e1af.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/精通Mysql索引/image_fb64a8df.png","slug":"image_fb64a8df.png","post":"clagje6cy0007v6ldblxadckx","modified":0,"renderable":0},{"_id":"source/_posts/SpringBoot单元测试/image_00758bcb.png","post":"clanqrodz0000x6lddqrne0i6","slug":"image_00758bcb.png","modified":1,"renderable":1},{"_id":"source/_posts/SpringBoot单元测试/image_2bf8a627.png","post":"clanqrodz0000x6lddqrne0i6","slug":"image_2bf8a627.png","modified":1,"renderable":1},{"_id":"source/_posts/SpringBoot单元测试/image_30360d29.png","post":"clanqrodz0000x6lddqrne0i6","slug":"image_30360d29.png","modified":1,"renderable":1},{"_id":"source/_posts/SpringBoot单元测试/image_3e75da01.png","post":"clanqrodz0000x6lddqrne0i6","slug":"image_3e75da01.png","modified":1,"renderable":1},{"_id":"source/_posts/SpringBoot单元测试/image_9e077c9d.png","post":"clanqrodz0000x6lddqrne0i6","slug":"image_9e077c9d.png","modified":1,"renderable":1},{"_id":"source/_posts/SpringBoot单元测试/image_a6c1a6d0.png","post":"clanqrodz0000x6lddqrne0i6","slug":"image_a6c1a6d0.png","modified":1,"renderable":1},{"_id":"source/_posts/SpringBoot单元测试/image_e9aafc0d.png","post":"clanqrodz0000x6lddqrne0i6","slug":"image_e9aafc0d.png","modified":1,"renderable":1},{"_id":"source/_posts/SpringBoot单元测试/image_faa9f8ba.png","post":"clanqrodz0000x6lddqrne0i6","slug":"image_faa9f8ba.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cla1u1fni00004sld4m8lg8sb","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla1uku9p0003wwldbt0ed88c"},{"post_id":"cla1uku9k0000wwld3jap61ky","category_id":"cla1uku9o0001wwldfw4makkm","_id":"cla1uku9r0007wwld9mll9mgo"},{"post_id":"cla1ut5bv00006llddor7gqde","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla1ut5c300026lld21judw1i"},{"post_id":"cla1wfs1m0000hzld2zuj5k6i","category_id":"cla1wfs1q0001hzld8czpfcpj","_id":"cla1wfs1s0004hzld91yb8kap"},{"post_id":"cla21kmyu000001ldd8hx7phc","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla21kmz1000401ldcn9r38n4"},{"post_id":"cla21kmyw000101ld4jd8gijc","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla21kmz1000501ld8mlh1xes"},{"post_id":"cla21kmz0000301ldgbif4r8y","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla21kmz2000801ldbdqe0gg8"},{"post_id":"cla22kxoj0000cxld7rmz50bk","category_id":"cla22kxoo0001cxldaj0hanny","_id":"cla22kxos0004cxld8ptefwwm"},{"post_id":"cla22ncim0000hpldesb6gc1n","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla22ncit0002hpld3unmdlee"},{"post_id":"cla2a5uer0000rhld2brcd2ez","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla2a5uf00002rhldcyjvg24u"},{"post_id":"cla2aa3710000vbld679fgjml","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla2ajtcu0003bqldht99bam0"},{"post_id":"cla65gxi60000msld6qyr7te5","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla65gxif0004msld3iux77e4"},{"post_id":"cla65gxi60000msld6qyr7te5","category_id":"cla65gxie0002msld1jjxcm48","_id":"cla65gxif0005msldg08m4s0x"},{"post_id":"cla65gxig0006msldcoyi6ja1","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla65gxih0008msld0md79ln7"},{"post_id":"cla65vzs60000uylddl2n5sz7","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla65vzse0002uyld3yk9b9oh"},{"post_id":"cla7kcdgu0000tvld43pe9jy5","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla7kcdh30002tvldgrbn9kol"},{"post_id":"cla7kwx9700004sld281xf8oo","category_id":"cla7kwx9c00014sld6qfdhxv5","_id":"cla7kwx9i00044sld17brarby"},{"post_id":"cla92uluj0000fdld41jbaz3k","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla92ulus0004fdld3onj8vwh"},{"post_id":"cla92uluj0000fdld41jbaz3k","category_id":"cla92ulur0002fdlddpjgawpn","_id":"cla92ulut0005fdldg7ykbdi1"},{"post_id":"cla93e2ly0000jkld1woodrc6","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla93e2m80004jkld9y6y7zvn"},{"post_id":"cla93e2ly0000jkld1woodrc6","category_id":"cla93e2m70002jkldhjnr0sm0","_id":"cla93e2m90005jkld7l8p72l7"},{"post_id":"cla94lqxf00000old2q3s0yv5","category_id":"cl8ye4pnx00093eld9k027sjj","_id":"cla94lqxl00030old4xbo66wc"},{"post_id":"clagje6cl0000v6ldhohb421b","category_id":"clagje6cq0001v6ldbm22fm3r","_id":"clagje6cw0004v6ldapap3yx7"},{"post_id":"clagje6cy0007v6ldblxadckx","category_id":"clagje6cq0001v6ldbm22fm3r","_id":"clagje6cz0009v6ld2d897b6g"},{"post_id":"clanqrodz0000x6lddqrne0i6","category_id":"clanqroe30001x6ld32av5qtc","_id":"clanqroeb0004x6ldhop259t3"}],"PostTag":[{"post_id":"cla1uku9k0000wwld3jap61ky","tag_id":"cla1uku9p0002wwlda1xf3awq","_id":"cla1uku9q0005wwld2kxfeiyi"},{"post_id":"cla1u1fni00004sld4m8lg8sb","tag_id":"cla1uku9q0004wwldh2h81kby","_id":"cla1uku9r0009wwldg97i83pp"},{"post_id":"cla1u1fni00004sld4m8lg8sb","tag_id":"cla1uku9q0006wwld30xkfwfq","_id":"cla1uku9r000awwld4xxd5err"},{"post_id":"cla1u1fni00004sld4m8lg8sb","tag_id":"cla1uku9r0008wwldgeqta8zc","_id":"cla1uku9r000bwwld0mje2ssd"},{"post_id":"cla1ut5bv00006llddor7gqde","tag_id":"cla1uku9q0004wwldh2h81kby","_id":"cla1ut5c400046lld8fno6zfo"},{"post_id":"cla1ut5bv00006llddor7gqde","tag_id":"cla1ut5c100016lld3frt4kzl","_id":"cla1ut5c400056lld30ih0cq2"},{"post_id":"cla1ut5bv00006llddor7gqde","tag_id":"cla1ut5c400036lldcyw1873y","_id":"cla1ut5c400066lld9xvm45zo"},{"post_id":"cla1wfs1m0000hzld2zuj5k6i","tag_id":"cla1wfs1r0002hzld1pl29flo","_id":"cla1wfs1s0005hzld7vynglqt"},{"post_id":"cla1wfs1m0000hzld2zuj5k6i","tag_id":"cla1wfs1s0003hzld6z4t63zi","_id":"cla1wfs1t0006hzld8rytdeq0"},{"post_id":"cla21kmyu000001ldd8hx7phc","tag_id":"cla21kmyx000201ldd8xsdfop","_id":"cla21kmz2000701ldbv3objvy"},{"post_id":"cla21kmyw000101ld4jd8gijc","tag_id":"cla21kmz2000601ldcbcz18fd","_id":"cla21kmz3000a01ld67y8fwbq"},{"post_id":"cla21kmyu000001ldd8hx7phc","tag_id":"cla21qjxn0000fmld9oe2hrds","_id":"cla21qjxv0002fmld8w0mh7wo"},{"post_id":"cla21kmyw000101ld4jd8gijc","tag_id":"cla21qjxn0000fmld9oe2hrds","_id":"cla21qjxv0003fmld8p98e7vu"},{"post_id":"cla21kmz0000301ldgbif4r8y","tag_id":"cla21w3l00000ztld34570fm6","_id":"cla21w3l40001ztld03hnefqt"},{"post_id":"cla21kmz0000301ldgbif4r8y","tag_id":"cla21qjxn0000fmld9oe2hrds","_id":"cla21w3l40002ztldfewd3b8u"},{"post_id":"cla22kxoj0000cxld7rmz50bk","tag_id":"cla22kxor0002cxldhabxdrfu","_id":"cla22kxos0003cxldeqff5vf9"},{"post_id":"cla22ncim0000hpldesb6gc1n","tag_id":"cl8ye4po0000d3eldg6et6ncg","_id":"cla22nciu0003hpldcw8b7ya5"},{"post_id":"cla22ncim0000hpldesb6gc1n","tag_id":"cla22nciq0001hpld4aqe7hkt","_id":"cla22nciu0004hpld4xy9ak8z"},{"post_id":"cla2a5uer0000rhld2brcd2ez","tag_id":"cla2a5uex0001rhldcpjc8wwy","_id":"cla2a5uf10003rhldfqsf2qnu"},{"post_id":"cla2a5uer0000rhld2brcd2ez","tag_id":"cla1u1fnq00024sldg3c7dc7w","_id":"cla2a5uf10004rhld438k218t"},{"post_id":"cla2aa3710000vbld679fgjml","tag_id":"cla21kmyx000201ldd8xsdfop","_id":"cla2ajhst0000bqldd2uh81vn"},{"post_id":"cla2aa3710000vbld679fgjml","tag_id":"cla2ajqdk0001bqld8y1a1jox","_id":"cla2ajqdl0002bqld5cb7fkmk"},{"post_id":"cla65gxi60000msld6qyr7te5","tag_id":"cla65gxia0001msld49wf8s0h","_id":"cla65gxif0003mslddj9b0y4w"},{"post_id":"cla65gxig0006msldcoyi6ja1","tag_id":"cla65gxih0007msld2mc12yyt","_id":"cla65gxih0009msldhjen953q"},{"post_id":"cla65vzs60000uylddl2n5sz7","tag_id":"cla65vzsa0001uyld8ksrhv8s","_id":"cla65vzse0003uyld5hnu9y67"},{"post_id":"cla65vzs60000uylddl2n5sz7","tag_id":"cl8ye4po0000d3eldg6et6ncg","_id":"cla65vzse0004uyld39qwcg5w"},{"post_id":"cla7kcdgu0000tvld43pe9jy5","tag_id":"cla7kcdgy0001tvldb5du72u2","_id":"cla7kcdh30004tvlde05ccrwj"},{"post_id":"cla7kcdgu0000tvld43pe9jy5","tag_id":"cla7kcdh30003tvld7nvgct6x","_id":"cla7kcdh30005tvlde5lf3o65"},{"post_id":"cla7kwx9700004sld281xf8oo","tag_id":"cla7kwx9g00024sld1ho7gfbe","_id":"cla7kwx9i00054sld0ogo3683"},{"post_id":"cla7kwx9700004sld281xf8oo","tag_id":"cla7kwx9h00034sld1z060k10","_id":"cla7kwx9i00064sldhh866gi2"},{"post_id":"cla92uluj0000fdld41jbaz3k","tag_id":"cla92ulun0001fdld34g64txl","_id":"cla92ulus0003fdld5d8585sc"},{"post_id":"cla93e2ly0000jkld1woodrc6","tag_id":"cla93e2m30001jkld2214f3bk","_id":"cla93e2m80003jkld7ssnebp7"},{"post_id":"cla94lqxf00000old2q3s0yv5","tag_id":"cla7kcdgy0001tvldb5du72u2","_id":"cla94lqxk00010old1twg01j4"},{"post_id":"cla94lqxf00000old2q3s0yv5","tag_id":"cla7kcdh30003tvld7nvgct6x","_id":"cla94lqxk00020oldhgsr3k05"},{"post_id":"clagje6cl0000v6ldhohb421b","tag_id":"clagje6cv0002v6lddkfmha3v","_id":"clagje6cx0005v6lddlk61xaa"},{"post_id":"clagje6cl0000v6ldhohb421b","tag_id":"clagje6cw0003v6ld0qkahmo4","_id":"clagje6cx0006v6ld54p5g8f6"},{"post_id":"clagje6cy0007v6ldblxadckx","tag_id":"clagje6cz0008v6ld5hhwcp5h","_id":"clagje6d0000av6ld2tge00op"},{"post_id":"clanqrodz0000x6lddqrne0i6","tag_id":"clanqroea0002x6ld09mqf6np","_id":"clanqroeb0005x6ldfex50t82"},{"post_id":"clanqrodz0000x6lddqrne0i6","tag_id":"clanqroea0003x6ld64yhctpj","_id":"clanqroeb0006x6lddi137qb6"}],"Tag":[{"name":"ios","_id":"cl8ye4pnv00053eld4g7x30yu"},{"name":"objective-c","_id":"cl8ye4pny000a3eldehy9cg15"},{"name":"设计模式","_id":"cl8ye4po0000d3eldg6et6ncg"},{"name":"思考方式","_id":"cl8ye4po0000h3elddmf2gt5j"},{"name":"java8","_id":"cl9w4jneb00011mld3yk12gz5"},{"name":"web","_id":"cl9w6c3km0002yzld6zdiaiml"},{"name":"java","_id":"cla1u1fnq00024sldg3c7dc7w"},{"name":"hexo","_id":"cla1uku9p0002wwlda1xf3awq"},{"name":"jdk1.8","_id":"cla1uku9q0004wwldh2h81kby"},{"name":"lambda","_id":"cla1uku9q0006wwld30xkfwfq"},{"name":"函数式编程","_id":"cla1uku9r0008wwldgeqta8zc"},{"name":"stream","_id":"cla1ut5c100016lld3frt4kzl"},{"name":"lambda操作","_id":"cla1ut5c400036lldcyw1873y"},{"name":"git","_id":"cla1wfs1r0002hzld1pl29flo"},{"name":"代码合并","_id":"cla1wfs1s0003hzld6z4t63zi"},{"name":"java基础","_id":"cla21kmyx000201ldd8xsdfop"},{"name":"并发编程","_id":"cla21kmz2000601ldcbcz18fd"},{"name":"虚拟机","_id":"cla21kmz2000901ldcsdefdyf"},{"name":"八股文","_id":"cla21qjxn0000fmld9oe2hrds"},{"name":"java虚拟机","_id":"cla21w3l00000ztld34570fm6"},{"name":"sql优化","_id":"cla22kxor0002cxldhabxdrfu"},{"name":"程序设计","_id":"cla22nciq0001hpld4aqe7hkt"},{"name":"ioc","_id":"cla2a5uex0001rhldcpjc8wwy"},{"name":"源码","_id":"cla2ajqdk0001bqld8y1a1jox"},{"name":"工具轮子","_id":"cla65gxia0001msld49wf8s0h"},{"name":"java面试","_id":"cla65gxih0007msld2mc12yyt"},{"name":"jdk源码","_id":"cla65vzsa0001uyld8ksrhv8s"},{"name":"技巧","_id":"cla7kcdgy0001tvldb5du72u2"},{"name":"重构","_id":"cla7kcdh30003tvld7nvgct6x"},{"name":"mq","_id":"cla7kwx9g00024sld1ho7gfbe"},{"name":"中间件","_id":"cla7kwx9h00034sld1z060k10"},{"name":"锁","_id":"cla92ulun0001fdld34g64txl"},{"name":"轮子","_id":"cla93e2m30001jkld2214f3bk"},{"name":"join","_id":"clagje6cv0002v6lddkfmha3v"},{"name":"sql","_id":"clagje6cw0003v6ld0qkahmo4"},{"name":"索引","_id":"clagje6cz0008v6ld5hhwcp5h"},{"name":"单元测试","_id":"clanqroea0002x6ld09mqf6np"},{"name":"junit","_id":"clanqroea0003x6ld64yhctpj"}]}}